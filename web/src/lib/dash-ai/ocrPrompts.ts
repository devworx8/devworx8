/**
 * AUTO-GENERATED FILE. DO NOT EDIT MANUALLY.
 * Source of truth: lib/dash-ai/ocrPrompts.ts and lib/dash-ai/phonicsPrompt.ts
 * Generated by: scripts/generate-dash-ai-ssot.mjs
 */
export type OCRTask = 'homework' | 'document' | 'handwriting';

export const HOMEWORK_SCAN_PROMPT = [
  'OCR HOMEWORK SCAN:',
  '- Read all visible handwritten and printed text with high accuracy.',
  '- Identify subject, topic, and likely grade level (CAPS if South African).',
  '- If answers are present, evaluate correctness with brief reasoning.',
  '- Return uncertain text with [?] markers. Use confidence scores where helpful.',
  '- Provide kind, practical next-step feedback for learner and parent.',
  '- For math: show worked solutions step-by-step. Identify calculation errors.',
  '- Suggest 1-2 follow-up practice problems if gaps are found.',
  '- If the task includes labelled criteria (e.g., a) b) c) or 1. 2. 3.), preserve labels and wording exactly.',
  '- Do not merge, rename, skip, or reorder criteria.',
  '- For criteria-answer requests, use exact headings in this form: "a) <exact criterion text>" followed by the response.',
  '- Never replace an original criterion heading with a different heading.',
  '- Do not invent school names, learner names, signatures, or claims not visible in the prompt/image.',
].join('\n');

export const DOCUMENT_SCAN_PROMPT = [
  'OCR DOCUMENT SCAN:',
  '- Extract all text visible in the document image with high fidelity.',
  '- Preserve structure: headings (##), bullets (-), numbered steps (1. 2. 3.), tables.',
  '- Use markdown formatting for structure when outputting.',
  '- Return uncertain words with [?]. Provide a brief summary at the end.',
  '- If it is a worksheet or form, identify blank fields and question types.',
  '- If the document uses assessment criteria labels (a) b) c) d) e) or similar), keep labels and wording exact.',
  '- When drafting answers from this document, output one section per criterion with matching labels and no relabeling.',
  '- Use exact section headings in this form: "a) <exact criterion text>", "b) <exact criterion text>", etc.',
  '- Before finalizing, self-check that the number of response sections matches the number of criteria labels shown in the image.',
  '- Keep "evidence/documentation" requests in their own separate section; do not mix with criteria answers.',
  '- Avoid fabricated facts, school names, or sign-offs unless explicitly provided by the user.',
].join('\n');

export const HANDWRITING_ANALYSIS_PROMPT = [
  'OCR HANDWRITING ANALYSIS:',
  '- Read as much handwritten text as possible with best-effort accuracy.',
  '- Mark uncertain readings with [?].',
  '- Include an "unclear_spans" list with short quotes of low-confidence words/lines.',
  '- Assess handwriting legibility, letter formation, and spacing.',
  '- For preschool learners, include short fine-motor practice suggestions.',
  '- For older learners, suggest specific letter/word practice if needed.',
].join('\n');

const OCR_PATTERNS: Array<{ task: OCRTask; pattern: RegExp }> = [
  {
    task: 'homework',
    pattern: /\b(homework|worksheet|assignment|grade this|mark this|check my work|help with this|solve this|math problem|huiswerk|werkkaart|taak|opdrag|merk dit|help my met|wiskunde probleem|umsebenzi wasekhaya|ngomsebenzi wasekhaya|isabelo|ngisize ngalokhu|hlola umsebenzi wami)\b/i,
  },
  {
    task: 'handwriting',
    pattern: /\b(handwriting|write|letter formation|trace|motor skills?|penmanship|handskrif|skryf|letters vorming|natrek|fynmotoriese vaardighede|umbhalo wesandla|bhala|ukwakheka kwezinhlamvu|landelela|amakhono amancane ezandla)\b/i,
  },
  {
    task: 'document',
    pattern: /\b(scan|read this document|extract text|ocr|photo of notes|page|what does this say|read this|skandeer|lees hierdie dokument|haal teks uit|foto van notas|bladsy|wat staan hier|funda lokhu|skena|funda lo mbhalo|khipha umbhalo|isithombe samanothi|ikhasi|kuthini lokhu)\b/i,
  },
];

export function detectOCRTask(text: string): OCRTask | null {
  const value = String(text || '').trim();
  if (!value) return null;
  for (const item of OCR_PATTERNS) {
    if (item.pattern.test(value)) return item.task;
  }
  return null;
}

export function isOCRIntent(text: string): boolean {
  return detectOCRTask(text) !== null;
}

export function isShortOrAttachmentOnlyPrompt(text: string): boolean {
  const value = String(text || '').trim().toLowerCase();
  if (!value) return true;
  if (value.length <= 10) return true;

  const shortPromptPatterns = [
    /^(attached files?|attachment|image|photo|scan)\.?$/i,
    /^(help|please help|check|mark|read|scan|explain)\.?$/i,
    /^(help my|check this|read this|scan this)\.?$/i,
    /^(help my asseblief|help met dit|lees dit|skandeer dit)\.?$/i,
    /^(ngisize|ngicela usizo|funda lokhu|skena lokhu)\.?$/i,
  ];
  return shortPromptPatterns.some((pattern) => pattern.test(value));
}

export function getOCRPromptForTask(task: OCRTask | null | undefined): string {
  switch (task) {
    case 'homework':
      return HOMEWORK_SCAN_PROMPT;
    case 'handwriting':
      return HANDWRITING_ANALYSIS_PROMPT;
    case 'document':
    default:
      return DOCUMENT_SCAN_PROMPT;
  }
}

export const CRITERIA_RESPONSE_PROMPT = [
  'CRITERIA RESPONSE MODE:',
  '- When the user asks for help answering a rubric/criteria sheet, first identify each criterion label exactly as written.',
  '- Return responses mapped one-to-one using the same labels (e.g., a), b), c), d), e)).',
  '- Do not skip any criterion. Do not combine two criteria into one section.',
  '- Keep each heading exactly as provided, for example: "b) All areas of learning including literacy, numeracy and life skills are covered".',
  '- Never replace a criterion heading with a paraphrased heading.',
  '- Use this output format for each section: "<label and exact criterion text>" on one line, then the response paragraph(s).',
  '- Verify section count and order before finishing.',
  '- Keep wording formal and aligned to the criterion only.',
  '- Put supporting evidence/documents in a separate section titled exactly: "Attach all relevant documentation as evidence".',
  '- If any criterion text is unclear, mark it with [?] and ask one concise clarification question.',
  '- Do not add names, institutions, signatures, or dates unless the user explicitly provided them.',
].join('\n');

const CRITERIA_RESPONSE_PATTERNS: RegExp[] = [
  /\b(help|assist|draft|write|answer|respond)\b.{0,30}\b(criteria|criterion|rubric|assessment)\b/i,
  /\b(criteria|criterion|rubric|assessment)\b.{0,30}\b(answer|response|draft|write|help)\b/i,
  /\bgroup discussion response\b/i,
  /\bassessment criteria?\b/i,
  /\bassessment criterion\b/i,
  /\bcriteria\s*(1|2|3|4|5)\b/i,
  /\bassessment criterion\s*(1|2|3|4|5)\b/i,
  /\banswer (a|b|c|d|e)\b/i,
  /\battach all relevant documentation as evidence\b/i,
];

const CRITERIA_LINE_START_REGEX = /^\s*(?:[-*]\s*)?([a-z]|[1-9][0-9]?)\)\s*(.+?)\s*$/i;
const CRITERIA_NEXT_LABEL_INLINE_REGEX = /\s+(?:[a-z]|[1-9][0-9]?)\)\s+/i;

export type CriteriaHeading = {
  label: string;
  criterionText: string;
  heading: string;
  normalizedLabel: string;
  normalizedHeading: string;
  order: number;
};

export type CriteriaValidationResult = {
  valid: boolean;
  expectedCount: number;
  actualCount: number;
  mismatchReason?: 'count' | 'label_order' | 'heading_text';
  expectedHeadings: string[];
  actualHeadings: string[];
  missingLabels: string[];
};

function normalizeCriteriaLabel(label: string): string {
  const value = String(label || '').trim().toLowerCase();
  if (!value) return '';
  return value.endsWith(')') ? value : `${value})`;
}

function normalizeCriteriaHeading(heading: string): string {
  return String(heading || '')
    .toLowerCase()
    .replace(/\s+/g, ' ')
    .replace(/[“”"'`]+/g, '')
    .replace(/[^a-z0-9)\s]/g, '')
    .trim();
}

function finalizeCriteriaHeading(
  labelRaw: string,
  criterionRaw: string,
  order: number,
): CriteriaHeading | null {
  const normalizedLabel = normalizeCriteriaLabel(labelRaw);
  const criterionText = String(criterionRaw || '').replace(/\s+/g, ' ').trim();
  if (!normalizedLabel || !criterionText || criterionText.length < 3) return null;
  const heading = `${normalizedLabel} ${criterionText}`;
  return {
    label: normalizedLabel,
    criterionText,
    heading,
    normalizedLabel,
    normalizedHeading: normalizeCriteriaHeading(heading),
    order,
  };
}

function extractLineBasedCriteriaHeadings(text: string): CriteriaHeading[] {
  const lines = String(text || '').replace(/\r/g, '').split('\n');
  const headings: CriteriaHeading[] = [];

  for (const rawLine of lines) {
    const line = String(rawLine || '');
    const lineMatch = line.match(CRITERIA_LINE_START_REGEX);
    if (lineMatch) {
      const built = finalizeCriteriaHeading(lineMatch[1], lineMatch[2], headings.length);
      if (built) headings.push(built);
    }
  }

  return headings;
}

function extractInlineCriteriaHeadings(text: string): CriteriaHeading[] {
  const source = String(text || '').replace(/\s+/g, ' ').trim();
  if (!source) return [];

  const headings: CriteriaHeading[] = [];
  const labelRegex = /\b([a-z]|[1-9][0-9]?)\)\s*/gi;
  const matches: Array<{ label: string; index: number; start: number }> = [];
  let match: RegExpExecArray | null = null;

  while ((match = labelRegex.exec(source)) !== null) {
    matches.push({
      label: String(match[1] || '').toLowerCase(),
      index: match.index,
      start: labelRegex.lastIndex,
    });
  }

  for (let index = 0; index < matches.length; index += 1) {
    const current = matches[index];
    const next = matches[index + 1];
    const end = next ? next.index : source.length;
    const slice = source.slice(current.start, end).trim();
    if (!slice) continue;
    if (!CRITERIA_NEXT_LABEL_INLINE_REGEX.test(` ${slice}`) || index === matches.length - 1) {
      const built = finalizeCriteriaHeading(current.label, slice, headings.length);
      if (built) headings.push(built);
    }
  }

  return headings;
}

function dedupeCriteriaHeadings(headings: CriteriaHeading[]): CriteriaHeading[] {
  const deduped: CriteriaHeading[] = [];
  const seen = new Set<string>();
  for (const heading of headings) {
    const key = `${heading.normalizedLabel}|${heading.normalizedHeading}`;
    if (seen.has(key)) continue;
    seen.add(key);
    deduped.push({ ...heading, order: deduped.length });
  }
  return deduped;
}

export function extractCriteriaHeadings(text: string): CriteriaHeading[] {
  const lineBased = extractLineBasedCriteriaHeadings(text);
  const candidate = lineBased.length >= 2 ? lineBased : extractInlineCriteriaHeadings(text);
  return dedupeCriteriaHeadings(candidate);
}

export function buildCriteriaHeadingTemplate(headings: CriteriaHeading[]): string | null {
  if (!Array.isArray(headings) || headings.length === 0) return null;
  const lines = headings.map((heading, index) => `${index + 1}. ${heading.heading}`);
  return [
    'STRICT CRITERIA TEMPLATE:',
    '- You must use these exact section headings in the same order.',
    '- Do not rename, paraphrase, merge, or skip any heading.',
    ...lines,
  ].join('\n');
}

export function validateCriteriaLabelMapping(
  responseText: string,
  expectedHeadings: CriteriaHeading[],
): CriteriaValidationResult {
  const expected = Array.isArray(expectedHeadings) ? expectedHeadings : [];
  const actual = extractCriteriaHeadings(responseText);
  const expectedLabels = expected.map((item) => item.normalizedLabel);
  const actualLabels = actual.map((item) => item.normalizedLabel);
  const missingLabels = expectedLabels.filter((label) => !actualLabels.includes(label));

  if (expected.length === 0) {
    return {
      valid: true,
      expectedCount: 0,
      actualCount: actual.length,
      expectedHeadings: [],
      actualHeadings: actual.map((item) => item.heading),
      missingLabels: [],
    };
  }

  if (actual.length !== expected.length) {
    return {
      valid: false,
      expectedCount: expected.length,
      actualCount: actual.length,
      mismatchReason: 'count',
      expectedHeadings: expected.map((item) => item.heading),
      actualHeadings: actual.map((item) => item.heading),
      missingLabels,
    };
  }

  for (let index = 0; index < expected.length; index += 1) {
    if (expected[index].normalizedLabel !== actual[index].normalizedLabel) {
      return {
        valid: false,
        expectedCount: expected.length,
        actualCount: actual.length,
        mismatchReason: 'label_order',
        expectedHeadings: expected.map((item) => item.heading),
        actualHeadings: actual.map((item) => item.heading),
        missingLabels,
      };
    }
    if (expected[index].normalizedHeading !== actual[index].normalizedHeading) {
      return {
        valid: false,
        expectedCount: expected.length,
        actualCount: actual.length,
        mismatchReason: 'heading_text',
        expectedHeadings: expected.map((item) => item.heading),
        actualHeadings: actual.map((item) => item.heading),
        missingLabels,
      };
    }
  }

  return {
    valid: true,
    expectedCount: expected.length,
    actualCount: actual.length,
    expectedHeadings: expected.map((item) => item.heading),
    actualHeadings: actual.map((item) => item.heading),
    missingLabels,
  };
}

function countCriteriaLabels(text: string): number {
  return extractCriteriaHeadings(text).length;
}

export function isCriteriaResponseIntent(text: string): boolean {
  const value = String(text || '').trim();
  if (!value) return false;
  if (CRITERIA_RESPONSE_PATTERNS.some((pattern) => pattern.test(value))) {
    return true;
  }
  return countCriteriaLabels(value) >= 3;
}

export function getCriteriaResponsePrompt(text: string): string | null {
  return isCriteriaResponseIntent(text) ? CRITERIA_RESPONSE_PROMPT : null;
}
