drop extension if exists "pg_net";

create schema if not exists "app";

create schema if not exists "app_auth";

create schema if not exists "private";

create extension if not exists "cube" with schema "public";

create extension if not exists "earthdistance" with schema "public";

create extension if not exists "http" with schema "public";

create extension if not exists "pg_net" with schema "public";

create extension if not exists "pg_trgm" with schema "public";

create extension if not exists "pgjwt" with schema "public";

create extension if not exists "postgis" with schema "public";

create extension if not exists "vector" with schema "public";

create type "public"."admin_role_level_enum" as enum ('super_admin', 'platform_admin', 'regional_admin', 'support_admin', 'content_moderator');

create type "public"."admin_scope_enum" as enum ('global', 'regional', 'tenant', 'limited');

create type "public"."age_group_type" as enum ('child', 'teen', 'adult');

create type "public"."ai_model_tier" as enum ('free', 'starter', 'premium', 'enterprise');

create type "public"."approval_status" as enum ('draft', 'pending_review', 'approved', 'rejected');

create type "public"."audit_event_type" as enum ('auth_login_success', 'auth_login_failure', 'auth_logout', 'auth_password_change', 'user_role_change', 'course_created', 'course_updated', 'course_deleted', 'enrollment_created', 'enrollment_deleted', 'assignment_created', 'assignment_updated', 'assignment_deleted', 'submission_created', 'submission_updated', 'grade_created', 'grade_updated', 'permission_denied', 'ai_request', 'ai_quota_exceeded', 'data_export', 'admin_action');

create type "public"."billing_frequency" as enum ('monthly', 'annual');

create type "public"."campaign_type" as enum ('early_bird', 'sibling_discount', 'referral_bonus', 'seasonal_promo', 'bundle_offer', 'scholarship');

create type "public"."compliance_report_type_enum" as enum ('gdpr_audit', 'popia_compliance', 'data_retention', 'access_review', 'security_assessment', 'user_activity_report');

create type "public"."deletion_status_enum" as enum ('pending', 'in_progress', 'completed', 'failed', 'cancelled');

create type "public"."deletion_type_enum" as enum ('soft', 'hard', 'gdpr_compliance');

create type "public"."delivery_method_enum" as enum ('in_app', 'email', 'sms', 'push_notification', 'webhook');

create type "public"."delivery_provider_enum" as enum ('sendgrid', 'aws_ses', 'postmark', 'mailgun', 'twilio_sms', 'aws_sns', 'firebase_fcm', 'webhook', 'in_app');

create type "public"."delivery_status_enum" as enum ('pending', 'sent', 'delivered', 'failed', 'bounced', 'processing', 'complained', 'unsubscribed', 'cancelled');

create type "public"."discount_type" as enum ('percentage', 'fixed_amount', 'waive_registration', 'first_month_free');

create type "public"."escalation_level_enum" as enum ('warning', 'suspension', 'termination');

create type "public"."feedback_severity" as enum ('bug', 'feature', 'improvement');

create type "public"."feedback_status" as enum ('new', 'reviewing', 'resolved');

create type "public"."join_request_status" as enum ('pending', 'approved', 'rejected', 'expired', 'cancelled', 'revoked');

create type "public"."join_request_type" as enum ('teacher_invite', 'parent_join', 'member_join', 'guardian_claim', 'staff_invite', 'learner_enroll');

create type "public"."lead_status" as enum ('new', 'contacted', 'qualified', 'proposal', 'closed-won', 'closed-lost');

create type "public"."notification_source_enum" as enum ('error_monitoring', 'payment_gateway', 'user_reports', 'support_system', 'security_scanner', 'compliance_engine', 'analytics_engine');

create type "public"."notification_status_enum" as enum ('unread', 'read', 'acknowledged', 'resolved');

create type "public"."notification_type_enum" as enum ('system_error', 'payment_issue', 'abuse_report', 'support_urgent', 'security_alert', 'compliance_warning', 'subscription_event', 'user_behavior');

create type "public"."organization_type" as enum ('preschool', 'k12_school', 'university', 'corporate', 'sports_club', 'community_org', 'training_center', 'tutoring_center', 'skills_development', 'membership_org', 'npo');

create type "public"."overage_billing_status" as enum ('pending', 'processing', 'completed', 'failed', 'refunded');

create type "public"."overage_status" as enum ('none', 'approaching_limit', 'at_limit', 'exceeded');

create type "public"."report_status_enum" as enum ('generating', 'completed', 'failed', 'expired');

create type "public"."retry_strategy_enum" as enum ('exponential_backoff', 'linear_backoff', 'fixed_delay', 'immediate', 'none');

create type "public"."risk_level_enum" as enum ('low', 'medium', 'high', 'critical');

create type "public"."session_termination_enum" as enum ('logout', 'timeout', 'forced', 'security_breach', 'policy_violation');

create type "public"."session_termination_reason_enum" as enum ('user_logout', 'admin_forced', 'security_violation', 'session_expired', 'suspicious_activity', 'policy_violation');

create type "public"."severity_enum" as enum ('low', 'medium', 'high', 'critical');

create type "public"."subscription_owner_type" as enum ('user', 'school');

create type "public"."subscription_status" as enum ('active', 'past_due', 'canceled', 'unpaid', 'trialing');

create type "public"."subscription_tier" as enum ('free', 'starter', 'premium', 'enterprise', 'parent-starter', 'parent-plus', 'parent_starter', 'parent_plus', 'teacher_starter', 'teacher_pro', 'school_starter', 'school_premium', 'school_pro', 'school_enterprise', 'skills_starter', 'skills_premium', 'skills_enterprise', 'student_starter', 'student_pro');

create type "public"."superadmin_action_enum" as enum ('user_created', 'user_updated', 'user_suspended', 'user_reactivated', 'user_deleted', 'user_impersonated', 'password_reset', 'role_changed', 'admin_created', 'admin_permissions_updated', 'admin_role_assigned', 'admin_session_terminated', 'bulk_action_performed', 'bulk_suspension', 'bulk_activation', 'bulk_deletion', 'bulk_export', 'login_attempt_blocked', 'suspicious_activity_detected', 'security_breach_reported', 'data_exported', 'backup_created', 'backup_restored');

create type "public"."suspension_status_enum" as enum ('active', 'warning', 'suspended', 'terminated');

create type "public"."template_approval_status_enum" as enum ('pending', 'approved', 'rejected', 'auto_approved');

create type "public"."template_category_enum" as enum ('email', 'sms', 'in_app', 'push_notification', 'webhook', 'system_alert');

create type "public"."template_status_enum" as enum ('draft', 'pending_approval', 'active', 'inactive', 'archived');

create type "public"."template_variable_type_enum" as enum ('text', 'number', 'date', 'email', 'url', 'boolean', 'json');

create type "public"."tier_name_aligned" as enum ('free', 'trial', 'parent_starter', 'parent_plus', 'teacher_starter', 'teacher_pro', 'school_starter', 'school_premium', 'school_pro', 'school_enterprise');

create type "public"."user_account_status_enum" as enum ('active', 'suspended', 'terminated', 'pending_verification', 'locked', 'deleted');

create type "public"."whatsapp_consent_status" as enum ('pending', 'opted_in', 'opted_out');

create sequence "public"."activity_logs_id_seq";

create sequence "public"."migration_logs_id_seq";

drop trigger if exists "trigger_birthday_prefs_updated_at" on "public"."birthday_celebration_preferences";

drop trigger if exists "learner_documents_set_is_expired" on "public"."learner_documents";

drop trigger if exists "lesson_progress_updated_at" on "public"."lesson_progress";

drop trigger if exists "trg_organization_forms_meta" on "public"."organization_forms";

drop trigger if exists "soa_message_insert_trigger" on "public"."soa_messages";

drop trigger if exists "update_academic_terms_updated_at" on "public"."academic_terms";

drop trigger if exists "update_activity_progress_updated_at" on "public"."activity_progress";

drop trigger if exists "aftercare_enrollment_trigger" on "public"."aftercare_registrations";

drop trigger if exists "prevent_duplicate_aftercare_insert" on "public"."aftercare_registrations";

drop trigger if exists "prevent_duplicate_aftercare_update" on "public"."aftercare_registrations";

drop trigger if exists "trg_birthday_donation_days_meta" on "public"."birthday_donation_days";

drop trigger if exists "update_curriculum_themes_updated_at" on "public"."curriculum_themes";

drop trigger if exists "learner_documents_updated_at" on "public"."learner_documents";

drop trigger if exists "update_lesson_assignments_updated_at" on "public"."lesson_assignments";

drop trigger if exists "trigger_update_assignment_on_completion" on "public"."lesson_completions";

drop trigger if exists "update_lesson_completions_updated_at" on "public"."lesson_completions";

drop trigger if exists "update_lesson_templates_updated_at" on "public"."lesson_templates";

drop trigger if exists "prevent_duplicate_pop_insert" on "public"."pop_uploads";

drop trigger if exists "prevent_duplicate_pop_update" on "public"."pop_uploads";

drop trigger if exists "update_student_progress_summary_updated_at" on "public"."student_progress_summary";

drop trigger if exists "update_teacher_approvals_updated_at" on "public"."teacher_approvals";

drop trigger if exists "trg_uniform_requests_set_fields" on "public"."uniform_requests";

drop trigger if exists "update_weekly_plans_updated_at" on "public"."weekly_plans";

drop policy "teachers_manage_activity_progress" on "public"."activity_progress";

drop policy "birthday_prefs_parent_policy" on "public"."birthday_celebration_preferences";

drop policy "birthday_prefs_principal_view_policy" on "public"."birthday_celebration_preferences";

drop policy "Parents can insert child registration requests" on "public"."child_registration_requests";

drop policy "Parents can update own pending requests" on "public"."child_registration_requests";

drop policy "Parents can view own child registration requests" on "public"."child_registration_requests";

drop policy "Principals can update school registration requests" on "public"."child_registration_requests";

drop policy "Principals can view school registration requests" on "public"."child_registration_requests";

drop policy "staff_view_school_classes" on "public"."classes";

drop policy "Teachers can view student lesson progress" on "public"."lesson_progress";

drop policy "Users can delete own lesson progress" on "public"."lesson_progress";

drop policy "Users can insert own lesson progress" on "public"."lesson_progress";

drop policy "Users can update own lesson progress" on "public"."lesson_progress";

drop policy "Users can view own lesson progress" on "public"."lesson_progress";

drop policy "organization_forms_delete" on "public"."organization_forms";

drop policy "organization_forms_insert" on "public"."organization_forms";

drop policy "organization_forms_select" on "public"."organization_forms";

drop policy "organization_forms_update" on "public"."organization_forms";

drop policy "profiles_public_fields_for_fk_joins" on "public"."profiles";

drop policy "soa_participants_insert" on "public"."soa_message_participants";

drop policy "soa_participants_select" on "public"."soa_message_participants";

drop policy "soa_participants_update" on "public"."soa_message_participants";

drop policy "soa_reactions_delete" on "public"."soa_message_reactions";

drop policy "soa_reactions_insert" on "public"."soa_message_reactions";

drop policy "soa_reactions_select" on "public"."soa_message_reactions";

drop policy "soa_read_receipts_insert" on "public"."soa_message_read_receipts";

drop policy "soa_read_receipts_select" on "public"."soa_message_read_receipts";

drop policy "soa_threads_insert" on "public"."soa_message_threads";

drop policy "soa_threads_select" on "public"."soa_message_threads";

drop policy "soa_threads_update" on "public"."soa_message_threads";

drop policy "soa_messages_delete" on "public"."soa_messages";

drop policy "soa_messages_insert" on "public"."soa_messages";

drop policy "soa_messages_select" on "public"."soa_messages";

drop policy "soa_messages_update" on "public"."soa_messages";

drop policy "parents_view_school_students" on "public"."students";

drop policy "parents_view_school_students_via_child" on "public"."students";

drop policy "parents_view_their_children" on "public"."students";

drop policy "students_parent_access" on "public"."students";

drop policy "students_parent_update_children" on "public"."students";

drop policy "students_principal_access" on "public"."students";

drop policy "students_select_by_preschool_authenticated" on "public"."students";

drop policy "students_tenant_modify" on "public"."students";

drop policy "principals_manage_academic_terms" on "public"."academic_terms";

drop policy "teachers_view_academic_terms" on "public"."academic_terms";

drop policy "activity_comments_parent_select" on "public"."activity_comments";

drop policy "activity_progress_parent_child" on "public"."activity_progress";

drop policy "parents_view_child_activity_progress" on "public"."activity_progress";

drop policy "activity_reactions_parent_select" on "public"."activity_reactions";

drop policy "school_manage_own_templates" on "public"."activity_templates";

drop policy "authenticated_select_aftercare" on "public"."aftercare_registrations";

drop policy "authenticated_update_aftercare" on "public"."aftercare_registrations";

drop policy "birthday_donation_days_select" on "public"."birthday_donation_days";

drop policy "birthday_donations_select" on "public"."birthday_donations";

drop policy "Principals can view public teacher profiles" on "public"."candidate_profiles";

drop policy "child_registration_requests_parent_update" on "public"."child_registration_requests";

drop policy "child_registration_requests_parent_view" on "public"."child_registration_requests";

drop policy "classes_admin_all" on "public"."classes";

drop policy "classes_org_members_select" on "public"."classes";

drop policy "classes_teacher_select" on "public"."classes";

drop policy "parents_view_child_classes" on "public"."classes";

drop policy "principals_manage_curriculum_themes" on "public"."curriculum_themes";

drop policy "teachers_view_curriculum_themes" on "public"."curriculum_themes";

drop policy "tutor_attempts_insert" on "public"."dash_ai_tutor_attempts";

drop policy "tutor_attempts_select" on "public"."dash_ai_tutor_attempts";

drop policy "learner_documents_admin_all" on "public"."learner_documents";

drop policy "learner_documents_select_own" on "public"."learner_documents";

drop policy "parents_view_child_assignments" on "public"."lesson_assignments";

drop policy "teachers_manage_lesson_assignments" on "public"."lesson_assignments";

drop policy "parents_view_child_completions" on "public"."lesson_completions";

drop policy "teachers_manage_lesson_completions" on "public"."lesson_completions";

drop policy "principals_manage_lesson_templates" on "public"."lesson_templates";

drop policy "teachers_use_lesson_templates" on "public"."lesson_templates";

drop policy "admins_manage_folders" on "public"."organization_document_folders";

drop policy "members_view_folders" on "public"."organization_document_folders";

drop policy "admins_manage_documents" on "public"."organization_documents";

drop policy "members_view_documents" on "public"."organization_documents";

drop policy "Admins can manage organization members" on "public"."organization_members";

drop policy "Members can view organization members" on "public"."organization_members";

drop policy "preschools_user_read_via_preschool_id" on "public"."preschools";

drop policy "profiles_preschool_access" on "public"."profiles";

drop policy "profiles_read_for_documents" on "public"."profiles";

drop policy "principals_manage_excursions" on "public"."school_excursions";

drop policy "teachers_view_excursions" on "public"."school_excursions";

drop policy "principals_manage_meetings" on "public"."school_meetings";

drop policy "staff_view_meetings" on "public"."school_meetings";

drop policy "activity_feed_select" on "public"."student_activity_feed";

drop policy "student_fees_parent_child" on "public"."student_fees";

drop policy "student_fees_staff_org" on "public"."student_fees";

drop policy "parents_view_child_progress_summary" on "public"."student_progress_summary";

drop policy "teachers_manage_progress_summary" on "public"."student_progress_summary";

drop policy "students_parent_own_children" on "public"."students";

drop policy "students_parent_update_own_children" on "public"."students";

drop policy "students_school_admin_modify" on "public"."students";

drop policy "students_school_staff_select" on "public"."students";

drop policy "principals_manage_teacher_approvals" on "public"."teacher_approvals";

drop policy "Principals manage employment history" on "public"."teacher_employment_history";

drop policy "Principals manage reference requests" on "public"."teacher_reference_requests";

drop policy "Principals can create references for former teachers" on "public"."teacher_references";

drop policy "Principals can view teacher references" on "public"."teacher_references";

drop policy "uniform_requests_parent_insert" on "public"."uniform_requests";

drop policy "uniform_requests_parent_select" on "public"."uniform_requests";

drop policy "uniform_requests_parent_update" on "public"."uniform_requests";

drop policy "uniform_requests_staff_select" on "public"."uniform_requests";

drop policy "video_call_participants_insert" on "public"."video_call_participants";

drop policy "video_call_participants_select" on "public"."video_call_participants";

drop policy "video_calls_delete_policy" on "public"."video_calls";

drop policy "video_calls_insert_policy" on "public"."video_calls";

drop policy "video_calls_parent_select" on "public"."video_calls";

drop policy "video_calls_select_policy" on "public"."video_calls";

drop policy "video_calls_update_policy" on "public"."video_calls";

drop policy "weekly_reports_parent_select" on "public"."weekly_learning_reports";

drop policy "weekly_reports_school_select" on "public"."weekly_learning_reports";

drop policy "principals_approve_weekly_plans" on "public"."weekly_plans";

drop policy "teachers_manage_weekly_plans" on "public"."weekly_plans";

revoke delete on table "public"."birthday_celebration_preferences" from "anon";

revoke insert on table "public"."birthday_celebration_preferences" from "anon";

revoke references on table "public"."birthday_celebration_preferences" from "anon";

revoke select on table "public"."birthday_celebration_preferences" from "anon";

revoke trigger on table "public"."birthday_celebration_preferences" from "anon";

revoke truncate on table "public"."birthday_celebration_preferences" from "anon";

revoke update on table "public"."birthday_celebration_preferences" from "anon";

revoke delete on table "public"."birthday_celebration_preferences" from "authenticated";

revoke insert on table "public"."birthday_celebration_preferences" from "authenticated";

revoke references on table "public"."birthday_celebration_preferences" from "authenticated";

revoke select on table "public"."birthday_celebration_preferences" from "authenticated";

revoke trigger on table "public"."birthday_celebration_preferences" from "authenticated";

revoke truncate on table "public"."birthday_celebration_preferences" from "authenticated";

revoke update on table "public"."birthday_celebration_preferences" from "authenticated";

revoke delete on table "public"."birthday_celebration_preferences" from "service_role";

revoke insert on table "public"."birthday_celebration_preferences" from "service_role";

revoke references on table "public"."birthday_celebration_preferences" from "service_role";

revoke select on table "public"."birthday_celebration_preferences" from "service_role";

revoke trigger on table "public"."birthday_celebration_preferences" from "service_role";

revoke truncate on table "public"."birthday_celebration_preferences" from "service_role";

revoke update on table "public"."birthday_celebration_preferences" from "service_role";

revoke delete on table "public"."classes" from "anon";

revoke insert on table "public"."classes" from "anon";

revoke references on table "public"."classes" from "anon";

revoke select on table "public"."classes" from "anon";

revoke trigger on table "public"."classes" from "anon";

revoke truncate on table "public"."classes" from "anon";

revoke update on table "public"."classes" from "anon";

revoke delete on table "public"."organization_forms" from "anon";

revoke insert on table "public"."organization_forms" from "anon";

revoke references on table "public"."organization_forms" from "anon";

revoke select on table "public"."organization_forms" from "anon";

revoke trigger on table "public"."organization_forms" from "anon";

revoke truncate on table "public"."organization_forms" from "anon";

revoke update on table "public"."organization_forms" from "anon";

revoke delete on table "public"."organization_forms" from "authenticated";

revoke insert on table "public"."organization_forms" from "authenticated";

revoke references on table "public"."organization_forms" from "authenticated";

revoke select on table "public"."organization_forms" from "authenticated";

revoke trigger on table "public"."organization_forms" from "authenticated";

revoke truncate on table "public"."organization_forms" from "authenticated";

revoke update on table "public"."organization_forms" from "authenticated";

revoke delete on table "public"."organization_forms" from "service_role";

revoke insert on table "public"."organization_forms" from "service_role";

revoke references on table "public"."organization_forms" from "service_role";

revoke select on table "public"."organization_forms" from "service_role";

revoke trigger on table "public"."organization_forms" from "service_role";

revoke truncate on table "public"."organization_forms" from "service_role";

revoke update on table "public"."organization_forms" from "service_role";

revoke delete on table "public"."preschools" from "anon";

revoke insert on table "public"."preschools" from "anon";

revoke references on table "public"."preschools" from "anon";

revoke trigger on table "public"."preschools" from "anon";

revoke truncate on table "public"."preschools" from "anon";

revoke update on table "public"."preschools" from "anon";

revoke delete on table "public"."soa_message_participants" from "anon";

revoke insert on table "public"."soa_message_participants" from "anon";

revoke references on table "public"."soa_message_participants" from "anon";

revoke select on table "public"."soa_message_participants" from "anon";

revoke trigger on table "public"."soa_message_participants" from "anon";

revoke truncate on table "public"."soa_message_participants" from "anon";

revoke update on table "public"."soa_message_participants" from "anon";

revoke delete on table "public"."soa_message_participants" from "authenticated";

revoke insert on table "public"."soa_message_participants" from "authenticated";

revoke references on table "public"."soa_message_participants" from "authenticated";

revoke select on table "public"."soa_message_participants" from "authenticated";

revoke trigger on table "public"."soa_message_participants" from "authenticated";

revoke truncate on table "public"."soa_message_participants" from "authenticated";

revoke update on table "public"."soa_message_participants" from "authenticated";

revoke delete on table "public"."soa_message_participants" from "service_role";

revoke insert on table "public"."soa_message_participants" from "service_role";

revoke references on table "public"."soa_message_participants" from "service_role";

revoke select on table "public"."soa_message_participants" from "service_role";

revoke trigger on table "public"."soa_message_participants" from "service_role";

revoke truncate on table "public"."soa_message_participants" from "service_role";

revoke update on table "public"."soa_message_participants" from "service_role";

revoke delete on table "public"."soa_message_reactions" from "anon";

revoke insert on table "public"."soa_message_reactions" from "anon";

revoke references on table "public"."soa_message_reactions" from "anon";

revoke select on table "public"."soa_message_reactions" from "anon";

revoke trigger on table "public"."soa_message_reactions" from "anon";

revoke truncate on table "public"."soa_message_reactions" from "anon";

revoke update on table "public"."soa_message_reactions" from "anon";

revoke delete on table "public"."soa_message_reactions" from "authenticated";

revoke insert on table "public"."soa_message_reactions" from "authenticated";

revoke references on table "public"."soa_message_reactions" from "authenticated";

revoke select on table "public"."soa_message_reactions" from "authenticated";

revoke trigger on table "public"."soa_message_reactions" from "authenticated";

revoke truncate on table "public"."soa_message_reactions" from "authenticated";

revoke update on table "public"."soa_message_reactions" from "authenticated";

revoke delete on table "public"."soa_message_reactions" from "service_role";

revoke insert on table "public"."soa_message_reactions" from "service_role";

revoke references on table "public"."soa_message_reactions" from "service_role";

revoke select on table "public"."soa_message_reactions" from "service_role";

revoke trigger on table "public"."soa_message_reactions" from "service_role";

revoke truncate on table "public"."soa_message_reactions" from "service_role";

revoke update on table "public"."soa_message_reactions" from "service_role";

revoke delete on table "public"."soa_message_read_receipts" from "anon";

revoke insert on table "public"."soa_message_read_receipts" from "anon";

revoke references on table "public"."soa_message_read_receipts" from "anon";

revoke select on table "public"."soa_message_read_receipts" from "anon";

revoke trigger on table "public"."soa_message_read_receipts" from "anon";

revoke truncate on table "public"."soa_message_read_receipts" from "anon";

revoke update on table "public"."soa_message_read_receipts" from "anon";

revoke delete on table "public"."soa_message_read_receipts" from "authenticated";

revoke insert on table "public"."soa_message_read_receipts" from "authenticated";

revoke references on table "public"."soa_message_read_receipts" from "authenticated";

revoke select on table "public"."soa_message_read_receipts" from "authenticated";

revoke trigger on table "public"."soa_message_read_receipts" from "authenticated";

revoke truncate on table "public"."soa_message_read_receipts" from "authenticated";

revoke update on table "public"."soa_message_read_receipts" from "authenticated";

revoke delete on table "public"."soa_message_read_receipts" from "service_role";

revoke insert on table "public"."soa_message_read_receipts" from "service_role";

revoke references on table "public"."soa_message_read_receipts" from "service_role";

revoke select on table "public"."soa_message_read_receipts" from "service_role";

revoke trigger on table "public"."soa_message_read_receipts" from "service_role";

revoke truncate on table "public"."soa_message_read_receipts" from "service_role";

revoke update on table "public"."soa_message_read_receipts" from "service_role";

revoke delete on table "public"."soa_message_threads" from "anon";

revoke insert on table "public"."soa_message_threads" from "anon";

revoke references on table "public"."soa_message_threads" from "anon";

revoke select on table "public"."soa_message_threads" from "anon";

revoke trigger on table "public"."soa_message_threads" from "anon";

revoke truncate on table "public"."soa_message_threads" from "anon";

revoke update on table "public"."soa_message_threads" from "anon";

revoke delete on table "public"."soa_message_threads" from "authenticated";

revoke insert on table "public"."soa_message_threads" from "authenticated";

revoke references on table "public"."soa_message_threads" from "authenticated";

revoke select on table "public"."soa_message_threads" from "authenticated";

revoke trigger on table "public"."soa_message_threads" from "authenticated";

revoke truncate on table "public"."soa_message_threads" from "authenticated";

revoke update on table "public"."soa_message_threads" from "authenticated";

revoke delete on table "public"."soa_message_threads" from "service_role";

revoke insert on table "public"."soa_message_threads" from "service_role";

revoke references on table "public"."soa_message_threads" from "service_role";

revoke select on table "public"."soa_message_threads" from "service_role";

revoke trigger on table "public"."soa_message_threads" from "service_role";

revoke truncate on table "public"."soa_message_threads" from "service_role";

revoke update on table "public"."soa_message_threads" from "service_role";

revoke delete on table "public"."soa_messages" from "anon";

revoke insert on table "public"."soa_messages" from "anon";

revoke references on table "public"."soa_messages" from "anon";

revoke select on table "public"."soa_messages" from "anon";

revoke trigger on table "public"."soa_messages" from "anon";

revoke truncate on table "public"."soa_messages" from "anon";

revoke update on table "public"."soa_messages" from "anon";

revoke delete on table "public"."soa_messages" from "authenticated";

revoke insert on table "public"."soa_messages" from "authenticated";

revoke references on table "public"."soa_messages" from "authenticated";

revoke select on table "public"."soa_messages" from "authenticated";

revoke trigger on table "public"."soa_messages" from "authenticated";

revoke truncate on table "public"."soa_messages" from "authenticated";

revoke update on table "public"."soa_messages" from "authenticated";

revoke delete on table "public"."soa_messages" from "service_role";

revoke insert on table "public"."soa_messages" from "service_role";

revoke references on table "public"."soa_messages" from "service_role";

revoke select on table "public"."soa_messages" from "service_role";

revoke trigger on table "public"."soa_messages" from "service_role";

revoke truncate on table "public"."soa_messages" from "service_role";

revoke update on table "public"."soa_messages" from "service_role";

alter table "public"."activity_progress" drop constraint "activity_progress_activity_id_student_id_key";

alter table "public"."activity_progress" drop constraint "activity_progress_lesson_id_fkey";

alter table "public"."activity_progress" drop constraint "activity_progress_preschool_id_fkey";

alter table "public"."activity_progress" drop constraint "activity_progress_status_check";

alter table "public"."birthday_celebration_preferences" drop constraint "birthday_celebration_preferences_student_id_fkey";

alter table "public"."birthday_celebration_preferences" drop constraint "birthday_celebration_preferences_student_id_key";

alter table "public"."learner_documents" drop constraint "learner_documents_document_type_check";

alter table "public"."learner_documents" drop constraint "learner_documents_status_check";

alter table "public"."learner_documents" drop constraint "learner_documents_verified_by_fkey";

alter table "public"."lesson_progress" drop constraint "lesson_progress_lesson_id_user_id_key";

alter table "public"."organization_forms" drop constraint "organization_forms_audience_check";

alter table "public"."organization_forms" drop constraint "organization_forms_created_by_fkey";

alter table "public"."organization_forms" drop constraint "organization_forms_organization_id_fkey";

alter table "public"."organization_forms" drop constraint "organization_forms_status_check";

alter table "public"."organization_forms" drop constraint "organization_forms_updated_by_fkey";

alter table "public"."soa_message_participants" drop constraint "soa_message_participants_last_read_message_id_fkey";

alter table "public"."soa_message_participants" drop constraint "soa_message_participants_member_id_fkey";

alter table "public"."soa_message_participants" drop constraint "soa_message_participants_notification_preference_check";

alter table "public"."soa_message_participants" drop constraint "soa_message_participants_removed_by_fkey";

alter table "public"."soa_message_participants" drop constraint "soa_message_participants_role_check";

alter table "public"."soa_message_participants" drop constraint "soa_message_participants_thread_id_fkey";

alter table "public"."soa_message_participants" drop constraint "soa_message_participants_thread_id_user_id_key";

alter table "public"."soa_message_participants" drop constraint "soa_message_participants_user_id_fkey";

alter table "public"."soa_message_reactions" drop constraint "soa_message_reactions_message_id_fkey";

alter table "public"."soa_message_reactions" drop constraint "soa_message_reactions_message_id_user_id_emoji_key";

alter table "public"."soa_message_reactions" drop constraint "soa_message_reactions_user_id_fkey";

alter table "public"."soa_message_read_receipts" drop constraint "soa_message_read_receipts_message_id_fkey";

alter table "public"."soa_message_read_receipts" drop constraint "soa_message_read_receipts_message_id_user_id_key";

alter table "public"."soa_message_read_receipts" drop constraint "soa_message_read_receipts_user_id_fkey";

alter table "public"."soa_message_threads" drop constraint "soa_message_threads_created_by_fkey";

alter table "public"."soa_message_threads" drop constraint "soa_message_threads_organization_id_fkey";

alter table "public"."soa_message_threads" drop constraint "soa_message_threads_region_id_fkey";

alter table "public"."soa_message_threads" drop constraint "soa_message_threads_thread_type_check";

alter table "public"."soa_message_threads" drop constraint "soa_message_threads_wing_check";

alter table "public"."soa_messages" drop constraint "soa_messages_content_type_check";

alter table "public"."soa_messages" drop constraint "soa_messages_forwarded_from_id_fkey";

alter table "public"."soa_messages" drop constraint "soa_messages_reply_to_id_fkey";

alter table "public"."soa_messages" drop constraint "soa_messages_sender_id_fkey";

alter table "public"."soa_messages" drop constraint "soa_messages_thread_id_fkey";

alter table "public"."video_call_participants" drop constraint "video_call_participants_video_call_id_fkey";

alter table "public"."video_call_participants" drop constraint "video_call_participants_video_call_id_user_id_key";

alter table "public"."academic_terms" drop constraint "academic_terms_created_by_fkey";

alter table "public"."academic_terms" drop constraint "academic_terms_preschool_id_fkey";

alter table "public"."activity_comments" drop constraint "activity_comments_activity_id_fkey";

alter table "public"."activity_comments" drop constraint "activity_comments_parent_id_fkey";

alter table "public"."activity_progress" drop constraint "activity_progress_activity_id_fkey";

alter table "public"."activity_progress" drop constraint "activity_progress_student_id_fkey";

alter table "public"."activity_reactions" drop constraint "activity_reactions_activity_id_fkey";

alter table "public"."activity_reactions" drop constraint "activity_reactions_parent_id_fkey";

alter table "public"."activity_templates" drop constraint "activity_templates_created_by_fkey";

alter table "public"."activity_templates" drop constraint "activity_templates_preschool_id_fkey";

alter table "public"."birthday_donation_days" drop constraint "birthday_donation_days_organization_id_fkey";

alter table "public"."birthday_donations" drop constraint "birthday_donations_birthday_student_id_fkey";

alter table "public"."birthday_donations" drop constraint "birthday_donations_class_id_fkey";

alter table "public"."birthday_donations" drop constraint "birthday_donations_organization_id_fkey";

alter table "public"."birthday_donations" drop constraint "birthday_donations_payer_student_id_fkey";

alter table "public"."child_registration_requests" drop constraint "child_registration_requests_payment_verified_by_fkey";

alter table "public"."classes" drop constraint "classes_preschool_id_fkey";

alter table "public"."curriculum_themes" drop constraint "curriculum_themes_created_by_fkey";

alter table "public"."curriculum_themes" drop constraint "curriculum_themes_preschool_id_fkey";

alter table "public"."curriculum_themes" drop constraint "curriculum_themes_term_id_fkey";

alter table "public"."dash_ai_tutor_attempts" drop constraint "dash_ai_tutor_attempts_student_id_fkey";

alter table "public"."lesson_assignments" drop constraint "lesson_assignments_assigned_by_fkey";

alter table "public"."lesson_assignments" drop constraint "lesson_assignments_class_id_fkey";

alter table "public"."lesson_assignments" drop constraint "lesson_assignments_lesson_id_fkey";

alter table "public"."lesson_assignments" drop constraint "lesson_assignments_preschool_id_fkey";

alter table "public"."lesson_assignments" drop constraint "lesson_assignments_student_id_fkey";

alter table "public"."lesson_completions" drop constraint "lesson_completions_assignment_id_fkey";

alter table "public"."lesson_completions" drop constraint "lesson_completions_lesson_id_fkey";

alter table "public"."lesson_completions" drop constraint "lesson_completions_preschool_id_fkey";

alter table "public"."lesson_completions" drop constraint "lesson_completions_reviewed_by_fkey";

alter table "public"."lesson_completions" drop constraint "lesson_completions_student_id_fkey";

alter table "public"."lesson_progress" drop constraint "lesson_progress_lesson_id_fkey";

alter table "public"."lesson_progress" drop constraint "lesson_progress_status_check";

alter table "public"."lesson_templates" drop constraint "lesson_templates_created_by_fkey";

alter table "public"."lesson_templates" drop constraint "lesson_templates_preschool_id_fkey";

alter table "public"."notifications" drop constraint "notifications_type_check";

alter table "public"."notifications" drop constraint "notifications_user_id_fkey";

alter table "public"."organization_regions" drop constraint "organization_regions_organization_id_fkey";

alter table "public"."school_excursions" drop constraint "school_excursions_approved_by_fkey";

alter table "public"."school_excursions" drop constraint "school_excursions_created_by_fkey";

alter table "public"."school_excursions" drop constraint "school_excursions_preschool_id_fkey";

alter table "public"."school_excursions" drop constraint "school_excursions_term_id_fkey";

alter table "public"."school_excursions" drop constraint "school_excursions_theme_id_fkey";

alter table "public"."school_meetings" drop constraint "school_meetings_created_by_fkey";

alter table "public"."school_meetings" drop constraint "school_meetings_parent_meeting_id_fkey";

alter table "public"."school_meetings" drop constraint "school_meetings_preschool_id_fkey";

alter table "public"."student_activity_feed" drop constraint "student_activity_feed_student_id_fkey";

alter table "public"."student_progress_summary" drop constraint "student_progress_summary_preschool_id_fkey";

alter table "public"."student_progress_summary" drop constraint "student_progress_summary_student_id_fkey";

alter table "public"."teacher_approvals" drop constraint "teacher_approvals_invite_id_fkey";

alter table "public"."teacher_approvals" drop constraint "teacher_approvals_preschool_id_fkey";

alter table "public"."teacher_approvals" drop constraint "teacher_approvals_reviewed_by_fkey";

alter table "public"."teacher_approvals" drop constraint "teacher_approvals_teacher_id_fkey";

alter table "public"."teacher_reference_requests" drop constraint "teacher_reference_requests_candidate_profile_id_fkey";

alter table "public"."teacher_references" drop constraint "teacher_references_candidate_profile_id_fkey";

alter table "public"."uniform_requests" drop constraint "uniform_requests_parent_id_fkey";

alter table "public"."uniform_requests" drop constraint "uniform_requests_preschool_id_fkey";

alter table "public"."uniform_requests" drop constraint "uniform_requests_student_id_fkey";

alter table "public"."video_call_participants" drop constraint "video_call_participants_user_id_fkey";

alter table "public"."video_calls" drop constraint "video_calls_class_id_fkey";

alter table "public"."video_calls" drop constraint "video_calls_preschool_id_fkey";

alter table "public"."video_calls" drop constraint "video_calls_teacher_id_fkey";

alter table "public"."weekly_learning_reports" drop constraint "weekly_learning_reports_parent_id_fkey";

alter table "public"."weekly_learning_reports" drop constraint "weekly_learning_reports_preschool_id_fkey";

alter table "public"."weekly_learning_reports" drop constraint "weekly_learning_reports_student_id_fkey";

alter table "public"."weekly_plans" drop constraint "weekly_plans_approved_by_fkey";

alter table "public"."weekly_plans" drop constraint "weekly_plans_class_id_fkey";

alter table "public"."weekly_plans" drop constraint "weekly_plans_created_by_fkey";

alter table "public"."weekly_plans" drop constraint "weekly_plans_preschool_id_fkey";

alter table "public"."weekly_plans" drop constraint "weekly_plans_term_id_fkey";

alter table "public"."weekly_plans" drop constraint "weekly_plans_theme_id_fkey";

drop function if exists "public"."assign_initial_student_fees"(p_student_id uuid, p_preschool_id uuid);

drop function if exists "public"."create_default_soa_threads_for_region"(p_organization_id uuid, p_region_id uuid, p_created_by uuid);

drop view if exists "public"."duplicate_pops";

drop function if exists "public"."generate_learner_document_path"(p_learner_id uuid, p_doc_type text, p_file_extension text);

drop function if exists "public"."get_registration_fee"(p_preschool_id uuid);

drop function if exists "public"."mark_soa_thread_read"(p_thread_id uuid);

drop function if exists "public"."register_organization_member"(p_organization_id uuid, p_user_id uuid, p_region_id uuid, p_member_number text, p_member_type text, p_membership_tier text, p_membership_status text, p_first_name text, p_last_name text, p_email text, p_phone text, p_id_number text, p_role text, p_invite_code_used text, p_joined_via text, p_date_of_birth date, p_physical_address text);

drop function if exists "public"."set_learner_documents_is_expired"();

drop function if exists "public"."set_organization_form_meta"();

drop function if exists "public"."update_birthday_prefs_updated_at"();

drop function if exists "public"."update_soa_thread_on_message"();

drop view if exists "public"."duplicate_aftercare_registrations";

drop function if exists "public"."get_learner_document_summary"(p_learner_id uuid);

alter table "public"."birthday_celebration_preferences" drop constraint "birthday_celebration_preferences_pkey";

alter table "public"."organization_forms" drop constraint "organization_forms_pkey";

alter table "public"."soa_message_participants" drop constraint "soa_message_participants_pkey";

alter table "public"."soa_message_reactions" drop constraint "soa_message_reactions_pkey";

alter table "public"."soa_message_read_receipts" drop constraint "soa_message_read_receipts_pkey";

alter table "public"."soa_message_threads" drop constraint "soa_message_threads_pkey";

alter table "public"."soa_messages" drop constraint "soa_messages_pkey";

drop index if exists "public"."activity_progress_activity_id_student_id_key";

drop index if exists "public"."birthday_celebration_preferences_pkey";

drop index if exists "public"."birthday_celebration_preferences_student_id_key";

drop index if exists "public"."idx_aftercare_registrations_unique_child";

drop index if exists "public"."idx_birthday_prefs_student";

drop index if exists "public"."idx_learner_documents_created";

drop index if exists "public"."idx_learner_documents_learner_id";

drop index if exists "public"."idx_learner_documents_status";

drop index if exists "public"."idx_learner_documents_type";

drop index if exists "public"."idx_lesson_progress_user_lesson";

drop index if exists "public"."idx_organization_forms_org_id";

drop index if exists "public"."idx_organization_forms_status";

drop index if exists "public"."idx_profiles_org_id";

drop index if exists "public"."idx_soa_messages_created_at";

drop index if exists "public"."idx_soa_messages_reply_to";

drop index if exists "public"."idx_soa_messages_sender_id";

drop index if exists "public"."idx_soa_messages_thread_id";

drop index if exists "public"."idx_soa_participants_member_id";

drop index if exists "public"."idx_soa_participants_thread_id";

drop index if exists "public"."idx_soa_participants_user_id";

drop index if exists "public"."idx_soa_reactions_message_id";

drop index if exists "public"."idx_soa_read_receipts_message_id";

drop index if exists "public"."idx_soa_threads_created_by";

drop index if exists "public"."idx_soa_threads_last_message";

drop index if exists "public"."idx_soa_threads_org_id";

drop index if exists "public"."idx_soa_threads_region_id";

drop index if exists "public"."idx_soa_threads_type";

drop index if exists "public"."idx_soa_threads_wing";

drop index if exists "public"."lesson_progress_lesson_id_user_id_key";

drop index if exists "public"."organization_forms_pkey";

drop index if exists "public"."soa_message_participants_pkey";

drop index if exists "public"."soa_message_participants_thread_id_user_id_key";

drop index if exists "public"."soa_message_reactions_message_id_user_id_emoji_key";

drop index if exists "public"."soa_message_reactions_pkey";

drop index if exists "public"."soa_message_read_receipts_message_id_user_id_key";

drop index if exists "public"."soa_message_read_receipts_pkey";

drop index if exists "public"."soa_message_threads_pkey";

drop index if exists "public"."soa_messages_pkey";

drop index if exists "public"."video_call_participants_video_call_id_user_id_key";

drop index if exists "public"."idx_students_parent_id";

drop index if exists "public"."idx_video_call_participants_call_id";

drop table "public"."birthday_celebration_preferences";

drop table "public"."organization_forms";

drop table "public"."soa_message_participants";

drop table "public"."soa_message_reactions";

drop table "public"."soa_message_read_receipts";

drop table "public"."soa_message_threads";

drop table "public"."soa_messages";


  create table "public"."active_calls" (
    "id" uuid not null default gen_random_uuid(),
    "call_id" uuid not null,
    "caller_id" uuid not null,
    "callee_id" uuid not null,
    "call_type" text not null,
    "status" text not null default 'ringing'::text,
    "caller_name" text,
    "started_at" timestamp with time zone default now(),
    "answered_at" timestamp with time zone,
    "ended_at" timestamp with time zone,
    "duration_seconds" integer,
    "meeting_url" text
      );


alter table "public"."active_calls" enable row level security;


  create table "public"."activities" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "lesson_id" uuid,
    "title" text not null,
    "description" text,
    "activity_type" text,
    "instructions" text,
    "materials_needed" text,
    "estimated_duration" integer,
    "difficulty_level" text,
    "age_appropriate_min" integer,
    "age_appropriate_max" integer,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."activities" enable row level security;


  create table "public"."activity_attempts" (
    "id" uuid not null default gen_random_uuid(),
    "activity_id" uuid not null,
    "student_id" uuid not null,
    "started_at" timestamp with time zone default now(),
    "completed_at" timestamp with time zone,
    "score" numeric(5,2),
    "max_score" numeric(5,2) default 100.00,
    "answers" jsonb default '{}'::jsonb,
    "time_spent_seconds" integer default 0,
    "attempts_count" integer default 1,
    "is_submitted" boolean default false,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."activity_attempts" enable row level security;


  create table "public"."activity_feed" (
    "id" uuid not null default gen_random_uuid(),
    "actor_id" uuid not null,
    "action" character varying(100) not null,
    "target_type" character varying(50) not null,
    "target_id" uuid not null,
    "preschool_id" uuid not null,
    "metadata" jsonb default '{}'::jsonb,
    "visibility" character varying(50) default 'public'::character varying,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."activity_feed" enable row level security;


  create table "public"."activity_logs" (
    "id" bigint not null default nextval('public.activity_logs_id_seq'::regclass),
    "activity_type" text not null,
    "description" text,
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone default now(),
    "organization_id" uuid,
    "user_id" uuid,
    "user_name" text
      );


alter table "public"."activity_logs" enable row level security;


  create table "public"."activity_submissions" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "assigned_teacher_id" uuid,
    "preschool_id" uuid,
    "class_id" uuid,
    "type" text not null,
    "title" text,
    "score" numeric,
    "total" numeric,
    "percentage" numeric,
    "rubric" jsonb,
    "rubric_score" numeric,
    "rubric_total" numeric,
    "thumbnail_url" text,
    "data" jsonb,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."activity_submissions" enable row level security;


  create table "public"."ad_impressions" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid,
    "preschool_id" uuid,
    "ad_unit_id" text not null,
    "ad_network" text default 'admob'::text,
    "ad_type" text not null,
    "impression_id" text,
    "revenue_micros" bigint default 0,
    "currency_code" text default 'ZAR'::text,
    "device_info" jsonb default '{}'::jsonb,
    "app_version" text,
    "placement" text,
    "shown_at" timestamp with time zone default now(),
    "clicked_at" timestamp with time zone,
    "dismissed_at" timestamp with time zone,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."ad_impressions" enable row level security;


  create table "public"."addresses" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "user_id" uuid,
    "address_type" text,
    "street_address" text,
    "city" text,
    "state" text,
    "postal_code" text,
    "country" text default 'South Africa'::text,
    "is_primary" boolean default false,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."addresses" enable row level security;


  create table "public"."admin_users" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "user_id" uuid,
    "permissions" jsonb,
    "last_login_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "organization_id" uuid not null
      );


alter table "public"."admin_users" enable row level security;


  create table "public"."age_groups" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "name" text not null,
    "min_age_months" integer,
    "max_age_months" integer,
    "description" text,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now(),
    "preschool_id" uuid,
    "age_min" integer,
    "age_max" integer,
    "school_type" text default 'preschool'::text
      );


alter table "public"."age_groups" enable row level security;


  create table "public"."ai_admin_actions" (
    "id" uuid not null default gen_random_uuid(),
    "actor_user_id" uuid not null,
    "action" text not null,
    "target_scope" text,
    "target_user_id" uuid,
    "target_preschool_id" uuid,
    "details" jsonb not null default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."ai_admin_actions" enable row level security;


  create table "public"."ai_allocation_history" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "teacher_id" uuid not null,
    "action" text not null,
    "quotas_changed" jsonb not null,
    "previous_quotas" jsonb,
    "new_quotas" jsonb,
    "performed_by" uuid not null,
    "reason" text not null,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."ai_allocation_history" enable row level security;


  create table "public"."ai_allocation_requests" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "teacher_id" uuid not null,
    "requested_by" uuid not null,
    "requested_quotas" jsonb not null,
    "justification" text not null,
    "urgency" text not null,
    "auto_approve_similar" boolean not null default false,
    "status" text not null default 'pending'::text,
    "reviewed_by" uuid,
    "reviewed_at" timestamp with time zone,
    "review_reason" text,
    "expires_at" timestamp with time zone not null default (now() + '7 days'::interval),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."ai_allocation_requests" enable row level security;


  create table "public"."ai_attachments" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "conversation_id" text not null,
    "bucket" text not null default 'attachments'::text,
    "storage_path" text not null,
    "name" text not null,
    "mime_type" text not null,
    "size" bigint not null default 0,
    "sha256" text,
    "kind" text not null default 'other'::text,
    "status" text not null default 'uploaded'::text,
    "page_count" integer,
    "text_bytes" integer,
    "meta" jsonb,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."ai_attachments" enable row level security;


  create table "public"."ai_autonomy_settings" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "preschool_id" uuid not null,
    "autonomy_level" text not null default 'assistant'::text,
    "risk_caps" jsonb default '{"low": true, "high": false, "medium": true}'::jsonb,
    "quiet_hours" jsonb default '{"end": "07:00", "start": "22:00", "enabled": false}'::jsonb,
    "proactive_suggestions_enabled" boolean not null default true,
    "auto_execute_low_risk" boolean not null default false,
    "notification_preferences" jsonb default '{"push": false, "in_app": true}'::jsonb,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."ai_autonomy_settings" enable row level security;


  create table "public"."ai_context_snapshots" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "user_id" uuid not null,
    "snapshot" jsonb not null default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."ai_context_snapshots" enable row level security;


  create table "public"."ai_conversations" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "preschool_id" uuid,
    "conversation_id" text not null,
    "title" text not null,
    "messages" jsonb not null default '[]'::jsonb,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "message_count" integer default 0,
    "last_message_at" timestamp with time zone default now(),
    "preview" text
      );


alter table "public"."ai_conversations" enable row level security;


  create table "public"."ai_events" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "user_id" uuid not null,
    "event_type" text not null,
    "payload" jsonb not null default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."ai_events" enable row level security;


  create table "public"."ai_feedback" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "user_id" uuid not null,
    "task_id" text,
    "decision_id" text,
    "rating" smallint,
    "comment" text,
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."ai_feedback" enable row level security;


  create table "public"."ai_generated_content" (
    "id" uuid not null default gen_random_uuid(),
    "organization_id" uuid not null,
    "content_type" text not null,
    "prompt" text,
    "generated_text" text not null,
    "reviewed" boolean default false,
    "approved" boolean default false,
    "used_at" timestamp with time zone,
    "created_by" uuid,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."ai_generated_content" enable row level security;


  create table "public"."ai_generations" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "user_id" uuid not null,
    "feature_type" text not null,
    "prompt_tokens" integer not null default 0,
    "completion_tokens" integer not null default 0,
    "total_tokens" integer not null default 0,
    "cost_cents" integer not null default 0,
    "model" text not null default 'claude-3-sonnet'::text,
    "status" text not null default 'success'::text,
    "error_message" text,
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."ai_generations" enable row level security;


  create table "public"."ai_global_settings" (
    "id" uuid not null default gen_random_uuid(),
    "default_provider" text not null default 'claude'::text,
    "enable_automatic_fallback" boolean not null default true,
    "fallback_provider" text not null default 'openai'::text,
    "max_retries" integer default 3,
    "retry_delay_seconds" integer default 5,
    "updated_at" timestamp with time zone default now(),
    "updated_by" uuid
      );


alter table "public"."ai_global_settings" enable row level security;


  create table "public"."ai_insights" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "user_id" uuid not null,
    "insight_type" text not null,
    "title" text not null,
    "description" text not null,
    "confidence" double precision not null default 0.5,
    "priority" text not null default 'medium'::text,
    "category" text,
    "data_sources" jsonb default '[]'::jsonb,
    "actionable" boolean not null default false,
    "suggested_actions" jsonb default '[]'::jsonb,
    "impact_estimate" jsonb default '{}'::jsonb,
    "status" text not null default 'active'::text,
    "created_at" timestamp with time zone not null default now(),
    "expires_at" timestamp with time zone,
    "actioned_at" timestamp with time zone
      );


alter table "public"."ai_insights" enable row level security;


  create table "public"."ai_memories" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "user_id" uuid not null,
    "memory_type" text not null,
    "content" jsonb not null default '{}'::jsonb,
    "text_embedding" public.vector(1536),
    "importance" smallint not null default 1,
    "recency_score" double precision not null default 0,
    "accessed_count" integer not null default 0,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."ai_memories" enable row level security;


  create table "public"."ai_messages" (
    "id" uuid not null default gen_random_uuid(),
    "conversation_id" text not null,
    "user_id" uuid not null,
    "role" text not null,
    "content" text not null,
    "image_urls" text[],
    "image_hashes" text[],
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."ai_messages" enable row level security;


  create table "public"."ai_model_tiers" (
    "id" uuid not null default gen_random_uuid(),
    "tier" public.ai_model_tier not null,
    "name" text not null,
    "description" text,
    "allowed_models" jsonb not null default '[]'::jsonb,
    "max_requests_per_minute" integer not null default 0,
    "max_requests_per_day" integer not null default 0,
    "max_requests_per_month" integer not null default 0,
    "max_tokens_per_request" integer,
    "features" jsonb not null default '{}'::jsonb,
    "restrictions" jsonb not null default '{}'::jsonb,
    "metadata" jsonb not null default '{}'::jsonb,
    "is_active" boolean not null default true,
    "sort_order" integer not null default 0,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."ai_model_tiers" enable row level security;


  create table "public"."ai_overage_logs" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "feature" text not null,
    "units" integer not null default 1,
    "amount" numeric(10,2) not null,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."ai_overage_logs" enable row level security;


  create table "public"."ai_provider_config" (
    "id" uuid not null default gen_random_uuid(),
    "service_type" text not null,
    "provider_override" text,
    "model_free" text,
    "model_basic" text,
    "model_premium" text,
    "model_pro" text,
    "model_enterprise" text,
    "max_tokens" integer default 4096,
    "temperature" numeric(3,2) default 0.7,
    "description" text,
    "is_active" boolean not null default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by" uuid
      );


alter table "public"."ai_provider_config" enable row level security;


  create table "public"."ai_recommendations" (
    "id" uuid not null default gen_random_uuid(),
    "learner_id" uuid not null,
    "organization_id" uuid,
    "recommendation_type" text not null,
    "program_id" uuid,
    "confidence_score" numeric(5,2),
    "reasoning" text,
    "acted_upon" boolean default false,
    "acted_at" timestamp with time zone,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."ai_recommendations" enable row level security;


  create table "public"."ai_request_log" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "user_id" uuid not null,
    "request_type" character varying(50) not null,
    "function_name" character varying(100),
    "status" character varying(20) not null,
    "error_message" text,
    "response_time_ms" integer,
    "tokens_used" integer,
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp without time zone default now()
      );


alter table "public"."ai_request_log" enable row level security;


  create table "public"."ai_services" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "name" text not null,
    "provider" text not null,
    "model_version" text not null,
    "input_cost_per_1k_tokens" numeric(8,6) not null,
    "output_cost_per_1k_tokens" numeric(8,6) not null,
    "supports_homework_help" boolean default false,
    "supports_lesson_generation" boolean default false,
    "supports_grading" boolean default false,
    "supports_stem_activities" boolean default false,
    "rate_limit_per_minute" integer default 60,
    "rate_limit_per_hour" integer default 1000,
    "rate_limit_per_day" integer default 10000,
    "is_active" boolean default true,
    "is_available" boolean default true,
    "max_tokens" integer,
    "context_window" integer,
    "description" text,
    "capabilities" jsonb default '[]'::jsonb,
    "restrictions" jsonb default '{}'::jsonb
      );


alter table "public"."ai_services" enable row level security;


  create table "public"."ai_task_runs" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "user_id" uuid not null,
    "task_id" text not null,
    "status" text not null,
    "steps" jsonb not null default '[]'::jsonb,
    "started_at" timestamp with time zone not null default now(),
    "finished_at" timestamp with time zone,
    "error" text,
    "metrics" jsonb default '{}'::jsonb
      );


alter table "public"."ai_task_runs" enable row level security;


  create table "public"."ai_usage" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "organization_id" uuid,
    "model_used" text not null,
    "feature_used" text not null,
    "request_type" text not null default 'completion'::text,
    "tokens_used" integer,
    "request_tokens" integer,
    "response_tokens" integer,
    "processing_time_ms" integer,
    "request_id" text,
    "model_parameters" jsonb default '{}'::jsonb,
    "success" boolean not null default true,
    "error_message" text,
    "usage_date" date not null default CURRENT_DATE,
    "usage_hour" integer not null default EXTRACT(hour FROM now()),
    "metadata" jsonb not null default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."ai_usage" enable row level security;


  create table "public"."ai_usage_logs" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "organization_id" uuid,
    "user_id" uuid not null,
    "ai_service_id" uuid,
    "service_type" text not null,
    "request_context" text,
    "session_id" uuid,
    "input_text" text,
    "input_tokens" integer,
    "system_prompt" text,
    "output_text" text,
    "output_tokens" integer,
    "response_time_ms" integer,
    "status" text not null,
    "error_message" text,
    "input_cost" numeric(8,6),
    "output_cost" numeric(8,6),
    "total_cost" numeric(8,6),
    "user_rating" integer,
    "user_feedback" text,
    "ai_model_used" text,
    "ai_temperature" numeric(3,2),
    "ai_confidence_score" numeric(3,2),
    "preschool_id" uuid,
    "allocation_id" uuid,
    "quota_consumed_from" text,
    "school_total_usage" jsonb,
    "teacher_remaining_quota" jsonb,
    "metadata" jsonb default '{}'::jsonb,
    "processing_time_ms" integer
      );


alter table "public"."ai_usage_logs" enable row level security;


  create table "public"."ai_usage_resets" (
    "id" uuid not null default gen_random_uuid(),
    "requested_by_user_id" uuid not null,
    "target_scope" text not null,
    "target_user_id" uuid,
    "target_preschool_id" uuid,
    "mode" text not null default 'soft'::text,
    "reason" text,
    "status" text not null default 'completed'::text,
    "metadata" jsonb not null default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."ai_usage_resets" enable row level security;


  create table "public"."ai_usage_tiers" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "exams_per_month" integer not null,
    "explanations_per_month" integer not null,
    "chat_messages_per_day" integer not null,
    "priority_queue" boolean default false,
    "advanced_features" boolean default false,
    "monthly_price_zar" numeric(10,2) default 0,
    "is_active" boolean default true,
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now(),
    "tier_name" public.tier_name_aligned
      );


alter table "public"."ai_usage_tiers" enable row level security;


  create table "public"."announcement_views" (
    "id" uuid not null default gen_random_uuid(),
    "announcement_id" uuid not null,
    "user_id" uuid not null,
    "viewed_at" timestamp with time zone default now()
      );


alter table "public"."announcement_views" enable row level security;


  create table "public"."announcements" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "preschool_id" uuid,
    "title" text not null,
    "content" text not null,
    "author_id" uuid,
    "target_audience" text,
    "priority" text default 'medium'::text,
    "is_published" boolean default false,
    "published_at" timestamp with time zone,
    "expires_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "scheduled_for" timestamp with time zone,
    "attachments" jsonb,
    "view_count" integer default 0,
    "pinned" boolean default false
      );


alter table "public"."announcements" enable row level security;


  create table "public"."assessment_rubrics" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "created_by" uuid not null,
    "name" character varying(255) not null,
    "description" text,
    "age_group_id" uuid,
    "subject_area" character varying(100),
    "criteria" jsonb not null,
    "scoring_scale" jsonb not null,
    "is_active" boolean default true,
    "is_template" boolean default false,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."assessment_rubrics" enable row level security;


  create table "public"."assessments" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "class_id" uuid,
    "teacher_id" uuid,
    "title" text not null,
    "description" text,
    "assessment_type" text,
    "total_points" integer default 100,
    "due_date" timestamp with time zone,
    "is_published" boolean default false,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "student_id" uuid,
    "created_by" uuid,
    "organization_id" uuid
      );


alter table "public"."assessments" enable row level security;


  create table "public"."assignment_access" (
    "id" uuid not null default gen_random_uuid(),
    "assignment_id" uuid not null,
    "student_id" uuid not null,
    "group_id" uuid,
    "distributed_by" uuid not null,
    "distributed_at" timestamp with time zone not null default now(),
    "is_active" boolean not null default true,
    "release_date" timestamp with time zone default now(),
    "custom_due_date" timestamp with time zone,
    "custom_instructions" text,
    "custom_points" numeric(8,2),
    "metadata" jsonb not null default '{}'::jsonb
      );


alter table "public"."assignment_access" enable row level security;


  create table "public"."assignment_categories" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "organization_id" uuid not null,
    "name" text not null,
    "description" text,
    "color" text default '#3b82f6'::text,
    "is_active" boolean not null default true
      );


alter table "public"."assignment_categories" enable row level security;


  create table "public"."assignment_grades" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "submission_id" uuid not null,
    "teacher_id" uuid not null,
    "points_earned" numeric(5,2),
    "max_points" numeric(5,2),
    "percentage" numeric(5,2),
    "letter_grade" text,
    "feedback" text,
    "private_notes" text,
    "ai_generated" boolean default false,
    "ai_confidence" numeric(3,2),
    "ai_feedback" text,
    "status" text not null default 'draft'::text,
    "published_at" timestamp with time zone
      );


alter table "public"."assignment_grades" enable row level security;


  create table "public"."assignment_rubrics" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "assignment_id" uuid not null,
    "criteria_name" text not null,
    "criteria_description" text,
    "max_points" integer not null default 10,
    "weight" numeric(3,2) default 1.0,
    "rubric_levels" jsonb not null default '[]'::jsonb
      );


alter table "public"."assignment_rubrics" enable row level security;


  create table "public"."assignment_submissions" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "submission_text" text,
    "attachment_urls" text[],
    "status" text default 'pending'::text,
    "submitted_at" timestamp with time zone,
    "graded_at" timestamp with time zone,
    "grade" text,
    "teacher_feedback" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "assignment_id" uuid not null default gen_random_uuid(),
    "file_urls" text[],
    "feedback" text,
    "learner_id" uuid,
    "enrollment_id" uuid,
    "files" jsonb default '[]'::jsonb,
    "text_response" text
      );


alter table "public"."assignment_submissions" enable row level security;


  create table "public"."assignments" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "organization_id" uuid not null,
    "teacher_id" uuid not null,
    "class_id" uuid,
    "category_id" uuid,
    "title" text not null,
    "description" text,
    "instructions" text,
    "assigned_date" timestamp with time zone not null default now(),
    "due_date" timestamp with time zone,
    "max_points" numeric(8,2) default 100,
    "ai_assistance_enabled" boolean default false,
    "ai_grading_enabled" boolean default false,
    "status" text not null default 'draft'::text,
    "is_visible_to_students" boolean default false,
    "is_visible_to_parents" boolean default false,
    "preschool_id" uuid,
    "course_id" uuid,
    "assignment_type" text default 'homework'::text,
    "assigned_at" timestamp with time zone,
    "due_at" timestamp with time zone,
    "available_from" timestamp with time zone,
    "available_until" timestamp with time zone,
    "allow_late_submissions" boolean default true,
    "late_penalty_percent" numeric(5,2) default 0,
    "max_attempts" integer default 1,
    "attachments" jsonb default '[]'::jsonb,
    "metadata" jsonb default '{}'::jsonb,
    "deleted_at" timestamp with time zone
      );


alter table "public"."assignments" enable row level security;


  create table "public"."attendance" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "recorded_by" uuid not null,
    "attendance_date" date not null default CURRENT_DATE,
    "status" text not null default 'present'::text,
    "arrival_time" time without time zone,
    "departure_time" time without time zone,
    "notes" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "organization_id" uuid
      );


alter table "public"."attendance" enable row level security;


  create table "public"."attendance_records" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "class_id" uuid not null,
    "attendance_date" date not null default CURRENT_DATE,
    "status" text not null default 'present'::text,
    "arrival_time" time without time zone,
    "departure_time" time without time zone,
    "notes" text,
    "attendance_rate" numeric(5,2) default 100.0,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "preschool_id" uuid,
    "date" date default CURRENT_DATE
      );


alter table "public"."attendance_records" enable row level security;


  create table "public"."audit_logs" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "user_id" uuid,
    "action" text not null,
    "resource_type" text,
    "resource_id" uuid,
    "old_values" jsonb,
    "new_values" jsonb,
    "ip_address" inet,
    "user_agent" text,
    "created_at" timestamp with time zone default now(),
    "event_type" public.audit_event_type,
    "event_name" text,
    "event_description" text,
    "actor_id" uuid,
    "actor_role" text,
    "actor_organization_id" uuid,
    "target_id" uuid,
    "target_type" text,
    "target_name" text,
    "request_path" text,
    "request_method" text,
    "metadata" jsonb default '{}'::jsonb,
    "changes_made" jsonb default '{}'::jsonb,
    "session_id" text,
    "correlation_id" text,
    "success" boolean default true,
    "error_message" text,
    "occurred_at" timestamp with time zone
      );


alter table "public"."audit_logs" enable row level security;


  create table "public"."beta_feedback" (
    "id" uuid not null default gen_random_uuid(),
    "auth_user_id" uuid not null,
    "user_id" uuid,
    "role" text,
    "persona" text,
    "category" text,
    "screen" text,
    "description" text not null,
    "steps" text,
    "severity" text,
    "consent_diagnostics" boolean not null default false,
    "device_info" jsonb,
    "app_version" text,
    "build_channel" text,
    "platform" text,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."beta_feedback" enable row level security;


  create table "public"."beta_feedback_attachments" (
    "id" uuid not null default gen_random_uuid(),
    "feedback_id" uuid not null,
    "file_path" text not null,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."beta_feedback_attachments" enable row level security;


  create table "public"."billing_cycles" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "subscription_plan_id" uuid,
    "billing_period" character varying(20) not null,
    "cycle_start" date not null,
    "cycle_end" date not null,
    "amount" numeric(10,2) not null,
    "status" character varying(20) not null default 'active'::character varying,
    "auto_renew" boolean default true,
    "next_billing_date" date,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."billing_cycles" enable row level security;


  create table "public"."billing_invoices" (
    "id" uuid not null default gen_random_uuid(),
    "school_id" uuid,
    "subscription_id" uuid,
    "invoice_number" text not null,
    "amount" numeric(10,2) not null,
    "currency" text default 'ZAR'::text,
    "status" text not null,
    "due_date" timestamp with time zone not null,
    "paid_at" timestamp with time zone,
    "invoice_data" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."billing_invoices" enable row level security;


  create table "public"."billing_plans" (
    "id" uuid not null default gen_random_uuid(),
    "name" text not null,
    "display_name" text not null,
    "description" text,
    "price_cents" integer not null default 0,
    "currency" text not null default 'ZAR'::text,
    "ai_monthly_credits" integer not null default 0,
    "max_teachers" integer not null default 1,
    "max_parents" integer not null default 10,
    "max_students" integer not null default 20,
    "ads_enabled" boolean not null default true,
    "features" jsonb not null default '{}'::jsonb,
    "active" boolean not null default true,
    "sort_order" integer default 0,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."billing_plans" enable row level security;


  create table "public"."billing_preferences" (
    "user_id" uuid not null,
    "overage_enabled" boolean not null default false,
    "overage_price_per_unit" numeric(10,2) not null default 3.00,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."billing_preferences" enable row level security;


  create table "public"."blocked_content" (
    "id" uuid not null default gen_random_uuid(),
    "blocker_id" uuid not null,
    "content_type" character varying(50) not null,
    "content_id" uuid not null,
    "author_id" uuid,
    "reason" character varying(100),
    "school_id" uuid,
    "created_at" timestamp with time zone default now(),
    "is_active" boolean default true
      );


alter table "public"."blocked_content" enable row level security;


  create table "public"."books" (
    "id" uuid not null default gen_random_uuid(),
    "title" text not null,
    "subject" text not null,
    "grade" text not null,
    "grade_range" text,
    "language" text default 'English'::text,
    "file_path" text not null,
    "file_url" text,
    "file_size" bigint,
    "pages" integer,
    "description" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."books" enable row level security;


  create table "public"."calendar_event_mappings" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "internal_event_id" uuid,
    "provider" text not null,
    "external_event_id" text not null,
    "external_calendar_id" text,
    "created_by_user_id" uuid,
    "last_synced_at" timestamp with time zone not null default now(),
    "sync_direction" text not null default 'bidirectional'::text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."calendar_event_mappings" enable row level security;


  create table "public"."call_signals" (
    "id" uuid not null default gen_random_uuid(),
    "call_id" uuid not null,
    "from_user_id" uuid not null,
    "to_user_id" uuid not null,
    "signal_type" text not null,
    "payload" jsonb not null,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."call_signals" enable row level security;


  create table "public"."campaign_redemptions" (
    "id" uuid not null default gen_random_uuid(),
    "campaign_id" uuid not null,
    "registration_request_id" uuid,
    "redeemed_by_email" character varying(255) not null,
    "discount_applied" numeric(10,2) not null,
    "original_amount" numeric(10,2) not null,
    "final_amount" numeric(10,2) not null,
    "promo_code_used" character varying(50),
    "auto_applied" boolean default false,
    "redeemed_at" timestamp without time zone default now()
      );


alter table "public"."campaign_redemptions" enable row level security;


  create table "public"."caps_chunks" (
    "id" uuid not null default gen_random_uuid(),
    "document_id" uuid not null,
    "page_start" integer,
    "page_end" integer,
    "heading" text,
    "content" text not null,
    "token_count" integer,
    "embedding" public.vector(1536),
    "metadata" jsonb,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."caps_chunks" enable row level security;


  create table "public"."caps_content_chunks" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "document_id" uuid not null,
    "chunk_index" integer not null,
    "chunk_type" character varying(50),
    "heading" character varying(500),
    "content" text not null,
    "embedding" public.vector(1536),
    "page_number" integer,
    "word_count" integer,
    "created_at" timestamp without time zone default now()
      );


alter table "public"."caps_content_chunks" enable row level security;


  create table "public"."caps_documents" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "document_type" character varying(50) not null,
    "grade" character varying(10) not null,
    "subject" character varying(100) not null,
    "topic" character varying(255),
    "section" character varying(255),
    "year" integer,
    "term" integer,
    "title" character varying(500) not null,
    "description" text,
    "content_text" text not null,
    "file_url" text not null,
    "file_path" text not null,
    "file_size_bytes" bigint,
    "page_count" integer,
    "keywords" text[],
    "learning_outcomes" text[],
    "assessment_standards" text[],
    "source_url" text,
    "language" character varying(10) default 'en'::character varying,
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now(),
    "published_date" date,
    "source" text,
    "storage_path" text,
    "checksum" text
      );


alter table "public"."caps_documents" enable row level security;


  create table "public"."caps_exam_patterns" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "grade" character varying(10) not null,
    "subject" character varying(100) not null,
    "topic" character varying(255) not null,
    "frequency_score" double precision not null,
    "average_marks" double precision,
    "difficulty_trend" character varying(20),
    "years_appeared" integer[],
    "last_appeared_year" integer,
    "years_analyzed" integer not null,
    "likelihood_next_year" double precision,
    "recommended_study_priority" character varying(20),
    "analysis_date" timestamp without time zone default now(),
    "notes" text
      );


alter table "public"."caps_exam_patterns" enable row level security;


  create table "public"."caps_exam_questions" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "document_id" uuid,
    "question_number" character varying(20) not null,
    "sub_question" character varying(10),
    "question_text" text not null,
    "marks" integer not null,
    "difficulty" character varying(20),
    "grade" character varying(10) not null,
    "subject" character varying(100) not null,
    "topic" character varying(255),
    "subtopic" character varying(255),
    "year" integer not null,
    "paper_number" integer,
    "question_type" character varying(50),
    "cognitive_level" character varying(50),
    "answer_text" text,
    "marking_guideline" text,
    "common_errors" jsonb,
    "times_used" integer default 0,
    "last_used_date" timestamp without time zone,
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now()
      );


alter table "public"."caps_exam_questions" enable row level security;


  create table "public"."caps_textbook_mapping" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "caps_topic_id" uuid not null,
    "textbook_content_id" uuid not null,
    "coverage_percentage" integer,
    "is_primary_reference" boolean default false,
    "alignment_score" integer,
    "verified_by" uuid,
    "verification_date" timestamp without time zone,
    "verification_notes" text,
    "key_pages" integer[],
    "diagram_pages" integer[],
    "example_pages" integer[],
    "exercise_pages" integer[],
    "status" character varying(20) default 'draft'::character varying,
    "mapping_notes" text,
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now(),
    "created_by" uuid
      );


alter table "public"."caps_textbook_mapping" enable row level security;


  create table "public"."caps_topics" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "grade" character varying(10) not null,
    "subject" character varying(100) not null,
    "topic_code" character varying(50),
    "topic_title" character varying(255) not null,
    "description" text,
    "specific_aims" text[],
    "learning_outcomes" text[],
    "assessment_standards" text[],
    "content_outline" text not null,
    "skills_to_develop" text[],
    "knowledge_areas" text[],
    "suggested_time_hours" integer,
    "prerequisites" text[],
    "cognitive_level" character varying(50),
    "term" integer,
    "caps_document_reference" character varying(255),
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now()
      );


alter table "public"."caps_topics" enable row level security;


  create table "public"."chat_images" (
    "id" uuid not null default gen_random_uuid(),
    "hash" text not null,
    "storage_path" text not null,
    "public_url" text not null,
    "uploaded_by" uuid not null,
    "size_bytes" integer,
    "mime_type" text default 'image/jpeg'::text,
    "width" integer,
    "height" integer,
    "reference_count" integer default 1,
    "last_used_at" timestamp with time zone default now(),
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."chat_images" enable row level security;


  create table "public"."class_assignments" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "student_id" uuid,
    "class_id" uuid,
    "assigned_date" date default CURRENT_DATE,
    "status" text default 'active'::text,
    "start_date" date default CURRENT_DATE,
    "end_date" date,
    "notes" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."class_assignments" enable row level security;


  create table "public"."class_events" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "class_id" uuid not null,
    "teacher_id" uuid,
    "title" text not null,
    "description" text,
    "event_type" text not null default 'lesson'::text,
    "start_time" timestamp with time zone not null,
    "end_time" timestamp with time zone,
    "location" text,
    "notes" text,
    "status" text not null default 'scheduled'::text,
    "requires_parent_consent" boolean default false,
    "max_participants" integer,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."class_events" enable row level security;


  create table "public"."classroom_reports" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "teacher_id" uuid not null,
    "student_id" uuid not null,
    "class_id" uuid,
    "report_type" character varying(20) not null,
    "report_date" date not null,
    "activities_summary" jsonb,
    "total_activities" integer default 0,
    "behavior_notes" text,
    "mood_rating" integer,
    "participation_level" character varying(20),
    "social_interactions" text,
    "learning_highlights" text,
    "skills_developed" text[],
    "areas_for_improvement" text,
    "achievement_badges" text[],
    "meals_eaten" text[],
    "nap_time_start" time without time zone,
    "nap_time_end" time without time zone,
    "diaper_changes" integer default 0,
    "bathroom_visits" integer default 0,
    "health_observations" text,
    "incidents" text,
    "medications_given" text[],
    "temperature_checks" jsonb,
    "parent_message" text,
    "follow_up_needed" boolean default false,
    "next_steps" text,
    "media_highlights" text[],
    "photo_count" integer default 0,
    "is_sent_to_parents" boolean default false,
    "sent_at" timestamp with time zone,
    "parent_viewed_at" timestamp with time zone,
    "parent_acknowledgment" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."classroom_reports" enable row level security;


  create table "public"."config_kv" (
    "key" text not null,
    "value" jsonb not null,
    "description" text,
    "is_public" boolean default false,
    "preschool_id" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."config_kv" enable row level security;


  create table "public"."contact_discovery_settings" (
    "user_id" uuid not null,
    "allow_phone_discovery" boolean default true,
    "allow_contact_sync" boolean default true,
    "allow_cross_school_messages" boolean default true,
    "show_in_suggestions" boolean default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."contact_discovery_settings" enable row level security;


  create table "public"."contact_suggestions" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "suggested_user_id" uuid not null,
    "reason" character varying(50) not null,
    "confidence_score" integer default 50,
    "is_dismissed" boolean default false,
    "created_at" timestamp with time zone default now(),
    "expires_at" timestamp with time zone default (now() + '30 days'::interval)
      );


alter table "public"."contact_suggestions" enable row level security;


  create table "public"."content_reports" (
    "id" uuid not null default gen_random_uuid(),
    "reporter_id" uuid,
    "content_type" character varying(50) not null,
    "content_id" uuid not null,
    "content_title" text,
    "content_excerpt" text,
    "report_reason" character varying(100) not null,
    "report_details" text,
    "severity" character varying(20) default 'medium'::character varying,
    "status" character varying(20) default 'pending'::character varying,
    "school_id" uuid,
    "author_id" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "reviewed_by" uuid,
    "reviewed_at" timestamp with time zone,
    "resolution_notes" text,
    "auto_flagged" boolean default false
      );


alter table "public"."content_reports" enable row level security;


  create table "public"."conversation_members" (
    "id" uuid not null default gen_random_uuid(),
    "conversation_id" uuid not null,
    "user_id" uuid not null,
    "role" text not null default 'member'::text,
    "is_muted" boolean not null default false,
    "joined_at" timestamp with time zone not null default now(),
    "last_read_at" timestamp with time zone,
    "cleared_at" timestamp with time zone
      );


alter table "public"."conversation_members" enable row level security;


  create table "public"."conversations" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "class_id" uuid,
    "type" text not null default 'group'::text,
    "name" text,
    "description" text,
    "created_by" uuid,
    "settings" jsonb not null default '{"locked": false, "admins_only": false, "allow_member_posting": true}'::jsonb,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."conversations" enable row level security;


  create table "public"."course_grades" (
    "id" uuid not null default gen_random_uuid(),
    "course_id" uuid not null,
    "student_id" uuid not null,
    "final_grade" numeric(5,2) not null,
    "letter_grade" text not null,
    "gpa_points" numeric(3,2),
    "category_grades" jsonb default '{}'::jsonb,
    "calculation_method" text not null default 'points'::text,
    "total_points_earned" numeric(10,2),
    "total_points_possible" numeric(10,2),
    "is_final" boolean not null default false,
    "is_published" boolean not null default false,
    "calculated_at" timestamp with time zone not null default now(),
    "calculated_by" uuid not null,
    "metadata" jsonb not null default '{}'::jsonb
      );


alter table "public"."course_grades" enable row level security;


  create table "public"."course_join_requests" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "course_id" uuid not null,
    "requested_at" timestamp with time zone not null default now(),
    "message" text,
    "status" text not null default 'pending'::text,
    "processed_by" uuid,
    "processed_at" timestamp with time zone,
    "notes" text,
    "metadata" jsonb not null default '{}'::jsonb
      );


alter table "public"."course_join_requests" enable row level security;


  create table "public"."courses" (
    "id" uuid not null default gen_random_uuid(),
    "title" text not null,
    "description" text,
    "course_code" text,
    "instructor_id" uuid not null,
    "organization_id" uuid not null,
    "is_active" boolean not null default true,
    "max_students" integer,
    "join_code" text,
    "join_code_expires_at" timestamp with time zone,
    "start_date" date,
    "end_date" date,
    "metadata" jsonb not null default '{}'::jsonb,
    "deleted_at" timestamp with time zone,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."courses" enable row level security;


  create table "public"."cv_templates" (
    "id" uuid not null default gen_random_uuid(),
    "organization_id" uuid not null,
    "name" text not null,
    "template_type" text not null,
    "design" jsonb not null default '{}'::jsonb,
    "fields" jsonb not null default '[]'::jsonb,
    "is_default" boolean default false,
    "is_active" boolean default true,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."cv_templates" enable row level security;


  create table "public"."cv_uploads" (
    "id" uuid not null default gen_random_uuid(),
    "organization_id" uuid not null,
    "uploaded_by" uuid not null,
    "file_url" text not null,
    "file_type" text not null,
    "extracted_data" jsonb,
    "status" text not null default 'pending'::text,
    "error" text,
    "processed_at" timestamp with time zone,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."cv_uploads" enable row level security;


  create table "public"."daily_activities" (
    "id" uuid not null default gen_random_uuid(),
    "class_id" uuid not null,
    "created_by" uuid not null,
    "activity_name" text not null,
    "description" text,
    "activity_date" date default CURRENT_DATE,
    "start_time" time without time zone,
    "end_time" time without time zone,
    "materials_needed" text[],
    "learning_objectives" text[],
    "notes" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."daily_activities" enable row level security;


  create table "public"."dash_agent_instances" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "preschool_id" uuid not null,
    "session_id" text not null,
    "settings" jsonb not null default '{}'::jsonb,
    "last_active" timestamp with time zone not null default now(),
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."dash_agent_instances" enable row level security;


  create table "public"."dash_conversation_facts" (
    "id" uuid not null default gen_random_uuid(),
    "conversation_id" text,
    "user_id" uuid not null,
    "preschool_id" uuid not null,
    "key" text not null,
    "value" jsonb not null default '{}'::jsonb,
    "language" text,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."dash_conversation_facts" enable row level security;


  create table "public"."dash_curriculum_memory" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "memory_type" character varying(50) not null,
    "grade" character varying(10),
    "subject" character varying(100),
    "topic" character varying(255),
    "title" character varying(500),
    "content" text not null,
    "usefulness_score" double precision default 0.5,
    "times_referenced" integer default 0,
    "last_referenced" timestamp without time zone,
    "source" character varying(100),
    "verified" boolean default false,
    "related_document_ids" uuid[],
    "related_questions" uuid[],
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now()
      );


alter table "public"."dash_curriculum_memory" enable row level security;


  create table "public"."dash_reminders" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "preschool_id" uuid not null,
    "title" text not null,
    "payload" jsonb not null default '{}'::jsonb,
    "schedule_at" timestamp with time zone not null,
    "status" text not null default 'active'::text,
    "created_at" timestamp with time zone not null default now(),
    "triggered_at" timestamp with time zone
      );


alter table "public"."dash_reminders" enable row level security;


  create table "public"."dash_storage" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "user_id" uuid not null,
    "storage_key" text not null,
    "storage_value" jsonb not null,
    "data_type" text not null default 'general'::text,
    "category" text,
    "tags" text[],
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "expires_at" timestamp with time zone
      );


alter table "public"."dash_storage" enable row level security;


  create table "public"."dash_user_contexts" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "preschool_id" uuid not null,
    "preferred_language" text,
    "timezone" text,
    "traits" jsonb not null default '{}'::jsonb,
    "last_seen" timestamp with time zone not null default now(),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."dash_user_contexts" enable row level security;


  create table "public"."dashboard_voice_notes" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "storage_path" text not null,
    "duration_seconds" integer not null default 0,
    "file_size" bigint,
    "transcription" text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "deleted_at" timestamp with time zone
      );


alter table "public"."dashboard_voice_notes" enable row level security;


  create table "public"."deletion_requests" (
    "id" uuid not null default gen_random_uuid(),
    "request_id" text not null,
    "full_name" text not null,
    "email" text not null,
    "user_id" uuid,
    "role" text not null,
    "organization" text,
    "deletion_types" text[] not null,
    "reason" text,
    "status" text not null default 'pending'::text,
    "submitted_at" timestamp with time zone not null default now(),
    "verified_at" timestamp with time zone,
    "processed_at" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "processed_by" uuid,
    "notes" text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."deletion_requests" enable row level security;


  create table "public"."delivery_providers" (
    "id" uuid not null default gen_random_uuid(),
    "provider_name" public.delivery_provider_enum not null,
    "display_name" text not null,
    "description" text,
    "config" jsonb default '{}'::jsonb,
    "endpoints" jsonb default '{}'::jsonb,
    "rate_limits" jsonb default '{}'::jsonb,
    "is_enabled" boolean default true,
    "is_primary" boolean default false,
    "priority" integer default 0,
    "supported_channels" public.delivery_method_enum[] default '{}'::public.delivery_method_enum[],
    "daily_quota" integer,
    "monthly_quota" integer,
    "current_daily_usage" integer default 0,
    "current_monthly_usage" integer default 0,
    "quota_reset_daily" timestamp with time zone default date_trunc('day'::text, (now() + '1 day'::interval)),
    "quota_reset_monthly" timestamp with time zone default date_trunc('month'::text, (now() + '1 mon'::interval)),
    "last_health_check" timestamp with time zone,
    "health_status" text default 'unknown'::text,
    "error_rate_24h" numeric(5,2) default 0.0,
    "avg_response_time_ms" integer default 0,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "created_by" uuid,
    "updated_by" uuid
      );


alter table "public"."delivery_providers" enable row level security;


  create table "public"."delivery_retry_queue" (
    "id" uuid not null default gen_random_uuid(),
    "delivery_id" uuid not null,
    "retry_attempt" integer not null,
    "scheduled_at" timestamp with time zone not null,
    "reason" text,
    "previous_error" text,
    "retry_strategy" public.retry_strategy_enum not null,
    "is_processed" boolean default false,
    "processed_at" timestamp with time zone,
    "processing_result" jsonb,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."delivery_retry_queue" enable row level security;


  create table "public"."delivery_webhooks" (
    "id" uuid not null default gen_random_uuid(),
    "delivery_id" uuid not null,
    "provider" public.delivery_provider_enum not null,
    "event_type" text not null,
    "webhook_payload" jsonb not null,
    "is_processed" boolean default false,
    "processed_at" timestamp with time zone,
    "processing_error" text,
    "headers" jsonb default '{}'::jsonb,
    "source_ip" inet,
    "user_agent" text,
    "signature" text,
    "is_verified" boolean default false,
    "received_at" timestamp with time zone not null default now()
      );


alter table "public"."delivery_webhooks" enable row level security;


  create table "public"."dm_settings" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "partner_user_id" uuid not null,
    "is_muted" boolean not null default false,
    "cleared_at" timestamp with time zone,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."dm_settings" enable row level security;


  create table "public"."early_access_signups" (
    "id" uuid not null default gen_random_uuid(),
    "email" text not null,
    "source" text default 'homepage'::text,
    "platform" text default 'google_play'::text,
    "notified" boolean default false,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."early_access_signups" enable row level security;


  create table "public"."email_logs" (
    "id" uuid not null default gen_random_uuid(),
    "organization_id" uuid not null,
    "user_id" uuid not null,
    "recipient" text not null,
    "subject" text not null,
    "status" text not null,
    "message_id" text,
    "error_message" text,
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."email_logs" enable row level security;


  create table "public"."email_preferences" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "email" text not null,
    "newsletters_enabled" boolean default true,
    "progress_reports_enabled" boolean default true,
    "event_reminders_enabled" boolean default true,
    "marketing_enabled" boolean default false,
    "unsubscribed_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."email_preferences" enable row level security;


  create table "public"."email_templates" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid,
    "name" text not null,
    "template_type" text not null,
    "subject_template" text not null,
    "body_html" text not null,
    "body_text" text,
    "variables" jsonb default '[]'::jsonb,
    "is_system_template" boolean default false,
    "is_active" boolean default true,
    "created_by" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."email_templates" enable row level security;


  create table "public"."emergency_contacts" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "student_id" uuid,
    "name" text not null,
    "relationship" text not null,
    "phone" text not null,
    "email" text,
    "address" text,
    "is_primary" boolean default false,
    "can_pickup" boolean default true,
    "notes" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."emergency_contacts" enable row level security;


  create table "public"."enrollment_applications" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "child_name" text not null,
    "child_date_of_birth" date,
    "child_gender" text,
    "parent_name" text not null,
    "parent_email" text not null,
    "parent_phone" text,
    "parent_address" text,
    "emergency_contact_name" text,
    "emergency_contact_phone" text,
    "emergency_contact_relationship" text,
    "medical_conditions" text,
    "allergies" text,
    "status" text default 'pending'::text,
    "preferred_start_date" date,
    "preferred_class_id" uuid,
    "application_notes" text,
    "admin_notes" text,
    "documents" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "reviewed_by" uuid,
    "reviewed_at" timestamp with time zone
      );


alter table "public"."enrollment_applications" enable row level security;


  create table "public"."enrollments" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "course_id" uuid not null,
    "enrolled_at" timestamp with time zone not null default now(),
    "enrollment_method" text not null default 'manual'::text,
    "is_active" boolean not null default true,
    "dropped_at" timestamp with time zone,
    "drop_reason" text,
    "metadata" jsonb not null default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."enrollments" enable row level security;


  create table "public"."enterprise_leads" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "contact_name" text,
    "contact_email" text not null,
    "phone" text,
    "organization_name" text,
    "country" text,
    "role" text,
    "school_size" text,
    "plan_interest" text,
    "notes" text,
    "status" public.lead_status not null default 'new'::public.lead_status
      );


alter table "public"."enterprise_leads" enable row level security;


  create table "public"."error_logs" (
    "id" uuid not null default gen_random_uuid(),
    "timestamp" timestamp with time zone default now(),
    "level" text not null,
    "message" text not null,
    "source" text not null,
    "user_id" uuid,
    "details" jsonb,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."error_logs" enable row level security;


  create table "public"."event_attendees" (
    "id" uuid not null default gen_random_uuid(),
    "event_id" uuid not null,
    "member_id" uuid not null,
    "status" character varying(30) default 'registered'::character varying,
    "registered_at" timestamp with time zone default now(),
    "checked_in_at" timestamp with time zone,
    "notes" text
      );


alter table "public"."event_attendees" enable row level security;


  create table "public"."event_audiences" (
    "id" uuid not null default gen_random_uuid(),
    "event_id" uuid not null,
    "audience_type" character varying(50) not null,
    "target_id" uuid,
    "target_value" character varying(255),
    "created_at" timestamp with time zone default now()
      );


alter table "public"."event_audiences" enable row level security;


  create table "public"."event_invitations" (
    "id" uuid not null default gen_random_uuid(),
    "event_id" uuid not null,
    "inviter_id" uuid not null,
    "invitee_id" uuid not null,
    "status" character varying(20) default 'pending'::character varying,
    "response_message" text,
    "invited_at" timestamp with time zone default now(),
    "responded_at" timestamp with time zone,
    "reminder_count" integer default 0,
    "last_reminder_at" timestamp with time zone
      );


alter table "public"."event_invitations" enable row level security;


  create table "public"."event_media" (
    "id" uuid not null default gen_random_uuid(),
    "event_id" uuid not null,
    "update_id" uuid,
    "uploader_id" uuid not null,
    "media_type" character varying(20) not null,
    "file_url" text not null,
    "thumbnail_url" text,
    "file_name" character varying(255),
    "file_size" bigint,
    "mime_type" character varying(100),
    "alt_text" text,
    "caption" text,
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone default now(),
    "deleted_at" timestamp with time zone
      );


alter table "public"."event_media" enable row level security;


  create table "public"."event_notifications" (
    "id" uuid not null default gen_random_uuid(),
    "event_id" uuid not null,
    "update_id" uuid,
    "recipient_id" uuid not null,
    "notification_type" character varying(50) not null,
    "title" character varying(255) not null,
    "message" text,
    "read_at" timestamp with time zone,
    "sent_at" timestamp with time zone default now(),
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."event_notifications" enable row level security;


  create table "public"."event_participants" (
    "id" uuid not null default gen_random_uuid(),
    "event_id" uuid not null,
    "user_id" uuid not null,
    "student_id" uuid,
    "participation_type" character varying(50) default 'attendee'::character varying,
    "status" character varying(20) default 'registered'::character varying,
    "registered_at" timestamp with time zone default now(),
    "checked_in_at" timestamp with time zone,
    "checked_out_at" timestamp with time zone,
    "notes" text,
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."event_participants" enable row level security;


  create table "public"."event_reactions" (
    "id" uuid not null default gen_random_uuid(),
    "event_id" uuid,
    "update_id" uuid,
    "user_id" uuid not null,
    "reaction_type" character varying(50) not null,
    "content" text,
    "parent_reaction_id" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "deleted_at" timestamp with time zone
      );


alter table "public"."event_reactions" enable row level security;


  create table "public"."event_rsvps" (
    "id" uuid not null default gen_random_uuid(),
    "event_id" uuid not null,
    "user_id" uuid not null,
    "preschool_id" uuid not null,
    "status" text not null default 'pending'::text,
    "number_of_guests" integer default 0,
    "notes" text,
    "responded_at" timestamp with time zone,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."event_rsvps" enable row level security;


  create table "public"."event_updates" (
    "id" uuid not null default gen_random_uuid(),
    "event_id" uuid not null,
    "author_id" uuid not null,
    "title" character varying(255),
    "content" text not null,
    "update_type" character varying(50) default 'general'::character varying,
    "is_live" boolean default false,
    "posted_at" timestamp with time zone default now(),
    "visibility" character varying(20) default 'public'::character varying,
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "deleted_at" timestamp with time zone
      );


alter table "public"."event_updates" enable row level security;


  create table "public"."events" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "preschool_id" uuid,
    "title" text not null,
    "description" text,
    "event_type" text,
    "start_date" timestamp with time zone not null,
    "end_date" timestamp with time zone,
    "location" text,
    "created_by" uuid,
    "is_published" boolean default false,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "status" character varying(20) default 'upcoming'::character varying,
    "max_participants" integer,
    "cover_image_url" text,
    "is_featured" boolean default false,
    "tags" text[],
    "metadata" jsonb default '{}'::jsonb,
    "audience_type" character varying(50) default 'everyone'::character varying,
    "audience_config" jsonb default '{}'::jsonb,
    "requires_approval" boolean default false,
    "auto_accept_roles" text[] default '{}'::text[],
    "visibility" character varying(50) default 'public'::character varying,
    "current_participants" integer default 0,
    "event_date" timestamp with time zone
      );


alter table "public"."events" enable row level security;


  create table "public"."exam_assignments" (
    "id" uuid not null default gen_random_uuid(),
    "exam_generation_id" uuid,
    "teacher_id" uuid,
    "title" text not null,
    "description" text,
    "student_ids" uuid[] not null default '{}'::uuid[],
    "class_id" uuid,
    "assigned_at" timestamp with time zone default now(),
    "due_date" timestamp with time zone,
    "status" text default 'active'::text,
    "allow_late_submission" boolean default true,
    "show_correct_answers" boolean default false,
    "max_attempts" integer default 1,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."exam_assignments" enable row level security;


  create table "public"."exam_attempts" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "exam_paper_id" uuid not null,
    "student_id" uuid,
    "answers" jsonb not null,
    "score" integer,
    "total_marks" integer not null,
    "percentage" numeric(5,2),
    "started_at" timestamp with time zone not null default now(),
    "completed_at" timestamp with time zone,
    "time_taken" integer,
    "ai_feedback" jsonb,
    "strengths" text[],
    "areas_to_improve" text[],
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."exam_attempts" enable row level security;


  create table "public"."exam_generations" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid,
    "grade" text not null,
    "subject" text not null,
    "exam_type" text not null,
    "prompt" text,
    "generated_content" text,
    "display_title" text,
    "metadata" jsonb default '{}'::jsonb,
    "duration" integer,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "status" text default 'completed'::text,
    "model_used" text default 'claude-3-5-sonnet-20240620'::text,
    "viewed_at" timestamp with time zone,
    "downloaded_at" timestamp with time zone,
    "user_rating" integer,
    "user_feedback" text,
    "generation_duration_ms" integer,
    "token_count" integer,
    "error_message" text
      );


alter table "public"."exam_generations" enable row level security;


  create table "public"."exam_papers" (
    "id" uuid not null default gen_random_uuid(),
    "title" text not null,
    "subject" text not null,
    "grade" text not null,
    "year" integer not null,
    "term" text,
    "paper_type" text,
    "curriculum_code" text,
    "topics" text[],
    "difficulty_level" text,
    "questions" jsonb not null,
    "total_marks" integer not null,
    "time_allowed" integer,
    "pdf_url" text,
    "memo_pdf_url" text,
    "language" text default 'en-ZA'::text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by" uuid,
    "search_vector" tsvector
      );


alter table "public"."exam_papers" enable row level security;


  create table "public"."exam_submissions" (
    "id" uuid not null default gen_random_uuid(),
    "assignment_id" uuid,
    "student_id" uuid,
    "answers" jsonb not null default '{}'::jsonb,
    "score" numeric(5,2),
    "max_score" numeric(5,2),
    "percentage" numeric(5,2),
    "started_at" timestamp with time zone default now(),
    "submitted_at" timestamp with time zone,
    "time_taken_seconds" integer,
    "status" text default 'in_progress'::text,
    "attempt_number" integer default 1,
    "teacher_feedback" text,
    "graded_at" timestamp with time zone,
    "graded_by" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."exam_submissions" enable row level security;


  create table "public"."exam_user_progress" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid,
    "past_paper_id" uuid,
    "exam_generation_id" uuid,
    "grade" text not null,
    "subject" text not null,
    "exam_title" text,
    "attempt_number" integer default 1,
    "started_at" timestamp with time zone default now(),
    "completed_at" timestamp with time zone,
    "time_spent_minutes" integer,
    "score_obtained" numeric(6,2),
    "score_total" numeric(6,2),
    "percentage" numeric(5,2),
    "section_scores" jsonb,
    "user_notes" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."exam_user_progress" enable row level security;


  create table "public"."expense_categories" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "name" text not null,
    "description" text,
    "color" text default '#6366f1'::text,
    "icon" text default 'receipt'::text,
    "monthly_budget" numeric(10,2) default 0.00,
    "yearly_budget" numeric(10,2) default 0.00,
    "requires_approval" boolean default true,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by" uuid not null
      );


alter table "public"."expense_categories" enable row level security;


  create table "public"."feature_flags" (
    "id" uuid not null default gen_random_uuid(),
    "feature_key" text not null,
    "display_name" text not null,
    "description" text,
    "enabled" boolean default true,
    "tier_restrictions" jsonb default '{}'::jsonb,
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."feature_flags" enable row level security;


  create table "public"."fee_payments" (
    "id" uuid not null default gen_random_uuid(),
    "student_fee_assignment_id" uuid not null,
    "student_id" uuid not null,
    "preschool_id" uuid not null,
    "amount_cents" integer not null,
    "currency" text default 'ZAR'::text,
    "payment_method" text,
    "payfast_payment_id" text,
    "payfast_transaction_id" text,
    "payfast_status" text,
    "reference_number" text,
    "receipt_number" text,
    "status" text default 'pending'::text,
    "payment_date" timestamp with time zone default now(),
    "processed_at" timestamp with time zone,
    "metadata" jsonb default '{}'::jsonb,
    "processed_by" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."fee_payments" enable row level security;


  create table "public"."financial_transactions" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "student_id" uuid,
    "type" text not null,
    "amount" numeric(10,2) not null,
    "description" text not null,
    "reference_number" text,
    "status" text not null default 'pending'::text,
    "payment_method" text,
    "payment_reference" text,
    "expense_category_id" uuid,
    "vendor_name" text,
    "receipt_image_path" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by" uuid not null,
    "approved_by" uuid,
    "approved_at" timestamp with time zone,
    "metadata" jsonb default '{}'::jsonb
      );


alter table "public"."financial_transactions" enable row level security;


  create table "public"."gradebook_entries" (
    "id" uuid not null default gen_random_uuid(),
    "course_id" uuid not null,
    "student_id" uuid not null,
    "total_points_earned" numeric(10,2) default 0,
    "total_points_possible" numeric(10,2) default 0,
    "current_percentage" numeric(5,2) generated always as (
CASE
    WHEN (total_points_possible > (0)::numeric) THEN ((total_points_earned / total_points_possible) * (100)::numeric)
    ELSE (0)::numeric
END) stored,
    "current_letter_grade" text,
    "is_passing" boolean default false,
    "metadata" jsonb not null default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."gradebook_entries" enable row level security;


  create table "public"."grades" (
    "id" uuid not null default gen_random_uuid(),
    "submission_id" uuid not null,
    "graded_by" uuid not null,
    "points_earned" numeric(8,2) not null,
    "points_possible" numeric(8,2) not null,
    "percentage" numeric(5,2) generated always as (((points_earned / points_possible) * (100)::numeric)) stored,
    "letter_grade" text,
    "feedback" text,
    "rubric_scores" jsonb default '{}'::jsonb,
    "ai_assistance_used" boolean not null default false,
    "ai_suggestions" jsonb default '{}'::jsonb,
    "is_final" boolean not null default true,
    "is_published" boolean not null default false,
    "metadata" jsonb not null default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "organization_id" uuid
      );


alter table "public"."grades" enable row level security;


  create table "public"."group_invitations" (
    "id" uuid not null default gen_random_uuid(),
    "group_id" uuid not null,
    "inviter_id" uuid not null,
    "invitee_id" uuid not null,
    "message" text,
    "status" character varying(20) default 'pending'::character varying,
    "invited_at" timestamp with time zone default now(),
    "responded_at" timestamp with time zone,
    "expires_at" timestamp with time zone default (now() + '7 days'::interval)
      );


alter table "public"."group_invitations" enable row level security;


  create table "public"."group_members" (
    "id" uuid not null default gen_random_uuid(),
    "group_id" uuid not null,
    "user_id" uuid not null,
    "role_in_group" character varying(50) default 'member'::character varying,
    "joined_at" timestamp with time zone default now(),
    "invited_by" uuid,
    "status" character varying(20) default 'active'::character varying,
    "permissions" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."group_members" enable row level security;


  create table "public"."groups" (
    "id" uuid not null default gen_random_uuid(),
    "name" text not null,
    "description" text,
    "course_id" uuid not null,
    "created_by" uuid not null,
    "is_active" boolean not null default true,
    "max_members" integer,
    "metadata" jsonb not null default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "organization_id" uuid not null
      );


alter table "public"."groups" enable row level security;


  create table "public"."guardian_requests" (
    "id" uuid not null default gen_random_uuid(),
    "school_id" uuid,
    "parent_auth_id" uuid,
    "parent_email" text,
    "student_id" uuid,
    "child_full_name" text,
    "child_class" text,
    "status" text not null default 'pending'::text,
    "created_at" timestamp with time zone not null default now(),
    "approved_at" timestamp with time zone,
    "approved_by" uuid,
    "relationship" text
      );


alter table "public"."guardian_requests" enable row level security;


  create table "public"."guest_usage_log" (
    "id" uuid not null default gen_random_uuid(),
    "ip_address" text not null,
    "user_agent" text,
    "resource_type" text not null,
    "created_at" timestamp with time zone default now(),
    "metadata" jsonb default '{}'::jsonb
      );


alter table "public"."guest_usage_log" enable row level security;


  create table "public"."homework_activity_log" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "assignment_id" uuid,
    "submission_id" uuid,
    "actor_id" uuid,
    "actor_role" text,
    "event_source" text not null default 'system'::text,
    "event_type" text not null,
    "event_payload" jsonb not null default '{}'::jsonb,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."homework_activity_log" enable row level security;


  create table "public"."homework_assignment_targets" (
    "id" uuid not null default gen_random_uuid(),
    "assignment_id" uuid not null,
    "preschool_id" uuid not null,
    "class_id" uuid,
    "student_id" uuid,
    "submission_id" uuid,
    "status" text not null default 'pending'::text,
    "last_notified_at" timestamp with time zone,
    "last_viewed_at" timestamp with time zone,
    "due_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."homework_assignment_targets" enable row level security;


  create table "public"."homework_assignments" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "class_id" uuid,
    "teacher_id" uuid,
    "title" text not null,
    "description" text,
    "due_date" timestamp with time zone,
    "points_possible" integer default 100,
    "is_published" boolean default false,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "preschool_id" uuid,
    "lesson_id" uuid,
    "instructions" text,
    "due_date_offset_days" integer,
    "estimated_time_minutes" integer,
    "materials_needed" text,
    "difficulty_level" integer,
    "is_required" boolean default true,
    "is_active" boolean default true,
    "subject" text not null default 'general'::text,
    "grade_band" text not null default 'unspecified'::text,
    "ai_plan_id" uuid,
    "requires_media" boolean not null default false,
    "attachment_urls" jsonb not null default '[]'::jsonb,
    "metadata" jsonb not null default '{}'::jsonb,
    "rubric" jsonb not null default '{}'::jsonb,
    "assigned_at" timestamp with time zone,
    "closed_at" timestamp with time zone,
    "status" text not null default 'draft'::text
      );


alter table "public"."homework_assignments" enable row level security;


  create table "public"."homework_notifications" (
    "id" uuid not null default gen_random_uuid(),
    "assignment_id" uuid not null,
    "target_id" uuid,
    "preschool_id" uuid not null,
    "parent_id" uuid,
    "student_id" uuid,
    "channel" text not null default 'in_app'::text,
    "status" text not null default 'pending'::text,
    "error_message" text,
    "payload" jsonb not null default '{}'::jsonb,
    "sent_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."homework_notifications" enable row level security;


  create table "public"."homework_submissions" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "assignment_id" uuid,
    "student_id" uuid,
    "submission_text" text,
    "file_urls" text[],
    "submitted_at" timestamp with time zone default now(),
    "grade" integer,
    "feedback" text,
    "graded_at" timestamp with time zone,
    "graded_by" uuid,
    "status" text default 'submitted'::text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "homework_assignment_id" uuid,
    "submitted_by" uuid,
    "content_type" text not null default 'text'::text,
    "content_url" text,
    "content_metadata" jsonb not null default '{}'::jsonb,
    "ai_grade_id" uuid,
    "feedback_rubric" jsonb not null default '{}'::jsonb,
    "preschool_id" uuid,
    "submission_type" text default 'text'::text,
    "media_urls" jsonb default '[]'::jsonb,
    "ai_feedback" text,
    "ai_analysis" jsonb
      );


alter table "public"."homework_submissions" enable row level security;


  create table "public"."in_app_notifications" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "title" text not null,
    "message" text not null,
    "type" text not null default 'info'::text,
    "data" jsonb default '{}'::jsonb,
    "read" boolean default false,
    "read_at" timestamp with time zone,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."in_app_notifications" enable row level security;


  create table "public"."independent_children" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "parent_id" uuid,
    "first_name" text not null,
    "last_name" text not null,
    "date_of_birth" date,
    "grade_level" text,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."independent_children" enable row level security;


  create table "public"."independent_content_library" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "title" text not null,
    "content_type" text,
    "age_group" text,
    "subject" text,
    "content_url" text,
    "preview_url" text,
    "is_free" boolean default false,
    "price_cents" integer default 0,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."independent_content_library" enable row level security;


  create table "public"."integration_audit_log" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid,
    "integration_type" text not null,
    "action" text not null,
    "request_payload" jsonb,
    "response_payload" jsonb,
    "status_code" integer,
    "user_id" uuid,
    "user_role" text,
    "started_at" timestamp with time zone not null default now(),
    "completed_at" timestamp with time zone,
    "duration_ms" integer,
    "error_message" text,
    "error_code" text,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."integration_audit_log" enable row level security;


  create table "public"."interactive_activities" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid,
    "teacher_id" uuid,
    "activity_type" text not null,
    "title" text not null,
    "instructions" text,
    "content" jsonb not null,
    "difficulty_level" integer default 1,
    "age_group_min" integer default 3,
    "age_group_max" integer default 6,
    "time_limit_seconds" integer,
    "max_attempts" integer default 3,
    "stars_reward" integer default 1,
    "badge_reward" text,
    "subject" text,
    "skills" jsonb default '[]'::jsonb,
    "is_active" boolean default true,
    "is_template" boolean default false,
    "times_played" integer default 0,
    "avg_score" numeric(5,2),
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "stem_category" text default 'none'::text,
    "is_published" boolean default true,
    "description" text,
    "created_by" uuid,
    "play_count" integer default 0,
    "average_score" numeric(5,2)
      );


alter table "public"."interactive_activities" enable row level security;


  create table "public"."interview_schedules" (
    "id" uuid not null default gen_random_uuid(),
    "application_id" uuid not null,
    "scheduled_by" uuid not null,
    "interview_date" date not null,
    "interview_time" time without time zone not null,
    "meeting_link" text,
    "location" text,
    "notes" text,
    "status" text not null default 'scheduled'::text,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."interview_schedules" enable row level security;


  create table "public"."invitation_codes" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "preschool_id" uuid,
    "code" text not null,
    "role" text not null,
    "created_by" uuid,
    "used_by" uuid,
    "expires_at" timestamp with time zone,
    "used_at" timestamp with time zone,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now(),
    "email" text,
    "invited_by" uuid
      );


alter table "public"."invitation_codes" enable row level security;


  create table "public"."invitations" (
    "id" uuid not null default gen_random_uuid(),
    "organization_id" uuid not null,
    "code" text not null,
    "role" text not null,
    "email" text,
    "status" text not null default 'pending'::text,
    "created_by" uuid,
    "accepted_by" uuid,
    "accepted_at" timestamp with time zone,
    "expires_at" timestamp with time zone,
    "max_uses" integer default 1,
    "uses_count" integer default 0,
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."invitations" enable row level security;


  create table "public"."invite_logs" (
    "id" uuid not null default gen_random_uuid(),
    "sender_id" uuid not null,
    "recipient_phone" text not null,
    "recipient_email" text,
    "invitation_type" text not null,
    "status" text not null default 'pending'::text,
    "error_message" text,
    "metadata" jsonb default '{}'::jsonb,
    "preschool_id" uuid,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "invite_link" text,
    "invite_target" text,
    "invite_type" text
      );


alter table "public"."invite_logs" enable row level security;


  create table "public"."invoice_audit_log" (
    "id" uuid not null default gen_random_uuid(),
    "invoice_id" uuid not null,
    "action" character varying(50) not null,
    "description" text,
    "old_data" jsonb,
    "new_data" jsonb,
    "user_id" uuid,
    "user_role" character varying(50),
    "ip_address" inet,
    "user_agent" text,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."invoice_audit_log" enable row level security;


  create table "public"."invoice_items" (
    "id" uuid not null default gen_random_uuid(),
    "invoice_id" uuid not null,
    "description" text not null,
    "quantity" numeric(10,2) not null default 1,
    "unit_price" numeric(10,2) not null,
    "tax_rate" numeric(5,2) default 0,
    "tax_amount" numeric(10,2) default 0,
    "subtotal" numeric(10,2) generated always as ((quantity * unit_price)) stored,
    "total" numeric(10,2) generated always as (((quantity * unit_price) + tax_amount)) stored,
    "item_type" character varying(50) default 'service'::character varying,
    "category" character varying(50),
    "sort_order" integer default 0,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."invoice_items" enable row level security;


  create table "public"."invoice_payments" (
    "id" uuid not null default gen_random_uuid(),
    "invoice_id" uuid not null,
    "amount" numeric(10,2) not null,
    "payment_method" character varying(50) not null,
    "payment_date" date not null default CURRENT_DATE,
    "reference_number" character varying(100),
    "transaction_id" character varying(100),
    "bank_name" character varying(100),
    "account_holder" character varying(255),
    "notes" text,
    "receipt_url" text,
    "receipt_public_id" text,
    "verified" boolean default false,
    "verified_by" uuid,
    "verified_at" timestamp with time zone,
    "recorded_by" uuid not null,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."invoice_payments" enable row level security;


  create table "public"."invoice_templates" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "name" character varying(100) not null,
    "description" text,
    "template_data" jsonb default '{}'::jsonb,
    "default_items" jsonb default '[]'::jsonb,
    "is_default" boolean default false,
    "is_active" boolean default true,
    "usage_count" integer default 0,
    "last_used_at" timestamp with time zone,
    "created_by" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."invoice_templates" enable row level security;


  create table "public"."invoices" (
    "id" uuid not null default gen_random_uuid(),
    "invoice_number" character varying(50) not null,
    "preschool_id" uuid not null,
    "student_id" uuid,
    "issue_date" date not null default CURRENT_DATE,
    "due_date" date not null default (CURRENT_DATE + '30 days'::interval),
    "bill_to_name" character varying(255) not null,
    "bill_to_email" character varying(255),
    "bill_to_phone" character varying(20),
    "bill_to_address" text,
    "subtotal" numeric(10,2) not null default 0,
    "tax_rate" numeric(5,2) default 0,
    "tax_amount" numeric(10,2) default 0,
    "discount_amount" numeric(10,2) default 0,
    "total_amount" numeric(10,2) not null default 0,
    "paid_amount" numeric(10,2) default 0,
    "status" character varying(20) default 'draft'::character varying,
    "payment_status" character varying(20) default 'unpaid'::character varying,
    "notes" text,
    "terms" text,
    "internal_notes" text,
    "pdf_url" text,
    "pdf_public_id" text,
    "sent_at" timestamp with time zone,
    "viewed_at" timestamp with time zone,
    "payment_due_reminder_sent" boolean default false,
    "overdue_reminder_sent" boolean default false,
    "template_id" uuid,
    "created_by" uuid not null,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."invoices" enable row level security;


  create table "public"."job_alerts" (
    "id" uuid not null default gen_random_uuid(),
    "candidate_profile_id" uuid not null,
    "preferred_locations" text[] default ARRAY[]::text[],
    "max_commute_km" integer default 30,
    "employment_types" text[] default ARRAY[]::text[],
    "min_salary" numeric(10,2),
    "notification_enabled" boolean default true,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."job_alerts" enable row level security;


  create table "public"."job_applications" (
    "id" uuid not null default gen_random_uuid(),
    "job_posting_id" uuid not null,
    "candidate_profile_id" uuid not null,
    "status" text not null default 'new'::text,
    "cover_letter" text,
    "resume_file_path" text,
    "applied_at" timestamp with time zone not null default now(),
    "reviewed_at" timestamp with time zone,
    "reviewed_by" uuid,
    "notes" text
      );


alter table "public"."job_applications" enable row level security;


  create table "public"."job_distributions" (
    "id" uuid not null default gen_random_uuid(),
    "job_posting_id" uuid not null,
    "channel" text not null,
    "recipients_count" integer default 0,
    "distributed_by" uuid not null,
    "distributed_at" timestamp with time zone not null default now(),
    "metadata" jsonb default '{}'::jsonb
      );


alter table "public"."job_distributions" enable row level security;


  create table "public"."job_postings" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "title" text not null,
    "description" text not null,
    "requirements" text,
    "salary_range_min" numeric(10,2),
    "salary_range_max" numeric(10,2),
    "location" text,
    "employment_type" text not null,
    "status" text not null default 'active'::text,
    "created_by" uuid not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "expires_at" timestamp with time zone,
    "latitude" numeric(10,8),
    "longitude" numeric(11,8),
    "commute_radius_km" integer default 20
      );


alter table "public"."job_postings" enable row level security;


  create table "public"."join_requests" (
    "id" uuid not null default gen_random_uuid(),
    "request_type" public.join_request_type not null,
    "status" public.join_request_status not null default 'pending'::public.join_request_status,
    "requester_id" uuid,
    "requester_email" text,
    "requester_phone" text,
    "organization_id" uuid,
    "preschool_id" uuid,
    "target_student_id" uuid,
    "invite_code" text,
    "invite_token" text,
    "invited_by" uuid,
    "message" text,
    "relationship" text,
    "requested_role" text default 'parent'::text,
    "reviewed_by" uuid,
    "reviewed_at" timestamp with time zone,
    "review_notes" text,
    "expires_at" timestamp with time zone default (now() + '7 days'::interval),
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "temp_password" text,
    "region_id" uuid
      );


alter table "public"."join_requests" enable row level security;


  create table "public"."learner_connections" (
    "id" uuid not null default gen_random_uuid(),
    "learner_id" uuid not null,
    "connection_id" uuid not null,
    "connection_type" text not null,
    "status" text not null default 'pending'::text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."learner_connections" enable row level security;


  create table "public"."learner_cvs" (
    "id" uuid not null default gen_random_uuid(),
    "learner_id" uuid not null,
    "title" text not null,
    "template_id" text,
    "content" jsonb not null default '{}'::jsonb,
    "pdf_url" text,
    "is_primary" boolean default false,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."learner_cvs" enable row level security;


  create table "public"."learning_activities" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "title" text not null,
    "description" text,
    "age_group_id" uuid,
    "subject" text,
    "activity_type" text,
    "instructions" text,
    "materials" text,
    "duration_minutes" integer,
    "created_at" timestamp with time zone default now(),
    "is_active" boolean default true
      );


alter table "public"."learning_activities" enable row level security;


  create table "public"."lesson_approvals" (
    "id" uuid not null default gen_random_uuid(),
    "lesson_id" uuid not null,
    "preschool_id" uuid not null,
    "submitted_by" uuid,
    "reviewed_by" uuid,
    "status" text not null default 'pending'::text,
    "rejection_reason" text,
    "review_notes" text,
    "submitted_at" timestamp with time zone default now(),
    "reviewed_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."lesson_approvals" enable row level security;


  create table "public"."lesson_categories" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "name" text not null,
    "description" text,
    "color_code" text,
    "icon" text,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."lesson_categories" enable row level security;


  create table "public"."marketing_campaigns" (
    "id" uuid not null default gen_random_uuid(),
    "organization_id" uuid not null,
    "name" character varying(200) not null,
    "campaign_type" public.campaign_type not null,
    "description" text,
    "terms_conditions" text,
    "target_audience" text[],
    "target_classes" text[],
    "discount_type" public.discount_type not null,
    "discount_value" numeric(10,2),
    "max_discount_amount" numeric(10,2),
    "promo_code" character varying(50),
    "max_redemptions" integer,
    "current_redemptions" integer default 0,
    "min_purchase_amount" numeric(10,2),
    "start_date" timestamp without time zone not null,
    "end_date" timestamp without time zone not null,
    "auto_apply" boolean default false,
    "auto_apply_conditions" jsonb,
    "active" boolean default true,
    "featured" boolean default false,
    "views_count" integer default 0,
    "conversions_count" integer default 0,
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now()
      );


alter table "public"."marketing_campaigns" enable row level security;


  create table "public"."media_uploads" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "user_id" uuid,
    "preschool_id" uuid,
    "filename" text not null,
    "original_filename" text,
    "file_type" text,
    "file_size" integer,
    "storage_path" text,
    "url" text,
    "is_public" boolean default false,
    "metadata" jsonb,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."media_uploads" enable row level security;


  create table "public"."meeting_action_items" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "session_id" uuid not null,
    "created_by" uuid not null,
    "title" text not null,
    "description" text,
    "assigned_to" uuid,
    "due_date" date,
    "priority" text default 'medium'::text,
    "status" text not null default 'pending'::text,
    "completion_notes" text,
    "completed_at" timestamp with time zone
      );


alter table "public"."meeting_action_items" enable row level security;


  create table "public"."meeting_participants" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "session_id" uuid not null,
    "user_id" uuid not null,
    "role" text not null default 'participant'::text,
    "invited_by" uuid,
    "joined_at" timestamp with time zone,
    "left_at" timestamp with time zone,
    "duration_seconds" integer generated always as (
CASE
    WHEN ((joined_at IS NOT NULL) AND (left_at IS NOT NULL)) THEN (EXTRACT(epoch FROM (left_at - joined_at)))::integer
    ELSE NULL::integer
END) stored,
    "camera_enabled_duration" integer default 0,
    "microphone_enabled_duration" integer default 0,
    "screen_shared" boolean default false,
    "invitation_status" text default 'pending'::text
      );


alter table "public"."meeting_participants" enable row level security;


  create table "public"."meeting_rooms" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "organization_id" uuid not null,
    "created_by" uuid not null,
    "name" text not null,
    "description" text,
    "room_type" text not null default 'principal_hub'::text,
    "max_participants" integer default 50,
    "is_recording_enabled" boolean default true,
    "is_screen_sharing_enabled" boolean default true,
    "is_whiteboard_enabled" boolean default true,
    "access_type" text not null default 'organization'::text,
    "requires_approval" boolean default false,
    "is_active" boolean default true,
    "is_featured" boolean default false
      );


alter table "public"."meeting_rooms" enable row level security;


  create table "public"."meeting_sessions" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "room_id" uuid not null,
    "host_id" uuid not null,
    "title" text not null,
    "agenda" text,
    "scheduled_start" timestamp with time zone,
    "scheduled_end" timestamp with time zone,
    "actual_start" timestamp with time zone,
    "actual_end" timestamp with time zone,
    "is_recorded" boolean default false,
    "recording_url" text,
    "meeting_notes" text,
    "external_meeting_id" text,
    "external_meeting_url" text,
    "status" text not null default 'scheduled'::text
      );


alter table "public"."meeting_sessions" enable row level security;


  create table "public"."meeting_shared_resources" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "session_id" uuid not null,
    "shared_by" uuid not null,
    "resource_id" uuid,
    "file_name" text,
    "file_url" text,
    "file_size_bytes" bigint,
    "shared_at" timestamp with time zone default now(),
    "description" text
      );


alter table "public"."meeting_shared_resources" enable row level security;


  create table "public"."member_events" (
    "id" uuid not null default gen_random_uuid(),
    "organization_id" uuid not null,
    "region_id" uuid,
    "title" character varying(200) not null,
    "description" text,
    "event_type" character varying(50) default 'meeting'::character varying,
    "location" text,
    "location_coordinates" jsonb,
    "start_datetime" timestamp with time zone not null,
    "end_datetime" timestamp with time zone,
    "is_virtual" boolean default false,
    "virtual_link" text,
    "max_attendees" integer,
    "registration_required" boolean default false,
    "registration_deadline" timestamp with time zone,
    "status" character varying(30) default 'scheduled'::character varying,
    "created_by" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."member_events" enable row level security;


  create table "public"."member_fees" (
    "id" uuid not null default gen_random_uuid(),
    "organization_id" uuid not null,
    "member_id" uuid not null,
    "fee_structure_id" uuid,
    "fee_type" text not null,
    "fee_name" text not null,
    "description" text,
    "period_start" date,
    "period_end" date,
    "due_date" date not null,
    "original_amount" numeric(10,2) not null,
    "discount_amount" numeric(10,2) default 0,
    "discount_reason" text,
    "final_amount" numeric(10,2) not null,
    "paid_amount" numeric(10,2) default 0,
    "balance_due" numeric(10,2) generated always as ((final_amount - paid_amount)) stored,
    "status" text default 'pending'::text,
    "last_payment_date" date,
    "last_payment_amount" numeric(10,2),
    "payment_count" integer default 0,
    "reminder_sent_count" integer default 0,
    "last_reminder_sent_at" timestamp with time zone,
    "transaction_id" uuid,
    "notes" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by" uuid
      );


alter table "public"."member_fees" enable row level security;


  create table "public"."member_id_cards" (
    "id" uuid not null default gen_random_uuid(),
    "member_id" uuid not null,
    "organization_id" uuid not null,
    "card_number" character varying(50) not null,
    "qr_code_data" text not null,
    "status" character varying(30) default 'active'::character varying,
    "issue_date" date default CURRENT_DATE,
    "expiry_date" date,
    "card_template" character varying(50) default 'default'::character varying,
    "verification_count" integer default 0,
    "last_verified_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."member_id_cards" enable row level security;


  create table "public"."member_invoices" (
    "id" uuid not null default gen_random_uuid(),
    "organization_id" uuid not null,
    "member_id" uuid not null,
    "invoice_number" character varying(50) not null,
    "description" text,
    "line_items" jsonb default '[]'::jsonb,
    "subtotal" numeric(10,2) default 0,
    "tax_amount" numeric(10,2) default 0,
    "discount_amount" numeric(10,2) default 0,
    "total_amount" numeric(10,2) default 0,
    "currency" character varying(3) default 'ZAR'::character varying,
    "status" character varying(30) default 'draft'::character varying,
    "issue_date" date default CURRENT_DATE,
    "due_date" date,
    "paid_date" date,
    "payment_method" character varying(50),
    "payment_reference" character varying(100),
    "notes" text,
    "created_by" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."member_invoices" enable row level security;


  create table "public"."membership_fee_structure" (
    "id" uuid not null default gen_random_uuid(),
    "organization_id" uuid not null,
    "fee_name" text not null,
    "fee_code" text not null,
    "fee_type" text not null,
    "description" text,
    "member_types" text[] default ARRAY['learner'::text],
    "wings" text[] default ARRAY['main'::text],
    "membership_tiers" text[] default ARRAY['standard'::text],
    "regions" text[],
    "amount" numeric(10,2) not null,
    "currency" text default 'ZAR'::text,
    "includes_vat" boolean default false,
    "vat_percent" numeric(5,2) default 15,
    "valid_from" date default CURRENT_DATE,
    "valid_to" date,
    "early_bird_discount_percent" numeric(5,2) default 0,
    "early_bird_deadline_days" integer default 30,
    "pensioner_discount_percent" numeric(5,2) default 0,
    "student_discount_percent" numeric(5,2) default 0,
    "allow_installments" boolean default false,
    "installment_count" integer default 1,
    "is_active" boolean default true,
    "is_mandatory" boolean default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by" uuid,
    "tier_name" text,
    "tier_benefits" jsonb default '[]'::jsonb,
    "tier_color" text,
    "display_order" integer default 0
      );


alter table "public"."membership_fee_structure" enable row level security;


  create table "public"."membership_pop_uploads" (
    "id" uuid not null default gen_random_uuid(),
    "organization_id" uuid not null,
    "member_id" uuid not null,
    "member_fee_id" uuid,
    "upload_type" text not null default 'proof_of_payment'::text,
    "file_url" text not null,
    "file_name" text,
    "file_type" text,
    "file_size" integer,
    "payment_amount" numeric(10,2),
    "payment_date" date,
    "payment_method" text,
    "bank_reference" text,
    "status" text default 'pending'::text,
    "reviewed_by" uuid,
    "reviewed_at" timestamp with time zone,
    "rejection_reason" text,
    "uploader_notes" text,
    "reviewer_notes" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "uploaded_by" uuid
      );


alter table "public"."membership_pop_uploads" enable row level security;


  create table "public"."message_drafts" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "sender_id" uuid,
    "subject" text,
    "content" text,
    "recipient_ids" uuid[],
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."message_drafts" enable row level security;


  create table "public"."message_participants" (
    "id" uuid not null default gen_random_uuid(),
    "thread_id" uuid not null,
    "user_id" uuid not null,
    "role" text not null,
    "joined_at" timestamp with time zone default now(),
    "is_muted" boolean default false,
    "last_read_at" timestamp with time zone default now(),
    "can_send_messages" boolean default true,
    "is_admin" boolean default false
      );


alter table "public"."message_participants" enable row level security;


  create table "public"."message_reactions" (
    "id" uuid not null default gen_random_uuid(),
    "message_id" uuid not null,
    "user_id" uuid not null,
    "emoji" text not null,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."message_reactions" enable row level security;


  create table "public"."message_recipients" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "message_id" uuid,
    "recipient_id" uuid,
    "read_at" timestamp with time zone,
    "archived_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "is_read" boolean not null default false,
    "is_archived" boolean not null default false
      );


alter table "public"."message_recipients" enable row level security;


  create table "public"."message_threads" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "type" text not null,
    "student_id" uuid,
    "subject" text not null,
    "created_by" uuid not null,
    "last_message_at" timestamp with time zone default now(),
    "is_archived" boolean default false,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "is_group" boolean default false,
    "group_name" text,
    "group_description" text,
    "group_avatar_url" text,
    "group_type" text,
    "class_id" uuid,
    "allow_replies" boolean default true,
    "created_by_role" text
      );


alter table "public"."message_threads" enable row level security;


  create table "public"."messages" (
    "id" uuid not null default gen_random_uuid(),
    "thread_id" uuid not null,
    "sender_id" uuid not null,
    "content" text not null,
    "content_type" text default 'text'::text,
    "created_at" timestamp with time zone default now(),
    "edited_at" timestamp with time zone,
    "deleted_at" timestamp with time zone,
    "read_by" uuid[] default '{}'::uuid[],
    "reply_to_id" uuid,
    "forwarded_from_id" uuid,
    "delivered_at" timestamp with time zone,
    "voice_url" text,
    "voice_duration" integer
      );


alter table "public"."messages" enable row level security;


  create table "public"."migration_logs" (
    "id" integer not null default nextval('public.migration_logs_id_seq'::regclass),
    "version" text not null,
    "description" text,
    "applied_at" timestamp with time zone default now()
      );


alter table "public"."migration_logs" enable row level security;


  create table "public"."moderation_actions" (
    "id" uuid not null default gen_random_uuid(),
    "queue_item_id" uuid,
    "moderator_id" uuid,
    "action" character varying(30) not null,
    "reason" text,
    "details" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone default now(),
    "previous_status" character varying(20),
    "new_status" character varying(20)
      );


alter table "public"."moderation_actions" enable row level security;


  create table "public"."moderation_queue" (
    "id" uuid not null default gen_random_uuid(),
    "content_type" character varying(50) not null,
    "content_id" uuid not null,
    "content_title" text not null,
    "content_body" text,
    "author_id" uuid,
    "school_id" uuid,
    "priority" integer default 3,
    "flags" text[] default '{}'::text[],
    "report_count" integer default 0,
    "severity" character varying(20) default 'medium'::character varying,
    "status" character varying(20) default 'pending'::character varying,
    "auto_flagged" boolean default false,
    "created_at" timestamp with time zone default now(),
    "flagged_at" timestamp with time zone default now(),
    "reviewed_by" uuid,
    "reviewed_at" timestamp with time zone,
    "review_notes" text,
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."moderation_queue" enable row level security;


  create table "public"."newsletter_recipients" (
    "id" uuid not null default gen_random_uuid(),
    "newsletter_id" uuid not null,
    "user_id" uuid,
    "email" text not null,
    "status" text not null default 'pending'::text,
    "sent_at" timestamp with time zone,
    "opened_at" timestamp with time zone,
    "clicked_at" timestamp with time zone,
    "error_message" text,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."newsletter_recipients" enable row level security;


  create table "public"."newsletters" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "title" text not null,
    "content_html" text not null,
    "content_text" text,
    "status" text not null default 'draft'::text,
    "scheduled_for" timestamp with time zone,
    "sent_at" timestamp with time zone,
    "recipient_filter" jsonb,
    "total_recipients" integer default 0,
    "sent_count" integer default 0,
    "failed_count" integer default 0,
    "open_count" integer default 0,
    "click_count" integer default 0,
    "created_by" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."newsletters" enable row level security;


  create table "public"."notification_deliveries" (
    "id" uuid not null default gen_random_uuid(),
    "notification_id" uuid not null,
    "template_id" uuid,
    "recipient_id" uuid,
    "recipient_email" text,
    "recipient_phone" text,
    "recipient_device_token" text,
    "channel" public.delivery_method_enum not null,
    "provider_id" uuid,
    "provider_message_id" text,
    "subject" text,
    "body" text not null,
    "html_body" text,
    "attachments" jsonb default '[]'::jsonb,
    "priority" integer default 0,
    "send_at" timestamp with time zone default now(),
    "expires_at" timestamp with time zone,
    "template_variables" jsonb default '{}'::jsonb,
    "render_time_ms" integer,
    "status" public.delivery_status_enum default 'pending'::public.delivery_status_enum,
    "delivery_attempts" integer default 0,
    "max_retry_attempts" integer default 3,
    "retry_strategy" public.retry_strategy_enum default 'exponential_backoff'::public.retry_strategy_enum,
    "next_retry_at" timestamp with time zone,
    "provider_response" jsonb default '{}'::jsonb,
    "provider_status_code" integer,
    "provider_error_message" text,
    "sent_at" timestamp with time zone,
    "delivered_at" timestamp with time zone,
    "opened_at" timestamp with time zone,
    "clicked_at" timestamp with time zone,
    "bounced_at" timestamp with time zone,
    "complained_at" timestamp with time zone,
    "unsubscribed_at" timestamp with time zone,
    "estimated_cost" numeric(10,4),
    "actual_cost" numeric(10,4),
    "cost_currency" text default 'USD'::text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."notification_deliveries" enable row level security;


  create table "public"."notification_history" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "title" text not null,
    "body" text not null,
    "data" jsonb default '{}'::jsonb,
    "recipient_ids" text[],
    "sent_at" timestamp with time zone default now(),
    "delivery_status" text default 'sent'::text,
    "error_message" text,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."notification_history" enable row level security;


  create table "public"."notification_logs" (
    "id" uuid not null default gen_random_uuid(),
    "type" text not null default 'general'::text,
    "title" text not null,
    "body" text not null,
    "sent_count" integer default 0,
    "failed_count" integer default 0,
    "target_type" text,
    "target_value" text,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."notification_logs" enable row level security;


  create table "public"."notification_templates" (
    "id" uuid not null default gen_random_uuid(),
    "template_key" text not null,
    "name" text not null,
    "description" text,
    "category" public.template_category_enum not null,
    "subject_template" text,
    "body_template" text not null,
    "html_template" text,
    "variables" jsonb default '[]'::jsonb,
    "default_variables" jsonb default '{}'::jsonb,
    "required_variables" text[] default '{}'::text[],
    "language" text default 'en'::text,
    "localization_key" text,
    "status" public.template_status_enum default 'draft'::public.template_status_enum,
    "version" integer default 1,
    "is_system_template" boolean default false,
    "is_default" boolean default false,
    "usage_count" bigint default 0,
    "last_used_at" timestamp with time zone,
    "created_by" uuid,
    "updated_by" uuid,
    "approved_by" uuid,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "approved_at" timestamp with time zone
      );


alter table "public"."notification_templates" enable row level security;


  create table "public"."oauth_tokens" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "user_id" uuid not null,
    "provider" text not null,
    "access_token" text not null,
    "refresh_token" text,
    "token_type" text default 'Bearer'::text,
    "expires_at" timestamp with time zone not null,
    "scopes" text[] not null default '{}'::text[],
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "last_used_at" timestamp with time zone
      );


alter table "public"."oauth_tokens" enable row level security;


  create table "public"."offer_letters" (
    "id" uuid not null default gen_random_uuid(),
    "application_id" uuid not null,
    "salary_offered" numeric(10,2) not null,
    "start_date" date not null,
    "employment_type" text not null,
    "terms" jsonb default '{}'::jsonb,
    "generated_by" uuid not null,
    "generated_at" timestamp with time zone not null default now(),
    "accepted_at" timestamp with time zone,
    "declined_at" timestamp with time zone,
    "status" text not null default 'pending'::text
      );


alter table "public"."offer_letters" enable row level security;


  create table "public"."onboarding_progress" (
    "id" uuid not null default gen_random_uuid(),
    "school_id" uuid not null,
    "flow_type" character varying(50) not null,
    "current_step" character varying(50) not null,
    "completed_steps" text[] default ARRAY[]::text[],
    "step_data" jsonb default '{}'::jsonb,
    "started_at" timestamp with time zone default now(),
    "completed_at" timestamp with time zone,
    "created_by" uuid,
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."onboarding_progress" enable row level security;


  create table "public"."onboarding_requests" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "school_name" text not null,
    "principal_name" text not null,
    "principal_email" text not null,
    "principal_phone" text,
    "status" text default 'pending'::text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."onboarding_requests" enable row level security;


  create table "public"."org_dashboard_features" (
    "id" uuid not null default gen_random_uuid(),
    "org_type" text not null,
    "role" text not null,
    "age_group" public.age_group_type,
    "feature_key" text not null,
    "enabled" boolean not null default true,
    "min_app_version" text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."org_dashboard_features" enable row level security;


  create table "public"."org_invites" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "invited_by" uuid not null,
    "email" text not null,
    "role" text not null,
    "invite_token" text not null default encode(extensions.gen_random_bytes(32), 'base64'::text),
    "expires_at" timestamp with time zone not null default (now() + '7 days'::interval),
    "accepted_at" timestamp with time zone,
    "accepted_by" uuid,
    "status" text default 'pending'::text,
    "message" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."org_invites" enable row level security;


  create table "public"."organization_announcement_recipients" (
    "id" uuid not null default gen_random_uuid(),
    "announcement_id" uuid not null,
    "recipient_id" uuid not null,
    "read_at" timestamp with time zone,
    "notified_at" timestamp with time zone,
    "notification_method" text,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."organization_announcement_recipients" enable row level security;


  create table "public"."organization_announcements" (
    "id" uuid not null default gen_random_uuid(),
    "organization_id" uuid not null,
    "author_id" uuid not null,
    "title" text not null,
    "content" text not null,
    "target_audience" text not null default 'all'::text,
    "target_region_id" uuid,
    "priority" text not null default 'normal'::text,
    "announcement_type" text not null default 'general'::text,
    "attachments" jsonb default '[]'::jsonb,
    "is_published" boolean not null default true,
    "published_at" timestamp with time zone default now(),
    "expires_at" timestamp with time zone,
    "read_by" uuid[] default '{}'::uuid[],
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."organization_announcements" enable row level security;


  create table "public"."organization_bank_accounts" (
    "id" uuid not null default gen_random_uuid(),
    "organization_id" uuid not null,
    "account_name" text not null,
    "account_type" text not null,
    "bank_name" text not null,
    "account_number_masked" text,
    "branch_code" text,
    "swift_code" text,
    "region_id" uuid,
    "wing_id" uuid,
    "spending_limit_per_transaction" numeric(12,2),
    "spending_limit_daily" numeric(12,2),
    "spending_limit_monthly" numeric(12,2),
    "float_amount" numeric(12,2),
    "current_balance" numeric(12,2) default 0,
    "signatories" jsonb default '[]'::jsonb,
    "required_signatures" integer default 2,
    "is_active" boolean default true,
    "is_primary" boolean default false,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by" uuid,
    "account_number" text
      );


alter table "public"."organization_bank_accounts" enable row level security;


  create table "public"."organization_board_positions" (
    "id" uuid not null default gen_random_uuid(),
    "organization_id" uuid not null,
    "position_code" text not null,
    "position_title" text not null,
    "position_order" integer default 0,
    "member_id" uuid,
    "appointed_at" timestamp with time zone,
    "appointed_by" uuid,
    "term_start" date,
    "term_end" date,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by" uuid
      );


alter table "public"."organization_board_positions" enable row level security;


  create table "public"."organization_budgets" (
    "id" uuid not null default gen_random_uuid(),
    "organization_id" uuid not null,
    "fiscal_year" integer not null,
    "period_type" text default 'annual'::text,
    "period_start" date not null,
    "period_end" date not null,
    "region_id" uuid,
    "wing_id" uuid,
    "department" text,
    "category" text not null,
    "budgeted_amount" numeric(12,2) not null,
    "allocated_amount" numeric(12,2) default 0,
    "spent_amount" numeric(12,2) default 0,
    "committed_amount" numeric(12,2) default 0,
    "remaining_amount" numeric(12,2) generated always as (((budgeted_amount - spent_amount) - committed_amount)) stored,
    "utilization_percent" numeric(5,2) generated always as (
CASE
    WHEN (budgeted_amount > (0)::numeric) THEN ((spent_amount / budgeted_amount) * (100)::numeric)
    ELSE (0)::numeric
END) stored,
    "notes" text,
    "status" text default 'draft'::text,
    "approved_by" uuid,
    "approved_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by" uuid
      );


alter table "public"."organization_budgets" enable row level security;


  create table "public"."organization_document_access" (
    "id" uuid not null default gen_random_uuid(),
    "document_id" uuid not null,
    "grantee_user_id" uuid,
    "grantee_role" text,
    "grantee_region_id" uuid,
    "permission" text not null default 'view'::text,
    "valid_from" timestamp with time zone default now(),
    "valid_until" timestamp with time zone,
    "granted_by" uuid not null,
    "revoked_by" uuid,
    "revoked_at" timestamp with time zone,
    "reason" text,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."organization_document_access" enable row level security;


  create table "public"."organization_document_access_requests" (
    "id" uuid not null default gen_random_uuid(),
    "document_id" uuid not null,
    "requester_id" uuid not null,
    "requested_permission" text not null default 'view'::text,
    "reason" text not null,
    "status" text not null default 'pending'::text,
    "reviewed_by" uuid,
    "reviewed_at" timestamp with time zone,
    "review_notes" text,
    "access_grant_id" uuid,
    "created_at" timestamp with time zone not null default now(),
    "expires_at" timestamp with time zone default (now() + '7 days'::interval)
      );


alter table "public"."organization_document_access_requests" enable row level security;


  create table "public"."organization_document_audit_log" (
    "id" uuid not null default gen_random_uuid(),
    "document_id" uuid not null,
    "user_id" uuid not null,
    "action" text not null,
    "details" jsonb default '{}'::jsonb,
    "ip_address" inet,
    "user_agent" text,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."organization_document_audit_log" enable row level security;


  create table "public"."organization_payment_methods" (
    "id" uuid not null default gen_random_uuid(),
    "organization_id" uuid not null,
    "method_name" character varying(100) not null,
    "display_name" character varying(100) not null,
    "processing_fee" numeric(10,2) default 0,
    "fee_type" character varying(20) default 'fixed'::character varying,
    "fee_percentage" numeric(5,2) default 0,
    "description" text,
    "instructions" text,
    "bank_name" character varying(100),
    "account_number" character varying(50),
    "branch_code" character varying(20),
    "account_type" character varying(50),
    "reference_format" character varying(100),
    "active" boolean default true,
    "preferred" boolean default false,
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now()
      );


alter table "public"."organization_payment_methods" enable row level security;


  create table "public"."organization_petty_cash" (
    "id" uuid not null default gen_random_uuid(),
    "organization_id" uuid not null,
    "region_id" uuid,
    "wing_id" uuid,
    "custodian_id" uuid,
    "float_amount" numeric(10,2) not null default 5000,
    "current_balance" numeric(10,2) not null default 0,
    "last_replenishment_date" date,
    "last_replenishment_amount" numeric(10,2),
    "max_single_expense" numeric(10,2) default 500,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."organization_petty_cash" enable row level security;


  create table "public"."organization_roles" (
    "id" uuid not null default gen_random_uuid(),
    "organization_id" uuid not null,
    "role_id" character varying(100) not null,
    "role_name" character varying(100) not null,
    "display_name" character varying(100) not null,
    "description" text,
    "permissions" text[] default ARRAY[]::text[],
    "hierarchy_level" integer not null default 0,
    "capabilities" text[] default ARRAY[]::text[],
    "ai_config" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "is_active" boolean not null default true
      );


alter table "public"."organization_roles" enable row level security;


  create table "public"."organization_transactions" (
    "id" uuid not null default gen_random_uuid(),
    "organization_id" uuid not null,
    "account_id" uuid,
    "region_id" uuid,
    "wing_id" uuid,
    "transaction_type" text not null,
    "category" text not null,
    "subcategory" text,
    "amount" numeric(12,2) not null,
    "currency" text default 'ZAR'::text,
    "vat_amount" numeric(12,2) default 0,
    "description" text not null,
    "reference_number" text,
    "external_reference" text,
    "invoice_number" text,
    "member_id" uuid,
    "receipt_url" text,
    "invoice_url" text,
    "attachments" jsonb default '[]'::jsonb,
    "status" text default 'pending'::text,
    "submitted_by" uuid,
    "submitted_at" timestamp with time zone,
    "approved_by" uuid,
    "approved_at" timestamp with time zone,
    "rejection_reason" text,
    "payment_method" text,
    "payment_date" date,
    "payee_name" text,
    "payee_account" text,
    "reconciled" boolean default false,
    "reconciled_by" uuid,
    "reconciled_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."organization_transactions" enable row level security;


  create table "public"."organization_wings" (
    "id" uuid not null default gen_random_uuid(),
    "organization_id" uuid not null,
    "wing_code" text not null,
    "name" text not null,
    "description" text,
    "motto" text,
    "president_id" uuid,
    "deputy_id" uuid,
    "secretary_id" uuid,
    "treasurer_id" uuid,
    "min_age" integer,
    "max_age" integer,
    "annual_budget" numeric(12,2) default 0,
    "monthly_allocation" numeric(10,2) default 0,
    "current_balance" numeric(12,2) default 0,
    "email" text,
    "phone" text,
    "is_active" boolean default true,
    "established_date" date,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by" uuid
      );


alter table "public"."organization_wings" enable row level security;


  create table "public"."overage_billing_records" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "usage_tracking_id" uuid not null,
    "quota_type" character varying(50) not null,
    "overage_units" integer not null,
    "unit_price" numeric(10,2) not null,
    "total_amount" numeric(10,2) not null,
    "currency" character varying(3) default 'ZAR'::character varying,
    "billing_period_start" date not null,
    "billing_period_end" date not null,
    "status" public.overage_billing_status default 'pending'::public.overage_billing_status,
    "payment_reference" character varying(255),
    "payment_url" text,
    "paid_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."overage_billing_records" enable row level security;


  create table "public"."overage_notifications" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "quota_type" character varying(50) not null,
    "notification_type" character varying(50) not null,
    "message" text not null,
    "is_read" boolean default false,
    "sent_at" timestamp with time zone default now(),
    "read_at" timestamp with time zone
      );


alter table "public"."overage_notifications" enable row level security;


  create table "public"."parent_access_codes" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "preschool_id" uuid,
    "student_id" uuid,
    "code" text not null,
    "created_by" uuid,
    "used_by" uuid,
    "expires_at" timestamp with time zone,
    "used_at" timestamp with time zone,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."parent_access_codes" enable row level security;


  create table "public"."parent_child_links" (
    "id" uuid not null default gen_random_uuid(),
    "parent_id" uuid not null,
    "child_id" uuid not null,
    "relationship" text default 'parent'::text,
    "is_primary" boolean default false,
    "can_pick_up" boolean default true,
    "emergency_contact" boolean default false,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."parent_child_links" enable row level security;


  create table "public"."parent_join_requests" (
    "id" uuid not null default gen_random_uuid(),
    "parent_id" uuid not null,
    "organization_id" uuid not null,
    "preschool_id" uuid,
    "status" text not null default 'pending'::text,
    "message" text,
    "reviewed_by" uuid,
    "reviewed_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."parent_join_requests" enable row level security;


  create table "public"."parent_payments" (
    "id" uuid not null default gen_random_uuid(),
    "parent_id" uuid not null,
    "preschool_id" uuid not null,
    "subscription_id" uuid,
    "amount_cents" integer not null,
    "currency" text default 'ZAR'::text,
    "payment_method" text default 'payfast'::text,
    "payment_reference" text,
    "external_reference" text,
    "status" text default 'pending'::text,
    "paid_at" timestamp with time zone,
    "due_date" date,
    "description" text,
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."parent_payments" enable row level security;


  create table "public"."past_papers" (
    "id" uuid not null default gen_random_uuid(),
    "grade" text not null,
    "subject" text not null,
    "year" integer,
    "term" integer,
    "paper_number" integer,
    "exam_type" text default 'past_paper'::text,
    "title" text not null,
    "description" text,
    "total_marks" integer,
    "duration_minutes" integer,
    "file_url" text,
    "preview_url" text,
    "memo_file_url" text,
    "is_public" boolean default true,
    "download_count" integer default 0,
    "average_score" numeric(5,2),
    "tags" text[],
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."past_papers" enable row level security;


  create table "public"."payfast_itn_logs" (
    "id" uuid not null default gen_random_uuid(),
    "merchant_id" text,
    "merchant_key" text,
    "return_url" text,
    "cancel_url" text,
    "notify_url" text,
    "name_first" text,
    "name_last" text,
    "email_address" text,
    "m_payment_id" text,
    "amount" numeric(10,2),
    "item_name" text,
    "item_description" text,
    "payment_status" text,
    "pf_payment_id" text,
    "signature" text,
    "raw_post_data" text,
    "ip_address" inet,
    "processed_at" timestamp with time zone default now(),
    "is_valid" boolean,
    "processing_notes" text,
    "related_payment_id" uuid,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."payfast_itn_logs" enable row level security;


  create table "public"."payment_reminders" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "student_id" uuid not null,
    "student_fee_id" uuid,
    "type" text not null,
    "amount" numeric(10,2) not null,
    "due_date" date not null,
    "sent_to" text not null,
    "communication_method" text not null,
    "message_content" text not null,
    "subject" text,
    "sent_at" timestamp with time zone default now(),
    "status" text not null default 'sent'::text,
    "parent_response" text,
    "response_received_at" timestamp with time zone,
    "created_by" uuid not null,
    "metadata" jsonb default '{}'::jsonb
      );


alter table "public"."payment_reminders" enable row level security;


  create table "public"."payment_transactions" (
    "id" text not null,
    "school_id" uuid,
    "subscription_plan_id" text not null,
    "amount" numeric(10,2) not null,
    "currency" text default 'ZAR'::text,
    "status" text not null,
    "payfast_payment_id" text,
    "payfast_token" text,
    "payment_method" text default 'payfast'::text,
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone default now(),
    "completed_at" timestamp with time zone,
    "updated_at" timestamp with time zone default now(),
    "billing_cycle" text,
    "user_id" uuid,
    "provider" text,
    "provider_payment_id" text,
    "tier" text
      );


alter table "public"."payment_transactions" enable row level security;


  create table "public"."payments" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "preschool_id" uuid,
    "amount_cents" integer not null,
    "currency" text default 'ZAR'::text,
    "payment_method" text,
    "payment_provider" text,
    "provider_payment_id" text,
    "status" text default 'pending'::text,
    "description" text,
    "metadata" jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "parent_id" uuid,
    "student_id" uuid,
    "payment_reference" text,
    "attachment_url" text,
    "submitted_at" timestamp with time zone default now(),
    "amount" numeric(10,2),
    "fee_ids" text[] default '{}'::text[],
    "reviewed_by" uuid,
    "reviewed_at" timestamp with time zone,
    "review_notes" text
      );


alter table "public"."payments" enable row level security;


  create table "public"."pdf_custom_templates" (
    "id" uuid not null default gen_random_uuid(),
    "owner_user_id" uuid not null,
    "organization_id" uuid,
    "preschool_id" uuid,
    "name" text not null,
    "description" text,
    "document_type" text not null,
    "template_html" text not null,
    "input_schema" jsonb default '{}'::jsonb,
    "thumbnail_url" text,
    "is_org_shared" boolean default false,
    "is_public" boolean default false,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."pdf_custom_templates" enable row level security;


  create table "public"."pdf_documents" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "organization_id" uuid,
    "preschool_id" uuid,
    "title" text not null,
    "document_type" text not null,
    "storage_path" text not null,
    "filename" text not null,
    "file_size_bytes" bigint,
    "page_count" integer,
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."pdf_documents" enable row level security;


  create table "public"."pdf_user_preferences" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "organization_id" uuid,
    "preschool_id" uuid,
    "default_theme" text,
    "default_font" text default 'Arial'::text,
    "default_layout" jsonb default '{}'::jsonb,
    "default_branding" jsonb default '{}'::jsonb,
    "header_html_safe" text,
    "footer_html_safe" text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."pdf_user_preferences" enable row level security;


  create table "public"."petty_cash_accounts" (
    "id" uuid not null default gen_random_uuid(),
    "school_id" uuid not null,
    "name" character varying(255) not null,
    "description" text,
    "opening_balance" numeric(10,2) not null default 0.00,
    "is_active" boolean not null default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by" uuid,
    "low_balance_threshold" numeric(12,2) default 1000.00
      );


alter table "public"."petty_cash_accounts" enable row level security;


  create table "public"."petty_cash_receipts" (
    "id" uuid not null default gen_random_uuid(),
    "school_id" uuid not null,
    "transaction_id" uuid not null,
    "storage_path" text not null,
    "file_name" text not null,
    "original_name" text,
    "content_type" text,
    "size_bytes" bigint,
    "created_by" uuid not null,
    "created_at" timestamp with time zone default now(),
    "metadata" jsonb default '{}'::jsonb
      );


alter table "public"."petty_cash_receipts" enable row level security;


  create table "public"."petty_cash_reconciliations" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "system_amount" numeric(10,2) not null default 0,
    "physical_amount" numeric(10,2) not null default 0,
    "variance" numeric(10,2) generated always as ((physical_amount - system_amount)) stored,
    "cash_breakdown" jsonb,
    "notes" text,
    "reconciled_by" uuid not null,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."petty_cash_reconciliations" enable row level security;


  create table "public"."petty_cash_transactions" (
    "id" uuid not null default gen_random_uuid(),
    "school_id" uuid not null,
    "amount" numeric(10,2) not null,
    "description" text not null,
    "category" text not null,
    "type" text not null,
    "receipt_number" text,
    "status" text default 'pending'::text,
    "created_by" uuid not null,
    "approved_by" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "account_id" uuid,
    "transaction_type" character varying(20),
    "reference_number" character varying(100),
    "receipt_url" text,
    "transaction_date" date default CURRENT_DATE
      );


alter table "public"."petty_cash_transactions" enable row level security;


  create table "public"."phone_verification_logs" (
    "id" uuid not null default gen_random_uuid(),
    "user_phone_id" uuid not null,
    "verification_code" character varying(6) not null,
    "sent_at" timestamp with time zone default now(),
    "verified_at" timestamp with time zone,
    "ip_address" inet,
    "user_agent" text,
    "status" character varying(20) default 'pending'::character varying,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."phone_verification_logs" enable row level security;


  create table "public"."plan_quotas" (
    "id" uuid not null default gen_random_uuid(),
    "plan_tier" character varying(50) not null,
    "quota_type" character varying(50) not null,
    "monthly_limit" integer not null default 0,
    "annual_limit" integer,
    "overage_unit_price" numeric(10,2) default 0.00,
    "overage_enabled" boolean default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."plan_quotas" enable row level security;


  create table "public"."platform_analytics" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "metric_name" text not null,
    "metric_value" numeric(15,2),
    "dimensions" jsonb,
    "recorded_at" timestamp with time zone default now()
      );


alter table "public"."platform_analytics" enable row level security;


  create table "public"."platform_collected_payments" (
    "id" uuid not null default gen_random_uuid(),
    "payer_type" text not null,
    "payer_user_id" uuid,
    "payer_member_id" uuid,
    "payer_profile_id" uuid,
    "destination_organization_id" uuid not null,
    "amount" numeric(12,2) not null,
    "currency" text default 'ZAR'::text,
    "payment_method" text not null,
    "payment_reference" text,
    "payfast_payment_id" text,
    "payfast_pf_payment_id" text,
    "bank_reference" text,
    "payment_purpose" text not null,
    "related_fee_id" uuid,
    "related_invoice_id" uuid,
    "description" text,
    "status" text default 'pending'::text,
    "disbursement_status" text default 'pending'::text,
    "disbursement_date" date,
    "disbursement_reference" text,
    "platform_fee_amount" numeric(10,2) default 0,
    "platform_fee_percent" numeric(5,2) default 2.5,
    "net_amount" numeric(12,2),
    "payment_date" timestamp with time zone default now(),
    "completed_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."platform_collected_payments" enable row level security;


  create table "public"."platform_disbursements" (
    "id" uuid not null default gen_random_uuid(),
    "organization_id" uuid not null,
    "amount" numeric(12,2) not null,
    "currency" text default 'ZAR'::text,
    "bank_account_id" uuid,
    "bank_name" text,
    "account_number_last4" text,
    "status" text default 'pending'::text,
    "scheduled_date" date,
    "processed_at" timestamp with time zone,
    "reference" text,
    "batch_id" text,
    "included_payment_ids" uuid[] default '{}'::uuid[],
    "payment_count" integer default 0,
    "notes" text,
    "failure_reason" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by" uuid
      );


alter table "public"."platform_disbursements" enable row level security;


  create table "public"."platform_subscriptions" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "plan_id" uuid not null,
    "status" text not null default 'trial'::text,
    "billing_interval" text not null,
    "amount" numeric(10,2) not null default 0,
    "currency" text not null default 'ZAR'::text,
    "trial_start" timestamp with time zone,
    "trial_end" timestamp with time zone,
    "current_period_start" timestamp with time zone not null,
    "current_period_end" timestamp with time zone not null,
    "payment_provider" text not null,
    "provider_subscription_id" text,
    "provider_customer_id" text,
    "metadata" jsonb not null default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "canceled_at" timestamp with time zone,
    "ended_at" timestamp with time zone
      );


alter table "public"."platform_subscriptions" enable row level security;


  create table "public"."portfolio_items" (
    "id" uuid not null default gen_random_uuid(),
    "learner_id" uuid not null,
    "title" text not null,
    "description" text,
    "category" text,
    "file_url" text,
    "thumbnail_url" text,
    "program_id" uuid,
    "is_public" boolean default false,
    "display_order" integer default 0,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."portfolio_items" enable row level security;


  create table "public"."preschool_onboarding_requests" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "school_name" text,
    "principal_name" text,
    "principal_email" text,
    "principal_phone" text,
    "registration_number" text,
    "address" text,
    "status" text default 'pending'::text,
    "notes" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "admin_name" text,
    "admin_email" text,
    "preschool_name" text,
    "number_of_students" integer,
    "number_of_teachers" integer,
    "message" text,
    "phone" text
      );


alter table "public"."preschool_onboarding_requests" enable row level security;


  create table "public"."preschool_settings" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "enable_ai_program" boolean default false,
    "enable_robotics_program" boolean default false,
    "enable_computer_literacy" boolean default false,
    "require_lesson_approval" boolean default false,
    "default_homework_due_days" integer default 7,
    "stem_curriculum_version" text default 'v1.0'::text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."preschool_settings" enable row level security;


  create table "public"."preschool_voice_usage" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "subscription_tier" text not null,
    "period_type" text not null,
    "period_start" timestamp with time zone not null,
    "period_end" timestamp with time zone not null,
    "total_stt_minutes" numeric default 0,
    "total_tts_characters" integer default 0,
    "total_stt_requests" integer default 0,
    "total_tts_requests" integer default 0,
    "total_cost_usd" numeric default 0,
    "quota_exceeded" boolean default false,
    "quota_exceeded_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."preschool_voice_usage" enable row level security;


  create table "public"."principal_groups" (
    "id" uuid not null default gen_random_uuid(),
    "name" character varying(255) not null,
    "description" text,
    "created_by" uuid not null,
    "preschool_id" uuid not null,
    "group_type" character varying(50) default 'custom'::character varying,
    "color" character varying(7) default '#6366F1'::character varying,
    "icon" character varying(50) default 'people'::character varying,
    "is_active" boolean default true,
    "settings" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."principal_groups" enable row level security;


  create table "public"."progress_reports" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "student_id" uuid not null,
    "teacher_id" uuid not null,
    "report_period" text not null,
    "report_type" text default 'quarterly'::text,
    "overall_comments" text,
    "teacher_comments" text,
    "strengths" text,
    "areas_for_improvement" text,
    "subjects_performance" jsonb,
    "attendance_summary" jsonb,
    "behavioral_notes" jsonb,
    "overall_grade" text,
    "email_sent_at" timestamp with time zone,
    "email_message_id" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "report_category" text default 'general'::text,
    "school_readiness_indicators" jsonb default '{}'::jsonb,
    "developmental_milestones" jsonb default '{}'::jsonb,
    "transition_readiness_level" text,
    "readiness_notes" text,
    "recommendations" text,
    "status" text default 'draft'::text,
    "teacher_signature_data" text,
    "teacher_signed_at" timestamp with time zone,
    "principal_signature_data" text,
    "principal_signed_at" timestamp with time zone,
    "reviewed_by" uuid,
    "reviewed_at" timestamp with time zone,
    "rejection_reason" text,
    "review_notes" text,
    "submission_count" integer not null default 0,
    "approval_status" public.approval_status default 'draft'::public.approval_status,
    "teacher_signature" text,
    "principal_signature" text,
    "principal_notes" text
      );


alter table "public"."progress_reports" enable row level security;


  create table "public"."promotional_campaigns" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "code" character varying(50) not null,
    "name" text not null,
    "description" text,
    "user_type" text not null,
    "tier_filter" text[],
    "discount_type" text not null,
    "discount_value" numeric(10,2) not null,
    "promo_duration_months" integer not null default 6,
    "start_date" timestamp with time zone not null,
    "end_date" timestamp with time zone not null,
    "max_uses" integer,
    "current_uses" integer default 0,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by" uuid,
    "applies_to_registration" boolean default false,
    "product_type" text default 'subscription'::text
      );


alter table "public"."promotional_campaigns" enable row level security;


  create table "public"."push_device_tokens" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "expo_push_token" text not null,
    "platform" text not null,
    "app_version" text,
    "project_id" text,
    "last_seen_at" timestamp with time zone not null default now(),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."push_device_tokens" enable row level security;


  create table "public"."push_devices" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "expo_push_token" text not null,
    "platform" text default 'web'::text,
    "is_active" boolean not null default true,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "language" text default 'en'::text,
    "timezone" text default 'Africa/Johannesburg'::text,
    "device_installation_id" text not null,
    "device_metadata" jsonb default '{}'::jsonb,
    "last_seen_at" timestamp with time zone default now(),
    "revoked_at" timestamp with time zone,
    "device_id" text default ''::text,
    "fcm_token" text
      );


alter table "public"."push_devices" enable row level security;


  create table "public"."push_notification_queue" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "title" text not null,
    "body" text not null,
    "icon" text default '/icon-192.png'::text,
    "badge" text default '/icon-192.png'::text,
    "tag" text,
    "data" jsonb default '{}'::jsonb,
    "require_interaction" boolean default false,
    "status" text default 'pending'::text,
    "error_message" text,
    "created_at" timestamp with time zone default now(),
    "processed_at" timestamp with time zone
      );


alter table "public"."push_notification_queue" enable row level security;


  create table "public"."push_notifications" (
    "id" uuid not null default gen_random_uuid(),
    "recipient_user_id" uuid not null,
    "title" text not null,
    "body" text not null,
    "data" jsonb default '{}'::jsonb,
    "status" text not null,
    "expo_receipt_id" text,
    "notification_type" text not null,
    "preschool_id" uuid,
    "created_at" timestamp with time zone not null default now(),
    "delivered_at" timestamp with time zone,
    "error_message" text,
    "retry_count" integer not null default 0
      );


alter table "public"."push_notifications" enable row level security;


  create table "public"."push_subscriptions" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid,
    "endpoint" text not null,
    "p256dh" text,
    "auth" text,
    "topics" text[] default ARRAY['updates'::text],
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "preschool_id" uuid,
    "user_agent" text,
    "is_active" boolean default true
      );


alter table "public"."push_subscriptions" enable row level security;


  create table "public"."rag_chunks" (
    "id" uuid not null default gen_random_uuid(),
    "document_id" uuid not null,
    "user_id" uuid not null,
    "conversation_id" text not null,
    "attachment_id" uuid not null,
    "page" integer,
    "chunk_index" integer not null,
    "start_char" integer,
    "end_char" integer,
    "token_count" integer,
    "content" text not null,
    "embedding" public.vector(1536),
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."rag_chunks" enable row level security;


  create table "public"."rag_documents" (
    "id" uuid not null default gen_random_uuid(),
    "attachment_id" uuid not null,
    "user_id" uuid not null,
    "conversation_id" text not null,
    "title" text not null,
    "language" text,
    "status" text not null default 'processing'::text,
    "tokens" integer,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."rag_documents" enable row level security;


  create table "public"."rag_ingestion_logs" (
    "id" uuid not null default gen_random_uuid(),
    "attachment_id" uuid,
    "stage" text not null,
    "message" text,
    "level" text not null default 'info'::text,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."rag_ingestion_logs" enable row level security;


  create table "public"."reading_progress" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "textbook_id" uuid not null,
    "current_page" integer default 1,
    "total_pages_read" integer default 0,
    "progress_percentage" numeric(5,2) default 0.00,
    "last_read_at" timestamp with time zone,
    "total_reading_time_minutes" integer default 0,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."reading_progress" enable row level security;


  create table "public"."region_invite_codes" (
    "id" uuid not null default gen_random_uuid(),
    "organization_id" uuid not null,
    "region_id" uuid not null,
    "code" character varying(20) not null,
    "created_by" uuid not null,
    "max_uses" integer,
    "current_uses" integer default 0,
    "expires_at" timestamp with time zone,
    "is_active" boolean default true,
    "allowed_member_types" text[] default ARRAY['learner'::text, 'facilitator'::text, 'mentor'::text],
    "default_tier" character varying(20) default 'standard'::character varying,
    "description" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "temp_password" text
      );


alter table "public"."region_invite_codes" enable row level security;


  create table "public"."registration_requests" (
    "id" uuid not null default gen_random_uuid(),
    "organization_id" uuid not null,
    "guardian_name" text not null,
    "guardian_email" text not null,
    "guardian_phone" text not null,
    "guardian_address" text,
    "guardian_id_document_url" text,
    "student_first_name" text not null,
    "student_last_name" text not null,
    "student_dob" date not null,
    "student_gender" text,
    "student_birth_certificate_url" text,
    "student_clinic_card_url" text,
    "documents_uploaded" boolean default false,
    "documents_deadline" timestamp with time zone,
    "registration_fee_amount" numeric(10,2),
    "registration_fee_paid" boolean default false,
    "payment_method" text,
    "proof_of_payment_url" text,
    "campaign_applied" text,
    "discount_amount" numeric(10,2) default 0,
    "status" text not null default 'pending'::text,
    "reviewed_by" text,
    "reviewed_date" timestamp with time zone,
    "rejection_reason" text,
    "synced_from_edusite" boolean default false,
    "edusite_id" uuid,
    "synced_at" timestamp with time zone,
    "edudash_student_id" uuid,
    "edudash_parent_id" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "payment_verified" boolean default false,
    "payment_date" timestamp with time zone,
    "payment_verified_at" timestamp with time zone,
    "payment_verified_by" uuid,
    "guardian_first_name" text,
    "guardian_last_name" text,
    "student_grade" text,
    "student_allergies" text,
    "student_medical_conditions" text,
    "emergency_contact_name" text,
    "emergency_contact_phone" text,
    "emergency_contact_relation" text
      );


alter table "public"."registration_requests" enable row level security;


  create table "public"."resource_categories" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "organization_id" uuid not null,
    "name" text not null,
    "description" text,
    "icon" text default 'folder'::text,
    "color" text default '#6b7280'::text,
    "parent_category_id" uuid,
    "sort_order" integer default 0,
    "is_public" boolean default false,
    "is_active" boolean default true
      );


alter table "public"."resource_categories" enable row level security;


  create table "public"."resource_permissions" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "resource_id" uuid not null,
    "user_id" uuid,
    "role" text,
    "class_id" uuid,
    "permission_type" text not null default 'view'::text
      );


alter table "public"."resource_permissions" enable row level security;


  create table "public"."resource_reviews" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "resource_id" uuid not null,
    "user_id" uuid not null,
    "rating" integer not null,
    "review_text" text,
    "used_in_class" boolean default false,
    "student_engagement_rating" integer,
    "is_public" boolean default true,
    "is_flagged" boolean default false
      );


alter table "public"."resource_reviews" enable row level security;


  create table "public"."resources" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "organization_id" uuid not null,
    "created_by" uuid not null,
    "title" text not null,
    "description" text,
    "category_id" uuid,
    "resource_type" text not null,
    "file_url" text,
    "external_url" text,
    "content_text" text,
    "file_size_bytes" bigint,
    "file_mime_type" text,
    "duration_seconds" integer,
    "grade_levels" text[],
    "subjects" text[],
    "tags" text[],
    "visibility" text not null default 'organization'::text,
    "allow_downloads" boolean default true,
    "allow_comments" boolean default true,
    "view_count" integer default 0,
    "download_count" integer default 0,
    "average_rating" numeric(3,2) default 0,
    "rating_count" integer default 0,
    "ai_generated" boolean default false,
    "ai_summary" text,
    "is_featured" boolean default false,
    "is_archived" boolean default false,
    "moderation_status" text default 'approved'::text
      );


alter table "public"."resources" enable row level security;


  create table "public"."revenuecat_webhook_events" (
    "id" uuid not null default gen_random_uuid(),
    "event_id" text not null,
    "app_user_id" text not null,
    "type" text not null,
    "environment" text not null default 'PRODUCTION'::text,
    "raw" jsonb not null,
    "processed" boolean default false,
    "processed_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."revenuecat_webhook_events" enable row level security;


  create table "public"."rubric_grades" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "grade_id" uuid not null,
    "rubric_id" uuid not null,
    "points_earned" numeric(5,2) not null,
    "feedback" text
      );


alter table "public"."rubric_grades" enable row level security;


  create table "public"."scheduled_lessons" (
    "id" uuid not null default gen_random_uuid(),
    "class_id" uuid not null,
    "preschool_id" uuid not null,
    "teacher_id" uuid not null,
    "title" text not null,
    "description" text,
    "room_url" text,
    "scheduled_at" timestamp with time zone not null,
    "duration_minutes" integer default 60,
    "send_reminders" boolean default true,
    "reminder_sent_at" timestamp with time zone,
    "status" text not null default 'scheduled'::text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."scheduled_lessons" enable row level security;


  create table "public"."scheduled_tasks" (
    "id" uuid not null default gen_random_uuid(),
    "type" text not null,
    "title" text not null,
    "description" text,
    "scheduled_for" timestamp with time zone not null,
    "repeat_interval" interval,
    "data" jsonb not null default '{}'::jsonb,
    "status" text not null default 'pending'::text,
    "executed_at" timestamp with time zone,
    "execution_result" jsonb,
    "error_message" text,
    "created_by" uuid not null,
    "organization_id" uuid not null,
    "metadata" jsonb not null default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."scheduled_tasks" enable row level security;


  create table "public"."school_ai_subscriptions" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "subscription_tier" text not null,
    "org_type" text not null,
    "total_quotas" jsonb not null default '{"assessment_ai": 0, "claude_messages": 0, "content_generation": 0}'::jsonb,
    "allocated_quotas" jsonb not null default '{"assessment_ai": 0, "claude_messages": 0, "content_generation": 0}'::jsonb,
    "total_usage" jsonb not null default '{"assessment_ai": 0, "claude_messages": 0, "content_generation": 0}'::jsonb,
    "allow_teacher_self_allocation" boolean not null default false,
    "default_teacher_quotas" jsonb not null default '{"assessment_ai": 3, "claude_messages": 10, "content_generation": 5}'::jsonb,
    "max_individual_quota" jsonb not null default '{"assessment_ai": 30, "claude_messages": 100, "content_generation": 50}'::jsonb,
    "current_period_start" timestamp with time zone not null default date_trunc('month'::text, now()),
    "current_period_end" timestamp with time zone not null default (date_trunc('month'::text, now()) + '1 mon'::interval),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "updated_by" uuid
      );


alter table "public"."school_ai_subscriptions" enable row level security;


  create table "public"."school_branding" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "primary_color" character varying(7) default '#4F46E5'::character varying,
    "secondary_color" character varying(7) default '#7C3AED'::character varying,
    "accent_color" character varying(7) default '#00f5ff'::character varying,
    "logo_url" text,
    "logo_public_id" text,
    "letterhead_url" text,
    "letterhead_public_id" text,
    "font_family" character varying(50) default 'Inter'::character varying,
    "letterhead_html" text,
    "footer_text" text default 'Thank you for your payment!'::text,
    "payment_terms" text default 'Payment due within 30 days'::text,
    "tax_number" character varying(50),
    "vat_number" character varying(50),
    "registration_number" character varying(50),
    "billing_email" character varying(255),
    "billing_phone" character varying(20),
    "billing_address" text,
    "include_qr_code" boolean default true,
    "include_payment_terms" boolean default true,
    "show_tax_breakdown" boolean default true,
    "auto_invoice_numbering" boolean default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."school_branding" enable row level security;


  create table "public"."school_events" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "created_by" uuid not null,
    "title" text not null,
    "description" text,
    "event_type" text not null,
    "start_date" timestamp with time zone not null,
    "end_date" timestamp with time zone not null,
    "all_day" boolean default false,
    "is_recurring" boolean default false,
    "recurrence_rule" jsonb,
    "location" text,
    "target_audience" text[] default ARRAY['all'::text],
    "max_participants" integer,
    "rsvp_enabled" boolean default false,
    "rsvp_deadline" timestamp with time zone,
    "send_notifications" boolean default true,
    "notification_sent" boolean default false,
    "reminder_sent" boolean default false,
    "status" text default 'scheduled'::text,
    "color" text default '#3b82f6'::text,
    "attachments" jsonb,
    "notes" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."school_events" enable row level security;


  create table "public"."school_fee_structures" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "name" text not null,
    "description" text,
    "age_group" text,
    "grade_level" text,
    "amount_cents" integer not null,
    "currency" text default 'ZAR'::text,
    "billing_frequency" text default 'monthly'::text,
    "is_optional" boolean default false,
    "is_deposit" boolean default false,
    "fee_category" text default 'tuition'::text,
    "early_bird_discount_percent" numeric(5,2) default 0,
    "sibling_discount_percent" numeric(5,2) default 0,
    "is_active" boolean default true,
    "auto_charge" boolean default false,
    "due_date" date,
    "due_day_of_month" integer,
    "metadata" jsonb default '{}'::jsonb,
    "created_by" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."school_fee_structures" enable row level security;


  create table "public"."school_invitation_codes" (
    "id" uuid not null default gen_random_uuid(),
    "code" character varying(20) not null,
    "school_id" uuid,
    "invitation_type" character varying(20) not null,
    "invited_email" character varying(255),
    "invited_name" character varying(255),
    "invited_by" uuid,
    "max_uses" integer default 1,
    "current_uses" integer default 0,
    "expires_at" timestamp with time zone default (now() + '7 days'::interval),
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "preschool_id" uuid not null,
    "used_at" timestamp with time zone,
    "used_by" uuid,
    "description" text,
    "metadata" jsonb default '{}'::jsonb
      );


alter table "public"."school_invitation_codes" enable row level security;


  create table "public"."school_settings" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "petty_cash_limit" numeric(10,2) default 10000.00,
    "opening_balance" numeric(10,2) default 5000.00,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "currency" text default 'ZAR'::text,
    "late_fee_percentage" numeric(5,2) default 5.00,
    "grace_period_days" integer default 7,
    "updated_by" uuid
      );


alter table "public"."school_settings" enable row level security;


  create table "public"."school_verifications" (
    "id" uuid not null default gen_random_uuid(),
    "school_id" uuid not null,
    "verification_type" character varying(50) not null,
    "status" character varying(20) default 'pending'::character varying,
    "verification_data" jsonb default '{}'::jsonb,
    "verification_token" text,
    "expires_at" timestamp with time zone,
    "verified_by" uuid,
    "verified_at" timestamp with time zone,
    "failure_reason" text,
    "retry_count" integer default 0,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."school_verifications" enable row level security;


  create table "public"."schools" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "name" text not null,
    "email" text,
    "phone" text,
    "address" text,
    "status" text default 'active'::text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "city" character varying(100),
    "province" character varying(100),
    "country" character varying(100) default 'South Africa'::character varying,
    "postal_code" character varying(20),
    "is_active" boolean default true,
    "metadata" jsonb default '{}'::jsonb,
    "logo_url" text,
    "principal_id" uuid
      );


alter table "public"."schools" enable row level security;


  create table "public"."seats" (
    "id" uuid not null default gen_random_uuid(),
    "subscription_id" uuid not null,
    "user_id" uuid not null,
    "seat_type" text not null,
    "assigned_at" timestamp with time zone default now(),
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "preschool_id" uuid not null
      );


alter table "public"."seats" enable row level security;


  create table "public"."security_events" (
    "id" uuid not null default gen_random_uuid(),
    "event_type" text not null,
    "user_id" uuid,
    "user_email" text not null,
    "risk_level" text not null default 'low'::text,
    "ip_address" text,
    "user_agent" text,
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."security_events" enable row level security;


  create table "public"."service_alert_config" (
    "service_name" text not null,
    "alert_enabled" boolean default true,
    "alert_channels" text[] default ARRAY['email'::text, 'in_app'::text],
    "downtime_threshold_minutes" integer default 5,
    "response_time_threshold_ms" integer default 5000,
    "error_rate_threshold_percent" numeric(5,2) default 5.0,
    "budget_usd" numeric(10,2),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."service_alert_config" enable row level security;


  create table "public"."service_alerts" (
    "id" uuid not null default gen_random_uuid(),
    "service_name" text not null,
    "alert_type" text not null,
    "triggered_at" timestamp with time zone not null default now(),
    "resolved_at" timestamp with time zone,
    "channel" text not null,
    "payload" jsonb default '{}'::jsonb,
    "status" text not null default 'pending'::text,
    "dedupe_key" text not null,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."service_alerts" enable row level security;


  create table "public"."service_api_keys" (
    "id" uuid not null default gen_random_uuid(),
    "service_name" text not null,
    "key_alias" text not null,
    "owner_email" text not null,
    "created_at" timestamp with time zone not null default now(),
    "expires_at" timestamp with time zone,
    "last_verified_at" timestamp with time zone,
    "scopes" text[] default ARRAY[]::text[],
    "status" text not null default 'unknown'::text,
    "notes" text,
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."service_api_keys" enable row level security;


  create table "public"."service_cost_tracking" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid,
    "service_name" text not null,
    "period_month" date not null,
    "cost_usd" numeric(10,4) not null default 0,
    "cost_zar" numeric(10,2) not null default 0,
    "usage_units" jsonb not null default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."service_cost_tracking" enable row level security;


  create table "public"."service_health_status" (
    "id" uuid not null default gen_random_uuid(),
    "service_name" text not null,
    "service_category" text not null,
    "status" text not null default 'unknown'::text,
    "response_time_ms" integer,
    "error_rate_percent" numeric(5,2) default 0,
    "circuit_state" text default 'closed'::text,
    "last_checked_at" timestamp with time zone not null default now(),
    "last_success_at" timestamp with time zone,
    "last_failure_at" timestamp with time zone,
    "consecutive_failures" integer default 0,
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."service_health_status" enable row level security;


  create table "public"."service_incidents" (
    "id" uuid not null default gen_random_uuid(),
    "service_name" text not null,
    "started_at" timestamp with time zone not null default now(),
    "ended_at" timestamp with time zone,
    "status" text not null default 'ongoing'::text,
    "summary" text not null,
    "severity" text not null,
    "error_code" text,
    "pii_scrubbed_message" text,
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."service_incidents" enable row level security;


  create table "public"."service_usage_limits" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid,
    "service_name" text not null,
    "tier" text not null,
    "soft_limit" bigint not null,
    "hard_limit" bigint not null,
    "usage_this_period" bigint default 0,
    "period_start" date not null,
    "period_end" date not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."service_usage_limits" enable row level security;


  create table "public"."sms_messages" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "from_number" text not null,
    "to_number" text not null,
    "body" text not null,
    "status" text not null default 'queued'::text,
    "error_code" text,
    "error_message" text,
    "provider" text not null default 'twilio'::text,
    "provider_message_id" text,
    "sent_by_user_id" uuid,
    "sent_at" timestamp with time zone,
    "delivered_at" timestamp with time zone,
    "created_at" timestamp with time zone not null default now(),
    "segments" integer default 1,
    "cost_per_segment" numeric(10,4),
    "total_cost" numeric(10,4) generated always as (((segments)::numeric * COALESCE(cost_per_segment, (0)::numeric))) stored
      );


alter table "public"."sms_messages" enable row level security;


  create table "public"."sms_opt_outs" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "phone_number" text not null,
    "opted_out_at" timestamp with time zone not null default now(),
    "opt_out_method" text,
    "opted_in_at" timestamp with time zone,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."sms_opt_outs" enable row level security;


  create table "public"."sound_alert_settings" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "alert_type" text not null,
    "enabled" boolean not null default true,
    "sound_file" text,
    "volume" integer default 50,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."sound_alert_settings" enable row level security;


  create table "public"."standalone_users" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "profile_id" uuid not null,
    "user_type" text not null,
    "subscription_tier" text default 'free'::text,
    "is_trial" boolean default false,
    "trial_end_date" timestamp with time zone,
    "trial_started_at" timestamp with time zone,
    "subscription_status" text default 'active'::text,
    "usage_type" text default 'standalone'::text,
    "onboarding_completed" boolean default false,
    "preferences" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."standalone_users" enable row level security;


  create table "public"."stem_progress" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "preschool_id" uuid not null,
    "category" text not null,
    "lessons_completed" integer default 0,
    "activities_completed" integer default 0,
    "homework_submitted" integer default 0,
    "last_activity_date" date,
    "engagement_score" numeric(5,2) default 0.0,
    "streak_days" integer default 0,
    "badges_earned" jsonb default '[]'::jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."stem_progress" enable row level security;


  create table "public"."student_achievements" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "preschool_id" uuid not null,
    "achievement_type" text not null,
    "achievement_name" text not null,
    "achievement_icon" text,
    "achievement_color" text,
    "category" text,
    "related_activity_id" uuid,
    "related_lesson_id" uuid,
    "points" integer default 1,
    "level" integer default 1,
    "description" text,
    "awarded_by" uuid,
    "earned_at" timestamp with time zone default now(),
    "created_at" timestamp with time zone default now()
      );


alter table "public"."student_achievements" enable row level security;


  create table "public"."student_enrollments" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "class_id" uuid not null,
    "enrollment_date" date not null default CURRENT_DATE,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."student_enrollments" enable row level security;


  create table "public"."student_fee_assignments" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "fee_structure_id" uuid not null,
    "preschool_id" uuid not null,
    "override_amount_cents" integer,
    "discount_percent" numeric(5,2) default 0,
    "discount_reason" text,
    "total_amount_cents" integer not null,
    "paid_amount_cents" integer default 0,
    "balance_cents" integer generated always as ((total_amount_cents - paid_amount_cents)) stored,
    "status" text default 'pending'::text,
    "assigned_date" date default CURRENT_DATE,
    "due_date" date,
    "paid_date" date,
    "created_by" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."student_fee_assignments" enable row level security;


  create table "public"."student_groups" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "group_id" uuid not null,
    "added_by" uuid not null,
    "added_at" timestamp with time zone not null default now(),
    "is_active" boolean not null default true,
    "group_role" text default 'member'::text,
    "metadata" jsonb not null default '{}'::jsonb
      );


alter table "public"."student_groups" enable row level security;


  create table "public"."student_parent_relationships" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "parent_id" uuid not null,
    "relationship_type" text default 'parent'::text,
    "is_primary" boolean default false,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."student_parent_relationships" enable row level security;


  create table "public"."student_progress" (
    "id" uuid not null default gen_random_uuid(),
    "course_id" uuid not null,
    "student_id" uuid not null,
    "progress_data" jsonb not null default '{}'::jsonb,
    "alerts" jsonb default '[]'::jsonb,
    "alert_level" text default 'none'::text,
    "assignments_completed" integer default 0,
    "assignments_total" integer default 0,
    "assignments_late" integer default 0,
    "assignments_missing" integer default 0,
    "average_grade" numeric(5,2),
    "trend_direction" text default 'stable'::text,
    "last_activity_at" timestamp with time zone,
    "engagement_score" integer default 0,
    "last_calculated" timestamp with time zone not null default now(),
    "calculated_by" uuid not null,
    "metadata" jsonb not null default '{}'::jsonb
      );


alter table "public"."student_progress" enable row level security;


  create table "public"."student_streaks" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "preschool_id" uuid not null,
    "streak_type" text not null,
    "current_streak" integer default 0,
    "longest_streak" integer default 0,
    "last_activity_date" date,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."student_streaks" enable row level security;


  create table "public"."study_groups" (
    "id" uuid not null default gen_random_uuid(),
    "name" text not null,
    "description" text,
    "program_id" uuid,
    "organization_id" uuid,
    "created_by" uuid not null,
    "members" jsonb default '[]'::jsonb,
    "is_active" boolean default true,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."study_groups" enable row level security;


  create table "public"."submissions" (
    "id" uuid not null default gen_random_uuid(),
    "assignment_id" uuid not null,
    "student_id" uuid not null,
    "content" text,
    "attachments" jsonb default '[]'::jsonb,
    "submission_type" text not null default 'text'::text,
    "attempt_number" integer not null default 1,
    "submitted_at" timestamp with time zone not null default now(),
    "is_late" boolean not null default false,
    "is_draft" boolean not null default false,
    "ai_assistance_used" boolean not null default false,
    "ai_assistance_details" jsonb default '{}'::jsonb,
    "metadata" jsonb not null default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."submissions" enable row level security;


  create table "public"."subscription_plans" (
    "id" uuid not null default gen_random_uuid(),
    "name" text not null,
    "tier" public.subscription_tier not null,
    "description" text,
    "price_monthly" numeric(10,2) not null default 0,
    "price_annual" numeric(10,2) not null default 0,
    "max_teachers" integer not null default 0,
    "max_students" integer not null default 0,
    "max_schools" integer not null default 1,
    "features" jsonb not null default '[]'::jsonb,
    "school_types" text[] not null default ARRAY['preschool'::text],
    "is_active" boolean not null default true,
    "sort_order" integer not null default 0,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."subscription_plans" enable row level security;


  create table "public"."subscription_seats" (
    "id" uuid not null default gen_random_uuid(),
    "subscription_id" uuid not null,
    "user_id" uuid,
    "assigned_at" timestamp with time zone default now(),
    "assigned_by" uuid,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "revoked_at" timestamp with time zone,
    "revoked_by" uuid,
    "preschool_id" uuid not null
      );


alter table "public"."subscription_seats" enable row level security;


  create table "public"."subscription_usage" (
    "id" uuid not null default gen_random_uuid(),
    "subscription_id" uuid not null,
    "school_id" uuid not null,
    "usage_type" text not null,
    "usage_count" integer not null default 0,
    "usage_limit" integer,
    "period_start" timestamp with time zone not null,
    "period_end" timestamp with time zone not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."subscription_usage" enable row level security;


  create table "public"."subscriptions" (
    "id" uuid not null default gen_random_uuid(),
    "school_id" uuid,
    "plan_id" uuid not null,
    "status" public.subscription_status not null default 'trialing'::public.subscription_status,
    "billing_frequency" public.billing_frequency not null default 'monthly'::public.billing_frequency,
    "start_date" timestamp with time zone not null default now(),
    "end_date" timestamp with time zone,
    "trial_end_date" timestamp with time zone,
    "next_billing_date" timestamp with time zone,
    "canceled_at" timestamp with time zone,
    "seats_total" integer not null default 0,
    "seats_used" integer not null default 0,
    "payfast_token" text,
    "payfast_payment_id" text,
    "stripe_subscription_id" text,
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "owner_type" text default 'school'::text,
    "user_id" uuid
      );


alter table "public"."subscriptions" enable row level security;


  create table "public"."superadmin_agent_executions" (
    "id" uuid not null default gen_random_uuid(),
    "agent_id" text not null,
    "triggered_by" uuid,
    "trigger_type" text not null default 'manual'::text,
    "status" text not null default 'pending'::text,
    "started_at" timestamp with time zone not null default now(),
    "finished_at" timestamp with time zone,
    "steps" jsonb not null default '[]'::jsonb,
    "result" jsonb,
    "error_message" text,
    "tokens_used" integer default 0,
    "cost_usd" numeric(10,6) default 0
      );


alter table "public"."superadmin_agent_executions" enable row level security;


  create table "public"."superadmin_ai_agents" (
    "id" text not null,
    "name" text not null,
    "description" text not null,
    "agent_type" text not null,
    "status" text not null default 'idle'::text,
    "configuration" jsonb not null default '{}'::jsonb,
    "last_run_at" timestamp with time zone,
    "last_run_status" text,
    "success_rate" numeric(5,2) default 0,
    "total_runs" integer default 0,
    "successful_runs" integer default 0,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."superadmin_ai_agents" enable row level security;


  create table "public"."superadmin_audit_log" (
    "id" uuid not null default gen_random_uuid(),
    "superadmin_user_id" uuid,
    "superadmin_email" text not null,
    "action" text not null,
    "table_name" text not null,
    "record_id" uuid,
    "old_values" jsonb,
    "new_values" jsonb,
    "ip_address" inet,
    "user_agent" text,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."superadmin_audit_log" enable row level security;


  create table "public"."superadmin_autonomous_tasks" (
    "id" text not null,
    "name" text not null,
    "description" text not null,
    "task_type" text not null,
    "schedule_cron" text not null,
    "is_enabled" boolean not null default true,
    "last_execution_at" timestamp with time zone,
    "next_execution_at" timestamp with time zone,
    "last_execution_status" text,
    "configuration" jsonb not null default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."superadmin_autonomous_tasks" enable row level security;


  create table "public"."superadmin_command_log" (
    "id" uuid not null default gen_random_uuid(),
    "admin_id" uuid not null,
    "command_type" text not null,
    "command_input" text not null,
    "command_output" text,
    "target_entity" text,
    "target_id" text,
    "status" text not null default 'pending'::text,
    "metadata" jsonb default '{}'::jsonb,
    "tokens_used" integer default 0,
    "model_used" text,
    "duration_ms" integer,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."superadmin_command_log" enable row level security;


  create table "public"."superadmin_compliance_reports" (
    "id" uuid not null default gen_random_uuid(),
    "report_type" public.compliance_report_type_enum not null,
    "tenant_id" uuid,
    "date_range_start" timestamp with time zone not null,
    "date_range_end" timestamp with time zone not null,
    "filter_criteria" jsonb default '{}'::jsonb,
    "generated_by" uuid not null,
    "status" public.report_status_enum not null default 'generating'::public.report_status_enum,
    "report_data" jsonb,
    "file_path" text,
    "file_size_bytes" bigint,
    "summary_stats" jsonb default '{}'::jsonb,
    "error_message" text,
    "access_granted_to" uuid[] default '{}'::uuid[],
    "generated_at" timestamp with time zone,
    "expires_at" timestamp with time zone default (now() + '90 days'::interval),
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."superadmin_compliance_reports" enable row level security;


  create table "public"."superadmin_integrations" (
    "id" text not null,
    "name" text not null,
    "integration_type" text not null,
    "is_enabled" boolean not null default false,
    "configuration" jsonb not null default '{}'::jsonb,
    "credentials_encrypted" text,
    "last_sync_at" timestamp with time zone,
    "last_sync_status" text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."superadmin_integrations" enable row level security;


  create table "public"."superadmin_notification_deliveries" (
    "id" uuid not null default gen_random_uuid(),
    "notification_id" uuid not null,
    "method" public.delivery_method_enum not null,
    "recipient" text not null,
    "status" public.delivery_status_enum not null default 'pending'::public.delivery_status_enum,
    "external_id" text,
    "error_message" text,
    "delivery_metadata" jsonb default '{}'::jsonb,
    "scheduled_for" timestamp with time zone default now(),
    "sent_at" timestamp with time zone,
    "delivered_at" timestamp with time zone,
    "failed_at" timestamp with time zone,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."superadmin_notification_deliveries" enable row level security;


  create table "public"."superadmin_notification_rules" (
    "id" uuid not null default gen_random_uuid(),
    "rule_name" text not null,
    "conditions" jsonb not null,
    "actions" jsonb not null,
    "is_active" boolean default true,
    "created_by" uuid not null,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."superadmin_notification_rules" enable row level security;


  create table "public"."superadmin_notifications" (
    "id" uuid not null default gen_random_uuid(),
    "admin_id" uuid,
    "tenant_id" uuid,
    "type" public.notification_type_enum not null,
    "source" public.notification_source_enum not null,
    "severity" public.severity_enum not null default 'medium'::public.severity_enum,
    "title" text not null,
    "message" text not null,
    "status" public.notification_status_enum not null default 'unread'::public.notification_status_enum,
    "metadata" jsonb default '{}'::jsonb,
    "related_resource_type" text,
    "related_resource_id" text,
    "delivery_attempts" integer default 0,
    "last_delivery_attempt" timestamp with time zone,
    "expires_at" timestamp with time zone default (now() + '30 days'::interval),
    "acknowledged_at" timestamp with time zone,
    "resolved_at" timestamp with time zone,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."superadmin_notifications" enable row level security;


  create table "public"."superadmin_platform_insights" (
    "id" uuid not null default gen_random_uuid(),
    "insight_type" text not null,
    "priority" text not null default 'medium'::text,
    "title" text not null,
    "description" text not null,
    "data" jsonb not null default '{}'::jsonb,
    "action_label" text,
    "action_route" text,
    "is_dismissed" boolean not null default false,
    "dismissed_by" uuid,
    "dismissed_at" timestamp with time zone,
    "expires_at" timestamp with time zone,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."superadmin_platform_insights" enable row level security;


  create table "public"."superadmin_role_assignments" (
    "id" uuid not null default gen_random_uuid(),
    "admin_id" uuid not null,
    "tenant_id" uuid,
    "role_level" public.admin_role_level_enum not null,
    "permissions" jsonb not null default '{}'::jsonb,
    "scope_restrictions" jsonb default '{}'::jsonb,
    "max_users_manageable" integer,
    "max_bulk_operations" integer default 10,
    "is_active" boolean not null default true,
    "valid_from" timestamp with time zone default now(),
    "valid_until" timestamp with time zone,
    "assigned_by" uuid not null,
    "assignment_reason" text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "revoked_at" timestamp with time zone,
    "revoked_by" uuid,
    "revocation_reason" text
      );


alter table "public"."superadmin_role_assignments" enable row level security;


  create table "public"."superadmin_session_management" (
    "id" uuid not null default gen_random_uuid(),
    "admin_id" uuid not null,
    "tenant_id" uuid,
    "session_id" text not null,
    "session_start" timestamp with time zone default now(),
    "session_end" timestamp with time zone,
    "ip_address" inet,
    "user_agent" text,
    "device_fingerprint" text,
    "termination_reason" public.session_termination_reason_enum,
    "terminated_by" uuid,
    "is_suspicious" boolean default false,
    "security_flags" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."superadmin_session_management" enable row level security;


  create table "public"."superadmin_user_actions" (
    "id" uuid not null default gen_random_uuid(),
    "admin_id" uuid not null,
    "target_user_id" uuid,
    "tenant_id" uuid,
    "action" public.superadmin_action_enum not null,
    "resource_type" text,
    "resource_id" text,
    "description" text not null,
    "previous_values" jsonb,
    "new_values" jsonb,
    "ip_address" inet,
    "user_agent" text,
    "session_id" text,
    "bulk_operation_id" uuid,
    "affected_count" integer default 1,
    "compliance_flags" jsonb default '{}'::jsonb,
    "risk_assessment" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now(),
    "admin_user_id" uuid
      );


alter table "public"."superadmin_user_actions" enable row level security;


  create table "public"."superadmin_user_deletion_requests" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "requester_id" uuid not null,
    "tenant_id" uuid,
    "deletion_type" public.deletion_type_enum not null default 'soft'::public.deletion_type_enum,
    "status" public.deletion_status_enum not null default 'pending'::public.deletion_status_enum,
    "escalation_level" public.escalation_level_enum,
    "reason" text not null,
    "internal_notes" text,
    "scheduled_for" timestamp with time zone,
    "started_at" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "error_message" text,
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "target_user_id" uuid
      );


alter table "public"."superadmin_user_deletion_requests" enable row level security;


  create table "public"."superadmin_user_risk_assessments" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "tenant_id" uuid,
    "risk_score" integer not null default 0,
    "risk_level" public.risk_level_enum generated always as (public.validate_risk_score(risk_score)) stored,
    "login_anomalies_score" integer default 0,
    "payment_issues_score" integer default 0,
    "abuse_reports_score" integer default 0,
    "policy_violations_score" integer default 0,
    "suspicious_activity_score" integer default 0,
    "assessment_reason" text,
    "automated_flags" jsonb default '{}'::jsonb,
    "manual_notes" text,
    "assessed_by" uuid,
    "assessment_type" text default 'automated'::text,
    "valid_until" timestamp with time zone default (now() + '30 days'::interval),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."superadmin_user_risk_assessments" enable row level security;


  create table "public"."support_tickets" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "user_id" uuid,
    "preschool_id" uuid,
    "subject" text not null,
    "description" text not null,
    "priority" text default 'medium'::text,
    "status" text default 'open'::text,
    "assigned_to" text,
    "resolution_notes" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."support_tickets" enable row level security;


  create table "public"."sync_logs" (
    "id" uuid not null default gen_random_uuid(),
    "source_table" text not null,
    "record_id" uuid not null,
    "sync_direction" text not null,
    "sync_type" text not null,
    "success" boolean not null default false,
    "error_message" text,
    "request_payload" jsonb,
    "response_payload" jsonb,
    "synced_at" timestamp with time zone default now()
      );


alter table "public"."sync_logs" enable row level security;


  create table "public"."system_config" (
    "key" text not null,
    "value" jsonb not null,
    "description" text,
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."system_config" enable row level security;


  create table "public"."system_settings" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "key" text not null,
    "value" text,
    "description" text,
    "is_public" boolean default false,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."system_settings" enable row level security;


  create table "public"."teacher_ai_allocations" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "user_id" uuid not null,
    "teacher_name" text not null,
    "teacher_email" text not null,
    "role" text not null,
    "allocated_quotas" jsonb not null default '{"assessment_ai": 0, "claude_messages": 0, "content_generation": 0}'::jsonb,
    "used_quotas" jsonb not null default '{"assessment_ai": 0, "claude_messages": 0, "content_generation": 0}'::jsonb,
    "allocated_by" uuid not null,
    "allocated_at" timestamp with time zone not null default now(),
    "allocation_reason" text,
    "is_active" boolean not null default true,
    "is_suspended" boolean not null default false,
    "suspension_reason" text,
    "auto_renew" boolean not null default false,
    "priority_level" text not null default 'normal'::text,
    "period_start" timestamp with time zone not null default date_trunc('month'::text, now()),
    "period_end" timestamp with time zone not null default (date_trunc('month'::text, now()) + '1 mon'::interval),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."teacher_ai_allocations" enable row level security;


  create table "public"."teacher_class_codes" (
    "id" uuid not null default gen_random_uuid(),
    "code" text not null,
    "teacher_id" uuid not null,
    "preschool_id" uuid,
    "active" boolean not null default true,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."teacher_class_codes" enable row level security;


  create table "public"."teacher_invitations" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "preschool_id" uuid,
    "email" text not null,
    "name" text,
    "invited_by" uuid,
    "invitation_code" text,
    "status" text default 'pending'::text,
    "expires_at" timestamp with time zone,
    "accepted_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."teacher_invitations" enable row level security;


  create table "public"."teacher_performance_metrics" (
    "id" uuid not null default gen_random_uuid(),
    "teacher_id" uuid not null,
    "preschool_id" uuid not null,
    "metric_period_start" date not null,
    "metric_period_end" date not null,
    "lessons_planned" integer default 0,
    "lessons_delivered" integer default 0,
    "student_attendance_rate" numeric(5,2) default 0,
    "assignment_grading_turnaround_days" numeric(4,2) default 0,
    "parent_feedback_score" numeric(3,2) default 0,
    "professional_development_hours" numeric(5,2) default 0,
    "punctuality_score" numeric(3,2) default 0,
    "student_engagement_score" numeric(3,2) default 0,
    "classroom_management_score" numeric(3,2) default 0,
    "overall_performance_score" numeric(3,2) default 0,
    "notes" text,
    "recorded_by" uuid,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."teacher_performance_metrics" enable row level security;


  create table "public"."teacher_student_notes" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "teacher_id" uuid not null,
    "preschool_id" uuid,
    "class_id" uuid,
    "note_type" text not null default 'general'::text,
    "title" text not null,
    "content" text not null,
    "is_visible_to_parents" boolean default true,
    "is_read" boolean default false,
    "read_at" timestamp with time zone,
    "requires_acknowledgment" boolean default false,
    "acknowledged_at" timestamp with time zone,
    "acknowledged_by" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."teacher_student_notes" enable row level security;


  create table "public"."teachers" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "user_id" uuid,
    "preschool_id" uuid,
    "first_name" text,
    "last_name" text,
    "email" text,
    "phone" text,
    "subject_specialization" text,
    "is_active" boolean not null default true,
    "auth_user_id" uuid,
    "full_name" text,
    "role" text not null default 'teacher'::text,
    "cv_file_path" text,
    "cv_file_name" text,
    "cv_mime_type" text,
    "cv_file_size" integer,
    "cv_uploaded_at" timestamp with time zone,
    "cv_uploaded_by" uuid,
    "qualifications_file_path" text,
    "qualifications_file_name" text,
    "qualifications_mime_type" text,
    "qualifications_file_size" integer,
    "qualifications_uploaded_at" timestamp with time zone,
    "qualifications_uploaded_by" uuid,
    "id_copy_file_path" text,
    "id_copy_file_name" text,
    "id_copy_mime_type" text,
    "id_copy_file_size" integer,
    "id_copy_uploaded_at" timestamp with time zone,
    "id_copy_uploaded_by" uuid,
    "contracts_file_path" text,
    "contracts_file_name" text,
    "contracts_mime_type" text,
    "contracts_file_size" integer,
    "contracts_uploaded_at" timestamp with time zone,
    "contracts_uploaded_by" uuid
      );


alter table "public"."teachers" enable row level security;


  create table "public"."template_approvals" (
    "id" uuid not null default gen_random_uuid(),
    "template_id" uuid not null,
    "version" integer not null,
    "status" public.template_approval_status_enum default 'pending'::public.template_approval_status_enum,
    "requested_by" uuid not null,
    "reviewed_by" uuid,
    "review_notes" text,
    "changes_requested" text,
    "requested_at" timestamp with time zone not null default now(),
    "reviewed_at" timestamp with time zone
      );


alter table "public"."template_approvals" enable row level security;


  create table "public"."template_usage_logs" (
    "id" uuid not null default gen_random_uuid(),
    "template_id" uuid not null,
    "notification_id" uuid,
    "rendered_subject" text,
    "rendered_body" text,
    "variables_used" jsonb default '{}'::jsonb,
    "recipient" text,
    "channel" public.delivery_method_enum,
    "render_time_ms" integer,
    "delivery_success" boolean,
    "error_message" text,
    "created_at" timestamp with time zone not null default now(),
    "created_by" uuid
      );


alter table "public"."template_usage_logs" enable row level security;


  create table "public"."template_variables" (
    "id" uuid not null default gen_random_uuid(),
    "template_id" uuid not null,
    "variable_name" text not null,
    "variable_type" public.template_variable_type_enum default 'text'::public.template_variable_type_enum,
    "description" text,
    "is_required" boolean default false,
    "default_value" text,
    "validation_pattern" text,
    "min_length" integer,
    "max_length" integer,
    "display_name" text,
    "placeholder" text,
    "help_text" text,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."template_variables" enable row level security;


  create table "public"."tenants" (
    "id" uuid not null default gen_random_uuid(),
    "name" text not null,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "is_active" boolean default true
      );


alter table "public"."tenants" enable row level security;


  create table "public"."tester_feedback" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "user_id" uuid not null,
    "feedback_text" text not null,
    "screenshot_path" text,
    "device_info" jsonb not null default '{}'::jsonb,
    "app_version" text,
    "platform" text,
    "severity" public.feedback_severity not null default 'bug'::public.feedback_severity,
    "status" public.feedback_status not null default 'new'::public.feedback_status,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."tester_feedback" enable row level security;


  create table "public"."textbook_chapters" (
    "id" uuid not null default gen_random_uuid(),
    "textbook_id" uuid not null,
    "chapter_number" integer not null,
    "title" text not null,
    "subtitle" text,
    "page_start" integer not null,
    "page_end" integer not null,
    "content_text" text,
    "summary" text,
    "caps_topics" text[],
    "learning_outcomes" text[],
    "difficulty_level" text,
    "estimated_reading_time_minutes" integer,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."textbook_chapters" enable row level security;


  create table "public"."textbook_content" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "textbook_id" uuid not null,
    "chapter_number" integer,
    "section_number" integer,
    "subsection_number" integer,
    "title" character varying(255) not null,
    "description" text,
    "content_type" character varying(50),
    "page_start" integer not null,
    "page_end" integer not null,
    "key_concepts" text[],
    "activities_included" boolean default false,
    "exercises_included" boolean default false,
    "parent_id" uuid,
    "sequence_order" integer,
    "estimated_duration_minutes" integer,
    "difficulty_level" character varying(20),
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now()
      );


alter table "public"."textbook_content" enable row level security;


  create table "public"."textbook_pages" (
    "id" uuid not null default gen_random_uuid(),
    "textbook_id" uuid not null,
    "chapter_id" uuid,
    "page_number" integer not null,
    "content_text" text,
    "content_type" text default 'text'::text,
    "has_diagrams" boolean default false,
    "has_tables" boolean default false,
    "has_exercises" boolean default false,
    "diagram_urls" text[],
    "exercise_numbers" integer[],
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."textbook_pages" enable row level security;


  create table "public"."textbooks" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "title" character varying(255) not null,
    "publisher" character varying(100) not null,
    "isbn" character varying(20),
    "edition" character varying(50),
    "publication_year" integer,
    "grade" character varying(10) not null,
    "subject" character varying(100) not null,
    "language" character varying(10) default 'en'::character varying,
    "caps_approved" boolean default false,
    "dbe_approved" boolean default false,
    "approval_date" date,
    "format" character varying(20),
    "page_count" integer,
    "cover_image_url" text,
    "pdf_url" text,
    "publisher_website" text,
    "authors" text[],
    "description" text,
    "metadata" jsonb default '{}'::jsonb,
    "is_active" boolean default true,
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now(),
    "is_free" boolean default false,
    "caps_topics" text[],
    "total_pages" integer,
    "file_size_mb" numeric(10,2),
    "license_type" text default 'standard'::text,
    "requires_subscription" boolean default false,
    "cover_url" text
      );


alter table "public"."textbooks" enable row level security;


  create table "public"."trial_usage_log" (
    "id" uuid not null default gen_random_uuid(),
    "email" text,
    "phone" text,
    "device_fingerprint" text,
    "user_id" uuid,
    "activated_at" timestamp with time zone not null default now(),
    "expires_at" timestamp with time zone not null default (now() + '7 days'::interval),
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."trial_usage_log" enable row level security;


  create table "public"."tts_audio_cache" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid,
    "hash" text not null,
    "text" text not null,
    "language_code" text not null,
    "voice_id" text,
    "provider" text not null,
    "storage_path" text not null,
    "size_bytes" integer,
    "hit_count" integer default 0,
    "last_used_at" timestamp with time zone default now(),
    "created_by" uuid,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."tts_audio_cache" enable row level security;


  create table "public"."typing_indicators" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "thread_id" uuid not null,
    "user_id" uuid not null,
    "is_typing" boolean not null default true,
    "started_at" timestamp with time zone not null default now(),
    "last_updated_at" timestamp with time zone not null default now()
      );


alter table "public"."typing_indicators" enable row level security;


  create table "public"."user_ai_tiers" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "assigned_by" uuid,
    "assigned_reason" text,
    "override_daily_limit" integer,
    "override_monthly_limit" integer,
    "override_rpm_limit" integer,
    "is_active" boolean not null default true,
    "expires_at" timestamp with time zone,
    "metadata" jsonb not null default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "tier" public.tier_name_aligned
      );


alter table "public"."user_ai_tiers" enable row level security;


  create table "public"."user_ai_usage" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "user_id" uuid not null,
    "exams_generated_this_month" integer default 0,
    "explanations_requested_this_month" integer default 0,
    "chat_messages_today" integer default 0,
    "total_exams_generated" integer default 0,
    "total_explanations_requested" integer default 0,
    "total_chat_messages" integer default 0,
    "last_monthly_reset_at" timestamp without time zone default now(),
    "last_daily_reset_at" timestamp without time zone default now(),
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now(),
    "current_tier" public.tier_name_aligned
      );


alter table "public"."user_ai_usage" enable row level security;


  create table "public"."user_blocks" (
    "id" uuid not null default gen_random_uuid(),
    "blocker_id" uuid not null,
    "blocked_id" uuid not null,
    "block_type" character varying(50) default 'user'::character varying,
    "reason" character varying(100),
    "details" text,
    "school_id" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "expires_at" timestamp with time zone,
    "is_active" boolean default true
      );


alter table "public"."user_blocks" enable row level security;


  create table "public"."user_bookmarks" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "user_id" uuid not null,
    "textbook_id" uuid not null,
    "created_at" timestamp without time zone default now()
      );


alter table "public"."user_bookmarks" enable row level security;


  create table "public"."user_connections" (
    "id" uuid not null default gen_random_uuid(),
    "requester_id" uuid not null,
    "addressee_id" uuid not null,
    "status" character varying(20) default 'pending'::character varying,
    "connection_type" character varying(50) default 'cross_school'::character varying,
    "requested_at" timestamp with time zone default now(),
    "responded_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."user_connections" enable row level security;


  create table "public"."user_contacts" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "phone_number_hash" character varying(64) not null,
    "contact_name" character varying(255),
    "matched_user_id" uuid,
    "is_invited" boolean default false,
    "invited_at" timestamp with time zone,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."user_contacts" enable row level security;


  create table "public"."user_invitations" (
    "id" uuid not null default gen_random_uuid(),
    "email" text not null,
    "role" text not null,
    "invited_by" uuid,
    "status" text not null default 'pending'::text,
    "token" text not null default encode(extensions.gen_random_bytes(32), 'hex'::text),
    "expires_at" timestamp with time zone not null default (now() + '7 days'::interval),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."user_invitations" enable row level security;


  create table "public"."user_phone_numbers" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "phone_number" character varying(20) not null,
    "country_code" character varying(5) not null default '+27'::character varying,
    "is_verified" boolean default false,
    "is_primary" boolean default false,
    "verification_code" character varying(6),
    "verification_code_expires_at" timestamp with time zone,
    "verification_attempts" integer default 0,
    "verified_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."user_phone_numbers" enable row level security;


  create table "public"."user_preferences" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "user_id" uuid,
    "theme" text default 'light'::text,
    "language" text default 'en'::text,
    "timezone" text default 'Africa/Johannesburg'::text,
    "notifications_email" boolean default true,
    "notifications_push" boolean default true,
    "notifications_sms" boolean default false,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."user_preferences" enable row level security;


  create table "public"."user_presence" (
    "user_id" uuid not null,
    "status" text not null default 'offline'::text,
    "last_seen_at" timestamp with time zone default now(),
    "device_type" text,
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."user_presence" enable row level security;


  create table "public"."user_profiles" (
    "id" uuid not null default gen_random_uuid(),
    "auth_id" uuid,
    "email" text,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."user_profiles" enable row level security;


  create table "public"."user_promotional_subscriptions" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "user_id" uuid not null,
    "campaign_id" uuid not null,
    "tier" text not null,
    "original_price" numeric(10,2) not null,
    "promo_price" numeric(10,2) not null,
    "promo_start_date" timestamp with time zone not null default now(),
    "promo_end_date" timestamp with time zone not null,
    "is_active" boolean default true,
    "reverted_to_full_price" boolean default false,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."user_promotional_subscriptions" enable row level security;


  create table "public"."user_usage_tracking" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "quota_type" character varying(50) not null,
    "usage_period_start" date not null,
    "usage_period_end" date not null,
    "current_usage" integer not null default 0,
    "quota_limit" integer not null default 0,
    "overage_amount" integer not null default 0,
    "overage_status" public.overage_status default 'none'::public.overage_status,
    "last_updated" timestamp with time zone default now(),
    "created_at" timestamp with time zone default now()
      );


alter table "public"."user_usage_tracking" enable row level security;


  create table "public"."user_voice_usage" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "preschool_id" uuid not null,
    "period_type" text not null,
    "period_start" timestamp with time zone not null,
    "period_end" timestamp with time zone not null,
    "stt_total_minutes" numeric default 0,
    "stt_request_count" integer default 0,
    "stt_total_cost_usd" numeric default 0,
    "tts_total_characters" integer default 0,
    "tts_request_count" integer default 0,
    "tts_total_cost_usd" numeric default 0,
    "total_cost_usd" numeric default 0,
    "last_reset_at" timestamp with time zone default now(),
    "requests_in_current_minute" integer default 0,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."user_voice_usage" enable row level security;


  create table "public"."users" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "auth_user_id" uuid,
    "email" text not null,
    "name" text not null,
    "role" text not null,
    "phone" text,
    "is_active" boolean default true,
    "profile_completion_status" text default 'incomplete'::text,
    "preschool_id" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "date_of_birth" date,
    "gender" text,
    "nationality" text default 'South African'::text,
    "id_number" text,
    "emergency_contact_name" text,
    "emergency_contact_phone" text,
    "emergency_contact_relationship" text,
    "street_address" text,
    "city" text,
    "state_province" text,
    "postal_code" text,
    "country" text default 'South Africa'::text,
    "employee_id" text,
    "department" text,
    "position_title" text,
    "employment_start_date" date,
    "employment_status" text default 'full_time'::text,
    "salary_amount" numeric(10,2),
    "salary_currency" text default 'ZAR'::text,
    "highest_qualification" text,
    "institution_name" text,
    "qualification_year" integer,
    "certifications" text[],
    "teaching_experience_years" integer default 0,
    "subjects_taught" text[],
    "age_groups_taught" text[],
    "biography" text,
    "languages_spoken" text[] default ARRAY['English'::text],
    "profile_picture_url" text,
    "notes" text,
    "documents" jsonb default '{}'::jsonb,
    "availability" jsonb default '{}'::jsonb,
    "password_reset_required" boolean default false,
    "subscription_tier" text default 'free'::text,
    "subscription_status" text default 'active'::text,
    "subscription_start_date" timestamp with time zone,
    "subscription_plan_id" text,
    "avatar_url" text,
    "first_name" text,
    "last_name" text,
    "capabilities" jsonb default '[]'::jsonb,
    "organization_id" uuid,
    "home_latitude" double precision,
    "home_longitude" double precision,
    "last_login_at" timestamp with time zone
      );


alter table "public"."users" enable row level security;


  create table "public"."voice_notes" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by" uuid,
    "storage_path" text not null,
    "original_filename" text,
    "file_size" integer,
    "duration" integer,
    "mime_type" text default 'audio/m4a'::text,
    "transcript" text,
    "language" text default 'en'::text,
    "confidence" numeric(3,2),
    "metadata" jsonb default '{}'::jsonb,
    "language_code" text default 'en'::text
      );


alter table "public"."voice_notes" enable row level security;


  create table "public"."voice_preferences" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "user_id" uuid not null,
    "role" text not null,
    "language_code" text not null,
    "provider_preference" jsonb not null default '{"stt": ["azure", "google", "whisper", "device"], "tts": ["azure", "google", "device"]}'::jsonb,
    "tts_voice_id" text,
    "tts_rate" integer default 0,
    "tts_pitch" integer default 0,
    "tts_style" text,
    "last_good_tts_provider" text,
    "last_good_stt_provider" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."voice_preferences" enable row level security;


  create table "public"."voice_usage_logs" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid,
    "user_id" uuid,
    "service" text not null,
    "provider" text not null,
    "language_code" text not null,
    "units" numeric not null,
    "cost_estimate_usd" numeric,
    "latency_ms" integer,
    "success" boolean default true,
    "metadata" jsonb,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."voice_usage_logs" enable row level security;


  create table "public"."voice_usage_quotas" (
    "id" uuid not null default gen_random_uuid(),
    "subscription_tier" text not null,
    "stt_daily_minutes" integer not null default 10,
    "tts_daily_characters" integer not null default 5000,
    "stt_monthly_minutes" integer not null default 100,
    "tts_monthly_characters" integer not null default 50000,
    "stt_requests_per_minute" integer not null default 10,
    "tts_requests_per_minute" integer not null default 20,
    "daily_cost_cap_usd" numeric default 1.00,
    "monthly_cost_cap_usd" numeric default 10.00,
    "can_use_premium_voices" boolean default false,
    "can_use_whisper_stt" boolean default true,
    "can_use_azure_stt" boolean default false,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."voice_usage_quotas" enable row level security;


  create table "public"."webhook_logs" (
    "id" uuid not null default gen_random_uuid(),
    "source" text not null,
    "event_type" text not null,
    "payload" jsonb,
    "processed_at" timestamp with time zone default now(),
    "status" text not null,
    "error_message" text,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."webhook_logs" enable row level security;


  create table "public"."whatsapp_contacts" (
    "id" uuid not null default gen_random_uuid(),
    "preschool_id" uuid not null,
    "user_id" uuid not null,
    "phone_e164" text not null,
    "wa_user_id" text,
    "consent_status" public.whatsapp_consent_status not null default 'pending'::public.whatsapp_consent_status,
    "last_opt_in_at" timestamp with time zone,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."whatsapp_contacts" enable row level security;


  create table "public"."wing_regional_coordinators" (
    "id" uuid not null default gen_random_uuid(),
    "wing_id" uuid not null,
    "region_id" uuid not null,
    "coordinator_id" uuid,
    "monthly_float" numeric(10,2) default 10000,
    "current_balance" numeric(10,2) default 0,
    "spending_limit" numeric(10,2) default 1000,
    "is_active" boolean default true,
    "appointed_date" date default CURRENT_DATE,
    "appointed_by" uuid,
    "contact_email" text,
    "contact_phone" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."wing_regional_coordinators" enable row level security;

alter table "public"."activity_progress" drop column "lesson_id";

alter table "public"."activity_progress" drop column "max_attempts";

alter table "public"."activity_progress" drop column "preschool_id";

alter table "public"."activity_progress" drop column "progress_data";

alter table "public"."activity_progress" drop column "started_at";

alter table "public"."activity_progress" drop column "status";

alter table "public"."activity_progress" add column "time_spent_minutes" integer;

alter table "public"."activity_progress" alter column "activity_id" set not null;

alter table "public"."activity_progress" alter column "score" set data type integer using "score"::integer;

alter table "public"."aftercare_registrations" add column "child_allergies" text;

alter table "public"."aftercare_registrations" add column "child_grade" text not null;

alter table "public"."aftercare_registrations" add column "child_medical_conditions" text;

alter table "public"."aftercare_registrations" add column "emergency_contact_name" text not null;

alter table "public"."aftercare_registrations" add column "emergency_contact_phone" text not null;

alter table "public"."aftercare_registrations" add column "emergency_contact_relation" text not null;

alter table "public"."aftercare_registrations" add column "how_did_you_hear" text;

alter table "public"."aftercare_registrations" add column "notes" text;

alter table "public"."aftercare_registrations" add column "parent_first_name" text not null;

alter table "public"."aftercare_registrations" add column "parent_id_number" text;

alter table "public"."aftercare_registrations" add column "parent_last_name" text not null;

alter table "public"."aftercare_registrations" add column "parent_phone" text not null;

alter table "public"."aftercare_registrations" add column "payment_date" timestamp with time zone;

alter table "public"."aftercare_registrations" add column "payment_reference" text;

alter table "public"."aftercare_registrations" add column "promotion_code" text;

alter table "public"."aftercare_registrations" add column "proof_of_payment_url" text;

alter table "public"."aftercare_registrations" add column "registration_fee" numeric(10,2) default 200.00;

alter table "public"."aftercare_registrations" add column "registration_fee_original" numeric(10,2) default 400.00;

alter table "public"."aftercare_registrations" add column "student_id" uuid;

alter table "public"."aftercare_registrations" add column "updated_at" timestamp with time zone default now();

alter table "public"."aftercare_registrations" alter column "child_first_name" set not null;

alter table "public"."aftercare_registrations" alter column "child_last_name" set not null;

alter table "public"."aftercare_registrations" alter column "created_at" set default now();

alter table "public"."aftercare_registrations" alter column "parent_email" set not null;

alter table "public"."aftercare_registrations" alter column "preschool_id" set not null;

alter table "public"."aftercare_registrations" alter column "status" set default 'pending_payment'::text;

alter table "public"."candidate_profiles" add column "created_at" timestamp with time zone not null default now();

alter table "public"."candidate_profiles" add column "email" text not null;

alter table "public"."candidate_profiles" add column "experience_years" integer default 0;

alter table "public"."candidate_profiles" add column "first_name" text not null;

alter table "public"."candidate_profiles" add column "last_name" text not null;

alter table "public"."candidate_profiles" add column "location" text;

alter table "public"."candidate_profiles" add column "phone" text;

alter table "public"."candidate_profiles" add column "preferred_location_lat" numeric(10,8);

alter table "public"."candidate_profiles" add column "preferred_location_lng" numeric(11,8);

alter table "public"."candidate_profiles" add column "qualifications" jsonb default '[]'::jsonb;

alter table "public"."candidate_profiles" add column "skills" text[] default ARRAY[]::text[];

alter table "public"."candidate_profiles" add column "willing_to_commute_km" integer default 30;

alter table "public"."child_registration_requests" drop column "payment_reference";

alter table "public"."child_registration_requests" add column "campaign_applied" text;

alter table "public"."child_registration_requests" add column "child_birth_date" date not null;

alter table "public"."child_registration_requests" add column "child_first_name" text not null;

alter table "public"."child_registration_requests" add column "child_gender" text;

alter table "public"."child_registration_requests" add column "child_last_name" text not null;

alter table "public"."child_registration_requests" add column "created_at" timestamp with time zone default now();

alter table "public"."child_registration_requests" add column "dietary_requirements" text;

alter table "public"."child_registration_requests" add column "discount_amount" numeric(10,2) default 0;

alter table "public"."child_registration_requests" add column "emergency_contact_name" text;

alter table "public"."child_registration_requests" add column "emergency_contact_phone" text;

alter table "public"."child_registration_requests" add column "final_amount" numeric(10,2);

alter table "public"."child_registration_requests" add column "medical_info" text;

alter table "public"."child_registration_requests" add column "notes" text;

alter table "public"."child_registration_requests" add column "rejection_reason" text;

alter table "public"."child_registration_requests" add column "requested_at" timestamp with time zone default now();

alter table "public"."child_registration_requests" add column "reviewed_at" timestamp with time zone;

alter table "public"."child_registration_requests" add column "reviewed_by" uuid;

alter table "public"."child_registration_requests" add column "special_needs" text;

alter table "public"."child_registration_requests" add column "updated_at" timestamp with time zone default now();

alter table "public"."child_registration_requests" alter column "parent_id" set not null;

alter table "public"."child_registration_requests" alter column "preschool_id" set not null;

alter table "public"."child_registration_requests" enable row level security;

alter table "public"."classes" add column "academic_year" character varying(10) default '2026'::character varying;

alter table "public"."classes" add column "active" boolean default true;

alter table "public"."classes" add column "age_group" text;

alter table "public"."classes" add column "age_group_id" uuid;

alter table "public"."classes" add column "age_max" integer;

alter table "public"."classes" add column "age_min" integer;

alter table "public"."classes" add column "age_range" character varying(50);

alter table "public"."classes" add column "class_type" character varying(50);

alter table "public"."classes" add column "created_at" timestamp with time zone default now();

alter table "public"."classes" add column "current_students" integer not null default 0;

alter table "public"."classes" add column "duration" character varying(50);

alter table "public"."classes" add column "grade" text;

alter table "public"."classes" add column "grade_level" text;

alter table "public"."classes" add column "max_capacity" integer not null default 20;

alter table "public"."classes" add column "max_students" integer default 20;

alter table "public"."classes" add column "name" text not null;

alter table "public"."classes" add column "organization_id" uuid;

alter table "public"."classes" add column "room" text;

alter table "public"."classes" add column "room_number" text;

alter table "public"."classes" add column "schedule" text;

alter table "public"."classes" add column "student_count" integer default 0;

alter table "public"."classes" add column "teacher_name" text;

alter table "public"."classes" add column "updated_at" timestamp with time zone default now();

alter table "public"."classes" alter column "id" set default extensions.uuid_generate_v4();

alter table "public"."classes" alter column "preschool_id" set not null;

alter table "public"."classes" enable row level security;

alter table "public"."fee_structures" add column "created_at" timestamp with time zone default now();

alter table "public"."fee_structures" add column "effective_to" date;

alter table "public"."fee_structures" add column "grade_levels" text[];

alter table "public"."fee_structures" add column "late_fee_amount" numeric(10,2) default 0.00;

alter table "public"."fee_structures" add column "late_fee_days" integer default 7;

alter table "public"."fee_structures" add column "updated_at" timestamp with time zone default now();

alter table "public"."fee_structures" alter column "amount" set not null;

alter table "public"."fee_structures" alter column "created_by" set not null;

alter table "public"."fee_structures" alter column "due_day" set default 1;

alter table "public"."fee_structures" alter column "effective_from" set default CURRENT_DATE;

alter table "public"."fee_structures" alter column "fee_type" set not null;

alter table "public"."fee_structures" alter column "frequency" set not null;

alter table "public"."fee_structures" alter column "is_active" set default true;

alter table "public"."fee_structures" alter column "mandatory" set default true;

alter table "public"."fee_structures" alter column "name" set not null;

alter table "public"."fee_structures" alter column "preschool_id" set not null;

alter table "public"."fee_structures" enable row level security;

alter table "public"."learner_documents" drop column "description";

alter table "public"."learner_documents" drop column "expiry_date";

alter table "public"."learner_documents" drop column "is_active";

alter table "public"."learner_documents" drop column "is_expired";

alter table "public"."learner_documents" drop column "is_public";

alter table "public"."learner_documents" drop column "metadata";

alter table "public"."learner_documents" drop column "verification_notes";

alter table "public"."learner_documents" drop column "verified_at";

alter table "public"."learner_documents" drop column "verified_by";

alter table "public"."lesson_activities" drop column "preschool_id";

alter table "public"."lesson_activities" add column "activity_type" text not null;

alter table "public"."lesson_activities" add column "content" jsonb default '{}'::jsonb;

alter table "public"."lesson_activities" add column "created_at" timestamp with time zone default now();

alter table "public"."lesson_activities" add column "description" text;

alter table "public"."lesson_activities" add column "duration_minutes" integer default 15;

alter table "public"."lesson_activities" add column "is_required" boolean default true;

alter table "public"."lesson_activities" add column "order_index" integer not null default 0;

alter table "public"."lesson_activities" add column "points_possible" integer default 0;

alter table "public"."lesson_activities" add column "title" text not null;

alter table "public"."lesson_activities" add column "updated_at" timestamp with time zone default now();

alter table "public"."lesson_activities" alter column "lesson_id" set not null;

alter table "public"."lesson_activities" enable row level security;

alter table "public"."lesson_assignments" add column "interactive_activity_id" uuid;

alter table "public"."lesson_assignments" add column "lesson_type" text default 'standard'::text;

alter table "public"."lesson_assignments" add column "stem_category" text default 'none'::text;

alter table "public"."lesson_progress" drop column "assessment_scores";

alter table "public"."lesson_progress" drop column "bookmarked_at";

alter table "public"."lesson_progress" drop column "completed_steps";

alter table "public"."lesson_progress" drop column "current_step_id";

alter table "public"."lesson_progress" drop column "time_spent";

alter table "public"."lesson_progress" add column "completed_sections" jsonb default '[]'::jsonb;

alter table "public"."lesson_progress" add column "current_section" integer default 0;

alter table "public"."lesson_progress" add column "quiz_scores" jsonb default '{}'::jsonb;

alter table "public"."lesson_progress" add column "time_spent_seconds" integer default 0;

alter table "public"."lessons" add column "age_group" text not null default '3-6'::text;

alter table "public"."lessons" add column "age_group_max" integer;

alter table "public"."lessons" add column "age_group_min" integer;

alter table "public"."lessons" add column "category_id" uuid;

alter table "public"."lessons" add column "completion_count" integer default 0;

alter table "public"."lessons" add column "content" text;

alter table "public"."lessons" add column "created_at" timestamp with time zone default now();

alter table "public"."lessons" add column "description" text;

alter table "public"."lessons" add column "difficulty_level" text;

alter table "public"."lessons" add column "duration_minutes" integer;

alter table "public"."lessons" add column "is_ai_generated" boolean default false;

alter table "public"."lessons" add column "is_featured" boolean not null default false;

alter table "public"."lessons" add column "is_premium" boolean not null default false;

alter table "public"."lessons" add column "is_public" boolean default false;

alter table "public"."lessons" add column "language" text default 'en'::text;

alter table "public"."lessons" add column "materials_needed" text;

alter table "public"."lessons" add column "objectives" text[];

alter table "public"."lessons" add column "rating" numeric(2,1) default 0.0;

alter table "public"."lessons" add column "short_description" text;

alter table "public"."lessons" add column "status" text not null default 'draft'::text;

alter table "public"."lessons" add column "subject" text not null default 'general'::text;

alter table "public"."lessons" add column "teacher_id" uuid;

alter table "public"."lessons" add column "title" text not null;

alter table "public"."lessons" add column "updated_at" timestamp with time zone default now();

alter table "public"."lessons" alter column "id" set default extensions.uuid_generate_v4();

alter table "public"."lessons" enable row level security;

alter table "public"."notifications" drop column "read_at";

alter table "public"."notifications" add column "expires_at" timestamp with time zone;

alter table "public"."notifications" add column "preschool_id" uuid;

alter table "public"."notifications" alter column "id" set default extensions.uuid_generate_v4();

alter table "public"."notifications" alter column "is_read" drop not null;

alter table "public"."notifications" alter column "type" drop not null;

alter table "public"."notifications" alter column "user_id" drop not null;

alter table "public"."organization_document_folders" add column "color" text default '#3B82F6'::text;

alter table "public"."organization_document_folders" add column "created_at" timestamp with time zone not null default now();

alter table "public"."organization_document_folders" add column "created_by" uuid not null;

alter table "public"."organization_document_folders" add column "default_access_level" text not null default 'admin_only'::text;

alter table "public"."organization_document_folders" add column "description" text;

alter table "public"."organization_document_folders" add column "folder_path" text not null default '/'::text;

alter table "public"."organization_document_folders" add column "icon" text default 'folder'::text;

alter table "public"."organization_document_folders" add column "name" text not null;

alter table "public"."organization_document_folders" add column "parent_folder_id" uuid;

alter table "public"."organization_document_folders" add column "sort_order" integer default 0;

alter table "public"."organization_document_folders" add column "updated_at" timestamp with time zone not null default now();

alter table "public"."organization_document_folders" alter column "organization_id" set not null;

alter table "public"."organization_document_folders" enable row level security;

alter table "public"."organization_documents" add column "approved_at" timestamp with time zone;

alter table "public"."organization_documents" add column "approved_by" uuid;

alter table "public"."organization_documents" add column "created_at" timestamp with time zone not null default now();

alter table "public"."organization_documents" add column "deleted_at" timestamp with time zone;

alter table "public"."organization_documents" add column "deleted_by" uuid;

alter table "public"."organization_documents" add column "description" text;

alter table "public"."organization_documents" add column "document_type" text not null default 'general'::text;

alter table "public"."organization_documents" add column "encryption_algorithm" text default 'AES-256-GCM'::text;

alter table "public"."organization_documents" add column "encryption_key_id" text;

alter table "public"."organization_documents" add column "expires_at" timestamp with time zone;

alter table "public"."organization_documents" add column "file_name" text not null;

alter table "public"."organization_documents" add column "file_size" integer;

alter table "public"."organization_documents" add column "file_url" text not null;

alter table "public"."organization_documents" add column "folder_id" uuid;

alter table "public"."organization_documents" add column "is_deleted" boolean not null default false;

alter table "public"."organization_documents" add column "is_encrypted" boolean not null default false;

alter table "public"."organization_documents" add column "metadata" jsonb default '{}'::jsonb;

alter table "public"."organization_documents" add column "mime_type" text not null;

alter table "public"."organization_documents" add column "name" text not null;

alter table "public"."organization_documents" add column "previous_version_id" uuid;

alter table "public"."organization_documents" add column "requires_approval" boolean not null default false;

alter table "public"."organization_documents" add column "storage_path" text not null;

alter table "public"."organization_documents" add column "tags" text[] default '{}'::text[];

alter table "public"."organization_documents" add column "updated_at" timestamp with time zone not null default now();

alter table "public"."organization_documents" add column "uploaded_by" uuid not null;

alter table "public"."organization_documents" add column "version" integer not null default 1;

alter table "public"."organization_documents" alter column "access_level" set default 'admin_only'::text;

alter table "public"."organization_documents" alter column "access_level" set not null;

alter table "public"."organization_documents" alter column "organization_id" set not null;

alter table "public"."organization_members" add column "age_verified" boolean default false;

alter table "public"."organization_members" add column "age_verified_at" timestamp with time zone;

alter table "public"."organization_members" add column "appointed_at" timestamp with time zone;

alter table "public"."organization_members" add column "appointed_by" uuid;

alter table "public"."organization_members" add column "birth_year" integer;

alter table "public"."organization_members" add column "city" character varying(100);

alter table "public"."organization_members" add column "created_at" timestamp with time zone not null default now();

alter table "public"."organization_members" add column "created_by" uuid;

alter table "public"."organization_members" add column "date_of_birth" date;

alter table "public"."organization_members" add column "email" character varying(255);

alter table "public"."organization_members" add column "emergency_contact_name" character varying(200);

alter table "public"."organization_members" add column "emergency_contact_phone" character varying(20);

alter table "public"."organization_members" add column "expiry_date" date;

alter table "public"."organization_members" add column "first_name" character varying(100);

alter table "public"."organization_members" add column "id_number" character varying(20);

alter table "public"."organization_members" add column "invite_code_used" character varying(20);

alter table "public"."organization_members" add column "invited_by" uuid;

alter table "public"."organization_members" add column "join_date" date default CURRENT_DATE;

alter table "public"."organization_members" add column "joined_via" character varying(50);

alter table "public"."organization_members" add column "last_name" character varying(100);

alter table "public"."organization_members" add column "member_number" character varying(50);

alter table "public"."organization_members" add column "membership_status" character varying(50) default 'pending'::character varying;

alter table "public"."organization_members" add column "membership_tier" character varying(50) default 'standard'::character varying;

alter table "public"."organization_members" add column "notes" text;

alter table "public"."organization_members" add column "phone" character varying(20);

alter table "public"."organization_members" add column "photo_url" text;

alter table "public"."organization_members" add column "physical_address" text;

alter table "public"."organization_members" add column "postal_code" character varying(20);

alter table "public"."organization_members" add column "province" character varying(100);

alter table "public"."organization_members" add column "qr_code_data" text;

alter table "public"."organization_members" add column "updated_at" timestamp with time zone not null default now();

alter table "public"."organization_members" add column "wing" text default 'main'::text;

alter table "public"."organization_members" alter column "member_type" set default 'member'::character varying;

alter table "public"."organization_members" alter column "member_type" set data type character varying(50) using "member_type"::character varying(50);

alter table "public"."organization_members" alter column "organization_id" set not null;

alter table "public"."organization_members" alter column "seat_status" set default 'inactive'::text;

alter table "public"."organization_members" alter column "seat_status" set not null;

alter table "public"."organization_members" alter column "user_id" set not null;

alter table "public"."organization_members" enable row level security;

alter table "public"."organization_regions" add column "code" character varying(20) not null;

alter table "public"."organization_regions" add column "contact_email" character varying(255);

alter table "public"."organization_regions" add column "contact_phone" character varying(20);

alter table "public"."organization_regions" add column "created_at" timestamp with time zone default now();

alter table "public"."organization_regions" add column "description" text;

alter table "public"."organization_regions" add column "is_active" boolean default true;

alter table "public"."organization_regions" add column "manager_id" uuid;

alter table "public"."organization_regions" add column "name" character varying(100) not null;

alter table "public"."organization_regions" add column "province_code" character varying(10);

alter table "public"."organization_regions" add column "updated_at" timestamp with time zone default now();

alter table "public"."organization_regions" alter column "id" set default gen_random_uuid();

alter table "public"."organization_regions" alter column "organization_id" set not null;

alter table "public"."organization_regions" enable row level security;

alter table "public"."organizations" add column "academic_year" character varying(10) default '2025'::character varying;

alter table "public"."organizations" add column "accepting_registrations" boolean default true;

alter table "public"."organizations" add column "address" text;

alter table "public"."organizations" add column "address_line1" character varying(255);

alter table "public"."organizations" add column "address_line2" character varying(255);

alter table "public"."organizations" add column "ai_preferences" jsonb default '{}'::jsonb;

alter table "public"."organizations" add column "billing_email" character varying(255);

alter table "public"."organizations" add column "brand_colors" jsonb default '{}'::jsonb;

alter table "public"."organizations" add column "branding" jsonb default '{}'::jsonb;

alter table "public"."organizations" add column "city" character varying(100);

alter table "public"."organizations" add column "config" jsonb default '{}'::jsonb;

alter table "public"."organizations" add column "contact_email" character varying(255);

alter table "public"."organizations" add column "contact_phone" character varying(50);

alter table "public"."organizations" add column "country" text;

alter table "public"."organizations" add column "created_at" timestamp with time zone not null default now();

alter table "public"."organizations" add column "created_by" uuid;

alter table "public"."organizations" add column "dashboard_settings" jsonb default '{}'::jsonb;

alter table "public"."organizations" add column "description" text;

alter table "public"."organizations" add column "email" text;

alter table "public"."organizations" add column "enrollment_open" boolean default true;

alter table "public"."organizations" add column "features" jsonb default '{"hasGrading": true, "hasCalendar": true, "hasPayments": true, "hasDocuments": true, "hasMessaging": true, "hasReporting": true, "hasAttendance": true, "hasScheduling": true}'::jsonb;

alter table "public"."organizations" add column "is_active" boolean not null default true;

alter table "public"."organizations" add column "is_public" boolean default false;

alter table "public"."organizations" add column "is_verified" boolean default false;

alter table "public"."organizations" add column "locale" character varying(10) default 'en-ZA'::character varying;

alter table "public"."organizations" add column "logo_url" text;

alter table "public"."organizations" add column "max_centres" integer default 1;

alter table "public"."organizations" add column "max_students" integer default 500;

alter table "public"."organizations" add column "metadata" jsonb default '{}'::jsonb;

alter table "public"."organizations" add column "name" text not null;

alter table "public"."organizations" add column "organization_type" character varying(50) default 'org'::character varying;

alter table "public"."organizations" add column "phone" text;

alter table "public"."organizations" add column "plan_tier" text not null default 'free'::text;

alter table "public"."organizations" add column "postal_code" character varying(20);

alter table "public"."organizations" add column "preschool_id" uuid;

alter table "public"."organizations" add column "primary_color" character varying(7);

alter table "public"."organizations" add column "primary_contact_email" character varying(255);

alter table "public"."organizations" add column "primary_contact_name" character varying(255);

alter table "public"."organizations" add column "primary_contact_phone" character varying(50);

alter table "public"."organizations" add column "principal_id" uuid;

alter table "public"."organizations" add column "province" character varying(100);

alter table "public"."organizations" add column "school_code" character varying(20);

alter table "public"."organizations" add column "settings" jsonb default '{}'::jsonb;

alter table "public"."organizations" add column "slug" character varying(100);

alter table "public"."organizations" add column "social_media" jsonb default '{}'::jsonb;

alter table "public"."organizations" add column "state" character varying(100);

alter table "public"."organizations" add column "status" text;

alter table "public"."organizations" add column "stripe_customer_id" character varying(255);

alter table "public"."organizations" add column "subscription_end_date" timestamp with time zone;

alter table "public"."organizations" add column "subscription_ends_at" timestamp with time zone;

alter table "public"."organizations" add column "subscription_start_date" timestamp with time zone;

alter table "public"."organizations" add column "subscription_status" character varying(50) default 'active'::character varying;

alter table "public"."organizations" add column "subscription_tier" text;

alter table "public"."organizations" add column "timezone" character varying(100) default 'Africa/Johannesburg'::character varying;

alter table "public"."organizations" add column "trial_ends_at" timestamp with time zone;

alter table "public"."organizations" add column "type" text;

alter table "public"."organizations" add column "updated_at" timestamp with time zone not null default now();

alter table "public"."organizations" add column "website" character varying(255);

alter table "public"."organizations" alter column "id" set default gen_random_uuid();

alter table "public"."organizations" enable row level security;

alter table "public"."pop_uploads" add column "achievement_level" character varying(50);

alter table "public"."pop_uploads" add column "created_at" timestamp with time zone default now();

alter table "public"."pop_uploads" add column "description" text;

alter table "public"."pop_uploads" add column "file_name" character varying(255) not null;

alter table "public"."pop_uploads" add column "file_path" text not null;

alter table "public"."pop_uploads" add column "file_size" integer not null;

alter table "public"."pop_uploads" add column "file_type" character varying(100) not null;

alter table "public"."pop_uploads" add column "learning_area" text;

alter table "public"."pop_uploads" add column "payment_method" character varying(50);

alter table "public"."pop_uploads" add column "payment_reference" character varying(100);

alter table "public"."pop_uploads" add column "preschool_id" uuid not null;

alter table "public"."pop_uploads" add column "review_notes" text;

alter table "public"."pop_uploads" add column "reviewed_at" timestamp with time zone;

alter table "public"."pop_uploads" add column "reviewed_by" uuid;

alter table "public"."pop_uploads" add column "subject" character varying(100);

alter table "public"."pop_uploads" add column "title" character varying(255) not null;

alter table "public"."pop_uploads" add column "updated_at" timestamp with time zone default now();

alter table "public"."pop_uploads" add column "upload_type" character varying(20) not null;

alter table "public"."pop_uploads" add column "uploaded_by" uuid not null;

alter table "public"."pop_uploads" alter column "payment_amount" set data type numeric(10,2) using "payment_amount"::numeric(10,2);

alter table "public"."pop_uploads" alter column "status" set default 'pending'::character varying;

alter table "public"."pop_uploads" alter column "status" set data type character varying(20) using "status"::character varying(20);

alter table "public"."pop_uploads" alter column "student_id" set not null;

alter table "public"."pop_uploads" enable row level security;

alter table "public"."preschools" add column "accepting_registrations" boolean default true;

alter table "public"."preschools" add column "address" text;

alter table "public"."preschools" add column "approved" boolean default false;

alter table "public"."preschools" add column "approved_at" timestamp with time zone;

alter table "public"."preschools" add column "approved_by" uuid;

alter table "public"."preschools" add column "billing_email" character varying(255);

alter table "public"."preschools" add column "city" character varying(100);

alter table "public"."preschools" add column "contact_email" text;

alter table "public"."preschools" add column "contact_phone" text;

alter table "public"."preschools" add column "country" character varying(100) default 'South Africa'::character varying;

alter table "public"."preschools" add column "created_at" timestamp with time zone default now();

alter table "public"."preschools" add column "description" text;

alter table "public"."preschools" add column "domain" character varying(100);

alter table "public"."preschools" add column "email" text;

alter table "public"."preschools" add column "grade_levels" text[] default ARRAY[]::text[];

alter table "public"."preschools" add column "is_active" boolean default true;

alter table "public"."preschools" add column "is_public" boolean default false;

alter table "public"."preschools" add column "is_verified" boolean default false;

alter table "public"."preschools" add column "location_latitude" double precision;

alter table "public"."preschools" add column "location_longitude" double precision;

alter table "public"."preschools" add column "logo_url" text;

alter table "public"."preschools" add column "max_students" integer default 50;

alter table "public"."preschools" add column "max_teachers" integer default 10;

alter table "public"."preschools" add column "metadata" jsonb default '{}'::jsonb;

alter table "public"."preschools" add column "name" text not null;

alter table "public"."preschools" add column "onboarding_completed_at" timestamp with time zone;

alter table "public"."preschools" add column "onboarding_flow" character varying(50);

alter table "public"."preschools" add column "onboarding_status" character varying(20) default 'requested'::character varying;

alter table "public"."preschools" add column "payfast_token" text;

alter table "public"."preschools" add column "phone" text;

alter table "public"."preschools" add column "physical_address" text;

alter table "public"."preschools" add column "postal_code" character varying(20);

alter table "public"."preschools" add column "principal_id" uuid;

alter table "public"."preschools" add column "province" character varying(100);

alter table "public"."preschools" add column "registration_notes" text;

alter table "public"."preschools" add column "registration_number" text;

alter table "public"."preschools" add column "school_type" text default 'preschool'::text;

alter table "public"."preschools" add column "setup_completed" boolean default false;

alter table "public"."preschools" add column "subscription_end_date" date;

alter table "public"."preschools" add column "subscription_plan" character varying(20) default 'trial'::character varying;

alter table "public"."preschools" add column "subscription_plan_id" uuid;

alter table "public"."preschools" add column "subscription_start_date" date;

alter table "public"."preschools" add column "subscription_status" character varying(20) default 'pending'::character varying;

alter table "public"."preschools" add column "subscription_tier" text default 'basic'::text;

alter table "public"."preschools" add column "tenant_slug" character varying(50);

alter table "public"."preschools" add column "timezone" character varying(50) default 'UTC'::character varying;

alter table "public"."preschools" add column "updated_at" timestamp with time zone default now();

alter table "public"."preschools" add column "verification_status" character varying(20) default 'pending'::character varying;

alter table "public"."preschools" add column "verified" boolean default false;

alter table "public"."preschools" add column "website_url" text;

alter table "public"."preschools" alter column "id" set default extensions.uuid_generate_v4();

alter table "public"."preschools" alter column "settings" set default '{}'::jsonb;

alter table "public"."preschools" enable row level security;

alter table "public"."profiles" add column "address" text;

alter table "public"."profiles" add column "age_group" public.age_group_type;

alter table "public"."profiles" add column "assigned_teacher_id" uuid;

alter table "public"."profiles" add column "billing_email" character varying(255);

alter table "public"."profiles" add column "capabilities" jsonb default '{}'::jsonb;

alter table "public"."profiles" add column "date_of_birth" date;

alter table "public"."profiles" add column "expo_push_token" text;

alter table "public"."profiles" add column "guardian_profile_id" uuid;

alter table "public"."profiles" add column "hire_date" date;

alter table "public"."profiles" add column "invoice_notification_preferences" jsonb not null default '{"digest": {"overdue_daily": false, "weekly_summary": false}, "events": {"new_invoice": {"push": false, "email": true}, "invoice_sent": {"push": false, "email": true}, "invoice_viewed": {"push": false, "email": false}, "overdue_reminder": {"push": false, "email": true, "cadence_days": [1, 3, 7]}, "payment_confirmed": {"push": false, "email": true}}, "channels": {"sms": false, "push": false, "email": true}, "pdf_include_signature": true, "email_include_signature": true}'::jsonb;

alter table "public"."profiles" add column "is_standalone" boolean generated always as ((preschool_id IS NULL)) stored;

alter table "public"."profiles" add column "is_trial" boolean default false;

alter table "public"."profiles" add column "notification_preferences" jsonb default '{"invoices": {"sms": false, "email": true}}'::jsonb;

alter table "public"."profiles" add column "phone_secondary" character varying(20);

alter table "public"."profiles" add column "preferred_language" text default 'en'::text;

alter table "public"."profiles" add column "push_token_updated_at" timestamp with time zone;

alter table "public"."profiles" add column "ringtone_preferences" jsonb default '{"updatedAt": "2024-01-01T00:00:00.000Z", "incomingVolume": 1.0, "outgoingVolume": 0.8, "incomingRingtone": "default_old", "outgoingRingback": "default", "vibrateOnIncoming": true, "vibrateOnOutgoing": false}'::jsonb;

alter table "public"."profiles" add column "seat_status" text default 'inactive'::text;

alter table "public"."profiles" add column "signature_public_id" text;

alter table "public"."profiles" add column "signature_updated_at" timestamp with time zone default now();

alter table "public"."profiles" add column "signature_url" text;

alter table "public"."profiles" add column "subject_specialization" text[] default ARRAY['General Education'::text];

alter table "public"."profiles" add column "subscription_tier" public.tier_name_aligned default 'free'::public.tier_name_aligned;

alter table "public"."profiles" add column "tenant_slug" text;

alter table "public"."profiles" add column "trial_end_date" timestamp with time zone;

alter table "public"."profiles" add column "trial_ends_at" timestamp with time zone;

alter table "public"."profiles" add column "trial_granted_at" timestamp with time zone;

alter table "public"."profiles" add column "trial_plan_tier" text default 'premium'::text;

alter table "public"."profiles" add column "trial_started_at" timestamp with time zone;

alter table "public"."profiles" add column "usage_type" text;

alter table "public"."profiles" alter column "created_at" set not null;

alter table "public"."profiles" alter column "id" drop default;

alter table "public"."profiles" alter column "is_active" set not null;

alter table "public"."profiles" alter column "role" set default 'parent'::text;

alter table "public"."profiles" alter column "role" set not null;

alter table "public"."profiles" alter column "updated_at" set default now();

alter table "public"."profiles" alter column "updated_at" set not null;

alter table "public"."profiles" enable row level security;

alter table "public"."student_activity_feed" add column "activity_at" timestamp with time zone not null default now();

alter table "public"."student_activity_feed" add column "activity_type" text not null;

alter table "public"."student_activity_feed" add column "class_id" uuid;

alter table "public"."student_activity_feed" add column "created_at" timestamp with time zone default now();

alter table "public"."student_activity_feed" add column "description" text;

alter table "public"."student_activity_feed" add column "duration_minutes" integer;

alter table "public"."student_activity_feed" add column "is_published" boolean default true;

alter table "public"."student_activity_feed" add column "media_urls" jsonb default '[]'::jsonb;

alter table "public"."student_activity_feed" add column "preschool_id" uuid not null;

alter table "public"."student_activity_feed" add column "reactions" jsonb default '[]'::jsonb;

alter table "public"."student_activity_feed" add column "teacher_id" uuid not null;

alter table "public"."student_activity_feed" add column "title" text not null;

alter table "public"."student_activity_feed" add column "updated_at" timestamp with time zone default now();

alter table "public"."student_activity_feed" add column "visibility" text default 'parent_only'::text;

alter table "public"."student_activity_feed" enable row level security;

alter table "public"."student_fees" add column "amount_paid" numeric(10,2) default 0.00;

alter table "public"."student_fees" add column "created_at" timestamp with time zone default now();

alter table "public"."student_fees" add column "discount_amount" numeric(10,2) default 0.00;

alter table "public"."student_fees" add column "paid_date" date;

alter table "public"."student_fees" add column "updated_at" timestamp with time zone default now();

alter table "public"."student_fees" alter column "amount_outstanding" set default 0.00;

alter table "public"."student_fees" alter column "amount_outstanding" set not null;

alter table "public"."student_fees" alter column "fee_structure_id" set not null;

alter table "public"."student_fees" alter column "final_amount" set not null;

alter table "public"."student_fees" alter column "status" set default 'pending'::text;

alter table "public"."student_fees" alter column "status" set not null;

alter table "public"."student_fees" alter column "student_id" set not null;

alter table "public"."student_fees" enable row level security;

alter table "public"."students" add column "academic_year" character varying(10) default '2025'::character varying;

alter table "public"."students" add column "age_group_id" uuid;

alter table "public"."students" add column "age_group_ref" uuid;

alter table "public"."students" add column "allergies" text;

alter table "public"."students" add column "avatar_url" text;

alter table "public"."students" add column "created_at" timestamp with time zone default now();

alter table "public"."students" add column "date_of_birth" date;

alter table "public"."students" add column "emergency_contact_name" text;

alter table "public"."students" add column "emergency_contact_phone" text;

alter table "public"."students" add column "emergency_contact_relation" text;

alter table "public"."students" add column "enrollment_date" date;

alter table "public"."students" add column "gender" text;

alter table "public"."students" add column "grade" text;

alter table "public"."students" add column "grade_level" text;

alter table "public"."students" add column "home_address" text;

alter table "public"."students" add column "home_phone" character varying(20);

alter table "public"."students" add column "id_number" character varying(50);

alter table "public"."students" add column "is_active" boolean default true;

alter table "public"."students" add column "medical_conditions" text;

alter table "public"."students" add column "medication" text;

alter table "public"."students" add column "notes" text;

alter table "public"."students" add column "organization_id" uuid;

alter table "public"."students" add column "payment_date" timestamp with time zone;

alter table "public"."students" add column "payment_verified" boolean default false;

alter table "public"."students" add column "registration_fee_amount" numeric(10,2);

alter table "public"."students" add column "registration_fee_paid" boolean default false;

alter table "public"."students" add column "status" text default 'active'::text;

alter table "public"."students" add column "student_id" character varying(50);

alter table "public"."students" add column "updated_at" timestamp with time zone default now();

alter table "public"."students" alter column "first_name" set not null;

alter table "public"."students" alter column "id" set default extensions.uuid_generate_v4();

alter table "public"."students" alter column "last_name" set not null;

alter table "public"."students" enable row level security;

alter table "public"."teacher_invites" add column "accepted_at" timestamp with time zone;

alter table "public"."teacher_invites" add column "accepted_by" uuid;

alter table "public"."teacher_invites" add column "created_at" timestamp with time zone not null default now();

alter table "public"."teacher_invites" add column "email" text not null;

alter table "public"."teacher_invites" add column "expires_at" timestamp with time zone not null default (now() + '14 days'::interval);

alter table "public"."teacher_invites" add column "invited_by" uuid not null;

alter table "public"."teacher_invites" add column "school_id" uuid not null;

alter table "public"."teacher_invites" add column "status" text not null default 'pending'::text;

alter table "public"."teacher_invites" add column "token" text not null;

alter table "public"."teacher_invites" enable row level security;

alter table "public"."uniform_requests" add column "shorts_quantity" integer default 1;

alter table "public"."uniform_requests" add column "tshirt_quantity" integer default 1;

alter table "public"."video_call_participants" drop column "role";

alter table "public"."video_call_participants" drop column "video_call_id";

alter table "public"."video_call_participants" add column "call_id" uuid not null;

alter table "public"."video_call_participants" add column "duration_minutes" integer;

alter table "public"."video_call_participants" add column "invitation_sent" boolean default false;

alter table "public"."video_call_participants" add column "invitation_sent_at" timestamp with time zone;

alter table "public"."video_call_participants" add column "status" text default 'invited'::text;

alter table "public"."video_call_participants" add column "student_id" uuid;

alter table "public"."video_calls" add column "actual_end" timestamp with time zone;

alter table "public"."video_calls" add column "actual_start" timestamp with time zone;

alter table "public"."video_calls" add column "description" text;

alter table "public"."video_calls" add column "max_participants" integer default 50;

alter table "public"."video_calls" add column "meeting_id" text;

alter table "public"."video_calls" add column "meeting_password" text;

alter table "public"."video_calls" add column "meeting_url" text;

alter table "public"."video_calls" add column "recording_enabled" boolean default false;

alter table "public"."video_calls" add column "recording_url" text;

alter table "public"."video_calls" add column "require_password" boolean default true;

alter table "public"."video_calls" add column "scheduled_end" timestamp with time zone not null;

alter table "public"."video_calls" add column "title" text not null;

alter table "public"."video_calls" add column "updated_at" timestamp with time zone default now();

alter table "public"."video_calls" add column "waiting_room_enabled" boolean default true;

alter table "public"."video_calls" alter column "preschool_id" set not null;

alter table "public"."video_calls" alter column "scheduled_start" set not null;

alter table "public"."video_calls" alter column "status" set default 'scheduled'::text;

alter table "public"."video_calls" alter column "teacher_id" set not null;

alter sequence "public"."activity_logs_id_seq" owned by "public"."activity_logs"."id";

alter sequence "public"."migration_logs_id_seq" owned by "public"."migration_logs"."id";

CREATE UNIQUE INDEX active_calls_call_id_key ON public.active_calls USING btree (call_id);

CREATE UNIQUE INDEX active_calls_pkey ON public.active_calls USING btree (id);

CREATE UNIQUE INDEX activities_pkey ON public.activities USING btree (id);

CREATE UNIQUE INDEX activity_attempts_pkey ON public.activity_attempts USING btree (id);

CREATE UNIQUE INDEX activity_feed_pkey ON public.activity_feed USING btree (id);

CREATE UNIQUE INDEX activity_logs_pkey ON public.activity_logs USING btree (id);

CREATE UNIQUE INDEX activity_progress_student_id_activity_id_key ON public.activity_progress USING btree (student_id, activity_id);

CREATE UNIQUE INDEX activity_submissions_pkey ON public.activity_submissions USING btree (id);

CREATE UNIQUE INDEX ad_impressions_pkey ON public.ad_impressions USING btree (id);

CREATE UNIQUE INDEX addresses_pkey ON public.addresses USING btree (id);

CREATE UNIQUE INDEX admin_users_pkey ON public.admin_users USING btree (id);

CREATE UNIQUE INDEX age_groups_pkey ON public.age_groups USING btree (id);

CREATE UNIQUE INDEX ai_admin_actions_pkey ON public.ai_admin_actions USING btree (id);

CREATE UNIQUE INDEX ai_allocation_history_pkey ON public.ai_allocation_history USING btree (id);

CREATE UNIQUE INDEX ai_allocation_requests_pkey ON public.ai_allocation_requests USING btree (id);

CREATE UNIQUE INDEX ai_attachments_pkey ON public.ai_attachments USING btree (id);

CREATE UNIQUE INDEX ai_attachments_storage_path_key ON public.ai_attachments USING btree (storage_path);

CREATE UNIQUE INDEX ai_autonomy_settings_pkey ON public.ai_autonomy_settings USING btree (id);

CREATE UNIQUE INDEX ai_autonomy_settings_user_id_key ON public.ai_autonomy_settings USING btree (user_id);

CREATE UNIQUE INDEX ai_context_snapshots_pkey ON public.ai_context_snapshots USING btree (id);

CREATE UNIQUE INDEX ai_conversations_conversation_id_key ON public.ai_conversations USING btree (conversation_id);

CREATE UNIQUE INDEX ai_conversations_pkey ON public.ai_conversations USING btree (id);

CREATE UNIQUE INDEX ai_events_pkey ON public.ai_events USING btree (id);

CREATE UNIQUE INDEX ai_feedback_pkey ON public.ai_feedback USING btree (id);

CREATE UNIQUE INDEX ai_generated_content_pkey ON public.ai_generated_content USING btree (id);

CREATE UNIQUE INDEX ai_generations_pkey ON public.ai_generations USING btree (id);

CREATE UNIQUE INDEX ai_global_settings_pkey ON public.ai_global_settings USING btree (id);

CREATE UNIQUE INDEX ai_insights_pkey ON public.ai_insights USING btree (id);

CREATE UNIQUE INDEX ai_memories_pkey ON public.ai_memories USING btree (id);

CREATE UNIQUE INDEX ai_messages_pkey ON public.ai_messages USING btree (id);

CREATE UNIQUE INDEX ai_model_tiers_pkey ON public.ai_model_tiers USING btree (id);

CREATE UNIQUE INDEX ai_model_tiers_tier_key ON public.ai_model_tiers USING btree (tier);

CREATE UNIQUE INDEX ai_overage_logs_pkey ON public.ai_overage_logs USING btree (id);

CREATE UNIQUE INDEX ai_provider_config_pkey ON public.ai_provider_config USING btree (id);

CREATE UNIQUE INDEX ai_provider_config_service_type_key ON public.ai_provider_config USING btree (service_type);

CREATE UNIQUE INDEX ai_recommendations_pkey ON public.ai_recommendations USING btree (id);

CREATE UNIQUE INDEX ai_request_log_pkey ON public.ai_request_log USING btree (id);

CREATE INDEX ai_services_active_idx ON public.ai_services USING btree (is_active, is_available);

CREATE UNIQUE INDEX ai_services_name_key ON public.ai_services USING btree (name);

CREATE UNIQUE INDEX ai_services_pkey ON public.ai_services USING btree (id);

CREATE INDEX ai_services_provider_idx ON public.ai_services USING btree (provider);

CREATE UNIQUE INDEX ai_task_runs_pkey ON public.ai_task_runs USING btree (id);

CREATE INDEX ai_usage_logs_created_at_idx ON public.ai_usage_logs USING btree (created_at);

CREATE INDEX ai_usage_logs_org_id_idx ON public.ai_usage_logs USING btree (organization_id);

CREATE UNIQUE INDEX ai_usage_logs_pkey ON public.ai_usage_logs USING btree (id);

CREATE INDEX ai_usage_logs_service_type_idx ON public.ai_usage_logs USING btree (service_type);

CREATE INDEX ai_usage_logs_status_idx ON public.ai_usage_logs USING btree (status);

CREATE INDEX ai_usage_logs_user_created_idx ON public.ai_usage_logs USING btree (user_id, created_at);

CREATE INDEX ai_usage_logs_user_id_idx ON public.ai_usage_logs USING btree (user_id);

CREATE UNIQUE INDEX ai_usage_pkey ON public.ai_usage USING btree (id);

CREATE UNIQUE INDEX ai_usage_resets_pkey ON public.ai_usage_resets USING btree (id);

CREATE UNIQUE INDEX ai_usage_tiers_pkey ON public.ai_usage_tiers USING btree (id);

CREATE UNIQUE INDEX ai_usage_tiers_tier_name_key ON public.ai_usage_tiers USING btree (tier_name);

CREATE UNIQUE INDEX announcement_views_announcement_id_user_id_key ON public.announcement_views USING btree (announcement_id, user_id);

CREATE UNIQUE INDEX announcement_views_pkey ON public.announcement_views USING btree (id);

CREATE UNIQUE INDEX announcements_pkey ON public.announcements USING btree (id);

CREATE UNIQUE INDEX assessment_rubrics_pkey ON public.assessment_rubrics USING btree (id);

CREATE UNIQUE INDEX assessments_pkey ON public.assessments USING btree (id);

CREATE UNIQUE INDEX assignment_access_assignment_id_student_id_key ON public.assignment_access USING btree (assignment_id, student_id);

CREATE UNIQUE INDEX assignment_access_pkey ON public.assignment_access USING btree (id);

CREATE UNIQUE INDEX assignment_categories_pkey ON public.assignment_categories USING btree (id);

CREATE UNIQUE INDEX assignment_grades_pkey ON public.assignment_grades USING btree (id);

CREATE UNIQUE INDEX assignment_grades_submission_id_key ON public.assignment_grades USING btree (submission_id);

CREATE UNIQUE INDEX assignment_rubrics_pkey ON public.assignment_rubrics USING btree (id);

CREATE UNIQUE INDEX assignment_submissions_pkey ON public.assignment_submissions USING btree (id);

CREATE UNIQUE INDEX assignments_pkey ON public.assignments USING btree (id);

CREATE UNIQUE INDEX attendance_pkey ON public.attendance USING btree (id);

CREATE UNIQUE INDEX attendance_records_pkey ON public.attendance_records USING btree (id);

CREATE UNIQUE INDEX attendance_records_student_id_attendance_date_key ON public.attendance_records USING btree (student_id, attendance_date);

CREATE UNIQUE INDEX attendance_student_id_attendance_date_key ON public.attendance USING btree (student_id, attendance_date);

CREATE UNIQUE INDEX audit_logs_pkey ON public.audit_logs USING btree (id);

CREATE INDEX beta_feedback_attachments_feedback_id_idx ON public.beta_feedback_attachments USING btree (feedback_id);

CREATE UNIQUE INDEX beta_feedback_attachments_pkey ON public.beta_feedback_attachments USING btree (id);

CREATE INDEX beta_feedback_auth_user_id_idx ON public.beta_feedback USING btree (auth_user_id);

CREATE INDEX beta_feedback_created_at_idx ON public.beta_feedback USING btree (created_at);

CREATE UNIQUE INDEX beta_feedback_pkey ON public.beta_feedback USING btree (id);

CREATE INDEX beta_feedback_user_id_idx ON public.beta_feedback USING btree (user_id);

CREATE UNIQUE INDEX billing_cycles_pkey ON public.billing_cycles USING btree (id);

CREATE UNIQUE INDEX billing_invoices_invoice_number_key ON public.billing_invoices USING btree (invoice_number);

CREATE UNIQUE INDEX billing_invoices_pkey ON public.billing_invoices USING btree (id);

CREATE UNIQUE INDEX billing_plans_name_key ON public.billing_plans USING btree (name);

CREATE UNIQUE INDEX billing_plans_pkey ON public.billing_plans USING btree (id);

CREATE UNIQUE INDEX billing_preferences_pkey ON public.billing_preferences USING btree (user_id);

CREATE UNIQUE INDEX blocked_content_pkey ON public.blocked_content USING btree (id);

CREATE UNIQUE INDEX blocked_content_unique ON public.blocked_content USING btree (blocker_id, content_type, content_id);

CREATE UNIQUE INDEX books_pkey ON public.books USING btree (id);

CREATE UNIQUE INDEX calendar_event_mappings_pkey ON public.calendar_event_mappings USING btree (id);

CREATE UNIQUE INDEX calendar_event_mappings_provider_external_event_id_key ON public.calendar_event_mappings USING btree (provider, external_event_id);

CREATE UNIQUE INDEX call_signals_pkey ON public.call_signals USING btree (id);

CREATE UNIQUE INDEX campaign_redemptions_campaign_id_registration_request_id_key ON public.campaign_redemptions USING btree (campaign_id, registration_request_id);

CREATE UNIQUE INDEX campaign_redemptions_pkey ON public.campaign_redemptions USING btree (id);

CREATE UNIQUE INDEX candidate_profiles_email_key ON public.candidate_profiles USING btree (email);

CREATE UNIQUE INDEX caps_chunks_pkey ON public.caps_chunks USING btree (id);

CREATE UNIQUE INDEX caps_content_chunks_document_id_chunk_index_key ON public.caps_content_chunks USING btree (document_id, chunk_index);

CREATE UNIQUE INDEX caps_content_chunks_pkey ON public.caps_content_chunks USING btree (id);

CREATE UNIQUE INDEX caps_documents_pkey ON public.caps_documents USING btree (id);

CREATE UNIQUE INDEX caps_exam_patterns_grade_subject_topic_key ON public.caps_exam_patterns USING btree (grade, subject, topic);

CREATE UNIQUE INDEX caps_exam_patterns_pkey ON public.caps_exam_patterns USING btree (id);

CREATE UNIQUE INDEX caps_exam_questions_pkey ON public.caps_exam_questions USING btree (id);

CREATE UNIQUE INDEX caps_textbook_mapping_caps_topic_id_textbook_content_id_key ON public.caps_textbook_mapping USING btree (caps_topic_id, textbook_content_id);

CREATE UNIQUE INDEX caps_textbook_mapping_pkey ON public.caps_textbook_mapping USING btree (id);

CREATE UNIQUE INDEX caps_topics_grade_subject_topic_code_key ON public.caps_topics USING btree (grade, subject, topic_code);

CREATE UNIQUE INDEX caps_topics_pkey ON public.caps_topics USING btree (id);

CREATE UNIQUE INDEX chat_images_hash_key ON public.chat_images USING btree (hash);

CREATE UNIQUE INDEX chat_images_pkey ON public.chat_images USING btree (id);

CREATE UNIQUE INDEX child_registration_unique_pending ON public.child_registration_requests USING btree (parent_id, preschool_id, child_first_name, child_last_name, child_birth_date) WHERE (status = 'pending'::text);

CREATE UNIQUE INDEX class_assignments_pkey ON public.class_assignments USING btree (id);

CREATE UNIQUE INDEX class_assignments_student_id_class_id_key ON public.class_assignments USING btree (student_id, class_id);

CREATE UNIQUE INDEX class_events_pkey ON public.class_events USING btree (id);

CREATE UNIQUE INDEX classroom_reports_pkey ON public.classroom_reports USING btree (id);

CREATE UNIQUE INDEX config_kv_pkey ON public.config_kv USING btree (key);

CREATE UNIQUE INDEX contact_discovery_settings_pkey ON public.contact_discovery_settings USING btree (user_id);

CREATE UNIQUE INDEX contact_suggestions_pkey ON public.contact_suggestions USING btree (id);

CREATE UNIQUE INDEX contact_suggestions_user_id_suggested_user_id_key ON public.contact_suggestions USING btree (user_id, suggested_user_id);

CREATE UNIQUE INDEX content_reports_pkey ON public.content_reports USING btree (id);

CREATE UNIQUE INDEX content_reports_unique ON public.content_reports USING btree (reporter_id, content_type, content_id, report_reason);

CREATE UNIQUE INDEX conversation_members_conversation_id_user_id_key ON public.conversation_members USING btree (conversation_id, user_id);

CREATE UNIQUE INDEX conversation_members_pkey ON public.conversation_members USING btree (id);

CREATE UNIQUE INDEX conversations_pkey ON public.conversations USING btree (id);

CREATE UNIQUE INDEX course_grades_course_id_student_id_key ON public.course_grades USING btree (course_id, student_id);

CREATE UNIQUE INDEX course_grades_pkey ON public.course_grades USING btree (id);

CREATE UNIQUE INDEX course_join_requests_pkey ON public.course_join_requests USING btree (id);

CREATE UNIQUE INDEX course_join_requests_student_id_course_id_key ON public.course_join_requests USING btree (student_id, course_id);

CREATE UNIQUE INDEX courses_join_code_key ON public.courses USING btree (join_code);

CREATE UNIQUE INDEX courses_pkey ON public.courses USING btree (id);

CREATE UNIQUE INDEX cv_templates_pkey ON public.cv_templates USING btree (id);

CREATE UNIQUE INDEX cv_uploads_pkey ON public.cv_uploads USING btree (id);

CREATE UNIQUE INDEX daily_activities_pkey ON public.daily_activities USING btree (id);

CREATE UNIQUE INDEX dash_agent_instances_pkey ON public.dash_agent_instances USING btree (id);

CREATE UNIQUE INDEX dash_conversation_facts_pkey ON public.dash_conversation_facts USING btree (id);

CREATE UNIQUE INDEX dash_curriculum_memory_pkey ON public.dash_curriculum_memory USING btree (id);

CREATE UNIQUE INDEX dash_reminders_pkey ON public.dash_reminders USING btree (id);

CREATE UNIQUE INDEX dash_storage_pkey ON public.dash_storage USING btree (id);

CREATE UNIQUE INDEX dash_storage_preschool_id_user_id_storage_key_key ON public.dash_storage USING btree (preschool_id, user_id, storage_key);

CREATE UNIQUE INDEX dash_user_contexts_pkey ON public.dash_user_contexts USING btree (id);

CREATE UNIQUE INDEX dash_user_contexts_user_id_key ON public.dash_user_contexts USING btree (user_id);

CREATE UNIQUE INDEX dashboard_voice_notes_pkey ON public.dashboard_voice_notes USING btree (id);

CREATE UNIQUE INDEX deletion_requests_pkey ON public.deletion_requests USING btree (id);

CREATE UNIQUE INDEX deletion_requests_request_id_key ON public.deletion_requests USING btree (request_id);

CREATE UNIQUE INDEX delivery_providers_pkey ON public.delivery_providers USING btree (id);

CREATE UNIQUE INDEX delivery_providers_provider_name_key ON public.delivery_providers USING btree (provider_name);

CREATE UNIQUE INDEX delivery_retry_queue_pkey ON public.delivery_retry_queue USING btree (id);

CREATE UNIQUE INDEX delivery_webhooks_pkey ON public.delivery_webhooks USING btree (id);

CREATE UNIQUE INDEX dm_settings_pkey ON public.dm_settings USING btree (id);

CREATE UNIQUE INDEX dm_settings_user_id_partner_user_id_key ON public.dm_settings USING btree (user_id, partner_user_id);

CREATE UNIQUE INDEX early_access_signups_email_key ON public.early_access_signups USING btree (email);

CREATE UNIQUE INDEX early_access_signups_pkey ON public.early_access_signups USING btree (id);

CREATE UNIQUE INDEX email_logs_pkey ON public.email_logs USING btree (id);

CREATE UNIQUE INDEX email_preferences_pkey ON public.email_preferences USING btree (id);

CREATE UNIQUE INDEX email_preferences_user_id_key ON public.email_preferences USING btree (user_id);

CREATE UNIQUE INDEX email_templates_pkey ON public.email_templates USING btree (id);

CREATE UNIQUE INDEX email_templates_preschool_id_name_template_type_key ON public.email_templates USING btree (preschool_id, name, template_type);

CREATE UNIQUE INDEX emergency_contacts_pkey ON public.emergency_contacts USING btree (id);

CREATE UNIQUE INDEX enrollment_applications_pkey ON public.enrollment_applications USING btree (id);

CREATE UNIQUE INDEX enrollments_pkey ON public.enrollments USING btree (id);

CREATE UNIQUE INDEX enrollments_student_id_course_id_key ON public.enrollments USING btree (student_id, course_id);

CREATE UNIQUE INDEX enterprise_leads_pkey ON public.enterprise_leads USING btree (id);

CREATE UNIQUE INDEX error_logs_pkey ON public.error_logs USING btree (id);

CREATE UNIQUE INDEX event_attendees_event_id_member_id_key ON public.event_attendees USING btree (event_id, member_id);

CREATE UNIQUE INDEX event_attendees_pkey ON public.event_attendees USING btree (id);

CREATE UNIQUE INDEX event_audiences_pkey ON public.event_audiences USING btree (id);

CREATE UNIQUE INDEX event_audiences_unique_idx ON public.event_audiences USING btree (event_id, audience_type, COALESCE((target_id)::text, (target_value)::text));

CREATE UNIQUE INDEX event_invitations_event_id_invitee_id_key ON public.event_invitations USING btree (event_id, invitee_id);

CREATE UNIQUE INDEX event_invitations_pkey ON public.event_invitations USING btree (id);

CREATE UNIQUE INDEX event_media_pkey ON public.event_media USING btree (id);

CREATE UNIQUE INDEX event_notifications_pkey ON public.event_notifications USING btree (id);

CREATE UNIQUE INDEX event_participants_event_id_user_id_student_id_key ON public.event_participants USING btree (event_id, user_id, student_id);

CREATE UNIQUE INDEX event_participants_pkey ON public.event_participants USING btree (id);

CREATE UNIQUE INDEX event_reactions_pkey ON public.event_reactions USING btree (id);

CREATE UNIQUE INDEX event_rsvps_event_id_user_id_key ON public.event_rsvps USING btree (event_id, user_id);

CREATE UNIQUE INDEX event_rsvps_pkey ON public.event_rsvps USING btree (id);

CREATE UNIQUE INDEX event_updates_pkey ON public.event_updates USING btree (id);

CREATE UNIQUE INDEX events_pkey ON public.events USING btree (id);

CREATE UNIQUE INDEX exam_assignments_pkey ON public.exam_assignments USING btree (id);

CREATE UNIQUE INDEX exam_attempts_pkey ON public.exam_attempts USING btree (id);

CREATE UNIQUE INDEX exam_generations_pkey ON public.exam_generations USING btree (id);

CREATE UNIQUE INDEX exam_papers_pkey ON public.exam_papers USING btree (id);

CREATE UNIQUE INDEX exam_submissions_assignment_id_student_id_attempt_number_key ON public.exam_submissions USING btree (assignment_id, student_id, attempt_number);

CREATE UNIQUE INDEX exam_submissions_pkey ON public.exam_submissions USING btree (id);

CREATE UNIQUE INDEX exam_user_progress_pkey ON public.exam_user_progress USING btree (id);

CREATE UNIQUE INDEX expense_categories_pkey ON public.expense_categories USING btree (id);

CREATE UNIQUE INDEX expense_categories_preschool_id_name_key ON public.expense_categories USING btree (preschool_id, name);

CREATE UNIQUE INDEX feature_flags_feature_key_key ON public.feature_flags USING btree (feature_key);

CREATE UNIQUE INDEX feature_flags_pkey ON public.feature_flags USING btree (id);

CREATE UNIQUE INDEX fee_payments_payfast_payment_id_key ON public.fee_payments USING btree (payfast_payment_id);

CREATE UNIQUE INDEX fee_payments_pkey ON public.fee_payments USING btree (id);

CREATE UNIQUE INDEX fee_structures_preschool_id_name_key ON public.fee_structures USING btree (preschool_id, name);

CREATE UNIQUE INDEX financial_transactions_pkey ON public.financial_transactions USING btree (id);

CREATE UNIQUE INDEX gradebook_entries_course_id_student_id_key ON public.gradebook_entries USING btree (course_id, student_id);

CREATE UNIQUE INDEX gradebook_entries_pkey ON public.gradebook_entries USING btree (id);

CREATE UNIQUE INDEX grades_pkey ON public.grades USING btree (id);

CREATE UNIQUE INDEX grades_submission_id_key ON public.grades USING btree (submission_id);

CREATE UNIQUE INDEX group_invitations_group_id_invitee_id_key ON public.group_invitations USING btree (group_id, invitee_id);

CREATE UNIQUE INDEX group_invitations_pkey ON public.group_invitations USING btree (id);

CREATE UNIQUE INDEX group_members_group_id_user_id_key ON public.group_members USING btree (group_id, user_id);

CREATE UNIQUE INDEX group_members_pkey ON public.group_members USING btree (id);

CREATE UNIQUE INDEX groups_course_id_name_key ON public.groups USING btree (course_id, name);

CREATE UNIQUE INDEX groups_pkey ON public.groups USING btree (id);

CREATE UNIQUE INDEX guardian_requests_pkey ON public.guardian_requests USING btree (id);

CREATE UNIQUE INDEX guest_usage_log_pkey ON public.guest_usage_log USING btree (id);

CREATE UNIQUE INDEX homework_activity_log_pkey ON public.homework_activity_log USING btree (id);

CREATE UNIQUE INDEX homework_assignment_targets_pkey ON public.homework_assignment_targets USING btree (id);

CREATE UNIQUE INDEX homework_assignments_pkey ON public.homework_assignments USING btree (id);

CREATE UNIQUE INDEX homework_notifications_pkey ON public.homework_notifications USING btree (id);

CREATE UNIQUE INDEX homework_submissions_assignment_id_student_id_key ON public.homework_submissions USING btree (assignment_id, student_id);

CREATE UNIQUE INDEX homework_submissions_homework_assignment_id_student_id_key ON public.homework_submissions USING btree (homework_assignment_id, student_id);

CREATE UNIQUE INDEX homework_submissions_pkey ON public.homework_submissions USING btree (id);

CREATE INDEX idx_achievements_category ON public.student_achievements USING btree (category);

CREATE INDEX idx_achievements_earned ON public.student_achievements USING btree (earned_at DESC);

CREATE INDEX idx_achievements_preschool ON public.student_achievements USING btree (preschool_id);

CREATE INDEX idx_achievements_student ON public.student_achievements USING btree (student_id);

CREATE INDEX idx_achievements_type ON public.student_achievements USING btree (achievement_type);

CREATE INDEX idx_active_calls_call_id ON public.active_calls USING btree (call_id);

CREATE INDEX idx_active_calls_callee ON public.active_calls USING btree (callee_id, status);

CREATE INDEX idx_active_calls_callee_id_status ON public.active_calls USING btree (callee_id, status);

CREATE INDEX idx_active_calls_caller ON public.active_calls USING btree (caller_id, status);

CREATE INDEX idx_active_calls_caller_id_status ON public.active_calls USING btree (caller_id, status);

CREATE INDEX idx_active_calls_meeting_url ON public.active_calls USING btree (meeting_url) WHERE (meeting_url IS NOT NULL);

CREATE INDEX idx_activity_attempts_activity ON public.activity_attempts USING btree (activity_id);

CREATE INDEX idx_activity_attempts_date ON public.activity_attempts USING btree (started_at DESC);

CREATE INDEX idx_activity_attempts_student ON public.activity_attempts USING btree (student_id);

CREATE INDEX idx_activity_attempts_student_activity ON public.activity_attempts USING btree (student_id, activity_id);

CREATE INDEX idx_activity_feed_actor ON public.activity_feed USING btree (actor_id);

CREATE INDEX idx_activity_feed_actor_id ON public.activity_feed USING btree (actor_id);

CREATE INDEX idx_activity_feed_class ON public.student_activity_feed USING btree (class_id, activity_at DESC);

CREATE INDEX idx_activity_feed_created ON public.activity_feed USING btree (created_at DESC);

CREATE INDEX idx_activity_feed_preschool ON public.activity_feed USING btree (preschool_id);

CREATE INDEX idx_activity_feed_preschool_id ON public.activity_feed USING btree (preschool_id, created_at DESC);

CREATE INDEX idx_activity_feed_student ON public.student_activity_feed USING btree (student_id, activity_at DESC);

CREATE INDEX idx_activity_feed_target ON public.activity_feed USING btree (target_type, target_id);

CREATE INDEX idx_activity_logs_created_at ON public.activity_logs USING btree (created_at DESC);

CREATE INDEX idx_activity_logs_org_date ON public.activity_logs USING btree (organization_id, created_at DESC);

CREATE INDEX idx_activity_logs_organization_id ON public.activity_logs USING btree (organization_id);

CREATE INDEX idx_activity_progress_activity_id ON public.activity_progress USING btree (activity_id);

CREATE INDEX idx_activity_progress_completed ON public.activity_progress USING btree (completed_at);

CREATE INDEX idx_activity_progress_student_id ON public.activity_progress USING btree (student_id);

CREATE INDEX idx_activity_submissions_class ON public.activity_submissions USING btree (class_id);

CREATE INDEX idx_activity_submissions_teacher ON public.activity_submissions USING btree (assigned_teacher_id);

CREATE INDEX idx_activity_submissions_user ON public.activity_submissions USING btree (user_id);

CREATE INDEX idx_admin_users_organization_id ON public.admin_users USING btree (organization_id);

CREATE INDEX idx_aftercare_reg_created ON public.aftercare_registrations USING btree (created_at DESC);

CREATE INDEX idx_aftercare_reg_email ON public.aftercare_registrations USING btree (parent_email);

CREATE INDEX idx_aftercare_reg_grade ON public.aftercare_registrations USING btree (child_grade);

CREATE INDEX idx_aftercare_reg_has_pop ON public.aftercare_registrations USING btree (((proof_of_payment_url IS NOT NULL)));

CREATE INDEX idx_aftercare_reg_phone ON public.aftercare_registrations USING btree (parent_phone);

CREATE INDEX idx_aftercare_reg_preschool ON public.aftercare_registrations USING btree (preschool_id);

CREATE INDEX idx_aftercare_reg_status ON public.aftercare_registrations USING btree (status);

CREATE INDEX idx_age_groups_preschool_id ON public.age_groups USING btree (preschool_id);

CREATE INDEX idx_age_groups_school_type ON public.age_groups USING btree (school_type);

CREATE INDEX idx_ai_admin_actions_action_created_at ON public.ai_admin_actions USING btree (action, created_at DESC);

CREATE INDEX idx_ai_admin_actions_actor_created_at ON public.ai_admin_actions USING btree (actor_user_id, created_at DESC);

CREATE INDEX idx_ai_allocation_history_action_time ON public.ai_allocation_history USING btree (preschool_id, action, created_at DESC);

CREATE INDEX idx_ai_allocation_history_preschool_id ON public.ai_allocation_history USING btree (preschool_id);

CREATE INDEX idx_ai_allocation_history_teacher_id ON public.ai_allocation_history USING btree (teacher_id);

CREATE INDEX idx_ai_allocation_requests_expires ON public.ai_allocation_requests USING btree (expires_at) WHERE (status = 'pending'::text);

CREATE INDEX idx_ai_allocation_requests_preschool_id ON public.ai_allocation_requests USING btree (preschool_id);

CREATE INDEX idx_ai_allocation_requests_status ON public.ai_allocation_requests USING btree (preschool_id, status);

CREATE INDEX idx_ai_allocation_requests_urgency ON public.ai_allocation_requests USING btree (preschool_id, urgency, status) WHERE (status = 'pending'::text);

CREATE INDEX idx_ai_attachments_status ON public.ai_attachments USING btree (status) WHERE (status = ANY (ARRAY['processing'::text, 'failed'::text]));

CREATE INDEX idx_ai_attachments_user ON public.ai_attachments USING btree (user_id, conversation_id);

CREATE INDEX idx_ai_autonomy_settings_preschool ON public.ai_autonomy_settings USING btree (preschool_id);

CREATE INDEX idx_ai_autonomy_settings_user ON public.ai_autonomy_settings USING btree (user_id);

CREATE INDEX idx_ai_content_content_type ON public.ai_generated_content USING btree (content_type);

CREATE INDEX idx_ai_content_organization_id ON public.ai_generated_content USING btree (organization_id);

CREATE INDEX idx_ai_content_reviewed ON public.ai_generated_content USING btree (reviewed);

CREATE INDEX idx_ai_context_snapshots_preschool_created ON public.ai_context_snapshots USING btree (preschool_id, created_at DESC);

CREATE INDEX idx_ai_context_snapshots_snapshot_gin ON public.ai_context_snapshots USING gin (snapshot);

CREATE INDEX idx_ai_context_snapshots_user_created ON public.ai_context_snapshots USING btree (user_id, created_at DESC);

CREATE INDEX idx_ai_conversations_conversation_id ON public.ai_conversations USING btree (conversation_id);

CREATE INDEX idx_ai_conversations_preschool_updated ON public.ai_conversations USING btree (preschool_id, updated_at DESC);

CREATE INDEX idx_ai_conversations_user_updated ON public.ai_conversations USING btree (user_id, updated_at DESC);

CREATE INDEX idx_ai_events_payload_gin ON public.ai_events USING gin (payload);

CREATE INDEX idx_ai_events_preschool_created ON public.ai_events USING btree (preschool_id, created_at DESC);

CREATE INDEX idx_ai_events_type_created ON public.ai_events USING btree (event_type, created_at DESC);

CREATE INDEX idx_ai_events_user_created ON public.ai_events USING btree (user_id, created_at DESC);

CREATE INDEX idx_ai_feedback_decision_id ON public.ai_feedback USING btree (decision_id) WHERE (decision_id IS NOT NULL);

CREATE INDEX idx_ai_feedback_preschool_created ON public.ai_feedback USING btree (preschool_id, created_at DESC);

CREATE INDEX idx_ai_feedback_task_id ON public.ai_feedback USING btree (task_id) WHERE (task_id IS NOT NULL);

CREATE INDEX idx_ai_generations_preschool_id ON public.ai_generations USING btree (preschool_id);

CREATE INDEX idx_ai_insights_actionable ON public.ai_insights USING btree (actionable, created_at DESC) WHERE ((actionable = true) AND (status = 'active'::text));

CREATE INDEX idx_ai_insights_data_sources_gin ON public.ai_insights USING gin (data_sources);

CREATE INDEX idx_ai_insights_preschool_created ON public.ai_insights USING btree (preschool_id, created_at DESC);

CREATE INDEX idx_ai_insights_priority ON public.ai_insights USING btree (priority, created_at DESC) WHERE ((status = 'active'::text) AND (priority = ANY (ARRAY['high'::text, 'urgent'::text])));

CREATE INDEX idx_ai_insights_suggested_actions_gin ON public.ai_insights USING gin (suggested_actions);

CREATE INDEX idx_ai_insights_user_status ON public.ai_insights USING btree (user_id, status) WHERE (status = 'active'::text);

CREATE INDEX idx_ai_memories_content_gin ON public.ai_memories USING gin (content);

CREATE INDEX idx_ai_memories_embedding_ivfflat ON public.ai_memories USING ivfflat (text_embedding public.vector_cosine_ops) WITH (lists='100') WHERE (text_embedding IS NOT NULL);

CREATE INDEX idx_ai_memories_importance ON public.ai_memories USING btree (importance DESC) WHERE (importance >= 7);

CREATE INDEX idx_ai_memories_preschool_created ON public.ai_memories USING btree (preschool_id, created_at DESC);

CREATE INDEX idx_ai_memories_type ON public.ai_memories USING btree (memory_type);

CREATE INDEX idx_ai_memories_user_created ON public.ai_memories USING btree (user_id, created_at DESC);

CREATE INDEX idx_ai_model_tiers_active ON public.ai_model_tiers USING btree (is_active, sort_order);

CREATE INDEX idx_ai_model_tiers_tier ON public.ai_model_tiers USING btree (tier);

CREATE INDEX idx_ai_overage_logs_user_id ON public.ai_overage_logs USING btree (user_id);

CREATE INDEX idx_ai_provider_config_active ON public.ai_provider_config USING btree (is_active);

CREATE INDEX idx_ai_provider_config_service_type ON public.ai_provider_config USING btree (service_type);

CREATE INDEX idx_ai_recommendations_acted_upon ON public.ai_recommendations USING btree (acted_upon);

CREATE INDEX idx_ai_recommendations_learner_id ON public.ai_recommendations USING btree (learner_id);

CREATE INDEX idx_ai_recommendations_organization_id ON public.ai_recommendations USING btree (organization_id);

CREATE INDEX idx_ai_recommendations_program_id ON public.ai_recommendations USING btree (program_id);

CREATE INDEX idx_ai_request_log_created_at ON public.ai_request_log USING btree (created_at);

CREATE INDEX idx_ai_request_log_status ON public.ai_request_log USING btree (status);

CREATE INDEX idx_ai_request_log_user_id ON public.ai_request_log USING btree (user_id);

CREATE INDEX idx_ai_task_runs_metrics_gin ON public.ai_task_runs USING gin (metrics);

CREATE INDEX idx_ai_task_runs_preschool_started ON public.ai_task_runs USING btree (preschool_id, started_at DESC);

CREATE INDEX idx_ai_task_runs_status ON public.ai_task_runs USING btree (status) WHERE (status = ANY (ARRAY['running'::text, 'pending'::text]));

CREATE INDEX idx_ai_task_runs_steps_gin ON public.ai_task_runs USING gin (steps);

CREATE INDEX idx_ai_task_runs_task_id_started ON public.ai_task_runs USING btree (task_id, started_at DESC);

CREATE INDEX idx_ai_usage_created_at ON public.ai_usage USING btree (created_at);

CREATE INDEX idx_ai_usage_date ON public.ai_usage USING btree (usage_date);

CREATE INDEX idx_ai_usage_feature ON public.ai_usage USING btree (feature_used);

CREATE INDEX idx_ai_usage_logs_allocation_id ON public.ai_usage_logs USING btree (allocation_id) WHERE (allocation_id IS NOT NULL);

CREATE INDEX idx_ai_usage_logs_created_at ON public.ai_usage_logs USING btree (created_at);

CREATE INDEX idx_ai_usage_logs_org_date ON public.ai_usage_logs USING btree (organization_id, created_at DESC);

CREATE INDEX idx_ai_usage_logs_org_id ON public.ai_usage_logs USING btree (organization_id);

CREATE INDEX idx_ai_usage_logs_org_user_date ON public.ai_usage_logs USING btree (organization_id, user_id, created_at);

CREATE INDEX idx_ai_usage_logs_preschool_id ON public.ai_usage_logs USING btree (preschool_id);

CREATE INDEX idx_ai_usage_logs_preschool_tenant ON public.ai_usage_logs USING btree (preschool_id);

CREATE INDEX idx_ai_usage_logs_quota_type ON public.ai_usage_logs USING btree (preschool_id, quota_consumed_from, created_at DESC) WHERE (quota_consumed_from IS NOT NULL);

CREATE INDEX idx_ai_usage_logs_service_type ON public.ai_usage_logs USING btree (service_type);

CREATE INDEX idx_ai_usage_logs_service_type_status ON public.ai_usage_logs USING btree (service_type, status, created_at);

CREATE INDEX idx_ai_usage_logs_session ON public.ai_usage_logs USING btree (session_id, created_at) WHERE (session_id IS NOT NULL);

CREATE INDEX idx_ai_usage_logs_user ON public.ai_usage_logs USING btree (user_id);

CREATE INDEX idx_ai_usage_logs_user_date ON public.ai_usage_logs USING btree (preschool_id, user_id, created_at DESC);

CREATE INDEX idx_ai_usage_logs_user_id ON public.ai_usage_logs USING btree (user_id);

CREATE INDEX idx_ai_usage_logs_user_service_created ON public.ai_usage_logs USING btree (user_id, service_type, created_at DESC);

CREATE INDEX idx_ai_usage_model ON public.ai_usage USING btree (model_used);

CREATE INDEX idx_ai_usage_organization_id ON public.ai_usage USING btree (organization_id);

CREATE INDEX idx_ai_usage_resets_school ON public.ai_usage_resets USING btree (target_preschool_id, created_at DESC);

CREATE INDEX idx_ai_usage_resets_scope_created_at ON public.ai_usage_resets USING btree (target_scope, created_at DESC);

CREATE INDEX idx_ai_usage_resets_user ON public.ai_usage_resets USING btree (target_user_id, created_at DESC);

CREATE INDEX idx_ai_usage_success ON public.ai_usage USING btree (success);

CREATE INDEX idx_ai_usage_user_date_feature ON public.ai_usage USING btree (user_id, usage_date, feature_used);

CREATE INDEX idx_ai_usage_user_id ON public.ai_usage USING btree (user_id);

CREATE INDEX idx_alerts_dedupe ON public.service_alerts USING btree (dedupe_key, triggered_at DESC);

CREATE INDEX idx_alerts_pending ON public.service_alerts USING btree (status) WHERE (status = 'pending'::text);

CREATE INDEX idx_ann_recipients_announcement ON public.organization_announcement_recipients USING btree (announcement_id);

CREATE INDEX idx_ann_recipients_recipient ON public.organization_announcement_recipients USING btree (recipient_id);

CREATE INDEX idx_announcement_views_announcement ON public.announcement_views USING btree (announcement_id);

CREATE INDEX idx_announcements_author_id ON public.announcements USING btree (author_id);

CREATE INDEX idx_announcements_preschool_id ON public.announcements USING btree (preschool_id);

CREATE INDEX idx_announcements_preschool_pinned ON public.announcements USING btree (preschool_id, pinned DESC, published_at DESC);

CREATE INDEX idx_announcements_preschool_published ON public.announcements USING btree (preschool_id, is_published, published_at DESC);

CREATE INDEX idx_announcements_published_at ON public.announcements USING btree (published_at DESC);

CREATE INDEX idx_announcements_scheduled ON public.announcements USING btree (scheduled_for) WHERE (scheduled_for IS NOT NULL);

CREATE INDEX idx_api_keys_expiring ON public.service_api_keys USING btree (expires_at) WHERE ((expires_at IS NOT NULL) AND (status <> 'expired'::text));

CREATE INDEX idx_assessments_created_by ON public.assessments USING btree (created_by);

CREATE INDEX idx_assessments_organization_id ON public.assessments USING btree (organization_id);

CREATE INDEX idx_assessments_student_id ON public.assessments USING btree (student_id);

CREATE INDEX idx_assignment_access_active ON public.assignment_access USING btree (is_active);

CREATE INDEX idx_assignment_access_assignment_id ON public.assignment_access USING btree (assignment_id);

CREATE INDEX idx_assignment_access_group_id ON public.assignment_access USING btree (group_id);

CREATE INDEX idx_assignment_access_release_date ON public.assignment_access USING btree (release_date);

CREATE INDEX idx_assignment_access_student_id ON public.assignment_access USING btree (student_id);

CREATE INDEX idx_assignment_submissions_assignment_id ON public.assignment_submissions USING btree (assignment_id);

CREATE INDEX idx_assignment_submissions_enrollment_id ON public.assignment_submissions USING btree (enrollment_id);

CREATE INDEX idx_assignment_submissions_learner_id ON public.assignment_submissions USING btree (learner_id);

CREATE INDEX idx_assignment_submissions_status ON public.assignment_submissions USING btree (status);

CREATE INDEX idx_assignment_submissions_student_id ON public.assignment_submissions USING btree (student_id);

CREATE INDEX idx_assignments_assigned_at ON public.assignments USING btree (assigned_at) WHERE (deleted_at IS NULL);

CREATE INDEX idx_assignments_class_status ON public.assignments USING btree (class_id, status) WHERE (class_id IS NOT NULL);

CREATE INDEX idx_assignments_course_id ON public.assignments USING btree (course_id) WHERE (deleted_at IS NULL);

CREATE INDEX idx_assignments_due_at ON public.assignments USING btree (due_at) WHERE (deleted_at IS NULL);

CREATE INDEX idx_assignments_due_date ON public.assignments USING btree (due_date) WHERE (due_date IS NOT NULL);

CREATE INDEX idx_assignments_org_teacher ON public.assignments USING btree (organization_id, teacher_id);

CREATE INDEX idx_assignments_preschool_id ON public.assignments USING btree (preschool_id);

CREATE INDEX idx_assignments_teacher_id ON public.assignments USING btree (teacher_id);

CREATE INDEX idx_assignments_type ON public.assignments USING btree (assignment_type) WHERE (deleted_at IS NULL);

CREATE INDEX idx_attendance_date ON public.attendance USING btree (attendance_date);

CREATE INDEX idx_attendance_organization_id ON public.attendance USING btree (organization_id);

CREATE INDEX idx_attendance_recorded_by ON public.attendance USING btree (recorded_by);

CREATE INDEX idx_attendance_records_class_id ON public.attendance_records USING btree (class_id);

CREATE INDEX idx_attendance_records_date ON public.attendance_records USING btree (attendance_date);

CREATE INDEX idx_attendance_records_preschool_date ON public.attendance_records USING btree (preschool_id, date);

CREATE INDEX idx_attendance_records_preschool_student ON public.attendance_records USING btree (preschool_id, student_id);

CREATE INDEX idx_attendance_records_preschool_tenant ON public.attendance_records USING btree (preschool_id);

CREATE INDEX idx_attendance_records_status ON public.attendance_records USING btree (status, date);

CREATE INDEX idx_attendance_records_student_date ON public.attendance_records USING btree (student_id, date DESC);

CREATE INDEX idx_attendance_records_student_id ON public.attendance_records USING btree (student_id);

CREATE INDEX idx_attendance_student_id ON public.attendance USING btree (student_id);

CREATE INDEX idx_attendees_event ON public.event_attendees USING btree (event_id);

CREATE INDEX idx_attendees_member ON public.event_attendees USING btree (member_id);

CREATE INDEX idx_audit_logs_actor_id ON public.audit_logs USING btree (actor_id);

CREATE INDEX idx_audit_logs_actor_org ON public.audit_logs USING btree (actor_organization_id);

CREATE INDEX idx_audit_logs_actor_time ON public.audit_logs USING btree (actor_id, occurred_at DESC);

CREATE INDEX idx_audit_logs_correlation_id ON public.audit_logs USING btree (correlation_id);

CREATE INDEX idx_audit_logs_event_type ON public.audit_logs USING btree (event_type);

CREATE INDEX idx_audit_logs_ip_address ON public.audit_logs USING btree (ip_address);

CREATE INDEX idx_audit_logs_occurred_at ON public.audit_logs USING btree (occurred_at);

CREATE INDEX idx_audit_logs_session_id ON public.audit_logs USING btree (session_id);

CREATE INDEX idx_audit_logs_target ON public.audit_logs USING btree (target_id, target_type);

CREATE INDEX idx_audit_logs_target_time ON public.audit_logs USING btree (target_id, target_type, occurred_at DESC);

CREATE INDEX idx_bank_accounts_org ON public.organization_bank_accounts USING btree (organization_id);

CREATE INDEX idx_bank_accounts_region ON public.organization_bank_accounts USING btree (region_id);

CREATE INDEX idx_bank_accounts_type ON public.organization_bank_accounts USING btree (account_type);

CREATE INDEX idx_bank_accounts_wing ON public.organization_bank_accounts USING btree (wing_id);

CREATE INDEX idx_billing_cycles_next_billing ON public.billing_cycles USING btree (next_billing_date);

CREATE INDEX idx_billing_cycles_preschool_active ON public.billing_cycles USING btree (preschool_id, status);

CREATE INDEX idx_billing_invoices_due_date ON public.billing_invoices USING btree (due_date);

CREATE INDEX idx_billing_invoices_school_id ON public.billing_invoices USING btree (school_id);

CREATE INDEX idx_billing_invoices_status ON public.billing_invoices USING btree (status);

CREATE INDEX idx_billing_preferences_user_id ON public.billing_preferences USING btree (user_id);

CREATE INDEX idx_blocked_content_active ON public.blocked_content USING btree (is_active);

CREATE INDEX idx_blocked_content_author ON public.blocked_content USING btree (author_id);

CREATE INDEX idx_blocked_content_blocker ON public.blocked_content USING btree (blocker_id);

CREATE INDEX idx_blocked_content_school ON public.blocked_content USING btree (school_id);

CREATE INDEX idx_blocked_content_type ON public.blocked_content USING btree (content_type, content_id);

CREATE INDEX idx_board_positions_code ON public.organization_board_positions USING btree (position_code);

CREATE INDEX idx_board_positions_member ON public.organization_board_positions USING btree (member_id);

CREATE INDEX idx_board_positions_org ON public.organization_board_positions USING btree (organization_id);

CREATE INDEX idx_bookmarks_textbook ON public.user_bookmarks USING btree (textbook_id);

CREATE INDEX idx_bookmarks_user ON public.user_bookmarks USING btree (user_id);

CREATE INDEX idx_books_grade ON public.books USING btree (grade);

CREATE INDEX idx_books_grade_range ON public.books USING btree (grade_range);

CREATE INDEX idx_books_subject ON public.books USING btree (subject);

CREATE INDEX idx_budgets_category ON public.organization_budgets USING btree (category);

CREATE INDEX idx_budgets_org ON public.organization_budgets USING btree (organization_id);

CREATE INDEX idx_budgets_region ON public.organization_budgets USING btree (region_id);

CREATE INDEX idx_budgets_status ON public.organization_budgets USING btree (status);

CREATE INDEX idx_budgets_wing ON public.organization_budgets USING btree (wing_id);

CREATE INDEX idx_budgets_year ON public.organization_budgets USING btree (fiscal_year);

CREATE INDEX idx_calendar_mappings_internal_event ON public.calendar_event_mappings USING btree (internal_event_id);

CREATE INDEX idx_calendar_mappings_preschool ON public.calendar_event_mappings USING btree (preschool_id);

CREATE INDEX idx_calendar_mappings_provider_external ON public.calendar_event_mappings USING btree (provider, external_event_id);

CREATE INDEX idx_call_signals_call_id ON public.call_signals USING btree (call_id);

CREATE INDEX idx_call_signals_call_id_type ON public.call_signals USING btree (call_id, signal_type);

CREATE INDEX idx_call_signals_to_user ON public.call_signals USING btree (to_user_id, created_at DESC);

CREATE INDEX idx_call_signals_to_user_id ON public.call_signals USING btree (to_user_id, created_at DESC);

CREATE INDEX idx_campaigns_dates ON public.marketing_campaigns USING btree (start_date, end_date) WHERE (active = true);

CREATE INDEX idx_campaigns_org ON public.marketing_campaigns USING btree (organization_id) WHERE (active = true);

CREATE INDEX idx_campaigns_promo_code ON public.marketing_campaigns USING btree (promo_code) WHERE (promo_code IS NOT NULL);

CREATE UNIQUE INDEX idx_candidate_profiles_email ON public.candidate_profiles USING btree (lower(email));

CREATE INDEX idx_candidate_profiles_location ON public.candidate_profiles USING btree (location) WHERE (location IS NOT NULL);

CREATE INDEX idx_caps_chunks_doc ON public.caps_chunks USING btree (document_id);

CREATE INDEX idx_caps_chunks_embedding ON public.caps_chunks USING ivfflat (embedding public.vector_cosine_ops) WITH (lists='100');

CREATE INDEX idx_caps_chunks_token ON public.caps_chunks USING btree (token_count);

CREATE UNIQUE INDEX idx_caps_docs_checksum ON public.caps_documents USING btree (checksum);

CREATE INDEX idx_caps_docs_grade ON public.caps_documents USING btree (grade);

CREATE INDEX idx_caps_docs_grade_subject ON public.caps_documents USING btree (grade, subject);

CREATE INDEX idx_caps_docs_keywords ON public.caps_documents USING gin (keywords);

CREATE INDEX idx_caps_docs_language ON public.caps_documents USING btree (language);

CREATE INDEX idx_caps_docs_search ON public.caps_documents USING gin (to_tsvector('english'::regconfig, content_text));

CREATE INDEX idx_caps_docs_subject ON public.caps_documents USING btree (subject);

CREATE INDEX idx_caps_docs_type ON public.caps_documents USING btree (document_type);

CREATE INDEX idx_caps_docs_year ON public.caps_documents USING btree (year);

CREATE INDEX idx_caps_topics_code ON public.caps_topics USING btree (topic_code);

CREATE INDEX idx_caps_topics_grade_subject ON public.caps_topics USING btree (grade, subject);

CREATE INDEX idx_caps_topics_search ON public.caps_topics USING gin (to_tsvector('english'::regconfig, (((topic_title)::text || ' '::text) || content_outline)));

CREATE INDEX idx_caps_topics_term ON public.caps_topics USING btree (term);

CREATE INDEX idx_chapters_content_search ON public.textbook_chapters USING gin (to_tsvector('english'::regconfig, ((((title || ' '::text) || COALESCE(content_text, ''::text)) || ' '::text) || COALESCE(summary, ''::text))));

CREATE INDEX idx_chapters_pages ON public.textbook_chapters USING btree (page_start, page_end);

CREATE INDEX idx_chapters_textbook ON public.textbook_chapters USING btree (textbook_id);

CREATE INDEX idx_chapters_topics ON public.textbook_chapters USING gin (caps_topics);

CREATE INDEX idx_chat_images_created ON public.chat_images USING btree (created_at DESC);

CREATE INDEX idx_chat_images_hash ON public.chat_images USING btree (hash);

CREATE INDEX idx_chat_images_user ON public.chat_images USING btree (uploaded_by);

CREATE INDEX idx_child_registration_requests_parent_preschool ON public.child_registration_requests USING btree (parent_id, preschool_id);

CREATE INDEX idx_child_registration_requests_status_preschool ON public.child_registration_requests USING btree (preschool_id, status, requested_at DESC);

CREATE INDEX idx_chunks_document ON public.caps_content_chunks USING btree (document_id);

CREATE INDEX idx_chunks_type ON public.caps_content_chunks USING btree (chunk_type);

CREATE INDEX idx_class_events_class_id ON public.class_events USING btree (class_id);

CREATE INDEX idx_class_events_preschool_id ON public.class_events USING btree (preschool_id);

CREATE INDEX idx_class_events_start_time ON public.class_events USING btree (start_time);

CREATE INDEX idx_class_events_status ON public.class_events USING btree (status);

CREATE INDEX idx_class_events_upcoming ON public.class_events USING btree (class_id, start_time) WHERE (status = ANY (ARRAY['scheduled'::text, 'in_progress'::text]));

CREATE INDEX idx_classes_grade_level ON public.classes USING btree (grade_level);

CREATE INDEX idx_classes_org_teacher ON public.classes USING btree (preschool_id, teacher_id) WHERE (preschool_id IS NOT NULL);

CREATE INDEX idx_classes_organization_id ON public.classes USING btree (organization_id);

CREATE INDEX idx_classes_preschool_id ON public.classes USING btree (preschool_id);

CREATE INDEX idx_classes_teacher_id ON public.classes USING btree (teacher_id);

CREATE INDEX idx_classes_teacher_preschool ON public.classes USING btree (teacher_id, preschool_id);

CREATE INDEX idx_classroom_reports_preschool_student ON public.classroom_reports USING btree (preschool_id, student_id);

CREATE INDEX idx_classroom_reports_teacher_date ON public.classroom_reports USING btree (teacher_id, report_date);

CREATE INDEX idx_classroom_reports_type_date ON public.classroom_reports USING btree (report_type, report_date);

CREATE INDEX idx_compliance_reports_generated_by ON public.superadmin_compliance_reports USING btree (generated_by);

CREATE INDEX idx_compliance_reports_status ON public.superadmin_compliance_reports USING btree (status);

CREATE INDEX idx_compliance_reports_type ON public.superadmin_compliance_reports USING btree (report_type);

CREATE INDEX idx_contact_suggestions_expires ON public.contact_suggestions USING btree (expires_at);

CREATE INDEX idx_contact_suggestions_user_id ON public.contact_suggestions USING btree (user_id);

CREATE INDEX idx_content_reports_author ON public.content_reports USING btree (author_id);

CREATE INDEX idx_content_reports_created ON public.content_reports USING btree (created_at);

CREATE INDEX idx_content_reports_school ON public.content_reports USING btree (school_id);

CREATE INDEX idx_content_reports_severity ON public.content_reports USING btree (severity);

CREATE INDEX idx_content_reports_status ON public.content_reports USING btree (status);

CREATE INDEX idx_conversation_members_conv ON public.conversation_members USING btree (conversation_id);

CREATE INDEX idx_conversation_members_user ON public.conversation_members USING btree (user_id);

CREATE INDEX idx_conversations_class ON public.conversations USING btree (class_id);

CREATE INDEX idx_conversations_preschool ON public.conversations USING btree (preschool_id);

CREATE INDEX idx_cost_tracking_preschool ON public.service_cost_tracking USING btree (preschool_id, period_month);

CREATE INDEX idx_cost_tracking_service ON public.service_cost_tracking USING btree (service_name, period_month DESC);

CREATE INDEX idx_course_grades_course_id ON public.course_grades USING btree (course_id);

CREATE INDEX idx_course_grades_final_grade ON public.course_grades USING btree (final_grade);

CREATE INDEX idx_course_grades_published ON public.course_grades USING btree (is_published);

CREATE INDEX idx_course_grades_student_id ON public.course_grades USING btree (student_id);

CREATE INDEX idx_course_join_requests_course_id ON public.course_join_requests USING btree (course_id);

CREATE INDEX idx_course_join_requests_requested_at ON public.course_join_requests USING btree (requested_at);

CREATE INDEX idx_course_join_requests_status ON public.course_join_requests USING btree (status);

CREATE INDEX idx_course_join_requests_student_id ON public.course_join_requests USING btree (student_id);

CREATE INDEX idx_courses_active ON public.courses USING btree (is_active) WHERE (deleted_at IS NULL);

CREATE INDEX idx_courses_dates ON public.courses USING btree (start_date, end_date) WHERE (deleted_at IS NULL);

CREATE INDEX idx_courses_instructor_id ON public.courses USING btree (instructor_id) WHERE (deleted_at IS NULL);

CREATE INDEX idx_courses_join_code ON public.courses USING btree (join_code) WHERE ((join_code IS NOT NULL) AND (deleted_at IS NULL));

CREATE INDEX idx_courses_organization_id ON public.courses USING btree (organization_id) WHERE (deleted_at IS NULL);

CREATE INDEX idx_cv_templates_is_default ON public.cv_templates USING btree (organization_id, is_default) WHERE (is_default = true);

CREATE INDEX idx_cv_templates_organization_id ON public.cv_templates USING btree (organization_id);

CREATE INDEX idx_cv_uploads_org_id ON public.cv_uploads USING btree (organization_id);

CREATE INDEX idx_cv_uploads_processed_at ON public.cv_uploads USING btree (processed_at);

CREATE INDEX idx_cv_uploads_status ON public.cv_uploads USING btree (status);

CREATE INDEX idx_cv_uploads_uploaded_by ON public.cv_uploads USING btree (uploaded_by);

CREATE INDEX idx_daily_activities_class_id ON public.daily_activities USING btree (class_id);

CREATE INDEX idx_daily_activities_created_by ON public.daily_activities USING btree (created_by);

CREATE INDEX idx_daily_activities_date ON public.daily_activities USING btree (activity_date);

CREATE INDEX idx_dash_agent_instances_preschool ON public.dash_agent_instances USING btree (preschool_id, last_active DESC);

CREATE INDEX idx_dash_agent_instances_user ON public.dash_agent_instances USING btree (user_id, last_active DESC);

CREATE INDEX idx_dash_conversation_facts_key ON public.dash_conversation_facts USING btree (key);

CREATE INDEX idx_dash_conversation_facts_preschool ON public.dash_conversation_facts USING btree (preschool_id, created_at DESC);

CREATE INDEX idx_dash_conversation_facts_user ON public.dash_conversation_facts USING btree (user_id, created_at DESC);

CREATE INDEX idx_dash_conversation_facts_value_gin ON public.dash_conversation_facts USING gin (value);

CREATE INDEX idx_dash_reminders_due_active ON public.dash_reminders USING btree (schedule_at) WHERE (status = 'active'::text);

CREATE INDEX idx_dash_reminders_user_status ON public.dash_reminders USING btree (user_id, status);

CREATE INDEX idx_dash_storage_data_type ON public.dash_storage USING btree (data_type);

CREATE INDEX idx_dash_storage_expires_at ON public.dash_storage USING btree (expires_at) WHERE (expires_at IS NOT NULL);

CREATE INDEX idx_dash_storage_key ON public.dash_storage USING btree (storage_key);

CREATE INDEX idx_dash_storage_preschool_user ON public.dash_storage USING btree (preschool_id, user_id);

CREATE INDEX idx_dash_storage_tags ON public.dash_storage USING gin (tags);

CREATE INDEX idx_dash_storage_user_id ON public.dash_storage USING btree (user_id);

CREATE INDEX idx_dash_user_contexts_preschool ON public.dash_user_contexts USING btree (preschool_id);

CREATE INDEX idx_dashboard_voice_notes_created_at ON public.dashboard_voice_notes USING btree (created_at DESC);

CREATE INDEX idx_dashboard_voice_notes_deleted_at ON public.dashboard_voice_notes USING btree (deleted_at) WHERE (deleted_at IS NULL);

CREATE INDEX idx_dashboard_voice_notes_user_id ON public.dashboard_voice_notes USING btree (user_id);

CREATE INDEX idx_deletion_requests_email ON public.deletion_requests USING btree (email);

CREATE INDEX idx_deletion_requests_scheduled ON public.superadmin_user_deletion_requests USING btree (scheduled_for) WHERE (scheduled_for IS NOT NULL);

CREATE INDEX idx_deletion_requests_status ON public.superadmin_user_deletion_requests USING btree (status);

CREATE INDEX idx_deletion_requests_submitted_at ON public.deletion_requests USING btree (submitted_at DESC);

CREATE INDEX idx_deletion_requests_user_id ON public.superadmin_user_deletion_requests USING btree (user_id);

CREATE INDEX idx_delivery_providers_channels ON public.delivery_providers USING gin (supported_channels);

CREATE INDEX idx_delivery_providers_enabled ON public.delivery_providers USING btree (is_enabled) WHERE (is_enabled = true);

CREATE INDEX idx_delivery_providers_name ON public.delivery_providers USING btree (provider_name);

CREATE INDEX idx_delivery_providers_primary ON public.delivery_providers USING btree (is_primary) WHERE (is_primary = true);

CREATE INDEX idx_delivery_retry_queue_delivery_id ON public.delivery_retry_queue USING btree (delivery_id);

CREATE INDEX idx_delivery_retry_queue_scheduled_at ON public.delivery_retry_queue USING btree (scheduled_at);

CREATE INDEX idx_delivery_retry_queue_unprocessed ON public.delivery_retry_queue USING btree (is_processed, scheduled_at) WHERE (is_processed = false);

CREATE INDEX idx_delivery_webhooks_delivery_id ON public.delivery_webhooks USING btree (delivery_id);

CREATE INDEX idx_delivery_webhooks_event_type ON public.delivery_webhooks USING btree (event_type);

CREATE INDEX idx_delivery_webhooks_provider ON public.delivery_webhooks USING btree (provider);

CREATE INDEX idx_delivery_webhooks_unprocessed ON public.delivery_webhooks USING btree (is_processed, received_at) WHERE (is_processed = false);

CREATE INDEX idx_disbursements_org ON public.platform_disbursements USING btree (organization_id);

CREATE INDEX idx_disbursements_scheduled ON public.platform_disbursements USING btree (scheduled_date);

CREATE INDEX idx_disbursements_status ON public.platform_disbursements USING btree (status);

CREATE INDEX idx_doc_access_document ON public.organization_document_access USING btree (document_id);

CREATE INDEX idx_doc_access_user ON public.organization_document_access USING btree (grantee_user_id);

CREATE INDEX idx_doc_audit_action ON public.organization_document_audit_log USING btree (action);

CREATE INDEX idx_doc_audit_document ON public.organization_document_audit_log USING btree (document_id);

CREATE INDEX idx_doc_audit_user ON public.organization_document_audit_log USING btree (user_id);

CREATE INDEX idx_doc_folders_org ON public.organization_document_folders USING btree (organization_id);

CREATE INDEX idx_doc_folders_parent ON public.organization_document_folders USING btree (parent_folder_id);

CREATE INDEX idx_doc_requests_document ON public.organization_document_access_requests USING btree (document_id);

CREATE INDEX idx_doc_requests_requester ON public.organization_document_access_requests USING btree (requester_id);

CREATE INDEX idx_doc_requests_status ON public.organization_document_access_requests USING btree (status);

CREATE INDEX idx_documents_access ON public.organization_documents USING btree (access_level);

CREATE INDEX idx_documents_folder ON public.organization_documents USING btree (folder_id);

CREATE INDEX idx_documents_org ON public.organization_documents USING btree (organization_id);

CREATE INDEX idx_documents_type ON public.organization_documents USING btree (document_type);

CREATE INDEX idx_early_access_created ON public.early_access_signups USING btree (created_at DESC);

CREATE INDEX idx_early_access_email ON public.early_access_signups USING btree (email);

CREATE INDEX idx_email_logs_organization_created ON public.email_logs USING btree (organization_id, created_at DESC);

CREATE INDEX idx_email_logs_status ON public.email_logs USING btree (status);

CREATE INDEX idx_email_logs_user_created ON public.email_logs USING btree (user_id, created_at DESC);

CREATE INDEX idx_email_preferences_email ON public.email_preferences USING btree (email);

CREATE INDEX idx_email_preferences_user ON public.email_preferences USING btree (user_id);

CREATE INDEX idx_email_templates_preschool ON public.email_templates USING btree (preschool_id);

CREATE INDEX idx_email_templates_type ON public.email_templates USING btree (template_type);

CREATE INDEX idx_enrollment_applications_created_at ON public.enrollment_applications USING btree (created_at DESC);

CREATE INDEX idx_enrollment_applications_parent_email ON public.enrollment_applications USING btree (parent_email);

CREATE INDEX idx_enrollment_applications_preschool_status ON public.enrollment_applications USING btree (preschool_id, status);

CREATE INDEX idx_enrollments_active ON public.enrollments USING btree (is_active);

CREATE INDEX idx_enrollments_course_id ON public.enrollments USING btree (course_id);

CREATE INDEX idx_enrollments_enrolled_at ON public.enrollments USING btree (enrolled_at);

CREATE INDEX idx_enrollments_student_id ON public.enrollments USING btree (student_id);

CREATE INDEX idx_error_logs_level ON public.error_logs USING btree (level);

CREATE INDEX idx_error_logs_timestamp ON public.error_logs USING btree ("timestamp" DESC);

CREATE INDEX idx_event_audiences_event ON public.event_audiences USING btree (event_id);

CREATE INDEX idx_event_audiences_event_id ON public.event_audiences USING btree (event_id);

CREATE INDEX idx_event_audiences_target_id ON public.event_audiences USING btree (target_id) WHERE (target_id IS NOT NULL);

CREATE INDEX idx_event_audiences_target_value ON public.event_audiences USING btree (target_value) WHERE (target_value IS NOT NULL);

CREATE INDEX idx_event_audiences_type ON public.event_audiences USING btree (audience_type, target_id);

CREATE UNIQUE INDEX idx_event_audiences_unique_target ON public.event_audiences USING btree (event_id, audience_type, COALESCE((target_id)::text, (target_value)::text));

CREATE INDEX idx_event_invitations_event ON public.event_invitations USING btree (event_id);

CREATE INDEX idx_event_invitations_event_id ON public.event_invitations USING btree (event_id);

CREATE INDEX idx_event_invitations_invitee ON public.event_invitations USING btree (invitee_id);

CREATE INDEX idx_event_invitations_invitee_id ON public.event_invitations USING btree (invitee_id);

CREATE INDEX idx_event_invitations_pending ON public.event_invitations USING btree (invitee_id, status) WHERE ((status)::text = 'pending'::text);

CREATE INDEX idx_event_invitations_status ON public.event_invitations USING btree (status);

CREATE INDEX idx_event_media_event ON public.event_media USING btree (event_id);

CREATE INDEX idx_event_media_update ON public.event_media USING btree (update_id);

CREATE INDEX idx_event_notifications_event ON public.event_notifications USING btree (event_id);

CREATE INDEX idx_event_notifications_recipient ON public.event_notifications USING btree (recipient_id);

CREATE INDEX idx_event_participants_event ON public.event_participants USING btree (event_id);

CREATE INDEX idx_event_participants_user ON public.event_participants USING btree (user_id);

CREATE INDEX idx_event_reactions_event ON public.event_reactions USING btree (event_id);

CREATE INDEX idx_event_reactions_update ON public.event_reactions USING btree (update_id);

CREATE INDEX idx_event_rsvps_event ON public.event_rsvps USING btree (event_id, status);

CREATE INDEX idx_event_updates_author ON public.event_updates USING btree (author_id);

CREATE INDEX idx_event_updates_event ON public.event_updates USING btree (event_id);

CREATE INDEX idx_event_updates_posted ON public.event_updates USING btree (posted_at DESC);

CREATE INDEX idx_events_audience_type ON public.events USING btree (audience_type);

CREATE INDEX idx_events_featured ON public.events USING btree (is_featured) WHERE (is_featured = true);

CREATE INDEX idx_events_org ON public.member_events USING btree (organization_id);

CREATE INDEX idx_events_preschool_date ON public.events USING btree (preschool_id, event_date);

CREATE INDEX idx_events_preschool_status ON public.events USING btree (preschool_id, status);

CREATE INDEX idx_events_preschool_status_filtered ON public.events USING btree (preschool_id, status) WHERE ((preschool_id IS NOT NULL) AND (status IS NOT NULL));

CREATE INDEX idx_events_region ON public.member_events USING btree (region_id);

CREATE INDEX idx_events_requires_approval ON public.events USING btree (requires_approval);

CREATE INDEX idx_events_start ON public.member_events USING btree (start_datetime);

CREATE INDEX idx_events_status ON public.events USING btree (status);

CREATE INDEX idx_events_type ON public.events USING btree (event_type);

CREATE INDEX idx_events_visibility ON public.events USING btree (visibility);

CREATE INDEX idx_exam_assignments_class ON public.exam_assignments USING btree (class_id);

CREATE INDEX idx_exam_assignments_due_date ON public.exam_assignments USING btree (due_date);

CREATE INDEX idx_exam_assignments_status ON public.exam_assignments USING btree (status);

CREATE INDEX idx_exam_assignments_student_ids ON public.exam_assignments USING gin (student_ids);

CREATE INDEX idx_exam_assignments_teacher ON public.exam_assignments USING btree (teacher_id);

CREATE INDEX idx_exam_attempts_completed ON public.exam_attempts USING btree (completed_at) WHERE (completed_at IS NOT NULL);

CREATE INDEX idx_exam_attempts_exam ON public.exam_attempts USING btree (exam_paper_id);

CREATE INDEX idx_exam_attempts_student ON public.exam_attempts USING btree (student_id);

CREATE INDEX idx_exam_attempts_user ON public.exam_attempts USING btree (user_id);

CREATE INDEX idx_exam_generations_grade_subject ON public.exam_generations USING btree (grade, subject);

CREATE INDEX idx_exam_generations_model ON public.exam_generations USING btree (model_used, created_at DESC);

CREATE INDEX idx_exam_generations_status ON public.exam_generations USING btree (status, created_at DESC);

CREATE INDEX idx_exam_generations_user ON public.exam_generations USING btree (user_id, created_at DESC);

CREATE INDEX idx_exam_papers_difficulty ON public.exam_papers USING btree (difficulty_level);

CREATE INDEX idx_exam_papers_grade ON public.exam_papers USING btree (grade);

CREATE INDEX idx_exam_papers_grade_year ON public.exam_papers USING btree (grade, year);

CREATE INDEX idx_exam_papers_search ON public.exam_papers USING gin (search_vector);

CREATE INDEX idx_exam_papers_subject ON public.exam_papers USING btree (subject);

CREATE INDEX idx_exam_papers_topics ON public.exam_papers USING gin (topics);

CREATE INDEX idx_exam_papers_year ON public.exam_papers USING btree (year);

CREATE INDEX idx_exam_papers_year_subject ON public.exam_papers USING btree (year, subject);

CREATE INDEX idx_exam_q_difficulty ON public.caps_exam_questions USING btree (difficulty);

CREATE INDEX idx_exam_q_grade_subject ON public.caps_exam_questions USING btree (grade, subject);

CREATE INDEX idx_exam_q_topic ON public.caps_exam_questions USING btree (topic);

CREATE INDEX idx_exam_q_year ON public.caps_exam_questions USING btree (year);

CREATE INDEX idx_exam_submissions_assignment ON public.exam_submissions USING btree (assignment_id);

CREATE INDEX idx_exam_submissions_status ON public.exam_submissions USING btree (status);

CREATE INDEX idx_exam_submissions_student ON public.exam_submissions USING btree (student_id);

CREATE INDEX idx_exam_submissions_submitted_at ON public.exam_submissions USING btree (submitted_at);

CREATE INDEX idx_exam_user_progress_generation ON public.exam_user_progress USING btree (exam_generation_id);

CREATE INDEX idx_exam_user_progress_user ON public.exam_user_progress USING btree (user_id, created_at DESC);

CREATE INDEX idx_expense_categories_active ON public.expense_categories USING btree (is_active);

CREATE INDEX idx_expense_categories_preschool_id ON public.expense_categories USING btree (preschool_id);

CREATE INDEX idx_fee_payments_assignment ON public.fee_payments USING btree (student_fee_assignment_id);

CREATE INDEX idx_fee_payments_date ON public.fee_payments USING btree (payment_date DESC);

CREATE INDEX idx_fee_payments_payfast_id ON public.fee_payments USING btree (payfast_payment_id) WHERE (payfast_payment_id IS NOT NULL);

CREATE INDEX idx_fee_payments_preschool ON public.fee_payments USING btree (preschool_id);

CREATE INDEX idx_fee_payments_status ON public.fee_payments USING btree (status);

CREATE INDEX idx_fee_payments_student ON public.fee_payments USING btree (student_id);

CREATE INDEX idx_fee_structure_active ON public.membership_fee_structure USING btree (is_active);

CREATE INDEX idx_fee_structure_org ON public.membership_fee_structure USING btree (organization_id);

CREATE INDEX idx_fee_structure_type ON public.membership_fee_structure USING btree (fee_type);

CREATE INDEX idx_fee_structures_active ON public.fee_structures USING btree (is_active);

CREATE INDEX idx_fee_structures_preschool_id ON public.fee_structures USING btree (preschool_id);

CREATE INDEX idx_fee_structures_type ON public.fee_structures USING btree (fee_type);

CREATE INDEX idx_financial_transactions_amount ON public.financial_transactions USING btree (amount);

CREATE INDEX idx_financial_transactions_created_at ON public.financial_transactions USING btree (created_at DESC);

CREATE INDEX idx_financial_transactions_preschool_created ON public.financial_transactions USING btree (preschool_id, created_by);

CREATE INDEX idx_financial_transactions_preschool_id ON public.financial_transactions USING btree (preschool_id);

CREATE INDEX idx_financial_transactions_preschool_tenant ON public.financial_transactions USING btree (preschool_id);

CREATE INDEX idx_financial_transactions_status ON public.financial_transactions USING btree (status);

CREATE INDEX idx_financial_transactions_student_id ON public.financial_transactions USING btree (student_id);

CREATE INDEX idx_financial_transactions_type ON public.financial_transactions USING btree (type);

CREATE INDEX idx_gradebook_entries_course_id ON public.gradebook_entries USING btree (course_id);

CREATE INDEX idx_gradebook_entries_percentage ON public.gradebook_entries USING btree (current_percentage);

CREATE INDEX idx_gradebook_entries_student_id ON public.gradebook_entries USING btree (student_id);

CREATE INDEX idx_grades_created_at ON public.grades USING btree (created_at);

CREATE INDEX idx_grades_graded_by ON public.grades USING btree (graded_by);

CREATE INDEX idx_grades_is_published ON public.grades USING btree (is_published);

CREATE INDEX idx_grades_organization_id ON public.grades USING btree (organization_id);

CREATE INDEX idx_grades_submission ON public.assignment_grades USING btree (submission_id);

CREATE INDEX idx_grades_submission_id ON public.grades USING btree (submission_id);

CREATE INDEX idx_grades_teacher_status ON public.assignment_grades USING btree (teacher_id, status);

CREATE INDEX idx_group_invitations_expires ON public.group_invitations USING btree (expires_at) WHERE ((status)::text = 'pending'::text);

CREATE INDEX idx_group_invitations_group ON public.group_invitations USING btree (group_id);

CREATE INDEX idx_group_invitations_group_id ON public.group_invitations USING btree (group_id);

CREATE INDEX idx_group_invitations_invitee ON public.group_invitations USING btree (invitee_id);

CREATE INDEX idx_group_invitations_invitee_id ON public.group_invitations USING btree (invitee_id);

CREATE INDEX idx_group_invitations_status ON public.group_invitations USING btree (status);

CREATE INDEX idx_group_members_group ON public.group_members USING btree (group_id);

CREATE INDEX idx_group_members_group_id ON public.group_members USING btree (group_id);

CREATE INDEX idx_group_members_role ON public.group_members USING btree (role_in_group);

CREATE INDEX idx_group_members_status ON public.group_members USING btree (status);

CREATE INDEX idx_group_members_user ON public.group_members USING btree (user_id);

CREATE INDEX idx_group_members_user_id ON public.group_members USING btree (user_id);

CREATE INDEX idx_groups_active ON public.groups USING btree (is_active);

CREATE INDEX idx_groups_course_id ON public.groups USING btree (course_id);

CREATE INDEX idx_groups_created_by ON public.groups USING btree (created_by);

CREATE INDEX idx_groups_organization_id ON public.groups USING btree (organization_id);

CREATE INDEX idx_guardian_requests_duplicate_check ON public.guardian_requests USING btree (parent_auth_id, student_id, status) WHERE (status = ANY (ARRAY['pending'::text, 'approved'::text]));

CREATE UNIQUE INDEX idx_guardian_requests_no_duplicate_pending ON public.guardian_requests USING btree (parent_auth_id, student_id) WHERE (status = 'pending'::text);

CREATE INDEX idx_guardian_requests_parent ON public.guardian_requests USING btree (parent_auth_id);

CREATE INDEX idx_guardian_requests_parent_status ON public.guardian_requests USING btree (parent_auth_id, status);

CREATE INDEX idx_guardian_requests_school ON public.guardian_requests USING btree (school_id);

CREATE INDEX idx_guardian_requests_school_status ON public.guardian_requests USING btree (school_id, status, created_at DESC);

CREATE INDEX idx_guardian_requests_student ON public.guardian_requests USING btree (student_id);

CREATE INDEX idx_guest_usage_created ON public.guest_usage_log USING btree (created_at DESC);

CREATE INDEX idx_guest_usage_ip_date ON public.guest_usage_log USING btree (ip_address, created_at DESC);

CREATE INDEX idx_homework_activity_log_assignment ON public.homework_activity_log USING btree (assignment_id);

CREATE INDEX idx_homework_activity_log_preschool ON public.homework_activity_log USING btree (preschool_id, created_at DESC);

CREATE INDEX idx_homework_activity_log_submission ON public.homework_activity_log USING btree (submission_id) WHERE (submission_id IS NOT NULL);

CREATE INDEX idx_homework_assignment_targets_assignment ON public.homework_assignment_targets USING btree (assignment_id);

CREATE INDEX idx_homework_assignment_targets_class ON public.homework_assignment_targets USING btree (class_id) WHERE (class_id IS NOT NULL);

CREATE INDEX idx_homework_assignment_targets_status ON public.homework_assignment_targets USING btree (status);

CREATE INDEX idx_homework_assignment_targets_student ON public.homework_assignment_targets USING btree (student_id) WHERE (student_id IS NOT NULL);

CREATE INDEX idx_homework_assignments_class_id ON public.homework_assignments USING btree (class_id);

CREATE INDEX idx_homework_assignments_grade_band ON public.homework_assignments USING btree (grade_band);

CREATE INDEX idx_homework_assignments_preschool_id ON public.homework_assignments USING btree (preschool_id);

CREATE INDEX idx_homework_assignments_preschool_tenant ON public.homework_assignments USING btree (preschool_id);

CREATE INDEX idx_homework_assignments_status ON public.homework_assignments USING btree (status);

CREATE INDEX idx_homework_assignments_subject ON public.homework_assignments USING btree (subject);

CREATE INDEX idx_homework_assignments_teacher ON public.homework_assignments USING btree (teacher_id, preschool_id);

CREATE INDEX idx_homework_assignments_teacher_id ON public.homework_assignments USING btree (teacher_id);

CREATE INDEX idx_homework_notifications_assignment ON public.homework_notifications USING btree (assignment_id);

CREATE INDEX idx_homework_notifications_parent ON public.homework_notifications USING btree (parent_id) WHERE (parent_id IS NOT NULL);

CREATE INDEX idx_homework_notifications_status ON public.homework_notifications USING btree (status);

CREATE INDEX idx_homework_submissions_ai_grade_id ON public.homework_submissions USING btree (ai_grade_id) WHERE (ai_grade_id IS NOT NULL);

CREATE INDEX idx_homework_submissions_assignment_id ON public.homework_submissions USING btree (homework_assignment_id);

CREATE INDEX idx_homework_submissions_homework_assignment_id ON public.homework_submissions USING btree (homework_assignment_id);

CREATE INDEX idx_homework_submissions_status ON public.homework_submissions USING btree (status);

CREATE INDEX idx_homework_submissions_student_id ON public.homework_submissions USING btree (student_id);

CREATE INDEX idx_homework_submissions_submitted_by ON public.homework_submissions USING btree (submitted_by) WHERE (submitted_by IS NOT NULL);

CREATE INDEX idx_id_cards_member ON public.member_id_cards USING btree (member_id);

CREATE INDEX idx_id_cards_org ON public.member_id_cards USING btree (organization_id);

CREATE INDEX idx_id_cards_qr ON public.member_id_cards USING btree (qr_code_data);

CREATE INDEX idx_id_cards_status ON public.member_id_cards USING btree (status);

CREATE INDEX idx_in_app_notifications_read ON public.in_app_notifications USING btree (user_id, read);

CREATE INDEX idx_in_app_notifications_type ON public.in_app_notifications USING btree (type);

CREATE INDEX idx_in_app_notifications_user ON public.in_app_notifications USING btree (user_id);

CREATE INDEX idx_incidents_ongoing ON public.service_incidents USING btree (status) WHERE (status = 'ongoing'::text);

CREATE INDEX idx_incidents_service ON public.service_incidents USING btree (service_name, started_at DESC);

CREATE INDEX idx_integration_audit_created_at ON public.integration_audit_log USING btree (created_at DESC);

CREATE INDEX idx_integration_audit_log_preschool ON public.integration_audit_log USING btree (preschool_id);

CREATE INDEX idx_integration_audit_preschool ON public.integration_audit_log USING btree (preschool_id);

CREATE INDEX idx_integration_audit_type_action ON public.integration_audit_log USING btree (integration_type, action);

CREATE INDEX idx_integration_audit_user ON public.integration_audit_log USING btree (user_id);

CREATE INDEX idx_interactive_activities_activity_type ON public.interactive_activities USING btree (activity_type);

CREATE INDEX idx_interactive_activities_age ON public.interactive_activities USING btree (age_group_min, age_group_max);

CREATE INDEX idx_interactive_activities_difficulty ON public.interactive_activities USING btree (difficulty_level);

CREATE INDEX idx_interactive_activities_preschool ON public.interactive_activities USING btree (preschool_id);

CREATE INDEX idx_interactive_activities_published ON public.interactive_activities USING btree (is_published) WHERE (is_published = true);

CREATE INDEX idx_interactive_activities_stem_category ON public.interactive_activities USING btree (stem_category) WHERE (stem_category IS NOT NULL);

CREATE INDEX idx_interactive_activities_subject ON public.interactive_activities USING btree (subject);

CREATE INDEX idx_interactive_activities_type ON public.interactive_activities USING btree (activity_type);

CREATE INDEX idx_interview_schedules_application ON public.interview_schedules USING btree (application_id, interview_date DESC);

CREATE INDEX idx_interview_schedules_date ON public.interview_schedules USING btree (interview_date, interview_time) WHERE (status = 'scheduled'::text);

CREATE INDEX idx_invitations_code ON public.invitations USING btree (code);

CREATE INDEX idx_invitations_code_status ON public.invitations USING btree (code, status) WHERE (status = 'pending'::text);

CREATE INDEX idx_invitations_email ON public.invitations USING btree (email);

CREATE INDEX idx_invitations_organization_id ON public.invitations USING btree (organization_id);

CREATE INDEX idx_invitations_status ON public.invitations USING btree (status);

CREATE INDEX idx_invite_logs_created_at ON public.invite_logs USING btree (created_at DESC);

CREATE INDEX idx_invite_logs_invite_link ON public.invite_logs USING btree (invite_link);

CREATE INDEX idx_invite_logs_preschool_id ON public.invite_logs USING btree (preschool_id);

CREATE INDEX idx_invite_logs_recipient_phone ON public.invite_logs USING btree (recipient_phone);

CREATE INDEX idx_invite_logs_sender_id ON public.invite_logs USING btree (sender_id);

CREATE INDEX idx_invite_logs_status ON public.invite_logs USING btree (status);

CREATE INDEX idx_invoice_audit_log_invoice_id ON public.invoice_audit_log USING btree (invoice_id);

CREATE INDEX idx_invoice_items_invoice_id ON public.invoice_items USING btree (invoice_id);

CREATE INDEX idx_invoice_payments_invoice_id ON public.invoice_payments USING btree (invoice_id);

CREATE INDEX idx_invoice_payments_payment_date ON public.invoice_payments USING btree (payment_date DESC);

CREATE INDEX idx_invoice_templates_is_default ON public.invoice_templates USING btree (preschool_id, is_default) WHERE (is_default = true);

CREATE INDEX idx_invoice_templates_preschool_id ON public.invoice_templates USING btree (preschool_id);

CREATE INDEX idx_invoices_due_date ON public.invoices USING btree (preschool_id, due_date);

CREATE INDEX idx_invoices_issue_date ON public.invoices USING btree (preschool_id, issue_date DESC);

CREATE INDEX idx_invoices_member ON public.member_invoices USING btree (member_id);

CREATE INDEX idx_invoices_org ON public.member_invoices USING btree (organization_id);

CREATE INDEX idx_invoices_payment_status ON public.invoices USING btree (preschool_id, payment_status);

CREATE INDEX idx_invoices_preschool_id ON public.invoices USING btree (preschool_id);

CREATE INDEX idx_invoices_preschool_student ON public.invoices USING btree (preschool_id, student_id);

CREATE INDEX idx_invoices_preschool_tenant ON public.invoices USING btree (preschool_id);

CREATE INDEX idx_invoices_status ON public.invoices USING btree (preschool_id, status);

CREATE INDEX idx_invoices_student_id ON public.invoices USING btree (student_id);

CREATE INDEX idx_job_alerts_candidate ON public.job_alerts USING btree (candidate_profile_id);

CREATE INDEX idx_job_alerts_enabled ON public.job_alerts USING btree (notification_enabled) WHERE (notification_enabled = true);

CREATE INDEX idx_job_applications_candidate ON public.job_applications USING btree (candidate_profile_id, applied_at DESC);

CREATE INDEX idx_job_applications_posting_status ON public.job_applications USING btree (job_posting_id, status, applied_at DESC);

CREATE INDEX idx_job_applications_status ON public.job_applications USING btree (status, applied_at DESC);

CREATE INDEX idx_job_distributions_channel ON public.job_distributions USING btree (channel, distributed_at DESC);

CREATE INDEX idx_job_distributions_posting ON public.job_distributions USING btree (job_posting_id, distributed_at DESC);

CREATE INDEX idx_job_postings_expires ON public.job_postings USING btree (expires_at) WHERE (expires_at IS NOT NULL);

CREATE INDEX idx_job_postings_location ON public.job_postings USING gist (public.ll_to_earth((latitude)::double precision, (longitude)::double precision)) WHERE ((latitude IS NOT NULL) AND (longitude IS NOT NULL) AND (status = 'active'::text));

CREATE INDEX idx_job_postings_preschool_status ON public.job_postings USING btree (preschool_id, status, created_at DESC);

CREATE INDEX idx_job_postings_status ON public.job_postings USING btree (status) WHERE (status = 'active'::text);

CREATE INDEX idx_join_requests_expires_at ON public.join_requests USING btree (expires_at) WHERE (status = 'pending'::public.join_request_status);

CREATE INDEX idx_join_requests_invite_code ON public.join_requests USING btree (invite_code) WHERE (invite_code IS NOT NULL);

CREATE INDEX idx_join_requests_invite_token ON public.join_requests USING btree (invite_token) WHERE (invite_token IS NOT NULL);

CREATE INDEX idx_join_requests_organization_id ON public.join_requests USING btree (organization_id);

CREATE INDEX idx_join_requests_preschool_id ON public.join_requests USING btree (preschool_id);

CREATE INDEX idx_join_requests_region_id ON public.join_requests USING btree (region_id);

CREATE INDEX idx_join_requests_requester_email ON public.join_requests USING btree (requester_email) WHERE (requester_email IS NOT NULL);

CREATE INDEX idx_join_requests_requester_id ON public.join_requests USING btree (requester_id) WHERE (requester_id IS NOT NULL);

CREATE INDEX idx_join_requests_status ON public.join_requests USING btree (status);

CREATE INDEX idx_join_requests_type_status ON public.join_requests USING btree (request_type, status);

CREATE INDEX idx_learner_connections_connection_id ON public.learner_connections USING btree (connection_id);

CREATE INDEX idx_learner_connections_learner_id ON public.learner_connections USING btree (learner_id);

CREATE INDEX idx_learner_connections_status ON public.learner_connections USING btree (status);

CREATE INDEX idx_learner_cvs_is_primary ON public.learner_cvs USING btree (learner_id, is_primary) WHERE (is_primary = true);

CREATE INDEX idx_learner_cvs_learner_id ON public.learner_cvs USING btree (learner_id);

CREATE INDEX idx_lesson_activities_lesson_order ON public.lesson_activities USING btree (lesson_id, order_index);

CREATE INDEX idx_lesson_approvals_lesson ON public.lesson_approvals USING btree (lesson_id);

CREATE INDEX idx_lesson_approvals_preschool ON public.lesson_approvals USING btree (preschool_id);

CREATE INDEX idx_lesson_approvals_status ON public.lesson_approvals USING btree (status);

CREATE INDEX idx_lesson_assignments_interactive_activity ON public.lesson_assignments USING btree (interactive_activity_id) WHERE (interactive_activity_id IS NOT NULL);

CREATE INDEX idx_lesson_assignments_lesson_type ON public.lesson_assignments USING btree (lesson_type);

CREATE INDEX idx_lesson_assignments_stem_category ON public.lesson_assignments USING btree (stem_category);

CREATE INDEX idx_lessons_age_group ON public.lessons USING btree (age_group);

CREATE INDEX idx_lessons_completion_count ON public.lessons USING btree (completion_count);

CREATE INDEX idx_lessons_is_featured ON public.lessons USING btree (is_featured);

CREATE INDEX idx_lessons_preschool_id ON public.lessons USING btree (preschool_id);

CREATE INDEX idx_lessons_preschool_tenant ON public.lessons USING btree (preschool_id);

CREATE INDEX idx_lessons_rating ON public.lessons USING btree (rating);

CREATE INDEX idx_lessons_status ON public.lessons USING btree (status);

CREATE INDEX idx_lessons_status_public_created ON public.lessons USING btree (status, is_public, created_at DESC);

CREATE INDEX idx_lessons_subject ON public.lessons USING btree (subject);

CREATE INDEX idx_lessons_teacher ON public.lessons USING btree (teacher_id, preschool_id);

CREATE INDEX idx_mapping_caps_topic ON public.caps_textbook_mapping USING btree (caps_topic_id);

CREATE INDEX idx_mapping_status ON public.caps_textbook_mapping USING btree (status);

CREATE INDEX idx_mapping_textbook_content ON public.caps_textbook_mapping USING btree (textbook_content_id);

CREATE INDEX idx_mapping_verified ON public.caps_textbook_mapping USING btree (verification_date) WHERE ((status)::text = 'verified'::text);

CREATE INDEX idx_meeting_participants_session_user ON public.meeting_participants USING btree (session_id, user_id);

CREATE INDEX idx_meeting_participants_user_status ON public.meeting_participants USING btree (user_id, invitation_status, created_at);

CREATE INDEX idx_meeting_sessions_room_status ON public.meeting_sessions USING btree (room_id, status, scheduled_start);

CREATE INDEX idx_member_fees_due_date ON public.member_fees USING btree (due_date);

CREATE INDEX idx_member_fees_member ON public.member_fees USING btree (member_id);

CREATE INDEX idx_member_fees_org ON public.member_fees USING btree (organization_id);

CREATE INDEX idx_member_fees_status ON public.member_fees USING btree (status);

CREATE INDEX idx_member_fees_type ON public.member_fees USING btree (fee_type);

CREATE INDEX idx_membership_pop_fee ON public.membership_pop_uploads USING btree (member_fee_id);

CREATE INDEX idx_membership_pop_member ON public.membership_pop_uploads USING btree (member_id);

CREATE INDEX idx_membership_pop_org ON public.membership_pop_uploads USING btree (organization_id);

CREATE INDEX idx_membership_pop_status ON public.membership_pop_uploads USING btree (status);

CREATE INDEX idx_memory_grade_subject ON public.dash_curriculum_memory USING btree (grade, subject);

CREATE INDEX idx_memory_topic ON public.dash_curriculum_memory USING btree (topic);

CREATE INDEX idx_memory_type ON public.dash_curriculum_memory USING btree (memory_type);

CREATE INDEX idx_memory_usefulness ON public.dash_curriculum_memory USING btree (usefulness_score DESC);

CREATE INDEX idx_message_participants_thread_id ON public.message_participants USING btree (thread_id);

CREATE INDEX idx_message_participants_user_id ON public.message_participants USING btree (user_id);

CREATE INDEX idx_message_reactions_message ON public.message_reactions USING btree (message_id);

CREATE INDEX idx_message_reactions_user ON public.message_reactions USING btree (user_id);

CREATE INDEX idx_message_recipients_is_read ON public.message_recipients USING btree (is_read);

CREATE INDEX idx_message_recipients_message_id ON public.message_recipients USING btree (message_id);

CREATE INDEX idx_message_recipients_not_archived ON public.message_recipients USING btree (recipient_id) WHERE (is_archived = false);

CREATE INDEX idx_message_recipients_recipient_id ON public.message_recipients USING btree (recipient_id);

CREATE INDEX idx_message_recipients_unread ON public.message_recipients USING btree (recipient_id) WHERE (is_read = false);

CREATE INDEX idx_message_recipients_unread_announcements ON public.message_recipients USING btree (recipient_id, is_read) WHERE (is_read = false);

CREATE INDEX idx_message_threads_class_id ON public.message_threads USING btree (class_id) WHERE (class_id IS NOT NULL);

CREATE INDEX idx_message_threads_group_type ON public.message_threads USING btree (group_type) WHERE (group_type IS NOT NULL);

CREATE INDEX idx_message_threads_is_group ON public.message_threads USING btree (is_group) WHERE (is_group = true);

CREATE INDEX idx_message_threads_last_message_at ON public.message_threads USING btree (last_message_at DESC);

CREATE INDEX idx_message_threads_preschool_id ON public.message_threads USING btree (preschool_id);

CREATE INDEX idx_message_threads_student_id ON public.message_threads USING btree (student_id);

CREATE INDEX idx_messages_created ON public.ai_messages USING btree (created_at DESC);

CREATE INDEX idx_messages_delivered_at ON public.messages USING btree (delivered_at) WHERE (delivered_at IS NOT NULL);

CREATE INDEX idx_messages_read_by ON public.messages USING gin (read_by);

CREATE INDEX idx_messages_reply_to ON public.messages USING btree (reply_to_id) WHERE (reply_to_id IS NOT NULL);

CREATE INDEX idx_messages_sender_id ON public.messages USING btree (sender_id);

CREATE INDEX idx_messages_thread_id_created_at ON public.messages USING btree (thread_id, created_at DESC);

CREATE INDEX idx_messages_user ON public.ai_messages USING btree (user_id, created_at DESC);

CREATE INDEX idx_messages_voice ON public.messages USING btree (thread_id, created_at DESC) WHERE (voice_url IS NOT NULL);

CREATE INDEX idx_moderation_actions_created ON public.moderation_actions USING btree (created_at);

CREATE INDEX idx_moderation_actions_moderator ON public.moderation_actions USING btree (moderator_id);

CREATE INDEX idx_moderation_actions_queue ON public.moderation_actions USING btree (queue_item_id);

CREATE INDEX idx_moderation_queue_flagged ON public.moderation_queue USING btree (flagged_at);

CREATE INDEX idx_moderation_queue_priority ON public.moderation_queue USING btree (priority);

CREATE INDEX idx_moderation_queue_school ON public.moderation_queue USING btree (school_id);

CREATE INDEX idx_moderation_queue_severity ON public.moderation_queue USING btree (severity);

CREATE INDEX idx_moderation_queue_status ON public.moderation_queue USING btree (status);

CREATE INDEX idx_newsletter_recipients_email ON public.newsletter_recipients USING btree (email);

CREATE INDEX idx_newsletter_recipients_newsletter ON public.newsletter_recipients USING btree (newsletter_id);

CREATE INDEX idx_newsletter_recipients_user ON public.newsletter_recipients USING btree (user_id);

CREATE INDEX idx_newsletters_preschool ON public.newsletters USING btree (preschool_id);

CREATE INDEX idx_newsletters_scheduled ON public.newsletters USING btree (scheduled_for);

CREATE INDEX idx_newsletters_status ON public.newsletters USING btree (status);

CREATE INDEX idx_notification_deliveries_method ON public.superadmin_notification_deliveries USING btree (method);

CREATE INDEX idx_notification_deliveries_notification_id ON public.superadmin_notification_deliveries USING btree (notification_id);

CREATE INDEX idx_notification_deliveries_status ON public.superadmin_notification_deliveries USING btree (status);

CREATE INDEX idx_notification_deliveries_v2_channel ON public.notification_deliveries USING btree (channel);

CREATE INDEX idx_notification_deliveries_v2_created_at ON public.notification_deliveries USING btree (created_at);

CREATE INDEX idx_notification_deliveries_v2_notification_id ON public.notification_deliveries USING btree (notification_id);

CREATE INDEX idx_notification_deliveries_v2_provider_id ON public.notification_deliveries USING btree (provider_id);

CREATE INDEX idx_notification_deliveries_v2_recipient_id ON public.notification_deliveries USING btree (recipient_id);

CREATE INDEX idx_notification_deliveries_v2_send_at ON public.notification_deliveries USING btree (send_at);

CREATE INDEX idx_notification_deliveries_v2_status ON public.notification_deliveries USING btree (status);

CREATE INDEX idx_notification_deliveries_v2_status_retry ON public.notification_deliveries USING btree (status, next_retry_at) WHERE ((status = ANY (ARRAY['failed'::public.delivery_status_enum, 'pending'::public.delivery_status_enum])) AND (next_retry_at IS NOT NULL));

CREATE INDEX idx_notification_deliveries_v2_template_id ON public.notification_deliveries USING btree (template_id);

CREATE INDEX idx_notification_logs_created_at ON public.notification_logs USING btree (created_at DESC);

CREATE INDEX idx_notification_logs_type ON public.notification_logs USING btree (type);

CREATE INDEX idx_notification_templates_category ON public.notification_templates USING btree (category);

CREATE INDEX idx_notification_templates_key ON public.notification_templates USING btree (template_key);

CREATE INDEX idx_notification_templates_language ON public.notification_templates USING btree (language);

CREATE INDEX idx_notification_templates_localization ON public.notification_templates USING btree (localization_key) WHERE (localization_key IS NOT NULL);

CREATE INDEX idx_notification_templates_status ON public.notification_templates USING btree (status);

CREATE INDEX idx_notification_templates_system ON public.notification_templates USING btree (is_system_template) WHERE (is_system_template = true);

CREATE INDEX idx_notifications_admin_id ON public.superadmin_notifications USING btree (admin_id);

CREATE INDEX idx_notifications_created_at ON public.superadmin_notifications USING btree (created_at);

CREATE INDEX idx_notifications_expires_at ON public.superadmin_notifications USING btree (expires_at);

CREATE INDEX idx_notifications_preschool ON public.notifications USING btree (preschool_id, created_at DESC);

CREATE INDEX idx_notifications_severity ON public.superadmin_notifications USING btree (severity);

CREATE INDEX idx_notifications_status ON public.superadmin_notifications USING btree (status);

CREATE INDEX idx_notifications_type ON public.notifications USING btree (type) WHERE (type = 'message'::text);

CREATE INDEX idx_notifications_user_read ON public.notifications USING btree (user_id, is_read) WHERE (is_read = false);

CREATE INDEX idx_oauth_tokens_expires_at ON public.oauth_tokens USING btree (expires_at);

CREATE INDEX idx_oauth_tokens_preschool ON public.oauth_tokens USING btree (preschool_id);

CREATE INDEX idx_oauth_tokens_user_provider ON public.oauth_tokens USING btree (user_id, provider);

CREATE INDEX idx_offer_letters_application ON public.offer_letters USING btree (application_id);

CREATE INDEX idx_offer_letters_status ON public.offer_letters USING btree (status, generated_at DESC);

CREATE INDEX idx_onboarding_progress_flow_type ON public.onboarding_progress USING btree (flow_type, current_step);

CREATE INDEX idx_onboarding_progress_school_id ON public.onboarding_progress USING btree (school_id);

CREATE INDEX idx_onboarding_requests_admin_email ON public.preschool_onboarding_requests USING btree (admin_email);

CREATE INDEX idx_onboarding_requests_created_at ON public.preschool_onboarding_requests USING btree (created_at);

CREATE INDEX idx_onboarding_requests_status ON public.preschool_onboarding_requests USING btree (status);

CREATE INDEX idx_org_announcements_author ON public.organization_announcements USING btree (author_id);

CREATE INDEX idx_org_announcements_org_id ON public.organization_announcements USING btree (organization_id);

CREATE INDEX idx_org_announcements_published ON public.organization_announcements USING btree (is_published, published_at DESC);

CREATE INDEX idx_org_announcements_region ON public.organization_announcements USING btree (target_region_id) WHERE (target_region_id IS NOT NULL);

CREATE INDEX idx_org_announcements_target ON public.organization_announcements USING btree (target_audience);

CREATE INDEX idx_org_dash_features_age_group ON public.org_dashboard_features USING btree (age_group);

CREATE INDEX idx_org_dash_features_enabled ON public.org_dashboard_features USING btree (enabled) WHERE (enabled = true);

CREATE INDEX idx_org_dash_features_lookup ON public.org_dashboard_features USING btree (org_type, role, age_group, feature_key);

CREATE INDEX idx_org_dash_features_org_type ON public.org_dashboard_features USING btree (org_type);

CREATE INDEX idx_org_dash_features_role ON public.org_dashboard_features USING btree (role);

CREATE UNIQUE INDEX idx_org_dash_features_unique_no_age ON public.org_dashboard_features USING btree (org_type, role, feature_key) WHERE (age_group IS NULL);

CREATE UNIQUE INDEX idx_org_dash_features_unique_with_age ON public.org_dashboard_features USING btree (org_type, role, age_group, feature_key) WHERE (age_group IS NOT NULL);

CREATE INDEX idx_org_invites_email_status ON public.org_invites USING btree (email, status);

CREATE INDEX idx_org_members_appointed_by ON public.organization_members USING btree (appointed_by);

CREATE INDEX idx_org_members_birth_year ON public.organization_members USING btree (birth_year);

CREATE INDEX idx_org_members_email ON public.organization_members USING btree (email);

CREATE UNIQUE INDEX idx_org_members_id_number_unique ON public.organization_members USING btree (id_number) WHERE ((id_number IS NOT NULL) AND ((id_number)::text <> ''::text));

CREATE INDEX idx_org_members_member_number ON public.organization_members USING btree (member_number);

CREATE INDEX idx_org_members_member_type ON public.organization_members USING btree (member_type);

CREATE INDEX idx_org_members_membership_status ON public.organization_members USING btree (membership_status);

CREATE INDEX idx_org_members_membership_tier ON public.organization_members USING btree (membership_tier);

CREATE INDEX idx_org_members_org_id ON public.organization_members USING btree (organization_id);

CREATE INDEX idx_org_members_region ON public.organization_members USING btree (region_id);

CREATE INDEX idx_org_members_role ON public.organization_members USING btree (role);

CREATE INDEX idx_org_members_seat_status ON public.organization_members USING btree (seat_status);

CREATE INDEX idx_org_members_user_id ON public.organization_members USING btree (user_id);

CREATE INDEX idx_org_members_user_org_status ON public.organization_members USING btree (user_id, organization_id, seat_status);

CREATE INDEX idx_org_members_wing ON public.organization_members USING btree (wing);

CREATE INDEX idx_org_regions_code ON public.organization_regions USING btree (code);

CREATE INDEX idx_org_regions_org_id ON public.organization_regions USING btree (organization_id);

CREATE INDEX idx_org_transactions_account ON public.organization_transactions USING btree (account_id);

CREATE INDEX idx_org_transactions_category ON public.organization_transactions USING btree (category);

CREATE INDEX idx_org_transactions_date ON public.organization_transactions USING btree (created_at);

CREATE INDEX idx_org_transactions_member ON public.organization_transactions USING btree (member_id);

CREATE INDEX idx_org_transactions_org ON public.organization_transactions USING btree (organization_id);

CREATE INDEX idx_org_transactions_payment_date ON public.organization_transactions USING btree (payment_date);

CREATE INDEX idx_org_transactions_region ON public.organization_transactions USING btree (region_id);

CREATE INDEX idx_org_transactions_status ON public.organization_transactions USING btree (status);

CREATE INDEX idx_org_transactions_type ON public.organization_transactions USING btree (transaction_type);

CREATE INDEX idx_org_transactions_wing ON public.organization_transactions USING btree (wing_id);

CREATE INDEX idx_org_wings_code ON public.organization_wings USING btree (wing_code);

CREATE INDEX idx_org_wings_organization ON public.organization_wings USING btree (organization_id);

CREATE INDEX idx_org_wings_president ON public.organization_wings USING btree (president_id);

CREATE INDEX idx_organization_roles_hierarchy ON public.organization_roles USING btree (hierarchy_level);

CREATE INDEX idx_organization_roles_org_id ON public.organization_roles USING btree (organization_id);

CREATE INDEX idx_organization_roles_role_id ON public.organization_roles USING btree (role_id);

CREATE INDEX idx_organizations_academic_year ON public.organizations USING btree (academic_year);

CREATE INDEX idx_organizations_city ON public.organizations USING btree (city);

CREATE INDEX idx_organizations_created_at ON public.organizations USING btree (created_at);

CREATE INDEX idx_organizations_dashboard_settings ON public.organizations USING gin (dashboard_settings);

CREATE INDEX idx_organizations_is_active ON public.organizations USING btree (is_active);

CREATE INDEX idx_organizations_is_verified ON public.organizations USING btree (is_verified);

CREATE INDEX idx_organizations_organization_type ON public.organizations USING btree (organization_type);

CREATE INDEX idx_organizations_plan_tier ON public.organizations USING btree (plan_tier);

CREATE INDEX idx_organizations_preschool_id ON public.organizations USING btree (preschool_id);

CREATE INDEX idx_organizations_principal ON public.organizations USING btree (principal_id);

CREATE INDEX idx_organizations_province ON public.organizations USING btree (province);

CREATE INDEX idx_organizations_school_code ON public.organizations USING btree (school_code);

CREATE INDEX idx_organizations_subscription_tier ON public.organizations USING btree (subscription_tier);

CREATE INDEX idx_organizations_type ON public.organizations USING btree (type);

CREATE INDEX idx_pages_chapter ON public.textbook_pages USING btree (chapter_id);

CREATE INDEX idx_pages_content_search ON public.textbook_pages USING gin (to_tsvector('english'::regconfig, COALESCE(content_text, ''::text)));

CREATE INDEX idx_pages_exercises ON public.textbook_pages USING btree (has_exercises) WHERE (has_exercises = true);

CREATE INDEX idx_pages_number ON public.textbook_pages USING btree (page_number);

CREATE INDEX idx_pages_textbook ON public.textbook_pages USING btree (textbook_id);

CREATE INDEX idx_parent_child_links_child ON public.parent_child_links USING btree (child_id);

CREATE INDEX idx_parent_child_links_child_id ON public.parent_child_links USING btree (child_id);

CREATE INDEX idx_parent_child_links_parent ON public.parent_child_links USING btree (parent_id);

CREATE INDEX idx_parent_child_links_parent_id ON public.parent_child_links USING btree (parent_id);

CREATE INDEX idx_parent_child_parent ON public.parent_child_links USING btree (parent_id);

CREATE INDEX idx_parent_join_requests_organization_id ON public.parent_join_requests USING btree (organization_id);

CREATE INDEX idx_parent_join_requests_parent_id ON public.parent_join_requests USING btree (parent_id);

CREATE INDEX idx_parent_join_requests_preschool_id ON public.parent_join_requests USING btree (preschool_id);

CREATE INDEX idx_parent_join_requests_status ON public.parent_join_requests USING btree (status);

CREATE INDEX idx_parent_payments_parent_status ON public.parent_payments USING btree (parent_id, status);

CREATE INDEX idx_past_papers_grade_subject ON public.past_papers USING btree (grade, subject);

CREATE INDEX idx_past_papers_public ON public.past_papers USING btree (is_public) WHERE (is_public = true);

CREATE INDEX idx_past_papers_year_term ON public.past_papers USING btree (year, term);

CREATE INDEX idx_patterns_grade_subject ON public.caps_exam_patterns USING btree (grade, subject);

CREATE INDEX idx_patterns_priority ON public.caps_exam_patterns USING btree (recommended_study_priority);

CREATE INDEX idx_payfast_itn_logs_created_at ON public.payfast_itn_logs USING btree (created_at);

CREATE INDEX idx_payfast_itn_logs_m_payment_id ON public.payfast_itn_logs USING btree (m_payment_id);

CREATE INDEX idx_payfast_itn_logs_payment_status ON public.payfast_itn_logs USING btree (payment_status);

CREATE INDEX idx_payfast_itn_logs_pf_payment_id ON public.payfast_itn_logs USING btree (pf_payment_id);

CREATE INDEX idx_payment_methods_org ON public.organization_payment_methods USING btree (organization_id);

CREATE INDEX idx_payment_reminders_preschool_id ON public.payment_reminders USING btree (preschool_id);

CREATE INDEX idx_payment_reminders_sent_at ON public.payment_reminders USING btree (sent_at DESC);

CREATE INDEX idx_payment_reminders_student_id ON public.payment_reminders USING btree (student_id);

CREATE INDEX idx_payment_transactions_created_at ON public.payment_transactions USING btree (created_at);

CREATE INDEX idx_payment_transactions_payfast_payment_id ON public.payment_transactions USING btree (payfast_payment_id);

CREATE INDEX idx_payment_transactions_school_id ON public.payment_transactions USING btree (school_id);

CREATE INDEX idx_payment_transactions_status ON public.payment_transactions USING btree (status);

CREATE INDEX idx_payments_parent ON public.payments USING btree (parent_id);

CREATE INDEX idx_payments_preschool ON public.payments USING btree (preschool_id);

CREATE INDEX idx_payments_status ON public.payments USING btree (status);

CREATE INDEX idx_payments_submitted_at ON public.payments USING btree (submitted_at);

CREATE INDEX idx_petty_cash_accounts_active ON public.petty_cash_accounts USING btree (is_active) WHERE (is_active = true);

CREATE INDEX idx_petty_cash_accounts_preschool ON public.petty_cash_accounts USING btree (school_id);

CREATE INDEX idx_petty_cash_created_at ON public.petty_cash_transactions USING btree (created_at DESC);

CREATE INDEX idx_petty_cash_org ON public.organization_petty_cash USING btree (organization_id);

CREATE INDEX idx_petty_cash_preschool_id ON public.petty_cash_transactions USING btree (school_id);

CREATE INDEX idx_petty_cash_receipts_created_at ON public.petty_cash_receipts USING btree (created_at DESC);

CREATE INDEX idx_petty_cash_receipts_created_by ON public.petty_cash_receipts USING btree (created_by);

CREATE INDEX idx_petty_cash_receipts_school_id ON public.petty_cash_receipts USING btree (school_id);

CREATE INDEX idx_petty_cash_receipts_transaction_id ON public.petty_cash_receipts USING btree (transaction_id);

CREATE INDEX idx_petty_cash_reconciliations_created_at ON public.petty_cash_reconciliations USING btree (created_at DESC);

CREATE INDEX idx_petty_cash_reconciliations_preschool_id ON public.petty_cash_reconciliations USING btree (preschool_id);

CREATE INDEX idx_petty_cash_reconciliations_reconciled_by ON public.petty_cash_reconciliations USING btree (reconciled_by);

CREATE INDEX idx_petty_cash_region ON public.organization_petty_cash USING btree (region_id);

CREATE INDEX idx_petty_cash_status ON public.petty_cash_transactions USING btree (status);

CREATE INDEX idx_petty_cash_transactions_account ON public.petty_cash_transactions USING btree (account_id);

CREATE INDEX idx_petty_cash_transactions_date ON public.petty_cash_transactions USING btree (transaction_date DESC);

CREATE INDEX idx_petty_cash_transactions_preschool ON public.petty_cash_transactions USING btree (school_id);

CREATE INDEX idx_petty_cash_transactions_school_created ON public.petty_cash_transactions USING btree (school_id, created_by);

CREATE INDEX idx_petty_cash_transactions_school_tenant ON public.petty_cash_transactions USING btree (school_id);

CREATE INDEX idx_petty_cash_transactions_type ON public.petty_cash_transactions USING btree (transaction_type);

CREATE INDEX idx_petty_cash_wing ON public.organization_petty_cash USING btree (wing_id);

CREATE INDEX idx_phone_verification_logs_user_phone_id ON public.phone_verification_logs USING btree (user_phone_id);

CREATE INDEX idx_platform_payments_dest_org ON public.platform_collected_payments USING btree (destination_organization_id);

CREATE INDEX idx_platform_payments_disbursement ON public.platform_collected_payments USING btree (disbursement_status);

CREATE INDEX idx_platform_payments_payer ON public.platform_collected_payments USING btree (payer_user_id);

CREATE INDEX idx_platform_payments_payfast ON public.platform_collected_payments USING btree (payfast_payment_id);

CREATE INDEX idx_platform_payments_status ON public.platform_collected_payments USING btree (status);

CREATE INDEX idx_platform_subscriptions_plan ON public.platform_subscriptions USING btree (plan_id);

CREATE INDEX idx_platform_subscriptions_plan_id ON public.platform_subscriptions USING btree (plan_id);

CREATE INDEX idx_platform_subscriptions_status ON public.platform_subscriptions USING btree (status);

CREATE INDEX idx_platform_subscriptions_user ON public.platform_subscriptions USING btree (user_id);

CREATE INDEX idx_pop_uploads_created_at ON public.pop_uploads USING btree (created_at DESC);

CREATE INDEX idx_pop_uploads_payment_date ON public.pop_uploads USING btree (payment_date) WHERE ((upload_type)::text = 'proof_of_payment'::text);

CREATE INDEX idx_pop_uploads_preschool_id ON public.pop_uploads USING btree (preschool_id);

CREATE INDEX idx_pop_uploads_student_id ON public.pop_uploads USING btree (student_id);

CREATE INDEX idx_pop_uploads_type_status ON public.pop_uploads USING btree (upload_type, status);

CREATE INDEX idx_pop_uploads_uploaded_by ON public.pop_uploads USING btree (uploaded_by);

CREATE INDEX idx_portfolio_items_category ON public.portfolio_items USING btree (category);

CREATE INDEX idx_portfolio_items_is_public ON public.portfolio_items USING btree (is_public);

CREATE INDEX idx_portfolio_items_learner_id ON public.portfolio_items USING btree (learner_id);

CREATE INDEX idx_portfolio_items_program_id ON public.portfolio_items USING btree (program_id);

CREATE INDEX idx_preschool_voice_usage_period ON public.preschool_voice_usage USING btree (preschool_id, period_type, period_start);

CREATE INDEX idx_preschools_approved ON public.preschools USING btree (approved) WHERE (approved = true);

CREATE INDEX idx_preschools_city ON public.preschools USING btree (city);

CREATE INDEX idx_preschools_is_verified ON public.preschools USING btree (is_verified);

CREATE INDEX idx_preschools_location ON public.preschools USING btree (location_latitude, location_longitude);

CREATE INDEX idx_preschools_onboarding_flow ON public.preschools USING btree (onboarding_flow);

CREATE INDEX idx_preschools_province ON public.preschools USING btree (province);

CREATE INDEX idx_preschools_school_type ON public.preschools USING btree (school_type);

CREATE INDEX idx_preschools_settings ON public.preschools USING gin (settings);

CREATE INDEX idx_preschools_subscription_tier ON public.preschools USING btree (subscription_tier);

CREATE UNIQUE INDEX idx_preschools_tenant_slug_unique ON public.preschools USING btree (tenant_slug) WHERE (tenant_slug IS NOT NULL);

CREATE INDEX idx_preschools_verification_status ON public.preschools USING btree (verification_status);

CREATE INDEX idx_preschools_verified ON public.preschools USING btree (verified) WHERE (verified = true);

CREATE INDEX idx_principal_groups_active ON public.principal_groups USING btree (is_active) WHERE (is_active = true);

CREATE INDEX idx_principal_groups_created_by ON public.principal_groups USING btree (created_by);

CREATE INDEX idx_principal_groups_preschool ON public.principal_groups USING btree (preschool_id);

CREATE INDEX idx_principal_groups_preschool_id ON public.principal_groups USING btree (preschool_id);

CREATE INDEX idx_principal_groups_type ON public.principal_groups USING btree (group_type);

CREATE INDEX idx_profiles_age_group ON public.profiles USING btree (age_group);

CREATE INDEX idx_profiles_assigned_teacher ON public.profiles USING btree (assigned_teacher_id);

CREATE INDEX idx_profiles_date_of_birth ON public.profiles USING btree (date_of_birth);

CREATE INDEX idx_profiles_expo_push_token ON public.profiles USING btree (expo_push_token) WHERE (expo_push_token IS NOT NULL);

CREATE INDEX idx_profiles_guardian_profile_id ON public.profiles USING btree (guardian_profile_id);

CREATE INDEX idx_profiles_invoice_notification_prefs ON public.profiles USING gin (invoice_notification_preferences);

CREATE INDEX idx_profiles_invoice_prefs ON public.profiles USING gin (invoice_notification_preferences);

CREATE INDEX idx_profiles_is_standalone ON public.profiles USING btree (is_standalone) WHERE (is_standalone = true);

CREATE INDEX idx_profiles_organization_id ON public.profiles USING btree (organization_id);

CREATE INDEX idx_profiles_preferred_language ON public.profiles USING btree (preferred_language);

CREATE INDEX idx_profiles_ringtone_preferences ON public.profiles USING gin (ringtone_preferences);

CREATE INDEX idx_profiles_role ON public.profiles USING btree (role);

CREATE INDEX idx_profiles_role_org ON public.profiles USING btree (role, preschool_id) WHERE (role IS NOT NULL);

CREATE INDEX idx_profiles_seat_status ON public.profiles USING btree (seat_status) WHERE (role = 'teacher'::text);

CREATE INDEX idx_profiles_subscription_tier ON public.profiles USING btree (subscription_tier);

CREATE INDEX idx_profiles_trial_ends_at ON public.profiles USING btree (trial_ends_at) WHERE (trial_ends_at IS NOT NULL);

CREATE INDEX idx_profiles_trial_status ON public.profiles USING btree (is_trial, trial_end_date) WHERE (is_trial = true);

CREATE INDEX idx_profiles_usage_type ON public.profiles USING btree (usage_type) WHERE (usage_type IS NOT NULL);

CREATE INDEX idx_progress_reports_approval_status ON public.progress_reports USING btree (approval_status);

CREATE INDEX idx_progress_reports_category ON public.progress_reports USING btree (report_category);

CREATE INDEX idx_progress_reports_pending_review ON public.progress_reports USING btree (preschool_id, approval_status) WHERE (approval_status = 'pending_review'::public.approval_status);

CREATE INDEX idx_progress_reports_period ON public.progress_reports USING btree (report_period);

CREATE INDEX idx_progress_reports_preschool ON public.progress_reports USING btree (preschool_id);

CREATE INDEX idx_progress_reports_reviewed_by ON public.progress_reports USING btree (reviewed_by);

CREATE INDEX idx_progress_reports_status ON public.progress_reports USING btree (preschool_id, status);

CREATE INDEX idx_progress_reports_student ON public.progress_reports USING btree (student_id);

CREATE INDEX idx_progress_reports_teacher ON public.progress_reports USING btree (teacher_id);

CREATE INDEX idx_progress_reports_transition_level ON public.progress_reports USING btree (transition_readiness_level);

CREATE INDEX idx_promotional_campaigns_active ON public.promotional_campaigns USING btree (is_active, start_date, end_date);

CREATE INDEX idx_promotional_campaigns_user_type ON public.promotional_campaigns USING btree (user_type);

CREATE INDEX idx_push_devices_fcm_token ON public.push_devices USING btree (fcm_token) WHERE (fcm_token IS NOT NULL);

CREATE INDEX idx_push_devices_user_id ON public.push_devices USING btree (user_id);

CREATE INDEX idx_push_notifications_preschool_tenant ON public.push_notifications USING btree (preschool_id);

CREATE INDEX idx_push_notifications_recipient ON public.push_notifications USING btree (recipient_user_id);

CREATE INDEX idx_push_notifications_recipient_user_id ON public.push_notifications USING btree (recipient_user_id);

CREATE INDEX idx_push_queue_status_created ON public.push_notification_queue USING btree (status, created_at) WHERE (status = 'pending'::text);

CREATE INDEX idx_push_subscriptions_endpoint ON public.push_subscriptions USING btree (endpoint);

CREATE INDEX idx_push_subscriptions_preschool ON public.push_subscriptions USING btree (preschool_id) WHERE (is_active = true);

CREATE INDEX idx_push_subscriptions_system ON public.push_subscriptions USING btree (topics) WHERE ((is_active = true) AND (user_id IS NULL));

CREATE INDEX idx_push_subscriptions_topics ON public.push_subscriptions USING gin (topics);

CREATE INDEX idx_push_subscriptions_user ON public.push_subscriptions USING btree (user_id) WHERE ((is_active = true) AND (user_id IS NOT NULL));

CREATE INDEX idx_push_subscriptions_user_id ON public.push_subscriptions USING btree (user_id);

CREATE INDEX idx_push_tokens_last_seen ON public.push_device_tokens USING btree (last_seen_at DESC);

CREATE INDEX idx_push_tokens_user ON public.push_device_tokens USING btree (user_id);

CREATE INDEX idx_rag_chunks_attachment ON public.rag_chunks USING btree (attachment_id);

CREATE INDEX idx_rag_chunks_doc ON public.rag_chunks USING btree (document_id, chunk_index);

CREATE INDEX idx_rag_chunks_trgm ON public.rag_chunks USING gin (content public.gin_trgm_ops);

CREATE INDEX idx_rag_chunks_user ON public.rag_chunks USING btree (user_id, conversation_id);

CREATE INDEX idx_rag_chunks_vec ON public.rag_chunks USING ivfflat (embedding public.vector_cosine_ops) WITH (lists='100');

CREATE INDEX idx_rag_documents_attachment ON public.rag_documents USING btree (attachment_id);

CREATE INDEX idx_rag_documents_user ON public.rag_documents USING btree (user_id, conversation_id);

CREATE INDEX idx_rag_ingestion_logs_attachment ON public.rag_ingestion_logs USING btree (attachment_id, created_at DESC);

CREATE INDEX idx_reading_progress_textbook ON public.reading_progress USING btree (textbook_id);

CREATE INDEX idx_reading_progress_user ON public.reading_progress USING btree (user_id);

CREATE INDEX idx_region_invite_codes_active ON public.region_invite_codes USING btree (is_active) WHERE (is_active = true);

CREATE INDEX idx_region_invite_codes_code ON public.region_invite_codes USING btree (code);

CREATE INDEX idx_region_invite_codes_org ON public.region_invite_codes USING btree (organization_id);

CREATE INDEX idx_region_invite_codes_region ON public.region_invite_codes USING btree (region_id);

CREATE INDEX idx_registration_requests_created_at ON public.registration_requests USING btree (created_at DESC);

CREATE INDEX idx_registration_requests_edudash_parent_id ON public.registration_requests USING btree (edudash_parent_id);

CREATE INDEX idx_registration_requests_edudash_student_id ON public.registration_requests USING btree (edudash_student_id);

CREATE INDEX idx_registration_requests_edusite_id ON public.registration_requests USING btree (edusite_id);

CREATE INDEX idx_registration_requests_organization ON public.registration_requests USING btree (organization_id);

CREATE INDEX idx_registration_requests_status ON public.registration_requests USING btree (status);

CREATE INDEX idx_resources_category_type ON public.resources USING btree (category_id, resource_type) WHERE (category_id IS NOT NULL);

CREATE INDEX idx_resources_org_visibility_status ON public.resources USING btree (organization_id, visibility, moderation_status, is_archived);

CREATE INDEX idx_resources_subjects_grades ON public.resources USING gin (subjects, grade_levels) WHERE ((subjects IS NOT NULL) OR (grade_levels IS NOT NULL));

CREATE INDEX idx_resources_tags ON public.resources USING gin (tags) WHERE ((tags IS NOT NULL) AND (array_length(tags, 1) > 0));

CREATE INDEX idx_revenuecat_webhook_events_app_user_id ON public.revenuecat_webhook_events USING btree (app_user_id);

CREATE INDEX idx_revenuecat_webhook_events_created_at ON public.revenuecat_webhook_events USING btree (created_at);

CREATE INDEX idx_revenuecat_webhook_events_type ON public.revenuecat_webhook_events USING btree (type);

CREATE INDEX idx_risk_assessments_risk_level ON public.superadmin_user_risk_assessments USING btree (risk_level);

CREATE INDEX idx_risk_assessments_user_id ON public.superadmin_user_risk_assessments USING btree (user_id);

CREATE INDEX idx_risk_assessments_valid_until ON public.superadmin_user_risk_assessments USING btree (valid_until);

CREATE INDEX idx_role_assignments_active ON public.superadmin_role_assignments USING btree (is_active) WHERE (is_active = true);

CREATE INDEX idx_role_assignments_admin_id ON public.superadmin_role_assignments USING btree (admin_id);

CREATE INDEX idx_role_assignments_role_level ON public.superadmin_role_assignments USING btree (role_level);

CREATE INDEX idx_role_assignments_valid_until ON public.superadmin_role_assignments USING btree (valid_until) WHERE (valid_until IS NOT NULL);

CREATE INDEX idx_scheduled_lessons_class ON public.scheduled_lessons USING btree (class_id, scheduled_at);

CREATE INDEX idx_scheduled_lessons_teacher ON public.scheduled_lessons USING btree (teacher_id, scheduled_at);

CREATE INDEX idx_scheduled_tasks_organization_id ON public.scheduled_tasks USING btree (organization_id);

CREATE INDEX idx_scheduled_tasks_scheduled_for ON public.scheduled_tasks USING btree (scheduled_for);

CREATE INDEX idx_scheduled_tasks_status ON public.scheduled_tasks USING btree (status);

CREATE INDEX idx_scheduled_tasks_type ON public.scheduled_tasks USING btree (type);

CREATE INDEX idx_school_ai_subscriptions_period ON public.school_ai_subscriptions USING btree (current_period_start, current_period_end);

CREATE INDEX idx_school_ai_subscriptions_preschool_id ON public.school_ai_subscriptions USING btree (preschool_id);

CREATE INDEX idx_school_ai_subscriptions_tier_org ON public.school_ai_subscriptions USING btree (subscription_tier, org_type);

CREATE INDEX idx_school_branding_preschool_id ON public.school_branding USING btree (preschool_id);

CREATE INDEX idx_school_events_preschool_date ON public.school_events USING btree (preschool_id, start_date DESC);

CREATE INDEX idx_school_events_preschool_id ON public.school_events USING btree (preschool_id);

CREATE INDEX idx_school_events_start_date ON public.school_events USING btree (start_date);

CREATE INDEX idx_school_events_status ON public.school_events USING btree (preschool_id, status);

CREATE INDEX idx_school_events_type ON public.school_events USING btree (preschool_id, event_type);

CREATE INDEX idx_school_fees_active ON public.school_fee_structures USING btree (is_active) WHERE (is_active = true);

CREATE INDEX idx_school_fees_age_group ON public.school_fee_structures USING btree (age_group);

CREATE INDEX idx_school_fees_category ON public.school_fee_structures USING btree (fee_category);

CREATE INDEX idx_school_fees_preschool ON public.school_fee_structures USING btree (preschool_id);

CREATE INDEX idx_school_inv_codes_preschool ON public.school_invitation_codes USING btree (preschool_id);

CREATE INDEX idx_school_invitation_codes_code ON public.school_invitation_codes USING btree (code);

CREATE INDEX idx_school_invitation_codes_school_id ON public.school_invitation_codes USING btree (school_id);

CREATE INDEX idx_school_verifications_expires ON public.school_verifications USING btree (expires_at) WHERE (expires_at IS NOT NULL);

CREATE INDEX idx_school_verifications_school_id ON public.school_verifications USING btree (school_id);

CREATE INDEX idx_school_verifications_status ON public.school_verifications USING btree (verification_type, status);

CREATE INDEX idx_school_verifications_token ON public.school_verifications USING btree (verification_token) WHERE (verification_token IS NOT NULL);

CREATE INDEX idx_schools_city ON public.schools USING btree (city);

CREATE INDEX idx_schools_is_active ON public.schools USING btree (is_active);

CREATE INDEX idx_schools_province ON public.schools USING btree (province);

CREATE INDEX idx_seats_preschool_id ON public.seats USING btree (preschool_id);

CREATE INDEX idx_seats_subscription_user ON public.seats USING btree (subscription_id, user_id);

CREATE INDEX idx_security_events_created_at ON public.security_events USING btree (created_at DESC);

CREATE INDEX idx_security_events_event_type ON public.security_events USING btree (event_type);

CREATE INDEX idx_security_events_risk_level ON public.security_events USING btree (risk_level);

CREATE INDEX idx_security_events_user_id ON public.security_events USING btree (user_id);

CREATE INDEX idx_service_health_checked ON public.service_health_status USING btree (last_checked_at DESC);

CREATE INDEX idx_service_health_name ON public.service_health_status USING btree (service_name);

CREATE INDEX idx_service_health_status ON public.service_health_status USING btree (status) WHERE (status <> 'healthy'::text);

CREATE INDEX idx_session_management_admin_id ON public.superadmin_session_management USING btree (admin_id);

CREATE INDEX idx_session_management_session_id ON public.superadmin_session_management USING btree (session_id);

CREATE INDEX idx_session_management_suspicious ON public.superadmin_session_management USING btree (is_suspicious) WHERE (is_suspicious = true);

CREATE INDEX idx_sms_messages_created_at ON public.sms_messages USING btree (created_at DESC);

CREATE INDEX idx_sms_messages_preschool ON public.sms_messages USING btree (preschool_id);

CREATE INDEX idx_sms_messages_provider_id ON public.sms_messages USING btree (provider_message_id);

CREATE INDEX idx_sms_messages_status ON public.sms_messages USING btree (status);

CREATE INDEX idx_sms_messages_to_number ON public.sms_messages USING btree (to_number);

CREATE INDEX idx_sms_opt_outs_active ON public.sms_opt_outs USING btree (preschool_id) WHERE (opted_in_at IS NULL);

CREATE INDEX idx_sms_opt_outs_preschool_phone ON public.sms_opt_outs USING btree (preschool_id, phone_number);

CREATE INDEX idx_spr_parent_id ON public.student_parent_relationships USING btree (parent_id);

CREATE INDEX idx_spr_student_id ON public.student_parent_relationships USING btree (student_id);

CREATE INDEX idx_standalone_users_profile_id ON public.standalone_users USING btree (profile_id);

CREATE INDEX idx_standalone_users_trial ON public.standalone_users USING btree (is_trial, trial_end_date) WHERE (is_trial = true);

CREATE INDEX idx_standalone_users_type ON public.standalone_users USING btree (user_type);

CREATE INDEX idx_standalone_users_user_id ON public.standalone_users USING btree (user_id);

CREATE INDEX idx_stem_progress_category ON public.stem_progress USING btree (category);

CREATE INDEX idx_stem_progress_preschool_category ON public.stem_progress USING btree (preschool_id, category);

CREATE INDEX idx_stem_progress_student ON public.stem_progress USING btree (student_id);

CREATE INDEX idx_streaks_preschool ON public.student_streaks USING btree (preschool_id);

CREATE INDEX idx_streaks_student ON public.student_streaks USING btree (student_id);

CREATE INDEX idx_student_enrollments_active ON public.student_enrollments USING btree (is_active);

CREATE INDEX idx_student_enrollments_class_id ON public.student_enrollments USING btree (class_id);

CREATE INDEX idx_student_enrollments_student_id ON public.student_enrollments USING btree (student_id);

CREATE INDEX idx_student_fees_due_date ON public.student_fees USING btree (due_date);

CREATE INDEX idx_student_fees_preschool ON public.student_fee_assignments USING btree (preschool_id);

CREATE INDEX idx_student_fees_status ON public.student_fees USING btree (status);

CREATE INDEX idx_student_fees_structure ON public.student_fee_assignments USING btree (fee_structure_id);

CREATE INDEX idx_student_fees_student ON public.student_fee_assignments USING btree (student_id);

CREATE INDEX idx_student_fees_student_id ON public.student_fees USING btree (student_id);

CREATE INDEX idx_student_groups_active ON public.student_groups USING btree (is_active);

CREATE INDEX idx_student_groups_group_id ON public.student_groups USING btree (group_id);

CREATE INDEX idx_student_groups_student_id ON public.student_groups USING btree (student_id);

CREATE INDEX idx_student_parent_relationships_composite ON public.student_parent_relationships USING btree (student_id, parent_id);

CREATE INDEX idx_student_parent_relationships_parent_id ON public.student_parent_relationships USING btree (parent_id);

CREATE INDEX idx_student_parent_relationships_student_id ON public.student_parent_relationships USING btree (student_id);

CREATE INDEX idx_student_progress_alert_level ON public.student_progress USING btree (alert_level);

CREATE INDEX idx_student_progress_calculated ON public.student_progress USING btree (last_calculated);

CREATE INDEX idx_student_progress_course_id ON public.student_progress USING btree (course_id);

CREATE INDEX idx_student_progress_student_id ON public.student_progress USING btree (student_id);

CREATE INDEX idx_students_academic_year ON public.students USING btree (academic_year);

CREATE INDEX idx_students_class_id ON public.students USING btree (class_id);

CREATE INDEX idx_students_guardian ON public.students USING btree (guardian_id) WHERE (guardian_id IS NOT NULL);

CREATE INDEX idx_students_guardian_access ON public.students USING btree (guardian_id) WHERE (guardian_id IS NOT NULL);

CREATE INDEX idx_students_id_number ON public.students USING btree (id_number);

CREATE INDEX idx_students_org_parent ON public.students USING btree (preschool_id, parent_id) WHERE (preschool_id IS NOT NULL);

CREATE INDEX idx_students_organization_id ON public.students USING btree (organization_id);

CREATE INDEX idx_students_parent_access ON public.students USING btree (parent_id) WHERE (parent_id IS NOT NULL);

CREATE INDEX idx_students_preschool_class ON public.students USING btree (preschool_id, class_id);

CREATE INDEX idx_students_preschool_id ON public.students USING btree (preschool_id);

CREATE INDEX idx_students_preschool_tenant ON public.students USING btree (preschool_id);

CREATE INDEX idx_students_status_preschool ON public.students USING btree (preschool_id, status);

CREATE INDEX idx_students_student_id ON public.students USING btree (student_id);

CREATE INDEX idx_study_groups_created_by ON public.study_groups USING btree (created_by);

CREATE INDEX idx_study_groups_organization_id ON public.study_groups USING btree (organization_id);

CREATE INDEX idx_study_groups_program_id ON public.study_groups USING btree (program_id);

CREATE INDEX idx_submissions_assignment_id ON public.submissions USING btree (assignment_id);

CREATE INDEX idx_submissions_assignment_student ON public.assignment_submissions USING btree (assignment_id, student_id);

CREATE INDEX idx_submissions_is_draft ON public.submissions USING btree (is_draft);

CREATE INDEX idx_submissions_is_late ON public.submissions USING btree (is_late);

CREATE INDEX idx_submissions_status ON public.assignment_submissions USING btree (status);

CREATE INDEX idx_submissions_student_id ON public.submissions USING btree (student_id);

CREATE INDEX idx_submissions_submitted_at ON public.assignment_submissions USING btree (submitted_at) WHERE (submitted_at IS NOT NULL);

CREATE INDEX idx_subscription_plans_active ON public.subscription_plans USING btree (is_active, sort_order);

CREATE INDEX idx_subscription_plans_tier ON public.subscription_plans USING btree (tier);

CREATE INDEX idx_subscription_seats_active ON public.subscription_seats USING btree (subscription_id, is_active);

CREATE INDEX idx_subscription_seats_assigned_by ON public.subscription_seats USING btree (assigned_by) WHERE (assigned_by IS NOT NULL);

CREATE INDEX idx_subscription_seats_preschool_id ON public.subscription_seats USING btree (preschool_id);

CREATE INDEX idx_subscription_seats_subscription_id ON public.subscription_seats USING btree (subscription_id);

CREATE INDEX idx_subscription_seats_user ON public.subscription_seats USING btree (user_id);

CREATE INDEX idx_subscription_seats_user_id ON public.subscription_seats USING btree (user_id);

CREATE INDEX idx_subscription_usage_period ON public.subscription_usage USING btree (period_start, period_end);

CREATE INDEX idx_subscription_usage_subscription_id ON public.subscription_usage USING btree (subscription_id);

CREATE INDEX idx_subscription_usage_type ON public.subscription_usage USING btree (usage_type);

CREATE INDEX idx_subscriptions_next_billing ON public.subscriptions USING btree (next_billing_date) WHERE (next_billing_date IS NOT NULL);

CREATE INDEX idx_subscriptions_owner_type ON public.subscriptions USING btree (owner_type);

CREATE INDEX idx_subscriptions_plan_id ON public.subscriptions USING btree (plan_id);

CREATE INDEX idx_subscriptions_school_id ON public.subscriptions USING btree (school_id);

CREATE INDEX idx_subscriptions_status ON public.subscriptions USING btree (status);

CREATE INDEX idx_subscriptions_user_id ON public.subscriptions USING btree (user_id);

CREATE INDEX idx_superadmin_agent_executions_agent ON public.superadmin_agent_executions USING btree (agent_id, started_at DESC);

CREATE INDEX idx_superadmin_agent_executions_status ON public.superadmin_agent_executions USING btree (status) WHERE (status = ANY (ARRAY['pending'::text, 'running'::text]));

CREATE INDEX idx_superadmin_command_log_admin ON public.superadmin_command_log USING btree (admin_id, created_at DESC);

CREATE INDEX idx_superadmin_command_log_type ON public.superadmin_command_log USING btree (command_type, created_at DESC);

CREATE INDEX idx_superadmin_deletion_requests_created_at ON public.superadmin_user_deletion_requests USING btree (created_at);

CREATE INDEX idx_superadmin_deletion_requests_status ON public.superadmin_user_deletion_requests USING btree (status);

CREATE INDEX idx_superadmin_deletion_requests_target_user ON public.superadmin_user_deletion_requests USING btree (target_user_id);

CREATE INDEX idx_superadmin_insights_active ON public.superadmin_platform_insights USING btree (created_at DESC) WHERE (is_dismissed = false);

CREATE INDEX idx_superadmin_insights_type ON public.superadmin_platform_insights USING btree (insight_type, created_at DESC);

CREATE INDEX idx_superadmin_notifications_created_at ON public.superadmin_notifications USING btree (created_at);

CREATE INDEX idx_superadmin_notifications_severity ON public.superadmin_notifications USING btree (severity);

CREATE INDEX idx_superadmin_notifications_status ON public.superadmin_notifications USING btree (status);

CREATE INDEX idx_superadmin_notifications_type ON public.superadmin_notifications USING btree (type);

CREATE INDEX idx_superadmin_risk_assessments_risk_level ON public.superadmin_user_risk_assessments USING btree (risk_level);

CREATE INDEX idx_superadmin_risk_assessments_user_id ON public.superadmin_user_risk_assessments USING btree (user_id);

CREATE INDEX idx_superadmin_user_actions_action ON public.superadmin_user_actions USING btree (action);

CREATE INDEX idx_superadmin_user_actions_admin_user ON public.superadmin_user_actions USING btree (admin_user_id);

CREATE INDEX idx_superadmin_user_actions_created_at ON public.superadmin_user_actions USING btree (created_at);

CREATE INDEX idx_superadmin_user_actions_target_user ON public.superadmin_user_actions USING btree (target_user_id);

CREATE INDEX idx_sync_logs_record ON public.sync_logs USING btree (record_id);

CREATE INDEX idx_sync_logs_success ON public.sync_logs USING btree (success) WHERE (success = false);

CREATE INDEX idx_sync_logs_synced_at ON public.sync_logs USING btree (synced_at DESC);

CREATE INDEX idx_teacher_ai_allocations_active ON public.teacher_ai_allocations USING btree (preschool_id, is_active) WHERE (is_active = true);

CREATE INDEX idx_teacher_ai_allocations_period ON public.teacher_ai_allocations USING btree (preschool_id, period_start, period_end);

CREATE INDEX idx_teacher_ai_allocations_preschool_id ON public.teacher_ai_allocations USING btree (preschool_id);

CREATE INDEX idx_teacher_ai_allocations_priority ON public.teacher_ai_allocations USING btree (preschool_id, priority_level) WHERE (is_active = true);

CREATE INDEX idx_teacher_ai_allocations_user_id ON public.teacher_ai_allocations USING btree (user_id);

CREATE INDEX idx_teacher_class_codes_code ON public.teacher_class_codes USING btree (code);

CREATE INDEX idx_teacher_invitations_email ON public.teacher_invitations USING btree (email);

CREATE INDEX idx_teacher_invitations_preschool_id ON public.teacher_invitations USING btree (preschool_id);

CREATE INDEX idx_teacher_invitations_status ON public.teacher_invitations USING btree (status);

CREATE INDEX idx_teacher_invites_email ON public.teacher_invites USING btree (email);

CREATE INDEX idx_teacher_invites_school ON public.teacher_invites USING btree (school_id);

CREATE INDEX idx_teacher_notes_class ON public.teacher_student_notes USING btree (class_id);

CREATE INDEX idx_teacher_notes_created ON public.teacher_student_notes USING btree (created_at DESC);

CREATE INDEX idx_teacher_notes_preschool ON public.teacher_student_notes USING btree (preschool_id);

CREATE INDEX idx_teacher_notes_student ON public.teacher_student_notes USING btree (student_id);

CREATE INDEX idx_teacher_notes_teacher ON public.teacher_student_notes USING btree (teacher_id);

CREATE INDEX idx_teacher_notes_type ON public.teacher_student_notes USING btree (note_type);

CREATE INDEX idx_teacher_notes_unread ON public.teacher_student_notes USING btree (student_id, is_read) WHERE (NOT is_read);

CREATE INDEX idx_teacher_performance_period ON public.teacher_performance_metrics USING btree (metric_period_start, metric_period_end);

CREATE INDEX idx_teacher_performance_preschool_id ON public.teacher_performance_metrics USING btree (preschool_id);

CREATE INDEX idx_teacher_performance_teacher_id ON public.teacher_performance_metrics USING btree (teacher_id);

CREATE INDEX idx_teachers_org_user ON public.teachers USING btree (preschool_id, user_id) WHERE (preschool_id IS NOT NULL);

CREATE INDEX idx_teachers_preschool_id ON public.teachers USING btree (preschool_id);

CREATE INDEX idx_teachers_user_id ON public.teachers USING btree (user_id);

CREATE INDEX idx_template_approvals_requested_by ON public.template_approvals USING btree (requested_by);

CREATE INDEX idx_template_approvals_status ON public.template_approvals USING btree (status);

CREATE INDEX idx_template_approvals_template_id ON public.template_approvals USING btree (template_id);

CREATE INDEX idx_template_usage_logs_channel ON public.template_usage_logs USING btree (channel);

CREATE INDEX idx_template_usage_logs_created_at ON public.template_usage_logs USING btree (created_at);

CREATE INDEX idx_template_usage_logs_success ON public.template_usage_logs USING btree (delivery_success);

CREATE INDEX idx_template_usage_logs_template_id ON public.template_usage_logs USING btree (template_id);

CREATE INDEX idx_template_variables_name ON public.template_variables USING btree (variable_name);

CREATE INDEX idx_template_variables_required ON public.template_variables USING btree (is_required) WHERE (is_required = true);

CREATE INDEX idx_template_variables_template_id ON public.template_variables USING btree (template_id);

CREATE INDEX idx_tester_feedback_preschool_created_at ON public.tester_feedback USING btree (preschool_id, created_at DESC);

CREATE INDEX idx_tester_feedback_severity_status ON public.tester_feedback USING btree (severity, status);

CREATE INDEX idx_tester_feedback_status ON public.tester_feedback USING btree (status);

CREATE INDEX idx_tester_feedback_user ON public.tester_feedback USING btree (user_id);

CREATE INDEX idx_textbook_content_book ON public.textbook_content USING btree (textbook_id);

CREATE INDEX idx_textbook_content_pages ON public.textbook_content USING btree (textbook_id, page_start, page_end);

CREATE INDEX idx_textbook_content_parent ON public.textbook_content USING btree (parent_id);

CREATE INDEX idx_textbook_content_type ON public.textbook_content USING btree (content_type);

CREATE INDEX idx_textbooks_active ON public.textbooks USING btree (is_active) WHERE (is_active = true);

CREATE INDEX idx_textbooks_caps_topics ON public.textbooks USING gin (caps_topics);

CREATE INDEX idx_textbooks_free ON public.textbooks USING btree (is_free) WHERE (is_free = true);

CREATE INDEX idx_textbooks_grade_subject ON public.textbooks USING btree (grade, subject);

CREATE INDEX idx_textbooks_isbn ON public.textbooks USING btree (isbn);

CREATE INDEX idx_textbooks_publisher ON public.textbooks USING btree (publisher);

CREATE INDEX idx_textbooks_search ON public.textbooks USING gin (to_tsvector('english'::regconfig, (((((title)::text || ' '::text) || COALESCE(description, ''::text)) || ' '::text) || (subject)::text)));

CREATE INDEX idx_trial_usage_log_activated_at ON public.trial_usage_log USING btree (activated_at DESC);

CREATE INDEX idx_trial_usage_log_device ON public.trial_usage_log USING btree (device_fingerprint) WHERE (device_fingerprint IS NOT NULL);

CREATE INDEX idx_trial_usage_log_email ON public.trial_usage_log USING btree (email) WHERE (email IS NOT NULL);

CREATE INDEX idx_trial_usage_log_phone ON public.trial_usage_log USING btree (phone) WHERE (phone IS NOT NULL);

CREATE INDEX idx_trial_usage_log_user_id ON public.trial_usage_log USING btree (user_id) WHERE (user_id IS NOT NULL);

CREATE INDEX idx_tts_cache_last_used ON public.tts_audio_cache USING btree (last_used_at);

CREATE INDEX idx_tts_cache_preschool_lang ON public.tts_audio_cache USING btree (preschool_id, language_code);

CREATE INDEX idx_tts_cache_provider ON public.tts_audio_cache USING btree (provider);

CREATE INDEX idx_typing_indicators_is_typing ON public.typing_indicators USING btree (is_typing) WHERE (is_typing = true);

CREATE INDEX idx_typing_indicators_last_updated ON public.typing_indicators USING btree (last_updated_at);

CREATE INDEX idx_typing_indicators_thread_id ON public.typing_indicators USING btree (thread_id);

CREATE INDEX idx_typing_indicators_user_id ON public.typing_indicators USING btree (user_id);

CREATE INDEX idx_user_actions_action ON public.superadmin_user_actions USING btree (action);

CREATE INDEX idx_user_actions_admin_id ON public.superadmin_user_actions USING btree (admin_id);

CREATE INDEX idx_user_actions_bulk_operation ON public.superadmin_user_actions USING btree (bulk_operation_id) WHERE (bulk_operation_id IS NOT NULL);

CREATE INDEX idx_user_actions_created_at ON public.superadmin_user_actions USING btree (created_at);

CREATE INDEX idx_user_actions_target_user_id ON public.superadmin_user_actions USING btree (target_user_id);

CREATE INDEX idx_user_ai_tiers_active ON public.user_ai_tiers USING btree (is_active);

CREATE INDEX idx_user_ai_tiers_expires ON public.user_ai_tiers USING btree (expires_at) WHERE (expires_at IS NOT NULL);

CREATE INDEX idx_user_ai_tiers_tier ON public.user_ai_tiers USING btree (tier);

CREATE INDEX idx_user_ai_tiers_user_id ON public.user_ai_tiers USING btree (user_id);

CREATE INDEX idx_user_ai_usage_current_tier ON public.user_ai_usage USING btree (current_tier);

CREATE INDEX idx_user_ai_usage_user_id ON public.user_ai_usage USING btree (user_id);

CREATE INDEX idx_user_blocks_active ON public.user_blocks USING btree (is_active);

CREATE INDEX idx_user_blocks_blocked ON public.user_blocks USING btree (blocked_id);

CREATE INDEX idx_user_blocks_blocker ON public.user_blocks USING btree (blocker_id);

CREATE INDEX idx_user_blocks_created ON public.user_blocks USING btree (created_at);

CREATE INDEX idx_user_blocks_expires ON public.user_blocks USING btree (expires_at);

CREATE INDEX idx_user_blocks_school ON public.user_blocks USING btree (school_id);

CREATE INDEX idx_user_bookmarks_textbook ON public.user_bookmarks USING btree (textbook_id);

CREATE INDEX idx_user_bookmarks_user ON public.user_bookmarks USING btree (user_id);

CREATE INDEX idx_user_connections_addressee ON public.user_connections USING btree (addressee_id);

CREATE INDEX idx_user_connections_requester ON public.user_connections USING btree (requester_id);

CREATE INDEX idx_user_connections_status ON public.user_connections USING btree (status);

CREATE INDEX idx_user_contacts_matched_user ON public.user_contacts USING btree (matched_user_id);

CREATE INDEX idx_user_contacts_user_id ON public.user_contacts USING btree (user_id);

CREATE INDEX idx_user_invitations_email ON public.user_invitations USING btree (email);

CREATE INDEX idx_user_invitations_status ON public.user_invitations USING btree (status);

CREATE INDEX idx_user_invitations_token ON public.user_invitations USING btree (token);

CREATE INDEX idx_user_phone_numbers_phone ON public.user_phone_numbers USING btree (phone_number);

CREATE INDEX idx_user_phone_numbers_user_id ON public.user_phone_numbers USING btree (user_id);

CREATE INDEX idx_user_phone_numbers_verified ON public.user_phone_numbers USING btree (is_verified);

CREATE INDEX idx_user_presence_last_seen ON public.user_presence USING btree (last_seen_at DESC);

CREATE INDEX idx_user_presence_status ON public.user_presence USING btree (status);

CREATE INDEX idx_user_promo_subs_active ON public.user_promotional_subscriptions USING btree (is_active, promo_end_date);

CREATE INDEX idx_user_promo_subs_user_tier ON public.user_promotional_subscriptions USING btree (user_id, tier);

CREATE INDEX idx_user_voice_usage_preschool ON public.user_voice_usage USING btree (preschool_id, period_type);

CREATE INDEX idx_user_voice_usage_user_period ON public.user_voice_usage USING btree (user_id, period_type, period_start);

CREATE INDEX idx_users_active_status ON public.users USING btree (is_active, preschool_id) WHERE (is_active = true);

CREATE INDEX idx_users_auth_lookup ON public.users USING btree (auth_user_id) WHERE (auth_user_id IS NOT NULL);

CREATE INDEX idx_users_auth_user_id ON public.users USING btree (auth_user_id);

CREATE INDEX idx_users_auth_user_id_active ON public.users USING btree (auth_user_id) WHERE (is_active = true);

CREATE INDEX idx_users_auth_user_id_v2 ON public.users USING btree (auth_user_id) WHERE (auth_user_id IS NOT NULL);

CREATE INDEX idx_users_department ON public.users USING btree (department);

CREATE INDEX idx_users_employee_id ON public.users USING btree (employee_id);

CREATE INDEX idx_users_employment_status ON public.users USING btree (employment_status);

CREATE INDEX idx_users_home_location ON public.users USING btree (home_latitude, home_longitude);

CREATE INDEX idx_users_id_lookup ON public.users USING btree (id) WHERE (id IS NOT NULL);

CREATE INDEX idx_users_last_login_at ON public.users USING btree (last_login_at);

CREATE INDEX idx_users_org_lookup ON public.users USING btree (organization_id, preschool_id) WHERE ((organization_id IS NOT NULL) OR (preschool_id IS NOT NULL));

CREATE INDEX idx_users_org_role ON public.users USING btree (organization_id, role);

CREATE INDEX idx_users_organization_id ON public.users USING btree (organization_id);

CREATE INDEX idx_users_organization_id_v2 ON public.users USING btree (organization_id) WHERE (organization_id IS NOT NULL);

CREATE INDEX idx_users_password_reset_required ON public.users USING btree (password_reset_required) WHERE (password_reset_required = true);

CREATE INDEX idx_users_preschool_id ON public.users USING btree (preschool_id);

CREATE INDEX idx_users_preschool_id_v2 ON public.users USING btree (preschool_id) WHERE (preschool_id IS NOT NULL);

CREATE INDEX idx_users_preschool_role ON public.users USING btree (preschool_id, role);

CREATE INDEX idx_users_preschool_role_active ON public.users USING btree (preschool_id, role, is_active) WHERE ((preschool_id IS NOT NULL) AND (is_active = true));

CREATE INDEX idx_users_preschool_tenant ON public.users USING btree (preschool_id) WHERE (preschool_id IS NOT NULL);

CREATE INDEX idx_users_role ON public.users USING btree (role);

CREATE INDEX idx_users_role_active_lookup ON public.users USING btree (role, is_active) WHERE (COALESCE(is_active, true) = true);

CREATE INDEX idx_users_role_active_v2 ON public.users USING btree (role, is_active) WHERE (COALESCE(is_active, true) = true);

CREATE INDEX idx_users_role_preschool ON public.users USING btree (role, preschool_id);

CREATE INDEX idx_users_subscription_status ON public.users USING btree (subscription_status);

CREATE INDEX idx_users_subscription_tier ON public.users USING btree (subscription_tier);

CREATE INDEX idx_users_superadmin_direct ON public.users USING btree (id) WHERE (id = 'd2df36d4-74bc-4ffb-883b-036754764265'::uuid);

CREATE INDEX idx_users_superadmin_role ON public.users USING btree (id) WHERE (role = 'superadmin'::text);

CREATE INDEX idx_video_calls_class ON public.video_calls USING btree (class_id);

CREATE INDEX idx_video_calls_meeting ON public.video_calls USING btree (meeting_id);

CREATE INDEX idx_video_calls_preschool ON public.video_calls USING btree (preschool_id);

CREATE INDEX idx_video_calls_teacher ON public.video_calls USING btree (teacher_id);

CREATE INDEX idx_voice_notes_created_at ON public.voice_notes USING btree (created_at);

CREATE INDEX idx_voice_notes_created_by ON public.voice_notes USING btree (created_by);

CREATE INDEX idx_voice_prefs_preschool_lang ON public.voice_preferences USING btree (preschool_id, language_code);

CREATE INDEX idx_voice_usage_lang ON public.voice_usage_logs USING btree (language_code);

CREATE INDEX idx_voice_usage_preschool ON public.voice_usage_logs USING btree (preschool_id, created_at DESC);

CREATE INDEX idx_voice_usage_preschool_date ON public.voice_usage_logs USING btree (preschool_id, created_at);

CREATE INDEX idx_voice_usage_provider ON public.voice_usage_logs USING btree (provider);

CREATE INDEX idx_voice_usage_service ON public.voice_usage_logs USING btree (service, created_at DESC);

CREATE INDEX idx_voice_usage_user_date ON public.voice_usage_logs USING btree (user_id, created_at DESC);

CREATE INDEX idx_webhook_logs_created_at ON public.webhook_logs USING btree (created_at);

CREATE INDEX idx_webhook_logs_event_type ON public.webhook_logs USING btree (event_type);

CREATE INDEX idx_webhook_logs_source ON public.webhook_logs USING btree (source);

CREATE INDEX idx_wing_coords_coordinator ON public.wing_regional_coordinators USING btree (coordinator_id);

CREATE INDEX idx_wing_coords_region ON public.wing_regional_coordinators USING btree (region_id);

CREATE INDEX idx_wing_coords_wing ON public.wing_regional_coordinators USING btree (wing_id);

CREATE UNIQUE INDEX in_app_notifications_pkey ON public.in_app_notifications USING btree (id);

CREATE UNIQUE INDEX independent_children_pkey ON public.independent_children USING btree (id);

CREATE UNIQUE INDEX independent_content_library_pkey ON public.independent_content_library USING btree (id);

CREATE UNIQUE INDEX integration_audit_log_pkey ON public.integration_audit_log USING btree (id);

CREATE UNIQUE INDEX interactive_activities_pkey ON public.interactive_activities USING btree (id);

CREATE UNIQUE INDEX interview_schedules_pkey ON public.interview_schedules USING btree (id);

CREATE UNIQUE INDEX invitation_codes_code_key ON public.invitation_codes USING btree (code);

CREATE UNIQUE INDEX invitation_codes_pkey ON public.invitation_codes USING btree (id);

CREATE UNIQUE INDEX invitations_code_key ON public.invitations USING btree (code);

CREATE UNIQUE INDEX invitations_pkey ON public.invitations USING btree (id);

CREATE UNIQUE INDEX invite_logs_pkey ON public.invite_logs USING btree (id);

CREATE UNIQUE INDEX invoice_audit_log_pkey ON public.invoice_audit_log USING btree (id);

CREATE UNIQUE INDEX invoice_items_pkey ON public.invoice_items USING btree (id);

CREATE UNIQUE INDEX invoice_payments_pkey ON public.invoice_payments USING btree (id);

CREATE UNIQUE INDEX invoice_templates_pkey ON public.invoice_templates USING btree (id);

CREATE UNIQUE INDEX invoices_pkey ON public.invoices USING btree (id);

CREATE UNIQUE INDEX job_alerts_pkey ON public.job_alerts USING btree (id);

CREATE UNIQUE INDEX job_applications_pkey ON public.job_applications USING btree (id);

CREATE UNIQUE INDEX job_distributions_pkey ON public.job_distributions USING btree (id);

CREATE UNIQUE INDEX job_postings_pkey ON public.job_postings USING btree (id);

CREATE UNIQUE INDEX join_requests_invite_code_key ON public.join_requests USING btree (invite_code);

CREATE UNIQUE INDEX join_requests_pkey ON public.join_requests USING btree (id);

CREATE UNIQUE INDEX learner_connections_learner_id_connection_id_key ON public.learner_connections USING btree (learner_id, connection_id);

CREATE UNIQUE INDEX learner_connections_pkey ON public.learner_connections USING btree (id);

CREATE UNIQUE INDEX learner_cvs_pkey ON public.learner_cvs USING btree (id);

CREATE UNIQUE INDEX learning_activities_pkey ON public.learning_activities USING btree (id);

CREATE UNIQUE INDEX lesson_approvals_pkey ON public.lesson_approvals USING btree (id);

CREATE UNIQUE INDEX lesson_categories_pkey ON public.lesson_categories USING btree (id);

CREATE UNIQUE INDEX lesson_progress_user_id_lesson_id_key ON public.lesson_progress USING btree (user_id, lesson_id);

CREATE UNIQUE INDEX marketing_campaigns_pkey ON public.marketing_campaigns USING btree (id);

CREATE UNIQUE INDEX marketing_campaigns_promo_code_key ON public.marketing_campaigns USING btree (promo_code);

CREATE UNIQUE INDEX media_uploads_pkey ON public.media_uploads USING btree (id);

CREATE UNIQUE INDEX meeting_action_items_pkey ON public.meeting_action_items USING btree (id);

CREATE UNIQUE INDEX meeting_participants_pkey ON public.meeting_participants USING btree (id);

CREATE UNIQUE INDEX meeting_participants_session_id_user_id_key ON public.meeting_participants USING btree (session_id, user_id);

CREATE UNIQUE INDEX meeting_rooms_pkey ON public.meeting_rooms USING btree (id);

CREATE UNIQUE INDEX meeting_sessions_pkey ON public.meeting_sessions USING btree (id);

CREATE UNIQUE INDEX meeting_shared_resources_pkey ON public.meeting_shared_resources USING btree (id);

CREATE UNIQUE INDEX member_events_pkey ON public.member_events USING btree (id);

CREATE UNIQUE INDEX member_fees_pkey ON public.member_fees USING btree (id);

CREATE UNIQUE INDEX member_id_cards_organization_id_card_number_key ON public.member_id_cards USING btree (organization_id, card_number);

CREATE UNIQUE INDEX member_id_cards_pkey ON public.member_id_cards USING btree (id);

CREATE UNIQUE INDEX member_invoices_organization_id_invoice_number_key ON public.member_invoices USING btree (organization_id, invoice_number);

CREATE UNIQUE INDEX member_invoices_pkey ON public.member_invoices USING btree (id);

CREATE UNIQUE INDEX membership_fee_structure_pkey ON public.membership_fee_structure USING btree (id);

CREATE UNIQUE INDEX membership_pop_uploads_pkey ON public.membership_pop_uploads USING btree (id);

CREATE UNIQUE INDEX message_drafts_pkey ON public.message_drafts USING btree (id);

CREATE UNIQUE INDEX message_participants_pkey ON public.message_participants USING btree (id);

CREATE UNIQUE INDEX message_participants_thread_id_user_id_key ON public.message_participants USING btree (thread_id, user_id);

CREATE UNIQUE INDEX message_participants_thread_user_unique ON public.message_participants USING btree (thread_id, user_id);

CREATE UNIQUE INDEX message_reactions_message_id_user_id_emoji_key ON public.message_reactions USING btree (message_id, user_id, emoji);

CREATE UNIQUE INDEX message_reactions_pkey ON public.message_reactions USING btree (id);

CREATE UNIQUE INDEX message_recipients_message_id_recipient_id_key ON public.message_recipients USING btree (message_id, recipient_id);

CREATE UNIQUE INDEX message_recipients_pkey ON public.message_recipients USING btree (id);

CREATE UNIQUE INDEX message_threads_pkey ON public.message_threads USING btree (id);

CREATE UNIQUE INDEX messages_pkey ON public.messages USING btree (id);

CREATE UNIQUE INDEX migration_logs_pkey ON public.migration_logs USING btree (id);

CREATE UNIQUE INDEX migration_logs_version_key ON public.migration_logs USING btree (version);

CREATE UNIQUE INDEX moderation_actions_pkey ON public.moderation_actions USING btree (id);

CREATE UNIQUE INDEX moderation_queue_pkey ON public.moderation_queue USING btree (id);

CREATE UNIQUE INDEX newsletter_recipients_pkey ON public.newsletter_recipients USING btree (id);

CREATE UNIQUE INDEX newsletters_pkey ON public.newsletters USING btree (id);

CREATE UNIQUE INDEX notification_deliveries_pkey ON public.notification_deliveries USING btree (id);

CREATE UNIQUE INDEX notification_history_pkey ON public.notification_history USING btree (id);

CREATE UNIQUE INDEX notification_logs_pkey ON public.notification_logs USING btree (id);

CREATE UNIQUE INDEX notification_templates_pkey ON public.notification_templates USING btree (id);

CREATE UNIQUE INDEX notification_templates_template_key_key ON public.notification_templates USING btree (template_key);

CREATE UNIQUE INDEX oauth_tokens_pkey ON public.oauth_tokens USING btree (id);

CREATE UNIQUE INDEX oauth_tokens_user_id_provider_key ON public.oauth_tokens USING btree (user_id, provider);

CREATE UNIQUE INDEX offer_letters_pkey ON public.offer_letters USING btree (id);

CREATE UNIQUE INDEX onboarding_progress_pkey ON public.onboarding_progress USING btree (id);

CREATE UNIQUE INDEX onboarding_progress_school_id_flow_type_key ON public.onboarding_progress USING btree (school_id, flow_type);

CREATE UNIQUE INDEX onboarding_requests_pkey ON public.onboarding_requests USING btree (id);

CREATE UNIQUE INDEX one_offer_per_application ON public.offer_letters USING btree (application_id);

CREATE UNIQUE INDEX org_dashboard_features_pkey ON public.org_dashboard_features USING btree (id);

CREATE UNIQUE INDEX org_invites_invite_token_key ON public.org_invites USING btree (invite_token);

CREATE UNIQUE INDEX org_invites_pkey ON public.org_invites USING btree (id);

CREATE UNIQUE INDEX organization_announcement_reci_announcement_id_recipient_id_key ON public.organization_announcement_recipients USING btree (announcement_id, recipient_id);

CREATE UNIQUE INDEX organization_announcement_recipients_pkey ON public.organization_announcement_recipients USING btree (id);

CREATE UNIQUE INDEX organization_announcements_pkey ON public.organization_announcements USING btree (id);

CREATE UNIQUE INDEX organization_bank_accounts_pkey ON public.organization_bank_accounts USING btree (id);

CREATE UNIQUE INDEX organization_board_positions_pkey ON public.organization_board_positions USING btree (id);

CREATE UNIQUE INDEX organization_budgets_pkey ON public.organization_budgets USING btree (id);

CREATE UNIQUE INDEX organization_document_access_pkey ON public.organization_document_access USING btree (id);

CREATE UNIQUE INDEX organization_document_access_requests_pkey ON public.organization_document_access_requests USING btree (id);

CREATE UNIQUE INDEX organization_document_audit_log_pkey ON public.organization_document_audit_log USING btree (id);

CREATE UNIQUE INDEX organization_document_folders_organization_id_folder_path_n_key ON public.organization_document_folders USING btree (organization_id, folder_path, name);

CREATE UNIQUE INDEX organization_members_org_email_unique ON public.organization_members USING btree (organization_id, email);

CREATE UNIQUE INDEX organization_members_org_id_number_unique ON public.organization_members USING btree (organization_id, id_number);

CREATE UNIQUE INDEX organization_members_user_id_organization_id_key ON public.organization_members USING btree (user_id, organization_id);

CREATE UNIQUE INDEX organization_payment_methods_pkey ON public.organization_payment_methods USING btree (id);

CREATE UNIQUE INDEX organization_petty_cash_pkey ON public.organization_petty_cash USING btree (id);

CREATE UNIQUE INDEX organization_regions_organization_id_code_key ON public.organization_regions USING btree (organization_id, code);

CREATE UNIQUE INDEX organization_roles_pkey ON public.organization_roles USING btree (id);

CREATE UNIQUE INDEX organization_roles_unique_role ON public.organization_roles USING btree (organization_id, role_id);

CREATE UNIQUE INDEX organization_transactions_pkey ON public.organization_transactions USING btree (id);

CREATE UNIQUE INDEX organization_wings_pkey ON public.organization_wings USING btree (id);

CREATE INDEX organizations_school_code_idx ON public.organizations USING btree (school_code) WHERE (school_code IS NOT NULL);

CREATE UNIQUE INDEX organizations_school_code_key ON public.organizations USING btree (school_code);

CREATE UNIQUE INDEX organizations_slug_unique_idx ON public.organizations USING btree (slug) WHERE (slug IS NOT NULL);

CREATE UNIQUE INDEX overage_billing_records_pkey ON public.overage_billing_records USING btree (id);

CREATE UNIQUE INDEX overage_notifications_pkey ON public.overage_notifications USING btree (id);

CREATE UNIQUE INDEX parent_access_codes_code_key ON public.parent_access_codes USING btree (code);

CREATE UNIQUE INDEX parent_access_codes_pkey ON public.parent_access_codes USING btree (id);

CREATE UNIQUE INDEX parent_child_links_parent_id_child_id_key ON public.parent_child_links USING btree (parent_id, child_id);

CREATE UNIQUE INDEX parent_child_links_pkey ON public.parent_child_links USING btree (id);

CREATE UNIQUE INDEX parent_join_requests_parent_id_organization_id_key ON public.parent_join_requests USING btree (parent_id, organization_id);

CREATE UNIQUE INDEX parent_join_requests_pkey ON public.parent_join_requests USING btree (id);

CREATE UNIQUE INDEX parent_payments_pkey ON public.parent_payments USING btree (id);

CREATE UNIQUE INDEX past_papers_pkey ON public.past_papers USING btree (id);

CREATE UNIQUE INDEX payfast_itn_logs_pkey ON public.payfast_itn_logs USING btree (id);

CREATE UNIQUE INDEX payment_reminders_pkey ON public.payment_reminders USING btree (id);

CREATE UNIQUE INDEX payment_transactions_pkey ON public.payment_transactions USING btree (id);

CREATE UNIQUE INDEX payments_pkey ON public.payments USING btree (id);

CREATE INDEX pdf_custom_templates_owner_user_id_idx ON public.pdf_custom_templates USING btree (owner_user_id);

CREATE UNIQUE INDEX pdf_custom_templates_pkey ON public.pdf_custom_templates USING btree (id);

CREATE UNIQUE INDEX pdf_documents_pkey ON public.pdf_documents USING btree (id);

CREATE INDEX pdf_documents_user_id_idx ON public.pdf_documents USING btree (user_id);

CREATE UNIQUE INDEX pdf_user_preferences_pkey ON public.pdf_user_preferences USING btree (id);

CREATE INDEX pdf_user_preferences_user_id_idx ON public.pdf_user_preferences USING btree (user_id);

CREATE UNIQUE INDEX pdf_user_preferences_user_id_key ON public.pdf_user_preferences USING btree (user_id);

CREATE UNIQUE INDEX petty_cash_accounts_name_preschool_unique ON public.petty_cash_accounts USING btree (school_id, name);

CREATE UNIQUE INDEX petty_cash_accounts_pkey ON public.petty_cash_accounts USING btree (id);

CREATE UNIQUE INDEX petty_cash_receipts_pkey ON public.petty_cash_receipts USING btree (id);

CREATE UNIQUE INDEX petty_cash_reconciliations_pkey ON public.petty_cash_reconciliations USING btree (id);

CREATE UNIQUE INDEX petty_cash_transactions_pkey ON public.petty_cash_transactions USING btree (id);

CREATE UNIQUE INDEX phone_verification_logs_pkey ON public.phone_verification_logs USING btree (id);

CREATE UNIQUE INDEX plan_quotas_pkey ON public.plan_quotas USING btree (id);

CREATE UNIQUE INDEX plan_quotas_plan_tier_quota_type_key ON public.plan_quotas USING btree (plan_tier, quota_type);

CREATE UNIQUE INDEX platform_analytics_pkey ON public.platform_analytics USING btree (id);

CREATE UNIQUE INDEX platform_collected_payments_pkey ON public.platform_collected_payments USING btree (id);

CREATE UNIQUE INDEX platform_disbursements_pkey ON public.platform_disbursements USING btree (id);

CREATE UNIQUE INDEX platform_subscriptions_pkey ON public.platform_subscriptions USING btree (id);

CREATE UNIQUE INDEX portfolio_items_pkey ON public.portfolio_items USING btree (id);

CREATE UNIQUE INDEX preschool_onboarding_requests_pkey ON public.preschool_onboarding_requests USING btree (id);

CREATE UNIQUE INDEX preschool_settings_pkey ON public.preschool_settings USING btree (id);

CREATE UNIQUE INDEX preschool_settings_preschool_id_key ON public.preschool_settings USING btree (preschool_id);

CREATE UNIQUE INDEX preschool_voice_usage_pkey ON public.preschool_voice_usage USING btree (id);

CREATE UNIQUE INDEX preschool_voice_usage_preschool_id_period_type_period_start_key ON public.preschool_voice_usage USING btree (preschool_id, period_type, period_start);

CREATE UNIQUE INDEX preschools_email_key ON public.preschools USING btree (email);

CREATE UNIQUE INDEX preschools_registration_number_key ON public.preschools USING btree (registration_number);

CREATE INDEX preschools_tenant_slug_idx ON public.preschools USING btree (tenant_slug);

CREATE UNIQUE INDEX preschools_tenant_slug_key ON public.preschools USING btree (tenant_slug);

CREATE UNIQUE INDEX principal_groups_pkey ON public.principal_groups USING btree (id);

CREATE UNIQUE INDEX principal_groups_preschool_id_name_key ON public.principal_groups USING btree (preschool_id, name);

CREATE UNIQUE INDEX profiles_auth_user_id_unique ON public.profiles USING btree (auth_user_id) WHERE (auth_user_id IS NOT NULL);

CREATE UNIQUE INDEX progress_reports_pkey ON public.progress_reports USING btree (id);

CREATE UNIQUE INDEX progress_reports_student_id_report_period_key ON public.progress_reports USING btree (student_id, report_period);

CREATE UNIQUE INDEX promotional_campaigns_code_key ON public.promotional_campaigns USING btree (code);

CREATE UNIQUE INDEX promotional_campaigns_pkey ON public.promotional_campaigns USING btree (id);

CREATE UNIQUE INDEX push_device_tokens_pkey ON public.push_device_tokens USING btree (id);

CREATE UNIQUE INDEX push_device_tokens_user_id_expo_push_token_key ON public.push_device_tokens USING btree (user_id, expo_push_token);

CREATE INDEX push_devices_active_idx ON public.push_devices USING btree (is_active, last_seen_at) WHERE (is_active = true);

CREATE INDEX push_devices_device_id_idx ON public.push_devices USING btree (device_id) WHERE (device_id IS NOT NULL);

CREATE INDEX push_devices_language_idx ON public.push_devices USING btree (language);

CREATE UNIQUE INDEX push_devices_pkey ON public.push_devices USING btree (id);

CREATE INDEX push_devices_token_lookup_idx ON public.push_devices USING btree (expo_push_token) WHERE (is_active = true);

CREATE UNIQUE INDEX push_devices_user_device_unique ON public.push_devices USING btree (user_id, device_installation_id);

CREATE UNIQUE INDEX push_notification_queue_pkey ON public.push_notification_queue USING btree (id);

CREATE UNIQUE INDEX push_notifications_pkey ON public.push_notifications USING btree (id);

CREATE INDEX push_notifications_preschool_idx ON public.push_notifications USING btree (preschool_id, created_at DESC) WHERE (preschool_id IS NOT NULL);

CREATE INDEX push_notifications_status_idx ON public.push_notifications USING btree (status, created_at DESC);

CREATE INDEX push_notifications_type_idx ON public.push_notifications USING btree (notification_type, preschool_id, created_at DESC);

CREATE INDEX push_notifications_user_idx ON public.push_notifications USING btree (recipient_user_id, created_at DESC);

CREATE UNIQUE INDEX push_subscriptions_endpoint_key ON public.push_subscriptions USING btree (endpoint);

CREATE UNIQUE INDEX push_subscriptions_pkey ON public.push_subscriptions USING btree (id);

CREATE UNIQUE INDEX push_subscriptions_user_endpoint_key ON public.push_subscriptions USING btree (user_id, endpoint);

CREATE UNIQUE INDEX rag_chunks_pkey ON public.rag_chunks USING btree (id);

CREATE UNIQUE INDEX rag_documents_pkey ON public.rag_documents USING btree (id);

CREATE UNIQUE INDEX rag_ingestion_logs_pkey ON public.rag_ingestion_logs USING btree (id);

CREATE UNIQUE INDEX reading_progress_pkey ON public.reading_progress USING btree (id);

CREATE UNIQUE INDEX reading_progress_user_id_textbook_id_key ON public.reading_progress USING btree (user_id, textbook_id);

CREATE UNIQUE INDEX region_invite_codes_code_key ON public.region_invite_codes USING btree (code);

CREATE UNIQUE INDEX region_invite_codes_pkey ON public.region_invite_codes USING btree (id);

CREATE UNIQUE INDEX registration_requests_pkey ON public.registration_requests USING btree (id);

CREATE UNIQUE INDEX resource_categories_pkey ON public.resource_categories USING btree (id);

CREATE UNIQUE INDEX resource_permissions_pkey ON public.resource_permissions USING btree (id);

CREATE UNIQUE INDEX resource_reviews_pkey ON public.resource_reviews USING btree (id);

CREATE UNIQUE INDEX resource_reviews_resource_id_user_id_key ON public.resource_reviews USING btree (resource_id, user_id);

CREATE UNIQUE INDEX resources_pkey ON public.resources USING btree (id);

CREATE UNIQUE INDEX revenuecat_webhook_events_event_id_key ON public.revenuecat_webhook_events USING btree (event_id);

CREATE UNIQUE INDEX revenuecat_webhook_events_pkey ON public.revenuecat_webhook_events USING btree (id);

CREATE UNIQUE INDEX rubric_grades_grade_id_rubric_id_key ON public.rubric_grades USING btree (grade_id, rubric_id);

CREATE UNIQUE INDEX rubric_grades_pkey ON public.rubric_grades USING btree (id);

CREATE UNIQUE INDEX scheduled_lessons_pkey ON public.scheduled_lessons USING btree (id);

CREATE UNIQUE INDEX scheduled_tasks_pkey ON public.scheduled_tasks USING btree (id);

CREATE UNIQUE INDEX school_ai_subscriptions_pkey ON public.school_ai_subscriptions USING btree (id);

CREATE UNIQUE INDEX school_ai_subscriptions_preschool_id_key ON public.school_ai_subscriptions USING btree (preschool_id);

CREATE UNIQUE INDEX school_branding_pkey ON public.school_branding USING btree (id);

CREATE UNIQUE INDEX school_events_pkey ON public.school_events USING btree (id);

CREATE UNIQUE INDEX school_fee_structures_pkey ON public.school_fee_structures USING btree (id);

CREATE UNIQUE INDEX school_invitation_codes_code_key ON public.school_invitation_codes USING btree (code);

CREATE UNIQUE INDEX school_invitation_codes_pkey ON public.school_invitation_codes USING btree (id);

CREATE UNIQUE INDEX school_settings_pkey ON public.school_settings USING btree (id);

CREATE UNIQUE INDEX school_settings_preschool_id_key ON public.school_settings USING btree (preschool_id);

CREATE UNIQUE INDEX school_verifications_pkey ON public.school_verifications USING btree (id);

CREATE UNIQUE INDEX schools_pkey ON public.schools USING btree (id);

CREATE UNIQUE INDEX seats_pkey ON public.seats USING btree (id);

CREATE UNIQUE INDEX seats_subscription_id_user_id_key ON public.seats USING btree (subscription_id, user_id);

CREATE UNIQUE INDEX security_events_pkey ON public.security_events USING btree (id);

CREATE UNIQUE INDEX service_alert_config_pkey ON public.service_alert_config USING btree (service_name);

CREATE UNIQUE INDEX service_alerts_dedupe_key_triggered_at_key ON public.service_alerts USING btree (dedupe_key, triggered_at);

CREATE UNIQUE INDEX service_alerts_pkey ON public.service_alerts USING btree (id);

CREATE UNIQUE INDEX service_api_keys_pkey ON public.service_api_keys USING btree (id);

CREATE UNIQUE INDEX service_api_keys_service_name_key ON public.service_api_keys USING btree (service_name);

CREATE UNIQUE INDEX service_cost_tracking_pkey ON public.service_cost_tracking USING btree (id);

CREATE UNIQUE INDEX service_cost_tracking_preschool_id_service_name_period_mont_key ON public.service_cost_tracking USING btree (preschool_id, service_name, period_month);

CREATE UNIQUE INDEX service_health_status_pkey ON public.service_health_status USING btree (id);

CREATE UNIQUE INDEX service_health_status_service_name_key ON public.service_health_status USING btree (service_name);

CREATE UNIQUE INDEX service_incidents_pkey ON public.service_incidents USING btree (id);

CREATE UNIQUE INDEX service_usage_limits_pkey ON public.service_usage_limits USING btree (id);

CREATE UNIQUE INDEX service_usage_limits_preschool_id_service_name_period_start_key ON public.service_usage_limits USING btree (preschool_id, service_name, period_start);

CREATE UNIQUE INDEX sms_messages_pkey ON public.sms_messages USING btree (id);

CREATE UNIQUE INDEX sms_opt_outs_pkey ON public.sms_opt_outs USING btree (id);

CREATE UNIQUE INDEX sms_opt_outs_preschool_id_phone_number_key ON public.sms_opt_outs USING btree (preschool_id, phone_number);

CREATE UNIQUE INDEX sound_alert_settings_pkey ON public.sound_alert_settings USING btree (id);

CREATE UNIQUE INDEX sound_alert_settings_user_id_alert_type_key ON public.sound_alert_settings USING btree (user_id, alert_type);

CREATE UNIQUE INDEX standalone_users_pkey ON public.standalone_users USING btree (id);

CREATE UNIQUE INDEX standalone_users_profile_id_key ON public.standalone_users USING btree (profile_id);

CREATE UNIQUE INDEX standalone_users_user_id_key ON public.standalone_users USING btree (user_id);

CREATE UNIQUE INDEX stem_progress_pkey ON public.stem_progress USING btree (id);

CREATE UNIQUE INDEX stem_progress_student_id_preschool_id_category_key ON public.stem_progress USING btree (student_id, preschool_id, category);

CREATE UNIQUE INDEX student_achievements_pkey ON public.student_achievements USING btree (id);

CREATE UNIQUE INDEX student_enrollments_pkey ON public.student_enrollments USING btree (id);

CREATE UNIQUE INDEX student_enrollments_student_id_class_id_key ON public.student_enrollments USING btree (student_id, class_id);

CREATE UNIQUE INDEX student_fee_assignments_pkey ON public.student_fee_assignments USING btree (id);

CREATE UNIQUE INDEX student_fee_assignments_student_id_fee_structure_id_assigne_key ON public.student_fee_assignments USING btree (student_id, fee_structure_id, assigned_date);

CREATE UNIQUE INDEX student_fees_student_id_fee_structure_id_due_date_key ON public.student_fees USING btree (student_id, fee_structure_id, due_date);

CREATE UNIQUE INDEX student_groups_pkey ON public.student_groups USING btree (id);

CREATE UNIQUE INDEX student_groups_student_id_group_id_key ON public.student_groups USING btree (student_id, group_id);

CREATE UNIQUE INDEX student_parent_relationships_pkey ON public.student_parent_relationships USING btree (id);

CREATE UNIQUE INDEX student_parent_relationships_student_id_parent_id_key ON public.student_parent_relationships USING btree (student_id, parent_id);

CREATE UNIQUE INDEX student_progress_course_id_student_id_key ON public.student_progress USING btree (course_id, student_id);

CREATE UNIQUE INDEX student_progress_pkey ON public.student_progress USING btree (id);

CREATE UNIQUE INDEX student_streaks_pkey ON public.student_streaks USING btree (id);

CREATE UNIQUE INDEX student_streaks_student_id_streak_type_key ON public.student_streaks USING btree (student_id, streak_type);

CREATE UNIQUE INDEX students_student_id_key ON public.students USING btree (student_id);

CREATE UNIQUE INDEX study_groups_pkey ON public.study_groups USING btree (id);

CREATE UNIQUE INDEX submissions_assignment_id_student_id_attempt_number_key ON public.submissions USING btree (assignment_id, student_id, attempt_number);

CREATE UNIQUE INDEX submissions_pkey ON public.submissions USING btree (id);

CREATE UNIQUE INDEX subscription_plans_pkey ON public.subscription_plans USING btree (id);

CREATE UNIQUE INDEX subscription_plans_tier_key ON public.subscription_plans USING btree (tier);

CREATE UNIQUE INDEX subscription_seats_pkey ON public.subscription_seats USING btree (id);

CREATE UNIQUE INDEX subscription_usage_pkey ON public.subscription_usage USING btree (id);

CREATE UNIQUE INDEX subscription_usage_subscription_id_usage_type_period_start_key ON public.subscription_usage USING btree (subscription_id, usage_type, period_start);

CREATE UNIQUE INDEX subscriptions_pkey ON public.subscriptions USING btree (id);

CREATE UNIQUE INDEX superadmin_agent_executions_pkey ON public.superadmin_agent_executions USING btree (id);

CREATE UNIQUE INDEX superadmin_ai_agents_pkey ON public.superadmin_ai_agents USING btree (id);

CREATE UNIQUE INDEX superadmin_audit_log_pkey ON public.superadmin_audit_log USING btree (id);

CREATE UNIQUE INDEX superadmin_autonomous_tasks_pkey ON public.superadmin_autonomous_tasks USING btree (id);

CREATE UNIQUE INDEX superadmin_command_log_pkey ON public.superadmin_command_log USING btree (id);

CREATE UNIQUE INDEX superadmin_compliance_reports_pkey ON public.superadmin_compliance_reports USING btree (id);

CREATE UNIQUE INDEX superadmin_integrations_pkey ON public.superadmin_integrations USING btree (id);

CREATE UNIQUE INDEX superadmin_notification_deliveries_pkey ON public.superadmin_notification_deliveries USING btree (id);

CREATE UNIQUE INDEX superadmin_notification_rules_pkey ON public.superadmin_notification_rules USING btree (id);

CREATE UNIQUE INDEX superadmin_notification_rules_rule_name_key ON public.superadmin_notification_rules USING btree (rule_name);

CREATE UNIQUE INDEX superadmin_notifications_pkey ON public.superadmin_notifications USING btree (id);

CREATE UNIQUE INDEX superadmin_platform_insights_pkey ON public.superadmin_platform_insights USING btree (id);

CREATE UNIQUE INDEX superadmin_role_assignments_pkey ON public.superadmin_role_assignments USING btree (id);

CREATE UNIQUE INDEX superadmin_session_management_pkey ON public.superadmin_session_management USING btree (id);

CREATE UNIQUE INDEX superadmin_user_actions_pkey ON public.superadmin_user_actions USING btree (id);

CREATE UNIQUE INDEX superadmin_user_deletion_requests_pkey ON public.superadmin_user_deletion_requests USING btree (id);

CREATE UNIQUE INDEX superadmin_user_risk_assessments_pkey ON public.superadmin_user_risk_assessments USING btree (id);

CREATE UNIQUE INDEX support_tickets_pkey ON public.support_tickets USING btree (id);

CREATE UNIQUE INDEX sync_logs_pkey ON public.sync_logs USING btree (id);

CREATE UNIQUE INDEX system_config_pkey ON public.system_config USING btree (key);

CREATE UNIQUE INDEX system_settings_key_key ON public.system_settings USING btree (key);

CREATE UNIQUE INDEX system_settings_pkey ON public.system_settings USING btree (id);

CREATE UNIQUE INDEX teacher_ai_allocations_pkey ON public.teacher_ai_allocations USING btree (id);

CREATE UNIQUE INDEX teacher_ai_allocations_preschool_id_user_id_period_start_key ON public.teacher_ai_allocations USING btree (preschool_id, user_id, period_start);

CREATE UNIQUE INDEX teacher_class_codes_code_key ON public.teacher_class_codes USING btree (code);

CREATE UNIQUE INDEX teacher_class_codes_pkey ON public.teacher_class_codes USING btree (id);

CREATE UNIQUE INDEX teacher_invitations_invitation_code_key ON public.teacher_invitations USING btree (invitation_code);

CREATE UNIQUE INDEX teacher_invitations_pkey ON public.teacher_invitations USING btree (id);

CREATE UNIQUE INDEX teacher_invites_token_key ON public.teacher_invites USING btree (token);

CREATE UNIQUE INDEX teacher_performance_metrics_pkey ON public.teacher_performance_metrics USING btree (id);

CREATE UNIQUE INDEX teacher_performance_metrics_teacher_id_metric_period_start__key ON public.teacher_performance_metrics USING btree (teacher_id, metric_period_start, metric_period_end);

CREATE UNIQUE INDEX teacher_student_notes_pkey ON public.teacher_student_notes USING btree (id);

CREATE UNIQUE INDEX teachers_pkey ON public.teachers USING btree (id);

CREATE UNIQUE INDEX template_approvals_pkey ON public.template_approvals USING btree (id);

CREATE UNIQUE INDEX template_usage_logs_pkey ON public.template_usage_logs USING btree (id);

CREATE UNIQUE INDEX template_variables_pkey ON public.template_variables USING btree (id);

CREATE UNIQUE INDEX template_variables_template_id_variable_name_key ON public.template_variables USING btree (template_id, variable_name);

CREATE UNIQUE INDEX tenants_pkey ON public.tenants USING btree (id);

CREATE UNIQUE INDEX tester_feedback_pkey ON public.tester_feedback USING btree (id);

CREATE UNIQUE INDEX textbook_chapters_pkey ON public.textbook_chapters USING btree (id);

CREATE UNIQUE INDEX textbook_chapters_textbook_id_chapter_number_key ON public.textbook_chapters USING btree (textbook_id, chapter_number);

CREATE UNIQUE INDEX textbook_content_pkey ON public.textbook_content USING btree (id);

CREATE UNIQUE INDEX textbook_pages_pkey ON public.textbook_pages USING btree (id);

CREATE UNIQUE INDEX textbook_pages_textbook_id_page_number_key ON public.textbook_pages USING btree (textbook_id, page_number);

CREATE UNIQUE INDEX textbooks_isbn_edition_key ON public.textbooks USING btree (isbn, edition);

CREATE UNIQUE INDEX textbooks_pkey ON public.textbooks USING btree (id);

CREATE UNIQUE INDEX trial_usage_log_pkey ON public.trial_usage_log USING btree (id);

CREATE UNIQUE INDEX tts_audio_cache_hash_key ON public.tts_audio_cache USING btree (hash);

CREATE UNIQUE INDEX tts_audio_cache_pkey ON public.tts_audio_cache USING btree (id);

CREATE UNIQUE INDEX typing_indicators_pkey ON public.typing_indicators USING btree (id);

CREATE UNIQUE INDEX typing_indicators_thread_id_user_id_key ON public.typing_indicators USING btree (thread_id, user_id);

CREATE UNIQUE INDEX uniq_active_subscription_user ON public.subscription_seats USING btree (subscription_id, user_id) WHERE (revoked_at IS NULL);

CREATE UNIQUE INDEX uniq_assignment_class_target ON public.homework_assignment_targets USING btree (assignment_id, class_id) WHERE ((class_id IS NOT NULL) AND (student_id IS NULL));

CREATE UNIQUE INDEX uniq_assignment_student_target ON public.homework_assignment_targets USING btree (assignment_id, student_id) WHERE (student_id IS NOT NULL);

CREATE UNIQUE INDEX unique_alert_per_candidate ON public.job_alerts USING btree (candidate_profile_id);

CREATE UNIQUE INDEX unique_application_per_job ON public.job_applications USING btree (job_posting_id, candidate_profile_id);

CREATE UNIQUE INDEX unique_executive_position_idx ON public.organization_board_positions USING btree (organization_id, position_code) WHERE (position_code <> 'board_member'::text);

CREATE UNIQUE INDEX unique_fee_code ON public.membership_fee_structure USING btree (organization_id, fee_code);

CREATE UNIQUE INDEX unique_invoice_number_per_school ON public.invoices USING btree (preschool_id, invoice_number);

CREATE UNIQUE INDEX unique_org_wing ON public.organization_wings USING btree (organization_id, wing_code);

CREATE UNIQUE INDEX unique_preschool_branding ON public.school_branding USING btree (preschool_id);

CREATE UNIQUE INDEX unique_wing_region ON public.wing_regional_coordinators USING btree (wing_id, region_id);

CREATE UNIQUE INDEX user_ai_tiers_pkey ON public.user_ai_tiers USING btree (id);

CREATE UNIQUE INDEX user_ai_tiers_user_id_key ON public.user_ai_tiers USING btree (user_id);

CREATE UNIQUE INDEX user_ai_usage_pkey ON public.user_ai_usage USING btree (id);

CREATE UNIQUE INDEX user_ai_usage_user_id_key ON public.user_ai_usage USING btree (user_id);

CREATE UNIQUE INDEX user_blocks_pkey ON public.user_blocks USING btree (id);

CREATE UNIQUE INDEX user_blocks_unique ON public.user_blocks USING btree (blocker_id, blocked_id, block_type);

CREATE UNIQUE INDEX user_bookmarks_pkey ON public.user_bookmarks USING btree (id);

CREATE UNIQUE INDEX user_bookmarks_user_id_textbook_id_key ON public.user_bookmarks USING btree (user_id, textbook_id);

CREATE UNIQUE INDEX user_connections_pkey ON public.user_connections USING btree (id);

CREATE UNIQUE INDEX user_connections_requester_id_addressee_id_key ON public.user_connections USING btree (requester_id, addressee_id);

CREATE UNIQUE INDEX user_contacts_pkey ON public.user_contacts USING btree (id);

CREATE UNIQUE INDEX user_contacts_user_id_phone_number_hash_key ON public.user_contacts USING btree (user_id, phone_number_hash);

CREATE UNIQUE INDEX user_invitations_pkey ON public.user_invitations USING btree (id);

CREATE UNIQUE INDEX user_invitations_token_key ON public.user_invitations USING btree (token);

CREATE UNIQUE INDEX user_phone_numbers_phone_number_key ON public.user_phone_numbers USING btree (phone_number);

CREATE UNIQUE INDEX user_phone_numbers_pkey ON public.user_phone_numbers USING btree (id);

CREATE UNIQUE INDEX user_preferences_pkey ON public.user_preferences USING btree (id);

CREATE UNIQUE INDEX user_preferences_user_id_key ON public.user_preferences USING btree (user_id);

CREATE UNIQUE INDEX user_presence_pkey ON public.user_presence USING btree (user_id);

CREATE INDEX user_profiles_auth_id_idx ON public.user_profiles USING btree (auth_id);

CREATE UNIQUE INDEX user_profiles_pkey ON public.user_profiles USING btree (id);

CREATE UNIQUE INDEX user_promotional_subscriptions_pkey ON public.user_promotional_subscriptions USING btree (id);

CREATE UNIQUE INDEX user_promotional_subscriptions_user_id_tier_key ON public.user_promotional_subscriptions USING btree (user_id, tier);

CREATE UNIQUE INDEX user_usage_tracking_pkey ON public.user_usage_tracking USING btree (id);

CREATE UNIQUE INDEX user_usage_tracking_user_id_quota_type_usage_period_start_key ON public.user_usage_tracking USING btree (user_id, quota_type, usage_period_start);

CREATE UNIQUE INDEX user_voice_usage_pkey ON public.user_voice_usage USING btree (id);

CREATE UNIQUE INDEX user_voice_usage_user_id_period_type_period_start_key ON public.user_voice_usage USING btree (user_id, period_type, period_start);

CREATE UNIQUE INDEX users_auth_user_id_key ON public.users USING btree (auth_user_id);

CREATE UNIQUE INDEX users_auth_user_id_unique ON public.users USING btree (auth_user_id);

CREATE UNIQUE INDEX users_email_key ON public.users USING btree (email);

CREATE UNIQUE INDEX users_pkey ON public.users USING btree (id);

CREATE UNIQUE INDEX ux_teachers_user_id ON public.teachers USING btree (user_id);

CREATE UNIQUE INDEX video_call_participants_call_id_user_id_key ON public.video_call_participants USING btree (call_id, user_id);

CREATE UNIQUE INDEX video_calls_meeting_id_key ON public.video_calls USING btree (meeting_id);

CREATE UNIQUE INDEX voice_notes_pkey ON public.voice_notes USING btree (id);

CREATE UNIQUE INDEX voice_preferences_pkey ON public.voice_preferences USING btree (id);

CREATE UNIQUE INDEX voice_preferences_preschool_id_user_id_key ON public.voice_preferences USING btree (preschool_id, user_id);

CREATE UNIQUE INDEX voice_usage_logs_pkey ON public.voice_usage_logs USING btree (id);

CREATE UNIQUE INDEX voice_usage_quotas_pkey ON public.voice_usage_quotas USING btree (id);

CREATE UNIQUE INDEX voice_usage_quotas_subscription_tier_key ON public.voice_usage_quotas USING btree (subscription_tier);

CREATE UNIQUE INDEX webhook_logs_pkey ON public.webhook_logs USING btree (id);

CREATE INDEX whatsapp_contacts_consent_idx ON public.whatsapp_contacts USING btree (consent_status) WHERE (consent_status = 'opted_in'::public.whatsapp_consent_status);

CREATE INDEX whatsapp_contacts_phone_idx ON public.whatsapp_contacts USING btree (preschool_id, phone_e164);

CREATE UNIQUE INDEX whatsapp_contacts_pkey ON public.whatsapp_contacts USING btree (id);

CREATE UNIQUE INDEX whatsapp_contacts_unique_user_per_school ON public.whatsapp_contacts USING btree (preschool_id, user_id);

CREATE INDEX whatsapp_contacts_user_idx ON public.whatsapp_contacts USING btree (user_id);

CREATE INDEX whatsapp_contacts_user_preschool_idx ON public.whatsapp_contacts USING btree (user_id, preschool_id);

CREATE UNIQUE INDEX wing_regional_coordinators_pkey ON public.wing_regional_coordinators USING btree (id);

CREATE INDEX idx_students_parent_id ON public.students USING btree (parent_id);

CREATE INDEX idx_video_call_participants_call_id ON public.video_call_participants USING btree (call_id);

alter table "public"."active_calls" add constraint "active_calls_pkey" PRIMARY KEY using index "active_calls_pkey";

alter table "public"."activities" add constraint "activities_pkey" PRIMARY KEY using index "activities_pkey";

alter table "public"."activity_attempts" add constraint "activity_attempts_pkey" PRIMARY KEY using index "activity_attempts_pkey";

alter table "public"."activity_feed" add constraint "activity_feed_pkey" PRIMARY KEY using index "activity_feed_pkey";

alter table "public"."activity_logs" add constraint "activity_logs_pkey" PRIMARY KEY using index "activity_logs_pkey";

alter table "public"."activity_submissions" add constraint "activity_submissions_pkey" PRIMARY KEY using index "activity_submissions_pkey";

alter table "public"."ad_impressions" add constraint "ad_impressions_pkey" PRIMARY KEY using index "ad_impressions_pkey";

alter table "public"."addresses" add constraint "addresses_pkey" PRIMARY KEY using index "addresses_pkey";

alter table "public"."admin_users" add constraint "admin_users_pkey" PRIMARY KEY using index "admin_users_pkey";

alter table "public"."age_groups" add constraint "age_groups_pkey" PRIMARY KEY using index "age_groups_pkey";

alter table "public"."ai_admin_actions" add constraint "ai_admin_actions_pkey" PRIMARY KEY using index "ai_admin_actions_pkey";

alter table "public"."ai_allocation_history" add constraint "ai_allocation_history_pkey" PRIMARY KEY using index "ai_allocation_history_pkey";

alter table "public"."ai_allocation_requests" add constraint "ai_allocation_requests_pkey" PRIMARY KEY using index "ai_allocation_requests_pkey";

alter table "public"."ai_attachments" add constraint "ai_attachments_pkey" PRIMARY KEY using index "ai_attachments_pkey";

alter table "public"."ai_autonomy_settings" add constraint "ai_autonomy_settings_pkey" PRIMARY KEY using index "ai_autonomy_settings_pkey";

alter table "public"."ai_context_snapshots" add constraint "ai_context_snapshots_pkey" PRIMARY KEY using index "ai_context_snapshots_pkey";

alter table "public"."ai_conversations" add constraint "ai_conversations_pkey" PRIMARY KEY using index "ai_conversations_pkey";

alter table "public"."ai_events" add constraint "ai_events_pkey" PRIMARY KEY using index "ai_events_pkey";

alter table "public"."ai_feedback" add constraint "ai_feedback_pkey" PRIMARY KEY using index "ai_feedback_pkey";

alter table "public"."ai_generated_content" add constraint "ai_generated_content_pkey" PRIMARY KEY using index "ai_generated_content_pkey";

alter table "public"."ai_generations" add constraint "ai_generations_pkey" PRIMARY KEY using index "ai_generations_pkey";

alter table "public"."ai_global_settings" add constraint "ai_global_settings_pkey" PRIMARY KEY using index "ai_global_settings_pkey";

alter table "public"."ai_insights" add constraint "ai_insights_pkey" PRIMARY KEY using index "ai_insights_pkey";

alter table "public"."ai_memories" add constraint "ai_memories_pkey" PRIMARY KEY using index "ai_memories_pkey";

alter table "public"."ai_messages" add constraint "ai_messages_pkey" PRIMARY KEY using index "ai_messages_pkey";

alter table "public"."ai_model_tiers" add constraint "ai_model_tiers_pkey" PRIMARY KEY using index "ai_model_tiers_pkey";

alter table "public"."ai_overage_logs" add constraint "ai_overage_logs_pkey" PRIMARY KEY using index "ai_overage_logs_pkey";

alter table "public"."ai_provider_config" add constraint "ai_provider_config_pkey" PRIMARY KEY using index "ai_provider_config_pkey";

alter table "public"."ai_recommendations" add constraint "ai_recommendations_pkey" PRIMARY KEY using index "ai_recommendations_pkey";

alter table "public"."ai_request_log" add constraint "ai_request_log_pkey" PRIMARY KEY using index "ai_request_log_pkey";

alter table "public"."ai_services" add constraint "ai_services_pkey" PRIMARY KEY using index "ai_services_pkey";

alter table "public"."ai_task_runs" add constraint "ai_task_runs_pkey" PRIMARY KEY using index "ai_task_runs_pkey";

alter table "public"."ai_usage" add constraint "ai_usage_pkey" PRIMARY KEY using index "ai_usage_pkey";

alter table "public"."ai_usage_logs" add constraint "ai_usage_logs_pkey" PRIMARY KEY using index "ai_usage_logs_pkey";

alter table "public"."ai_usage_resets" add constraint "ai_usage_resets_pkey" PRIMARY KEY using index "ai_usage_resets_pkey";

alter table "public"."ai_usage_tiers" add constraint "ai_usage_tiers_pkey" PRIMARY KEY using index "ai_usage_tiers_pkey";

alter table "public"."announcement_views" add constraint "announcement_views_pkey" PRIMARY KEY using index "announcement_views_pkey";

alter table "public"."announcements" add constraint "announcements_pkey" PRIMARY KEY using index "announcements_pkey";

alter table "public"."assessment_rubrics" add constraint "assessment_rubrics_pkey" PRIMARY KEY using index "assessment_rubrics_pkey";

alter table "public"."assessments" add constraint "assessments_pkey" PRIMARY KEY using index "assessments_pkey";

alter table "public"."assignment_access" add constraint "assignment_access_pkey" PRIMARY KEY using index "assignment_access_pkey";

alter table "public"."assignment_categories" add constraint "assignment_categories_pkey" PRIMARY KEY using index "assignment_categories_pkey";

alter table "public"."assignment_grades" add constraint "assignment_grades_pkey" PRIMARY KEY using index "assignment_grades_pkey";

alter table "public"."assignment_rubrics" add constraint "assignment_rubrics_pkey" PRIMARY KEY using index "assignment_rubrics_pkey";

alter table "public"."assignment_submissions" add constraint "assignment_submissions_pkey" PRIMARY KEY using index "assignment_submissions_pkey";

alter table "public"."assignments" add constraint "assignments_pkey" PRIMARY KEY using index "assignments_pkey";

alter table "public"."attendance" add constraint "attendance_pkey" PRIMARY KEY using index "attendance_pkey";

alter table "public"."attendance_records" add constraint "attendance_records_pkey" PRIMARY KEY using index "attendance_records_pkey";

alter table "public"."audit_logs" add constraint "audit_logs_pkey" PRIMARY KEY using index "audit_logs_pkey";

alter table "public"."beta_feedback" add constraint "beta_feedback_pkey" PRIMARY KEY using index "beta_feedback_pkey";

alter table "public"."beta_feedback_attachments" add constraint "beta_feedback_attachments_pkey" PRIMARY KEY using index "beta_feedback_attachments_pkey";

alter table "public"."billing_cycles" add constraint "billing_cycles_pkey" PRIMARY KEY using index "billing_cycles_pkey";

alter table "public"."billing_invoices" add constraint "billing_invoices_pkey" PRIMARY KEY using index "billing_invoices_pkey";

alter table "public"."billing_plans" add constraint "billing_plans_pkey" PRIMARY KEY using index "billing_plans_pkey";

alter table "public"."billing_preferences" add constraint "billing_preferences_pkey" PRIMARY KEY using index "billing_preferences_pkey";

alter table "public"."blocked_content" add constraint "blocked_content_pkey" PRIMARY KEY using index "blocked_content_pkey";

alter table "public"."books" add constraint "books_pkey" PRIMARY KEY using index "books_pkey";

alter table "public"."calendar_event_mappings" add constraint "calendar_event_mappings_pkey" PRIMARY KEY using index "calendar_event_mappings_pkey";

alter table "public"."call_signals" add constraint "call_signals_pkey" PRIMARY KEY using index "call_signals_pkey";

alter table "public"."campaign_redemptions" add constraint "campaign_redemptions_pkey" PRIMARY KEY using index "campaign_redemptions_pkey";

alter table "public"."caps_chunks" add constraint "caps_chunks_pkey" PRIMARY KEY using index "caps_chunks_pkey";

alter table "public"."caps_content_chunks" add constraint "caps_content_chunks_pkey" PRIMARY KEY using index "caps_content_chunks_pkey";

alter table "public"."caps_documents" add constraint "caps_documents_pkey" PRIMARY KEY using index "caps_documents_pkey";

alter table "public"."caps_exam_patterns" add constraint "caps_exam_patterns_pkey" PRIMARY KEY using index "caps_exam_patterns_pkey";

alter table "public"."caps_exam_questions" add constraint "caps_exam_questions_pkey" PRIMARY KEY using index "caps_exam_questions_pkey";

alter table "public"."caps_textbook_mapping" add constraint "caps_textbook_mapping_pkey" PRIMARY KEY using index "caps_textbook_mapping_pkey";

alter table "public"."caps_topics" add constraint "caps_topics_pkey" PRIMARY KEY using index "caps_topics_pkey";

alter table "public"."chat_images" add constraint "chat_images_pkey" PRIMARY KEY using index "chat_images_pkey";

alter table "public"."class_assignments" add constraint "class_assignments_pkey" PRIMARY KEY using index "class_assignments_pkey";

alter table "public"."class_events" add constraint "class_events_pkey" PRIMARY KEY using index "class_events_pkey";

alter table "public"."classroom_reports" add constraint "classroom_reports_pkey" PRIMARY KEY using index "classroom_reports_pkey";

alter table "public"."config_kv" add constraint "config_kv_pkey" PRIMARY KEY using index "config_kv_pkey";

alter table "public"."contact_discovery_settings" add constraint "contact_discovery_settings_pkey" PRIMARY KEY using index "contact_discovery_settings_pkey";

alter table "public"."contact_suggestions" add constraint "contact_suggestions_pkey" PRIMARY KEY using index "contact_suggestions_pkey";

alter table "public"."content_reports" add constraint "content_reports_pkey" PRIMARY KEY using index "content_reports_pkey";

alter table "public"."conversation_members" add constraint "conversation_members_pkey" PRIMARY KEY using index "conversation_members_pkey";

alter table "public"."conversations" add constraint "conversations_pkey" PRIMARY KEY using index "conversations_pkey";

alter table "public"."course_grades" add constraint "course_grades_pkey" PRIMARY KEY using index "course_grades_pkey";

alter table "public"."course_join_requests" add constraint "course_join_requests_pkey" PRIMARY KEY using index "course_join_requests_pkey";

alter table "public"."courses" add constraint "courses_pkey" PRIMARY KEY using index "courses_pkey";

alter table "public"."cv_templates" add constraint "cv_templates_pkey" PRIMARY KEY using index "cv_templates_pkey";

alter table "public"."cv_uploads" add constraint "cv_uploads_pkey" PRIMARY KEY using index "cv_uploads_pkey";

alter table "public"."daily_activities" add constraint "daily_activities_pkey" PRIMARY KEY using index "daily_activities_pkey";

alter table "public"."dash_agent_instances" add constraint "dash_agent_instances_pkey" PRIMARY KEY using index "dash_agent_instances_pkey";

alter table "public"."dash_conversation_facts" add constraint "dash_conversation_facts_pkey" PRIMARY KEY using index "dash_conversation_facts_pkey";

alter table "public"."dash_curriculum_memory" add constraint "dash_curriculum_memory_pkey" PRIMARY KEY using index "dash_curriculum_memory_pkey";

alter table "public"."dash_reminders" add constraint "dash_reminders_pkey" PRIMARY KEY using index "dash_reminders_pkey";

alter table "public"."dash_storage" add constraint "dash_storage_pkey" PRIMARY KEY using index "dash_storage_pkey";

alter table "public"."dash_user_contexts" add constraint "dash_user_contexts_pkey" PRIMARY KEY using index "dash_user_contexts_pkey";

alter table "public"."dashboard_voice_notes" add constraint "dashboard_voice_notes_pkey" PRIMARY KEY using index "dashboard_voice_notes_pkey";

alter table "public"."deletion_requests" add constraint "deletion_requests_pkey" PRIMARY KEY using index "deletion_requests_pkey";

alter table "public"."delivery_providers" add constraint "delivery_providers_pkey" PRIMARY KEY using index "delivery_providers_pkey";

alter table "public"."delivery_retry_queue" add constraint "delivery_retry_queue_pkey" PRIMARY KEY using index "delivery_retry_queue_pkey";

alter table "public"."delivery_webhooks" add constraint "delivery_webhooks_pkey" PRIMARY KEY using index "delivery_webhooks_pkey";

alter table "public"."dm_settings" add constraint "dm_settings_pkey" PRIMARY KEY using index "dm_settings_pkey";

alter table "public"."early_access_signups" add constraint "early_access_signups_pkey" PRIMARY KEY using index "early_access_signups_pkey";

alter table "public"."email_logs" add constraint "email_logs_pkey" PRIMARY KEY using index "email_logs_pkey";

alter table "public"."email_preferences" add constraint "email_preferences_pkey" PRIMARY KEY using index "email_preferences_pkey";

alter table "public"."email_templates" add constraint "email_templates_pkey" PRIMARY KEY using index "email_templates_pkey";

alter table "public"."emergency_contacts" add constraint "emergency_contacts_pkey" PRIMARY KEY using index "emergency_contacts_pkey";

alter table "public"."enrollment_applications" add constraint "enrollment_applications_pkey" PRIMARY KEY using index "enrollment_applications_pkey";

alter table "public"."enrollments" add constraint "enrollments_pkey" PRIMARY KEY using index "enrollments_pkey";

alter table "public"."enterprise_leads" add constraint "enterprise_leads_pkey" PRIMARY KEY using index "enterprise_leads_pkey";

alter table "public"."error_logs" add constraint "error_logs_pkey" PRIMARY KEY using index "error_logs_pkey";

alter table "public"."event_attendees" add constraint "event_attendees_pkey" PRIMARY KEY using index "event_attendees_pkey";

alter table "public"."event_audiences" add constraint "event_audiences_pkey" PRIMARY KEY using index "event_audiences_pkey";

alter table "public"."event_invitations" add constraint "event_invitations_pkey" PRIMARY KEY using index "event_invitations_pkey";

alter table "public"."event_media" add constraint "event_media_pkey" PRIMARY KEY using index "event_media_pkey";

alter table "public"."event_notifications" add constraint "event_notifications_pkey" PRIMARY KEY using index "event_notifications_pkey";

alter table "public"."event_participants" add constraint "event_participants_pkey" PRIMARY KEY using index "event_participants_pkey";

alter table "public"."event_reactions" add constraint "event_reactions_pkey" PRIMARY KEY using index "event_reactions_pkey";

alter table "public"."event_rsvps" add constraint "event_rsvps_pkey" PRIMARY KEY using index "event_rsvps_pkey";

alter table "public"."event_updates" add constraint "event_updates_pkey" PRIMARY KEY using index "event_updates_pkey";

alter table "public"."events" add constraint "events_pkey" PRIMARY KEY using index "events_pkey";

alter table "public"."exam_assignments" add constraint "exam_assignments_pkey" PRIMARY KEY using index "exam_assignments_pkey";

alter table "public"."exam_attempts" add constraint "exam_attempts_pkey" PRIMARY KEY using index "exam_attempts_pkey";

alter table "public"."exam_generations" add constraint "exam_generations_pkey" PRIMARY KEY using index "exam_generations_pkey";

alter table "public"."exam_papers" add constraint "exam_papers_pkey" PRIMARY KEY using index "exam_papers_pkey";

alter table "public"."exam_submissions" add constraint "exam_submissions_pkey" PRIMARY KEY using index "exam_submissions_pkey";

alter table "public"."exam_user_progress" add constraint "exam_user_progress_pkey" PRIMARY KEY using index "exam_user_progress_pkey";

alter table "public"."expense_categories" add constraint "expense_categories_pkey" PRIMARY KEY using index "expense_categories_pkey";

alter table "public"."feature_flags" add constraint "feature_flags_pkey" PRIMARY KEY using index "feature_flags_pkey";

alter table "public"."fee_payments" add constraint "fee_payments_pkey" PRIMARY KEY using index "fee_payments_pkey";

alter table "public"."financial_transactions" add constraint "financial_transactions_pkey" PRIMARY KEY using index "financial_transactions_pkey";

alter table "public"."gradebook_entries" add constraint "gradebook_entries_pkey" PRIMARY KEY using index "gradebook_entries_pkey";

alter table "public"."grades" add constraint "grades_pkey" PRIMARY KEY using index "grades_pkey";

alter table "public"."group_invitations" add constraint "group_invitations_pkey" PRIMARY KEY using index "group_invitations_pkey";

alter table "public"."group_members" add constraint "group_members_pkey" PRIMARY KEY using index "group_members_pkey";

alter table "public"."groups" add constraint "groups_pkey" PRIMARY KEY using index "groups_pkey";

alter table "public"."guardian_requests" add constraint "guardian_requests_pkey" PRIMARY KEY using index "guardian_requests_pkey";

alter table "public"."guest_usage_log" add constraint "guest_usage_log_pkey" PRIMARY KEY using index "guest_usage_log_pkey";

alter table "public"."homework_activity_log" add constraint "homework_activity_log_pkey" PRIMARY KEY using index "homework_activity_log_pkey";

alter table "public"."homework_assignment_targets" add constraint "homework_assignment_targets_pkey" PRIMARY KEY using index "homework_assignment_targets_pkey";

alter table "public"."homework_assignments" add constraint "homework_assignments_pkey" PRIMARY KEY using index "homework_assignments_pkey";

alter table "public"."homework_notifications" add constraint "homework_notifications_pkey" PRIMARY KEY using index "homework_notifications_pkey";

alter table "public"."homework_submissions" add constraint "homework_submissions_pkey" PRIMARY KEY using index "homework_submissions_pkey";

alter table "public"."in_app_notifications" add constraint "in_app_notifications_pkey" PRIMARY KEY using index "in_app_notifications_pkey";

alter table "public"."independent_children" add constraint "independent_children_pkey" PRIMARY KEY using index "independent_children_pkey";

alter table "public"."independent_content_library" add constraint "independent_content_library_pkey" PRIMARY KEY using index "independent_content_library_pkey";

alter table "public"."integration_audit_log" add constraint "integration_audit_log_pkey" PRIMARY KEY using index "integration_audit_log_pkey";

alter table "public"."interactive_activities" add constraint "interactive_activities_pkey" PRIMARY KEY using index "interactive_activities_pkey";

alter table "public"."interview_schedules" add constraint "interview_schedules_pkey" PRIMARY KEY using index "interview_schedules_pkey";

alter table "public"."invitation_codes" add constraint "invitation_codes_pkey" PRIMARY KEY using index "invitation_codes_pkey";

alter table "public"."invitations" add constraint "invitations_pkey" PRIMARY KEY using index "invitations_pkey";

alter table "public"."invite_logs" add constraint "invite_logs_pkey" PRIMARY KEY using index "invite_logs_pkey";

alter table "public"."invoice_audit_log" add constraint "invoice_audit_log_pkey" PRIMARY KEY using index "invoice_audit_log_pkey";

alter table "public"."invoice_items" add constraint "invoice_items_pkey" PRIMARY KEY using index "invoice_items_pkey";

alter table "public"."invoice_payments" add constraint "invoice_payments_pkey" PRIMARY KEY using index "invoice_payments_pkey";

alter table "public"."invoice_templates" add constraint "invoice_templates_pkey" PRIMARY KEY using index "invoice_templates_pkey";

alter table "public"."invoices" add constraint "invoices_pkey" PRIMARY KEY using index "invoices_pkey";

alter table "public"."job_alerts" add constraint "job_alerts_pkey" PRIMARY KEY using index "job_alerts_pkey";

alter table "public"."job_applications" add constraint "job_applications_pkey" PRIMARY KEY using index "job_applications_pkey";

alter table "public"."job_distributions" add constraint "job_distributions_pkey" PRIMARY KEY using index "job_distributions_pkey";

alter table "public"."job_postings" add constraint "job_postings_pkey" PRIMARY KEY using index "job_postings_pkey";

alter table "public"."join_requests" add constraint "join_requests_pkey" PRIMARY KEY using index "join_requests_pkey";

alter table "public"."learner_connections" add constraint "learner_connections_pkey" PRIMARY KEY using index "learner_connections_pkey";

alter table "public"."learner_cvs" add constraint "learner_cvs_pkey" PRIMARY KEY using index "learner_cvs_pkey";

alter table "public"."learning_activities" add constraint "learning_activities_pkey" PRIMARY KEY using index "learning_activities_pkey";

alter table "public"."lesson_approvals" add constraint "lesson_approvals_pkey" PRIMARY KEY using index "lesson_approvals_pkey";

alter table "public"."lesson_categories" add constraint "lesson_categories_pkey" PRIMARY KEY using index "lesson_categories_pkey";

alter table "public"."marketing_campaigns" add constraint "marketing_campaigns_pkey" PRIMARY KEY using index "marketing_campaigns_pkey";

alter table "public"."media_uploads" add constraint "media_uploads_pkey" PRIMARY KEY using index "media_uploads_pkey";

alter table "public"."meeting_action_items" add constraint "meeting_action_items_pkey" PRIMARY KEY using index "meeting_action_items_pkey";

alter table "public"."meeting_participants" add constraint "meeting_participants_pkey" PRIMARY KEY using index "meeting_participants_pkey";

alter table "public"."meeting_rooms" add constraint "meeting_rooms_pkey" PRIMARY KEY using index "meeting_rooms_pkey";

alter table "public"."meeting_sessions" add constraint "meeting_sessions_pkey" PRIMARY KEY using index "meeting_sessions_pkey";

alter table "public"."meeting_shared_resources" add constraint "meeting_shared_resources_pkey" PRIMARY KEY using index "meeting_shared_resources_pkey";

alter table "public"."member_events" add constraint "member_events_pkey" PRIMARY KEY using index "member_events_pkey";

alter table "public"."member_fees" add constraint "member_fees_pkey" PRIMARY KEY using index "member_fees_pkey";

alter table "public"."member_id_cards" add constraint "member_id_cards_pkey" PRIMARY KEY using index "member_id_cards_pkey";

alter table "public"."member_invoices" add constraint "member_invoices_pkey" PRIMARY KEY using index "member_invoices_pkey";

alter table "public"."membership_fee_structure" add constraint "membership_fee_structure_pkey" PRIMARY KEY using index "membership_fee_structure_pkey";

alter table "public"."membership_pop_uploads" add constraint "membership_pop_uploads_pkey" PRIMARY KEY using index "membership_pop_uploads_pkey";

alter table "public"."message_drafts" add constraint "message_drafts_pkey" PRIMARY KEY using index "message_drafts_pkey";

alter table "public"."message_participants" add constraint "message_participants_pkey" PRIMARY KEY using index "message_participants_pkey";

alter table "public"."message_reactions" add constraint "message_reactions_pkey" PRIMARY KEY using index "message_reactions_pkey";

alter table "public"."message_recipients" add constraint "message_recipients_pkey" PRIMARY KEY using index "message_recipients_pkey";

alter table "public"."message_threads" add constraint "message_threads_pkey" PRIMARY KEY using index "message_threads_pkey";

alter table "public"."messages" add constraint "messages_pkey" PRIMARY KEY using index "messages_pkey";

alter table "public"."migration_logs" add constraint "migration_logs_pkey" PRIMARY KEY using index "migration_logs_pkey";

alter table "public"."moderation_actions" add constraint "moderation_actions_pkey" PRIMARY KEY using index "moderation_actions_pkey";

alter table "public"."moderation_queue" add constraint "moderation_queue_pkey" PRIMARY KEY using index "moderation_queue_pkey";

alter table "public"."newsletter_recipients" add constraint "newsletter_recipients_pkey" PRIMARY KEY using index "newsletter_recipients_pkey";

alter table "public"."newsletters" add constraint "newsletters_pkey" PRIMARY KEY using index "newsletters_pkey";

alter table "public"."notification_deliveries" add constraint "notification_deliveries_pkey" PRIMARY KEY using index "notification_deliveries_pkey";

alter table "public"."notification_history" add constraint "notification_history_pkey" PRIMARY KEY using index "notification_history_pkey";

alter table "public"."notification_logs" add constraint "notification_logs_pkey" PRIMARY KEY using index "notification_logs_pkey";

alter table "public"."notification_templates" add constraint "notification_templates_pkey" PRIMARY KEY using index "notification_templates_pkey";

alter table "public"."oauth_tokens" add constraint "oauth_tokens_pkey" PRIMARY KEY using index "oauth_tokens_pkey";

alter table "public"."offer_letters" add constraint "offer_letters_pkey" PRIMARY KEY using index "offer_letters_pkey";

alter table "public"."onboarding_progress" add constraint "onboarding_progress_pkey" PRIMARY KEY using index "onboarding_progress_pkey";

alter table "public"."onboarding_requests" add constraint "onboarding_requests_pkey" PRIMARY KEY using index "onboarding_requests_pkey";

alter table "public"."org_dashboard_features" add constraint "org_dashboard_features_pkey" PRIMARY KEY using index "org_dashboard_features_pkey";

alter table "public"."org_invites" add constraint "org_invites_pkey" PRIMARY KEY using index "org_invites_pkey";

alter table "public"."organization_announcement_recipients" add constraint "organization_announcement_recipients_pkey" PRIMARY KEY using index "organization_announcement_recipients_pkey";

alter table "public"."organization_announcements" add constraint "organization_announcements_pkey" PRIMARY KEY using index "organization_announcements_pkey";

alter table "public"."organization_bank_accounts" add constraint "organization_bank_accounts_pkey" PRIMARY KEY using index "organization_bank_accounts_pkey";

alter table "public"."organization_board_positions" add constraint "organization_board_positions_pkey" PRIMARY KEY using index "organization_board_positions_pkey";

alter table "public"."organization_budgets" add constraint "organization_budgets_pkey" PRIMARY KEY using index "organization_budgets_pkey";

alter table "public"."organization_document_access" add constraint "organization_document_access_pkey" PRIMARY KEY using index "organization_document_access_pkey";

alter table "public"."organization_document_access_requests" add constraint "organization_document_access_requests_pkey" PRIMARY KEY using index "organization_document_access_requests_pkey";

alter table "public"."organization_document_audit_log" add constraint "organization_document_audit_log_pkey" PRIMARY KEY using index "organization_document_audit_log_pkey";

alter table "public"."organization_payment_methods" add constraint "organization_payment_methods_pkey" PRIMARY KEY using index "organization_payment_methods_pkey";

alter table "public"."organization_petty_cash" add constraint "organization_petty_cash_pkey" PRIMARY KEY using index "organization_petty_cash_pkey";

alter table "public"."organization_roles" add constraint "organization_roles_pkey" PRIMARY KEY using index "organization_roles_pkey";

alter table "public"."organization_transactions" add constraint "organization_transactions_pkey" PRIMARY KEY using index "organization_transactions_pkey";

alter table "public"."organization_wings" add constraint "organization_wings_pkey" PRIMARY KEY using index "organization_wings_pkey";

alter table "public"."overage_billing_records" add constraint "overage_billing_records_pkey" PRIMARY KEY using index "overage_billing_records_pkey";

alter table "public"."overage_notifications" add constraint "overage_notifications_pkey" PRIMARY KEY using index "overage_notifications_pkey";

alter table "public"."parent_access_codes" add constraint "parent_access_codes_pkey" PRIMARY KEY using index "parent_access_codes_pkey";

alter table "public"."parent_child_links" add constraint "parent_child_links_pkey" PRIMARY KEY using index "parent_child_links_pkey";

alter table "public"."parent_join_requests" add constraint "parent_join_requests_pkey" PRIMARY KEY using index "parent_join_requests_pkey";

alter table "public"."parent_payments" add constraint "parent_payments_pkey" PRIMARY KEY using index "parent_payments_pkey";

alter table "public"."past_papers" add constraint "past_papers_pkey" PRIMARY KEY using index "past_papers_pkey";

alter table "public"."payfast_itn_logs" add constraint "payfast_itn_logs_pkey" PRIMARY KEY using index "payfast_itn_logs_pkey";

alter table "public"."payment_reminders" add constraint "payment_reminders_pkey" PRIMARY KEY using index "payment_reminders_pkey";

alter table "public"."payment_transactions" add constraint "payment_transactions_pkey" PRIMARY KEY using index "payment_transactions_pkey";

alter table "public"."payments" add constraint "payments_pkey" PRIMARY KEY using index "payments_pkey";

alter table "public"."pdf_custom_templates" add constraint "pdf_custom_templates_pkey" PRIMARY KEY using index "pdf_custom_templates_pkey";

alter table "public"."pdf_documents" add constraint "pdf_documents_pkey" PRIMARY KEY using index "pdf_documents_pkey";

alter table "public"."pdf_user_preferences" add constraint "pdf_user_preferences_pkey" PRIMARY KEY using index "pdf_user_preferences_pkey";

alter table "public"."petty_cash_accounts" add constraint "petty_cash_accounts_pkey" PRIMARY KEY using index "petty_cash_accounts_pkey";

alter table "public"."petty_cash_receipts" add constraint "petty_cash_receipts_pkey" PRIMARY KEY using index "petty_cash_receipts_pkey";

alter table "public"."petty_cash_reconciliations" add constraint "petty_cash_reconciliations_pkey" PRIMARY KEY using index "petty_cash_reconciliations_pkey";

alter table "public"."petty_cash_transactions" add constraint "petty_cash_transactions_pkey" PRIMARY KEY using index "petty_cash_transactions_pkey";

alter table "public"."phone_verification_logs" add constraint "phone_verification_logs_pkey" PRIMARY KEY using index "phone_verification_logs_pkey";

alter table "public"."plan_quotas" add constraint "plan_quotas_pkey" PRIMARY KEY using index "plan_quotas_pkey";

alter table "public"."platform_analytics" add constraint "platform_analytics_pkey" PRIMARY KEY using index "platform_analytics_pkey";

alter table "public"."platform_collected_payments" add constraint "platform_collected_payments_pkey" PRIMARY KEY using index "platform_collected_payments_pkey";

alter table "public"."platform_disbursements" add constraint "platform_disbursements_pkey" PRIMARY KEY using index "platform_disbursements_pkey";

alter table "public"."platform_subscriptions" add constraint "platform_subscriptions_pkey" PRIMARY KEY using index "platform_subscriptions_pkey";

alter table "public"."portfolio_items" add constraint "portfolio_items_pkey" PRIMARY KEY using index "portfolio_items_pkey";

alter table "public"."preschool_onboarding_requests" add constraint "preschool_onboarding_requests_pkey" PRIMARY KEY using index "preschool_onboarding_requests_pkey";

alter table "public"."preschool_settings" add constraint "preschool_settings_pkey" PRIMARY KEY using index "preschool_settings_pkey";

alter table "public"."preschool_voice_usage" add constraint "preschool_voice_usage_pkey" PRIMARY KEY using index "preschool_voice_usage_pkey";

alter table "public"."principal_groups" add constraint "principal_groups_pkey" PRIMARY KEY using index "principal_groups_pkey";

alter table "public"."progress_reports" add constraint "progress_reports_pkey" PRIMARY KEY using index "progress_reports_pkey";

alter table "public"."promotional_campaigns" add constraint "promotional_campaigns_pkey" PRIMARY KEY using index "promotional_campaigns_pkey";

alter table "public"."push_device_tokens" add constraint "push_device_tokens_pkey" PRIMARY KEY using index "push_device_tokens_pkey";

alter table "public"."push_devices" add constraint "push_devices_pkey" PRIMARY KEY using index "push_devices_pkey";

alter table "public"."push_notification_queue" add constraint "push_notification_queue_pkey" PRIMARY KEY using index "push_notification_queue_pkey";

alter table "public"."push_notifications" add constraint "push_notifications_pkey" PRIMARY KEY using index "push_notifications_pkey";

alter table "public"."push_subscriptions" add constraint "push_subscriptions_pkey" PRIMARY KEY using index "push_subscriptions_pkey";

alter table "public"."rag_chunks" add constraint "rag_chunks_pkey" PRIMARY KEY using index "rag_chunks_pkey";

alter table "public"."rag_documents" add constraint "rag_documents_pkey" PRIMARY KEY using index "rag_documents_pkey";

alter table "public"."rag_ingestion_logs" add constraint "rag_ingestion_logs_pkey" PRIMARY KEY using index "rag_ingestion_logs_pkey";

alter table "public"."reading_progress" add constraint "reading_progress_pkey" PRIMARY KEY using index "reading_progress_pkey";

alter table "public"."region_invite_codes" add constraint "region_invite_codes_pkey" PRIMARY KEY using index "region_invite_codes_pkey";

alter table "public"."registration_requests" add constraint "registration_requests_pkey" PRIMARY KEY using index "registration_requests_pkey";

alter table "public"."resource_categories" add constraint "resource_categories_pkey" PRIMARY KEY using index "resource_categories_pkey";

alter table "public"."resource_permissions" add constraint "resource_permissions_pkey" PRIMARY KEY using index "resource_permissions_pkey";

alter table "public"."resource_reviews" add constraint "resource_reviews_pkey" PRIMARY KEY using index "resource_reviews_pkey";

alter table "public"."resources" add constraint "resources_pkey" PRIMARY KEY using index "resources_pkey";

alter table "public"."revenuecat_webhook_events" add constraint "revenuecat_webhook_events_pkey" PRIMARY KEY using index "revenuecat_webhook_events_pkey";

alter table "public"."rubric_grades" add constraint "rubric_grades_pkey" PRIMARY KEY using index "rubric_grades_pkey";

alter table "public"."scheduled_lessons" add constraint "scheduled_lessons_pkey" PRIMARY KEY using index "scheduled_lessons_pkey";

alter table "public"."scheduled_tasks" add constraint "scheduled_tasks_pkey" PRIMARY KEY using index "scheduled_tasks_pkey";

alter table "public"."school_ai_subscriptions" add constraint "school_ai_subscriptions_pkey" PRIMARY KEY using index "school_ai_subscriptions_pkey";

alter table "public"."school_branding" add constraint "school_branding_pkey" PRIMARY KEY using index "school_branding_pkey";

alter table "public"."school_events" add constraint "school_events_pkey" PRIMARY KEY using index "school_events_pkey";

alter table "public"."school_fee_structures" add constraint "school_fee_structures_pkey" PRIMARY KEY using index "school_fee_structures_pkey";

alter table "public"."school_invitation_codes" add constraint "school_invitation_codes_pkey" PRIMARY KEY using index "school_invitation_codes_pkey";

alter table "public"."school_settings" add constraint "school_settings_pkey" PRIMARY KEY using index "school_settings_pkey";

alter table "public"."school_verifications" add constraint "school_verifications_pkey" PRIMARY KEY using index "school_verifications_pkey";

alter table "public"."schools" add constraint "schools_pkey" PRIMARY KEY using index "schools_pkey";

alter table "public"."seats" add constraint "seats_pkey" PRIMARY KEY using index "seats_pkey";

alter table "public"."security_events" add constraint "security_events_pkey" PRIMARY KEY using index "security_events_pkey";

alter table "public"."service_alert_config" add constraint "service_alert_config_pkey" PRIMARY KEY using index "service_alert_config_pkey";

alter table "public"."service_alerts" add constraint "service_alerts_pkey" PRIMARY KEY using index "service_alerts_pkey";

alter table "public"."service_api_keys" add constraint "service_api_keys_pkey" PRIMARY KEY using index "service_api_keys_pkey";

alter table "public"."service_cost_tracking" add constraint "service_cost_tracking_pkey" PRIMARY KEY using index "service_cost_tracking_pkey";

alter table "public"."service_health_status" add constraint "service_health_status_pkey" PRIMARY KEY using index "service_health_status_pkey";

alter table "public"."service_incidents" add constraint "service_incidents_pkey" PRIMARY KEY using index "service_incidents_pkey";

alter table "public"."service_usage_limits" add constraint "service_usage_limits_pkey" PRIMARY KEY using index "service_usage_limits_pkey";

alter table "public"."sms_messages" add constraint "sms_messages_pkey" PRIMARY KEY using index "sms_messages_pkey";

alter table "public"."sms_opt_outs" add constraint "sms_opt_outs_pkey" PRIMARY KEY using index "sms_opt_outs_pkey";

alter table "public"."sound_alert_settings" add constraint "sound_alert_settings_pkey" PRIMARY KEY using index "sound_alert_settings_pkey";

alter table "public"."standalone_users" add constraint "standalone_users_pkey" PRIMARY KEY using index "standalone_users_pkey";

alter table "public"."stem_progress" add constraint "stem_progress_pkey" PRIMARY KEY using index "stem_progress_pkey";

alter table "public"."student_achievements" add constraint "student_achievements_pkey" PRIMARY KEY using index "student_achievements_pkey";

alter table "public"."student_enrollments" add constraint "student_enrollments_pkey" PRIMARY KEY using index "student_enrollments_pkey";

alter table "public"."student_fee_assignments" add constraint "student_fee_assignments_pkey" PRIMARY KEY using index "student_fee_assignments_pkey";

alter table "public"."student_groups" add constraint "student_groups_pkey" PRIMARY KEY using index "student_groups_pkey";

alter table "public"."student_parent_relationships" add constraint "student_parent_relationships_pkey" PRIMARY KEY using index "student_parent_relationships_pkey";

alter table "public"."student_progress" add constraint "student_progress_pkey" PRIMARY KEY using index "student_progress_pkey";

alter table "public"."student_streaks" add constraint "student_streaks_pkey" PRIMARY KEY using index "student_streaks_pkey";

alter table "public"."study_groups" add constraint "study_groups_pkey" PRIMARY KEY using index "study_groups_pkey";

alter table "public"."submissions" add constraint "submissions_pkey" PRIMARY KEY using index "submissions_pkey";

alter table "public"."subscription_plans" add constraint "subscription_plans_pkey" PRIMARY KEY using index "subscription_plans_pkey";

alter table "public"."subscription_seats" add constraint "subscription_seats_pkey" PRIMARY KEY using index "subscription_seats_pkey";

alter table "public"."subscription_usage" add constraint "subscription_usage_pkey" PRIMARY KEY using index "subscription_usage_pkey";

alter table "public"."subscriptions" add constraint "subscriptions_pkey" PRIMARY KEY using index "subscriptions_pkey";

alter table "public"."superadmin_agent_executions" add constraint "superadmin_agent_executions_pkey" PRIMARY KEY using index "superadmin_agent_executions_pkey";

alter table "public"."superadmin_ai_agents" add constraint "superadmin_ai_agents_pkey" PRIMARY KEY using index "superadmin_ai_agents_pkey";

alter table "public"."superadmin_audit_log" add constraint "superadmin_audit_log_pkey" PRIMARY KEY using index "superadmin_audit_log_pkey";

alter table "public"."superadmin_autonomous_tasks" add constraint "superadmin_autonomous_tasks_pkey" PRIMARY KEY using index "superadmin_autonomous_tasks_pkey";

alter table "public"."superadmin_command_log" add constraint "superadmin_command_log_pkey" PRIMARY KEY using index "superadmin_command_log_pkey";

alter table "public"."superadmin_compliance_reports" add constraint "superadmin_compliance_reports_pkey" PRIMARY KEY using index "superadmin_compliance_reports_pkey";

alter table "public"."superadmin_integrations" add constraint "superadmin_integrations_pkey" PRIMARY KEY using index "superadmin_integrations_pkey";

alter table "public"."superadmin_notification_deliveries" add constraint "superadmin_notification_deliveries_pkey" PRIMARY KEY using index "superadmin_notification_deliveries_pkey";

alter table "public"."superadmin_notification_rules" add constraint "superadmin_notification_rules_pkey" PRIMARY KEY using index "superadmin_notification_rules_pkey";

alter table "public"."superadmin_notifications" add constraint "superadmin_notifications_pkey" PRIMARY KEY using index "superadmin_notifications_pkey";

alter table "public"."superadmin_platform_insights" add constraint "superadmin_platform_insights_pkey" PRIMARY KEY using index "superadmin_platform_insights_pkey";

alter table "public"."superadmin_role_assignments" add constraint "superadmin_role_assignments_pkey" PRIMARY KEY using index "superadmin_role_assignments_pkey";

alter table "public"."superadmin_session_management" add constraint "superadmin_session_management_pkey" PRIMARY KEY using index "superadmin_session_management_pkey";

alter table "public"."superadmin_user_actions" add constraint "superadmin_user_actions_pkey" PRIMARY KEY using index "superadmin_user_actions_pkey";

alter table "public"."superadmin_user_deletion_requests" add constraint "superadmin_user_deletion_requests_pkey" PRIMARY KEY using index "superadmin_user_deletion_requests_pkey";

alter table "public"."superadmin_user_risk_assessments" add constraint "superadmin_user_risk_assessments_pkey" PRIMARY KEY using index "superadmin_user_risk_assessments_pkey";

alter table "public"."support_tickets" add constraint "support_tickets_pkey" PRIMARY KEY using index "support_tickets_pkey";

alter table "public"."sync_logs" add constraint "sync_logs_pkey" PRIMARY KEY using index "sync_logs_pkey";

alter table "public"."system_config" add constraint "system_config_pkey" PRIMARY KEY using index "system_config_pkey";

alter table "public"."system_settings" add constraint "system_settings_pkey" PRIMARY KEY using index "system_settings_pkey";

alter table "public"."teacher_ai_allocations" add constraint "teacher_ai_allocations_pkey" PRIMARY KEY using index "teacher_ai_allocations_pkey";

alter table "public"."teacher_class_codes" add constraint "teacher_class_codes_pkey" PRIMARY KEY using index "teacher_class_codes_pkey";

alter table "public"."teacher_invitations" add constraint "teacher_invitations_pkey" PRIMARY KEY using index "teacher_invitations_pkey";

alter table "public"."teacher_performance_metrics" add constraint "teacher_performance_metrics_pkey" PRIMARY KEY using index "teacher_performance_metrics_pkey";

alter table "public"."teacher_student_notes" add constraint "teacher_student_notes_pkey" PRIMARY KEY using index "teacher_student_notes_pkey";

alter table "public"."teachers" add constraint "teachers_pkey" PRIMARY KEY using index "teachers_pkey";

alter table "public"."template_approvals" add constraint "template_approvals_pkey" PRIMARY KEY using index "template_approvals_pkey";

alter table "public"."template_usage_logs" add constraint "template_usage_logs_pkey" PRIMARY KEY using index "template_usage_logs_pkey";

alter table "public"."template_variables" add constraint "template_variables_pkey" PRIMARY KEY using index "template_variables_pkey";

alter table "public"."tenants" add constraint "tenants_pkey" PRIMARY KEY using index "tenants_pkey";

alter table "public"."tester_feedback" add constraint "tester_feedback_pkey" PRIMARY KEY using index "tester_feedback_pkey";

alter table "public"."textbook_chapters" add constraint "textbook_chapters_pkey" PRIMARY KEY using index "textbook_chapters_pkey";

alter table "public"."textbook_content" add constraint "textbook_content_pkey" PRIMARY KEY using index "textbook_content_pkey";

alter table "public"."textbook_pages" add constraint "textbook_pages_pkey" PRIMARY KEY using index "textbook_pages_pkey";

alter table "public"."textbooks" add constraint "textbooks_pkey" PRIMARY KEY using index "textbooks_pkey";

alter table "public"."trial_usage_log" add constraint "trial_usage_log_pkey" PRIMARY KEY using index "trial_usage_log_pkey";

alter table "public"."tts_audio_cache" add constraint "tts_audio_cache_pkey" PRIMARY KEY using index "tts_audio_cache_pkey";

alter table "public"."typing_indicators" add constraint "typing_indicators_pkey" PRIMARY KEY using index "typing_indicators_pkey";

alter table "public"."user_ai_tiers" add constraint "user_ai_tiers_pkey" PRIMARY KEY using index "user_ai_tiers_pkey";

alter table "public"."user_ai_usage" add constraint "user_ai_usage_pkey" PRIMARY KEY using index "user_ai_usage_pkey";

alter table "public"."user_blocks" add constraint "user_blocks_pkey" PRIMARY KEY using index "user_blocks_pkey";

alter table "public"."user_bookmarks" add constraint "user_bookmarks_pkey" PRIMARY KEY using index "user_bookmarks_pkey";

alter table "public"."user_connections" add constraint "user_connections_pkey" PRIMARY KEY using index "user_connections_pkey";

alter table "public"."user_contacts" add constraint "user_contacts_pkey" PRIMARY KEY using index "user_contacts_pkey";

alter table "public"."user_invitations" add constraint "user_invitations_pkey" PRIMARY KEY using index "user_invitations_pkey";

alter table "public"."user_phone_numbers" add constraint "user_phone_numbers_pkey" PRIMARY KEY using index "user_phone_numbers_pkey";

alter table "public"."user_preferences" add constraint "user_preferences_pkey" PRIMARY KEY using index "user_preferences_pkey";

alter table "public"."user_presence" add constraint "user_presence_pkey" PRIMARY KEY using index "user_presence_pkey";

alter table "public"."user_profiles" add constraint "user_profiles_pkey" PRIMARY KEY using index "user_profiles_pkey";

alter table "public"."user_promotional_subscriptions" add constraint "user_promotional_subscriptions_pkey" PRIMARY KEY using index "user_promotional_subscriptions_pkey";

alter table "public"."user_usage_tracking" add constraint "user_usage_tracking_pkey" PRIMARY KEY using index "user_usage_tracking_pkey";

alter table "public"."user_voice_usage" add constraint "user_voice_usage_pkey" PRIMARY KEY using index "user_voice_usage_pkey";

alter table "public"."users" add constraint "users_pkey" PRIMARY KEY using index "users_pkey";

alter table "public"."voice_notes" add constraint "voice_notes_pkey" PRIMARY KEY using index "voice_notes_pkey";

alter table "public"."voice_preferences" add constraint "voice_preferences_pkey" PRIMARY KEY using index "voice_preferences_pkey";

alter table "public"."voice_usage_logs" add constraint "voice_usage_logs_pkey" PRIMARY KEY using index "voice_usage_logs_pkey";

alter table "public"."voice_usage_quotas" add constraint "voice_usage_quotas_pkey" PRIMARY KEY using index "voice_usage_quotas_pkey";

alter table "public"."webhook_logs" add constraint "webhook_logs_pkey" PRIMARY KEY using index "webhook_logs_pkey";

alter table "public"."whatsapp_contacts" add constraint "whatsapp_contacts_pkey" PRIMARY KEY using index "whatsapp_contacts_pkey";

alter table "public"."wing_regional_coordinators" add constraint "wing_regional_coordinators_pkey" PRIMARY KEY using index "wing_regional_coordinators_pkey";

alter table "public"."active_calls" add constraint "active_calls_call_id_key" UNIQUE using index "active_calls_call_id_key";

alter table "public"."active_calls" add constraint "active_calls_call_type_check" CHECK ((call_type = ANY (ARRAY['voice'::text, 'video'::text]))) not valid;

alter table "public"."active_calls" validate constraint "active_calls_call_type_check";

alter table "public"."active_calls" add constraint "active_calls_callee_id_fkey" FOREIGN KEY (callee_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."active_calls" validate constraint "active_calls_callee_id_fkey";

alter table "public"."active_calls" add constraint "active_calls_caller_id_fkey" FOREIGN KEY (caller_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."active_calls" validate constraint "active_calls_caller_id_fkey";

alter table "public"."active_calls" add constraint "active_calls_status_check" CHECK ((status = ANY (ARRAY['ringing'::text, 'connected'::text, 'ended'::text, 'rejected'::text, 'missed'::text, 'busy'::text]))) not valid;

alter table "public"."active_calls" validate constraint "active_calls_status_check";

alter table "public"."activities" add constraint "activities_activity_type_check" CHECK ((activity_type = ANY (ARRAY['quiz'::text, 'worksheet'::text, 'video'::text, 'interactive'::text, 'reading'::text]))) not valid;

alter table "public"."activities" validate constraint "activities_activity_type_check";

alter table "public"."activities" add constraint "activities_difficulty_level_check" CHECK ((difficulty_level = ANY (ARRAY['easy'::text, 'medium'::text, 'hard'::text]))) not valid;

alter table "public"."activities" validate constraint "activities_difficulty_level_check";

alter table "public"."activities" add constraint "activities_lesson_id_fkey" FOREIGN KEY (lesson_id) REFERENCES public.lessons(id) ON DELETE CASCADE not valid;

alter table "public"."activities" validate constraint "activities_lesson_id_fkey";

alter table "public"."activity_attempts" add constraint "activity_attempts_activity_id_fkey" FOREIGN KEY (activity_id) REFERENCES public.lesson_activities(id) ON DELETE CASCADE not valid;

alter table "public"."activity_attempts" validate constraint "activity_attempts_activity_id_fkey";

alter table "public"."activity_attempts" add constraint "activity_attempts_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."activity_attempts" validate constraint "activity_attempts_student_id_fkey";

alter table "public"."activity_feed" add constraint "activity_feed_actor_id_fkey" FOREIGN KEY (actor_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."activity_feed" validate constraint "activity_feed_actor_id_fkey";

alter table "public"."activity_feed" add constraint "activity_feed_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."activity_feed" validate constraint "activity_feed_preschool_id_fkey";

alter table "public"."activity_progress" add constraint "activity_progress_student_id_activity_id_key" UNIQUE using index "activity_progress_student_id_activity_id_key";

alter table "public"."activity_submissions" add constraint "activity_submissions_assigned_teacher_id_fkey" FOREIGN KEY (assigned_teacher_id) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."activity_submissions" validate constraint "activity_submissions_assigned_teacher_id_fkey";

alter table "public"."activity_submissions" add constraint "activity_submissions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."activity_submissions" validate constraint "activity_submissions_user_id_fkey";

alter table "public"."ad_impressions" add constraint "ad_impressions_ad_network_check" CHECK ((ad_network = ANY (ARRAY['admob'::text, 'facebook'::text, 'unity'::text, 'ironsource'::text]))) not valid;

alter table "public"."ad_impressions" validate constraint "ad_impressions_ad_network_check";

alter table "public"."ad_impressions" add constraint "ad_impressions_ad_type_check" CHECK ((ad_type = ANY (ARRAY['banner'::text, 'interstitial'::text, 'rewarded'::text, 'native'::text]))) not valid;

alter table "public"."ad_impressions" validate constraint "ad_impressions_ad_type_check";

alter table "public"."ad_impressions" add constraint "ad_impressions_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."ad_impressions" validate constraint "ad_impressions_preschool_id_fkey";

alter table "public"."ad_impressions" add constraint "ad_impressions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."ad_impressions" validate constraint "ad_impressions_user_id_fkey";

alter table "public"."addresses" add constraint "addresses_address_type_check" CHECK ((address_type = ANY (ARRAY['home'::text, 'work'::text, 'billing'::text, 'emergency'::text]))) not valid;

alter table "public"."addresses" validate constraint "addresses_address_type_check";

alter table "public"."addresses" add constraint "addresses_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."addresses" validate constraint "addresses_user_id_fkey";

alter table "public"."admin_users" add constraint "admin_users_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."admin_users" validate constraint "admin_users_user_id_fkey";

alter table "public"."admin_users" add constraint "fk_admin_users_organization_id" FOREIGN KEY (organization_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."admin_users" validate constraint "fk_admin_users_organization_id";

alter table "public"."aftercare_registrations" add constraint "aftercare_registrations_child_grade_check" CHECK ((child_grade = ANY (ARRAY['R'::text, '1'::text, '2'::text, '3'::text, '4'::text, '5'::text, '6'::text, '7'::text]))) not valid;

alter table "public"."aftercare_registrations" validate constraint "aftercare_registrations_child_grade_check";

alter table "public"."aftercare_registrations" add constraint "aftercare_registrations_parent_user_id_fkey" FOREIGN KEY (parent_user_id) REFERENCES auth.users(id) not valid;

alter table "public"."aftercare_registrations" validate constraint "aftercare_registrations_parent_user_id_fkey";

alter table "public"."aftercare_registrations" add constraint "aftercare_registrations_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."aftercare_registrations" validate constraint "aftercare_registrations_preschool_id_fkey";

alter table "public"."aftercare_registrations" add constraint "aftercare_registrations_status_check" CHECK ((status = ANY (ARRAY['pending_payment'::text, 'paid'::text, 'enrolled'::text, 'cancelled'::text, 'waitlisted'::text]))) not valid;

alter table "public"."aftercare_registrations" validate constraint "aftercare_registrations_status_check";

alter table "public"."aftercare_registrations" add constraint "aftercare_registrations_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) not valid;

alter table "public"."aftercare_registrations" validate constraint "aftercare_registrations_student_id_fkey";

alter table "public"."age_groups" add constraint "age_groups_school_type_check" CHECK ((school_type = ANY (ARRAY['preschool'::text, 'primary'::text, 'secondary'::text, 'combined'::text]))) not valid;

alter table "public"."age_groups" validate constraint "age_groups_school_type_check";

alter table "public"."ai_admin_actions" add constraint "ai_admin_actions_actor_user_id_fkey" FOREIGN KEY (actor_user_id) REFERENCES public.users(id) ON DELETE RESTRICT not valid;

alter table "public"."ai_admin_actions" validate constraint "ai_admin_actions_actor_user_id_fkey";

alter table "public"."ai_admin_actions" add constraint "ai_admin_actions_target_preschool_id_fkey" FOREIGN KEY (target_preschool_id) REFERENCES public.preschools(id) ON DELETE SET NULL not valid;

alter table "public"."ai_admin_actions" validate constraint "ai_admin_actions_target_preschool_id_fkey";

alter table "public"."ai_admin_actions" add constraint "ai_admin_actions_target_user_id_fkey" FOREIGN KEY (target_user_id) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."ai_admin_actions" validate constraint "ai_admin_actions_target_user_id_fkey";

alter table "public"."ai_allocation_history" add constraint "ai_allocation_history_action_check" CHECK ((action = ANY (ARRAY['allocate'::text, 'revoke'::text, 'increase'::text, 'decrease'::text, 'suspend'::text, 'reactivate'::text]))) not valid;

alter table "public"."ai_allocation_history" validate constraint "ai_allocation_history_action_check";

alter table "public"."ai_allocation_history" add constraint "ai_allocation_history_performed_by_fkey" FOREIGN KEY (performed_by) REFERENCES public.users(id) not valid;

alter table "public"."ai_allocation_history" validate constraint "ai_allocation_history_performed_by_fkey";

alter table "public"."ai_allocation_history" add constraint "ai_allocation_history_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."ai_allocation_history" validate constraint "ai_allocation_history_preschool_id_fkey";

alter table "public"."ai_allocation_history" add constraint "ai_allocation_history_teacher_id_fkey" FOREIGN KEY (teacher_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."ai_allocation_history" validate constraint "ai_allocation_history_teacher_id_fkey";

alter table "public"."ai_allocation_requests" add constraint "ai_allocation_requests_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."ai_allocation_requests" validate constraint "ai_allocation_requests_preschool_id_fkey";

alter table "public"."ai_allocation_requests" add constraint "ai_allocation_requests_requested_by_fkey" FOREIGN KEY (requested_by) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."ai_allocation_requests" validate constraint "ai_allocation_requests_requested_by_fkey";

alter table "public"."ai_allocation_requests" add constraint "ai_allocation_requests_reviewed_by_fkey" FOREIGN KEY (reviewed_by) REFERENCES public.users(id) not valid;

alter table "public"."ai_allocation_requests" validate constraint "ai_allocation_requests_reviewed_by_fkey";

alter table "public"."ai_allocation_requests" add constraint "ai_allocation_requests_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'approved'::text, 'rejected'::text, 'expired'::text]))) not valid;

alter table "public"."ai_allocation_requests" validate constraint "ai_allocation_requests_status_check";

alter table "public"."ai_allocation_requests" add constraint "ai_allocation_requests_teacher_id_fkey" FOREIGN KEY (teacher_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."ai_allocation_requests" validate constraint "ai_allocation_requests_teacher_id_fkey";

alter table "public"."ai_allocation_requests" add constraint "ai_allocation_requests_urgency_check" CHECK ((urgency = ANY (ARRAY['low'::text, 'normal'::text, 'high'::text]))) not valid;

alter table "public"."ai_allocation_requests" validate constraint "ai_allocation_requests_urgency_check";

alter table "public"."ai_attachments" add constraint "ai_attachments_storage_path_key" UNIQUE using index "ai_attachments_storage_path_key";

alter table "public"."ai_attachments" add constraint "ai_attachments_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."ai_attachments" validate constraint "ai_attachments_user_id_fkey";

alter table "public"."ai_autonomy_settings" add constraint "ai_autonomy_settings_level_check" CHECK ((autonomy_level = ANY (ARRAY['observer'::text, 'assistant'::text, 'partner'::text, 'autonomous'::text]))) not valid;

alter table "public"."ai_autonomy_settings" validate constraint "ai_autonomy_settings_level_check";

alter table "public"."ai_autonomy_settings" add constraint "ai_autonomy_settings_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."ai_autonomy_settings" validate constraint "ai_autonomy_settings_preschool_id_fkey";

alter table "public"."ai_autonomy_settings" add constraint "ai_autonomy_settings_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."ai_autonomy_settings" validate constraint "ai_autonomy_settings_user_id_fkey";

alter table "public"."ai_autonomy_settings" add constraint "ai_autonomy_settings_user_id_key" UNIQUE using index "ai_autonomy_settings_user_id_key";

alter table "public"."ai_context_snapshots" add constraint "ai_context_snapshots_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."ai_context_snapshots" validate constraint "ai_context_snapshots_preschool_id_fkey";

alter table "public"."ai_context_snapshots" add constraint "ai_context_snapshots_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."ai_context_snapshots" validate constraint "ai_context_snapshots_user_id_fkey";

alter table "public"."ai_conversations" add constraint "ai_conversations_conversation_id_key" UNIQUE using index "ai_conversations_conversation_id_key";

alter table "public"."ai_conversations" add constraint "ai_conversations_messages_is_array" CHECK ((jsonb_typeof(messages) = 'array'::text)) not valid;

alter table "public"."ai_conversations" validate constraint "ai_conversations_messages_is_array";

alter table "public"."ai_conversations" add constraint "ai_conversations_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."ai_conversations" validate constraint "ai_conversations_preschool_id_fkey";

alter table "public"."ai_conversations" add constraint "ai_conversations_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."ai_conversations" validate constraint "ai_conversations_user_id_fkey";

alter table "public"."ai_events" add constraint "ai_events_event_type_check" CHECK ((event_type = ANY (ARRAY['ai.agent.decision_made'::text, 'ai.agent.task_started'::text, 'ai.agent.task_completed'::text, 'ai.agent.task_failed'::text, 'ai.agent.proactive_offer_shown'::text, 'ai.agent.proactive_offer_accepted'::text, 'ai.agent.proactive_offer_dismissed'::text, 'ai.memory.write'::text, 'ai.memory.read'::text, 'ai.memory.prune'::text, 'ai.permissions.missing'::text, 'ai.autonomy.escalation'::text, 'ai.context.snapshot'::text, 'ai.insight.generated'::text, 'ai.workflow.branch'::text, 'ai.workflow.retry'::text, 'ai.error.recovery'::text]))) not valid;

alter table "public"."ai_events" validate constraint "ai_events_event_type_check";

alter table "public"."ai_events" add constraint "ai_events_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."ai_events" validate constraint "ai_events_preschool_id_fkey";

alter table "public"."ai_events" add constraint "ai_events_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."ai_events" validate constraint "ai_events_user_id_fkey";

alter table "public"."ai_feedback" add constraint "ai_feedback_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."ai_feedback" validate constraint "ai_feedback_preschool_id_fkey";

alter table "public"."ai_feedback" add constraint "ai_feedback_rating_check" CHECK (((rating >= 1) AND (rating <= 5))) not valid;

alter table "public"."ai_feedback" validate constraint "ai_feedback_rating_check";

alter table "public"."ai_feedback" add constraint "ai_feedback_reference_check" CHECK (((task_id IS NOT NULL) OR (decision_id IS NOT NULL))) not valid;

alter table "public"."ai_feedback" validate constraint "ai_feedback_reference_check";

alter table "public"."ai_feedback" add constraint "ai_feedback_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."ai_feedback" validate constraint "ai_feedback_user_id_fkey";

alter table "public"."ai_generated_content" add constraint "ai_generated_content_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.profiles(id) not valid;

alter table "public"."ai_generated_content" validate constraint "ai_generated_content_created_by_fkey";

alter table "public"."ai_generated_content" add constraint "ai_generated_content_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."ai_generated_content" validate constraint "ai_generated_content_organization_id_fkey";

alter table "public"."ai_generations" add constraint "ai_generations_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."ai_generations" validate constraint "ai_generations_preschool_id_fkey";

alter table "public"."ai_generations" add constraint "ai_generations_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."ai_generations" validate constraint "ai_generations_user_id_fkey";

alter table "public"."ai_global_settings" add constraint "ai_global_settings_default_provider_check" CHECK ((default_provider = ANY (ARRAY['claude'::text, 'openai'::text]))) not valid;

alter table "public"."ai_global_settings" validate constraint "ai_global_settings_default_provider_check";

alter table "public"."ai_global_settings" add constraint "ai_global_settings_fallback_provider_check" CHECK ((fallback_provider = ANY (ARRAY['claude'::text, 'openai'::text]))) not valid;

alter table "public"."ai_global_settings" validate constraint "ai_global_settings_fallback_provider_check";

alter table "public"."ai_global_settings" add constraint "ai_global_settings_id_check" CHECK ((id = '00000000-0000-0000-0000-000000000001'::uuid)) not valid;

alter table "public"."ai_global_settings" validate constraint "ai_global_settings_id_check";

alter table "public"."ai_global_settings" add constraint "ai_global_settings_updated_by_fkey" FOREIGN KEY (updated_by) REFERENCES public.profiles(id) not valid;

alter table "public"."ai_global_settings" validate constraint "ai_global_settings_updated_by_fkey";

alter table "public"."ai_insights" add constraint "ai_insights_confidence_check" CHECK (((confidence >= (0)::double precision) AND (confidence <= (1)::double precision))) not valid;

alter table "public"."ai_insights" validate constraint "ai_insights_confidence_check";

alter table "public"."ai_insights" add constraint "ai_insights_insight_type_check" CHECK ((insight_type = ANY (ARRAY['pattern'::text, 'recommendation'::text, 'prediction'::text, 'alert'::text, 'opportunity'::text]))) not valid;

alter table "public"."ai_insights" validate constraint "ai_insights_insight_type_check";

alter table "public"."ai_insights" add constraint "ai_insights_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."ai_insights" validate constraint "ai_insights_preschool_id_fkey";

alter table "public"."ai_insights" add constraint "ai_insights_priority_check" CHECK ((priority = ANY (ARRAY['low'::text, 'medium'::text, 'high'::text, 'urgent'::text]))) not valid;

alter table "public"."ai_insights" validate constraint "ai_insights_priority_check";

alter table "public"."ai_insights" add constraint "ai_insights_status_check" CHECK ((status = ANY (ARRAY['active'::text, 'dismissed'::text, 'actioned'::text, 'expired'::text]))) not valid;

alter table "public"."ai_insights" validate constraint "ai_insights_status_check";

alter table "public"."ai_insights" add constraint "ai_insights_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."ai_insights" validate constraint "ai_insights_user_id_fkey";

alter table "public"."ai_memories" add constraint "ai_memories_importance_check" CHECK (((importance >= 1) AND (importance <= 10))) not valid;

alter table "public"."ai_memories" validate constraint "ai_memories_importance_check";

alter table "public"."ai_memories" add constraint "ai_memories_memory_type_check" CHECK ((memory_type = ANY (ARRAY['preference'::text, 'fact'::text, 'context'::text, 'skill'::text, 'goal'::text, 'interaction'::text, 'relationship'::text, 'pattern'::text, 'insight'::text, 'episodic'::text, 'working'::text, 'semantic'::text]))) not valid;

alter table "public"."ai_memories" validate constraint "ai_memories_memory_type_check";

alter table "public"."ai_memories" add constraint "ai_memories_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."ai_memories" validate constraint "ai_memories_preschool_id_fkey";

alter table "public"."ai_memories" add constraint "ai_memories_recency_score_check" CHECK ((recency_score >= (0)::double precision)) not valid;

alter table "public"."ai_memories" validate constraint "ai_memories_recency_score_check";

alter table "public"."ai_memories" add constraint "ai_memories_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."ai_memories" validate constraint "ai_memories_user_id_fkey";

alter table "public"."ai_messages" add constraint "ai_messages_role_check" CHECK ((role = ANY (ARRAY['user'::text, 'assistant'::text]))) not valid;

alter table "public"."ai_messages" validate constraint "ai_messages_role_check";

alter table "public"."ai_messages" add constraint "fk_messages_conversation" FOREIGN KEY (conversation_id) REFERENCES public.ai_conversations(conversation_id) ON DELETE CASCADE not valid;

alter table "public"."ai_messages" validate constraint "fk_messages_conversation";

alter table "public"."ai_messages" add constraint "fk_messages_user" FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."ai_messages" validate constraint "fk_messages_user";

alter table "public"."ai_model_tiers" add constraint "ai_model_tiers_tier_key" UNIQUE using index "ai_model_tiers_tier_key";

alter table "public"."ai_overage_logs" add constraint "ai_overage_logs_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."ai_overage_logs" validate constraint "ai_overage_logs_user_id_fkey";

alter table "public"."ai_provider_config" add constraint "ai_provider_config_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.profiles(id) not valid;

alter table "public"."ai_provider_config" validate constraint "ai_provider_config_created_by_fkey";

alter table "public"."ai_provider_config" add constraint "ai_provider_config_provider_override_check" CHECK (((provider_override = ANY (ARRAY['claude'::text, 'openai'::text])) OR (provider_override IS NULL))) not valid;

alter table "public"."ai_provider_config" validate constraint "ai_provider_config_provider_override_check";

alter table "public"."ai_provider_config" add constraint "ai_provider_config_service_type_check" CHECK ((service_type = ANY (ARRAY['homework_help'::text, 'lesson_generation'::text, 'grading_assistance'::text, 'dash_conversation'::text, 'general'::text]))) not valid;

alter table "public"."ai_provider_config" validate constraint "ai_provider_config_service_type_check";

alter table "public"."ai_provider_config" add constraint "ai_provider_config_service_type_key" UNIQUE using index "ai_provider_config_service_type_key";

alter table "public"."ai_recommendations" add constraint "ai_recommendations_learner_id_fkey" FOREIGN KEY (learner_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."ai_recommendations" validate constraint "ai_recommendations_learner_id_fkey";

alter table "public"."ai_recommendations" add constraint "ai_recommendations_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."ai_recommendations" validate constraint "ai_recommendations_organization_id_fkey";

alter table "public"."ai_recommendations" add constraint "ai_recommendations_program_id_fkey" FOREIGN KEY (program_id) REFERENCES public.courses(id) ON DELETE SET NULL not valid;

alter table "public"."ai_recommendations" validate constraint "ai_recommendations_program_id_fkey";

alter table "public"."ai_request_log" add constraint "ai_request_log_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."ai_request_log" validate constraint "ai_request_log_user_id_fkey";

alter table "public"."ai_services" add constraint "ai_services_name_key" UNIQUE using index "ai_services_name_key";

alter table "public"."ai_task_runs" add constraint "ai_task_runs_finished_after_started" CHECK (((finished_at IS NULL) OR (finished_at >= started_at))) not valid;

alter table "public"."ai_task_runs" validate constraint "ai_task_runs_finished_after_started";

alter table "public"."ai_task_runs" add constraint "ai_task_runs_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."ai_task_runs" validate constraint "ai_task_runs_preschool_id_fkey";

alter table "public"."ai_task_runs" add constraint "ai_task_runs_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'running'::text, 'completed'::text, 'failed'::text, 'cancelled'::text, 'paused'::text]))) not valid;

alter table "public"."ai_task_runs" validate constraint "ai_task_runs_status_check";

alter table "public"."ai_task_runs" add constraint "ai_task_runs_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."ai_task_runs" validate constraint "ai_task_runs_user_id_fkey";

alter table "public"."ai_usage" add constraint "ai_usage_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."ai_usage" validate constraint "ai_usage_organization_id_fkey";

alter table "public"."ai_usage" add constraint "ai_usage_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."ai_usage" validate constraint "ai_usage_user_id_fkey";

alter table "public"."ai_usage_logs" add constraint "ai_usage_logs_ai_service_id_fkey" FOREIGN KEY (ai_service_id) REFERENCES public.ai_services(id) not valid;

alter table "public"."ai_usage_logs" validate constraint "ai_usage_logs_ai_service_id_fkey";

alter table "public"."ai_usage_logs" add constraint "ai_usage_logs_allocation_id_fkey" FOREIGN KEY (allocation_id) REFERENCES public.teacher_ai_allocations(id) not valid;

alter table "public"."ai_usage_logs" validate constraint "ai_usage_logs_allocation_id_fkey";

alter table "public"."ai_usage_logs" add constraint "ai_usage_logs_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."ai_usage_logs" validate constraint "ai_usage_logs_preschool_id_fkey";

alter table "public"."ai_usage_logs" add constraint "ai_usage_logs_quota_consumed_from_check" CHECK ((quota_consumed_from = ANY (ARRAY['claude_messages'::text, 'content_generation'::text, 'assessment_ai'::text]))) not valid;

alter table "public"."ai_usage_logs" validate constraint "ai_usage_logs_quota_consumed_from_check";

alter table "public"."ai_usage_logs" add constraint "ai_usage_logs_response_time_check" CHECK (((response_time_ms IS NULL) OR (response_time_ms >= 0))) not valid;

alter table "public"."ai_usage_logs" validate constraint "ai_usage_logs_response_time_check";

alter table "public"."ai_usage_logs" add constraint "ai_usage_logs_service_type_check" CHECK ((service_type = ANY (ARRAY['lesson_generation'::text, 'homework_help'::text, 'grading_assistance'::text, 'general'::text, 'dash_conversation'::text, 'conversation'::text]))) not valid;

alter table "public"."ai_usage_logs" validate constraint "ai_usage_logs_service_type_check";

alter table "public"."ai_usage_logs" add constraint "ai_usage_logs_status_check" CHECK ((status = ANY (ARRAY['success'::text, 'error'::text, 'rate_limited'::text, 'quota_exceeded'::text]))) not valid;

alter table "public"."ai_usage_logs" validate constraint "ai_usage_logs_status_check";

alter table "public"."ai_usage_logs" add constraint "ai_usage_logs_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."ai_usage_logs" validate constraint "ai_usage_logs_user_id_fkey";

alter table "public"."ai_usage_logs" add constraint "ai_usage_logs_user_rating_check" CHECK (((user_rating >= 1) AND (user_rating <= 5))) not valid;

alter table "public"."ai_usage_logs" validate constraint "ai_usage_logs_user_rating_check";

alter table "public"."ai_usage_resets" add constraint "ai_usage_resets_mode_check" CHECK ((mode = ANY (ARRAY['soft'::text, 'hard'::text]))) not valid;

alter table "public"."ai_usage_resets" validate constraint "ai_usage_resets_mode_check";

alter table "public"."ai_usage_resets" add constraint "ai_usage_resets_requested_by_user_id_fkey" FOREIGN KEY (requested_by_user_id) REFERENCES public.users(id) ON DELETE RESTRICT not valid;

alter table "public"."ai_usage_resets" validate constraint "ai_usage_resets_requested_by_user_id_fkey";

alter table "public"."ai_usage_resets" add constraint "ai_usage_resets_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'completed'::text, 'failed'::text]))) not valid;

alter table "public"."ai_usage_resets" validate constraint "ai_usage_resets_status_check";

alter table "public"."ai_usage_resets" add constraint "ai_usage_resets_target_preschool_id_fkey" FOREIGN KEY (target_preschool_id) REFERENCES public.preschools(id) ON DELETE SET NULL not valid;

alter table "public"."ai_usage_resets" validate constraint "ai_usage_resets_target_preschool_id_fkey";

alter table "public"."ai_usage_resets" add constraint "ai_usage_resets_target_scope_check" CHECK ((target_scope = ANY (ARRAY['user'::text, 'preschool'::text, 'platform'::text]))) not valid;

alter table "public"."ai_usage_resets" validate constraint "ai_usage_resets_target_scope_check";

alter table "public"."ai_usage_resets" add constraint "ai_usage_resets_target_user_id_fkey" FOREIGN KEY (target_user_id) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."ai_usage_resets" validate constraint "ai_usage_resets_target_user_id_fkey";

alter table "public"."ai_usage_tiers" add constraint "ai_usage_tiers_tier_name_key" UNIQUE using index "ai_usage_tiers_tier_name_key";

alter table "public"."announcement_views" add constraint "announcement_views_announcement_id_fkey" FOREIGN KEY (announcement_id) REFERENCES public.announcements(id) ON DELETE CASCADE not valid;

alter table "public"."announcement_views" validate constraint "announcement_views_announcement_id_fkey";

alter table "public"."announcement_views" add constraint "announcement_views_announcement_id_user_id_key" UNIQUE using index "announcement_views_announcement_id_user_id_key";

alter table "public"."announcement_views" add constraint "announcement_views_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."announcement_views" validate constraint "announcement_views_user_id_fkey";

alter table "public"."announcements" add constraint "announcements_author_id_fkey" FOREIGN KEY (author_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."announcements" validate constraint "announcements_author_id_fkey";

alter table "public"."announcements" add constraint "announcements_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."announcements" validate constraint "announcements_preschool_id_fkey";

alter table "public"."announcements" add constraint "announcements_priority_check" CHECK ((priority = ANY (ARRAY['low'::text, 'medium'::text, 'high'::text, 'urgent'::text]))) not valid;

alter table "public"."announcements" validate constraint "announcements_priority_check";

alter table "public"."announcements" add constraint "announcements_target_audience_check" CHECK ((target_audience = ANY (ARRAY['all'::text, 'teachers'::text, 'parents'::text, 'students'::text]))) not valid;

alter table "public"."announcements" validate constraint "announcements_target_audience_check";

alter table "public"."assessment_rubrics" add constraint "assessment_rubrics_age_group_id_fkey" FOREIGN KEY (age_group_id) REFERENCES public.age_groups(id) ON DELETE SET NULL not valid;

alter table "public"."assessment_rubrics" validate constraint "assessment_rubrics_age_group_id_fkey";

alter table "public"."assessment_rubrics" add constraint "assessment_rubrics_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."assessment_rubrics" validate constraint "assessment_rubrics_created_by_fkey";

alter table "public"."assessment_rubrics" add constraint "assessment_rubrics_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."assessment_rubrics" validate constraint "assessment_rubrics_preschool_id_fkey";

alter table "public"."assessments" add constraint "assessments_assessment_type_check" CHECK ((assessment_type = ANY (ARRAY['quiz'::text, 'test'::text, 'project'::text, 'observation'::text]))) not valid;

alter table "public"."assessments" validate constraint "assessments_assessment_type_check";

alter table "public"."assessments" add constraint "assessments_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.classes(id) ON DELETE CASCADE not valid;

alter table "public"."assessments" validate constraint "assessments_class_id_fkey";

alter table "public"."assessments" add constraint "assessments_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) not valid;

alter table "public"."assessments" validate constraint "assessments_organization_id_fkey";

alter table "public"."assessments" add constraint "assessments_teacher_id_fkey" FOREIGN KEY (teacher_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."assessments" validate constraint "assessments_teacher_id_fkey";

alter table "public"."assessments" add constraint "fk_assessment_created_by" FOREIGN KEY (created_by) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."assessments" validate constraint "fk_assessment_created_by";

alter table "public"."assessments" add constraint "fk_assessment_student" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."assessments" validate constraint "fk_assessment_student";

alter table "public"."assignment_access" add constraint "assignment_access_assignment_id_fkey" FOREIGN KEY (assignment_id) REFERENCES public.assignments(id) ON DELETE CASCADE not valid;

alter table "public"."assignment_access" validate constraint "assignment_access_assignment_id_fkey";

alter table "public"."assignment_access" add constraint "assignment_access_assignment_id_student_id_key" UNIQUE using index "assignment_access_assignment_id_student_id_key";

alter table "public"."assignment_access" add constraint "assignment_access_custom_points_check" CHECK ((custom_points >= (0)::numeric)) not valid;

alter table "public"."assignment_access" validate constraint "assignment_access_custom_points_check";

alter table "public"."assignment_access" add constraint "assignment_access_distributed_by_fkey" FOREIGN KEY (distributed_by) REFERENCES public.profiles(id) ON DELETE RESTRICT not valid;

alter table "public"."assignment_access" validate constraint "assignment_access_distributed_by_fkey";

alter table "public"."assignment_access" add constraint "assignment_access_group_id_fkey" FOREIGN KEY (group_id) REFERENCES public.groups(id) ON DELETE SET NULL not valid;

alter table "public"."assignment_access" validate constraint "assignment_access_group_id_fkey";

alter table "public"."assignment_access" add constraint "assignment_access_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."assignment_access" validate constraint "assignment_access_student_id_fkey";

alter table "public"."assignment_categories" add constraint "assignment_categories_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."assignment_categories" validate constraint "assignment_categories_organization_id_fkey";

alter table "public"."assignment_grades" add constraint "assignment_grades_status_check" CHECK ((status = ANY (ARRAY['draft'::text, 'published'::text, 'needs_review'::text]))) not valid;

alter table "public"."assignment_grades" validate constraint "assignment_grades_status_check";

alter table "public"."assignment_grades" add constraint "assignment_grades_submission_id_fkey" FOREIGN KEY (submission_id) REFERENCES public.assignment_submissions(id) ON DELETE CASCADE not valid;

alter table "public"."assignment_grades" validate constraint "assignment_grades_submission_id_fkey";

alter table "public"."assignment_grades" add constraint "assignment_grades_submission_id_key" UNIQUE using index "assignment_grades_submission_id_key";

alter table "public"."assignment_grades" add constraint "assignment_grades_teacher_id_fkey" FOREIGN KEY (teacher_id) REFERENCES auth.users(id) not valid;

alter table "public"."assignment_grades" validate constraint "assignment_grades_teacher_id_fkey";

alter table "public"."assignment_rubrics" add constraint "assignment_rubrics_assignment_id_fkey" FOREIGN KEY (assignment_id) REFERENCES public.assignments(id) ON DELETE CASCADE not valid;

alter table "public"."assignment_rubrics" validate constraint "assignment_rubrics_assignment_id_fkey";

alter table "public"."assignment_submissions" add constraint "assignment_submissions_assignment_id_fkey" FOREIGN KEY (assignment_id) REFERENCES public.homework_assignments(id) ON DELETE CASCADE not valid;

alter table "public"."assignment_submissions" validate constraint "assignment_submissions_assignment_id_fkey";

alter table "public"."assignment_submissions" add constraint "assignment_submissions_enrollment_id_fkey" FOREIGN KEY (enrollment_id) REFERENCES public.enrollments(id) ON DELETE CASCADE not valid;

alter table "public"."assignment_submissions" validate constraint "assignment_submissions_enrollment_id_fkey";

alter table "public"."assignment_submissions" add constraint "assignment_submissions_learner_id_fkey" FOREIGN KEY (learner_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."assignment_submissions" validate constraint "assignment_submissions_learner_id_fkey";

alter table "public"."assignment_submissions" add constraint "assignment_submissions_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'submitted'::text, 'graded'::text, 'returned'::text]))) not valid;

alter table "public"."assignment_submissions" validate constraint "assignment_submissions_status_check";

alter table "public"."assignment_submissions" add constraint "assignment_submissions_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."assignment_submissions" validate constraint "assignment_submissions_student_id_fkey";

alter table "public"."assignments" add constraint "assignments_assignment_type_check" CHECK ((assignment_type = ANY (ARRAY['homework'::text, 'quiz'::text, 'exam'::text, 'project'::text, 'lab'::text, 'discussion'::text]))) not valid;

alter table "public"."assignments" validate constraint "assignments_assignment_type_check";

alter table "public"."assignments" add constraint "assignments_category_id_fkey" FOREIGN KEY (category_id) REFERENCES public.assignment_categories(id) ON DELETE SET NULL not valid;

alter table "public"."assignments" validate constraint "assignments_category_id_fkey";

alter table "public"."assignments" add constraint "assignments_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.classes(id) ON DELETE SET NULL not valid;

alter table "public"."assignments" validate constraint "assignments_class_id_fkey";

alter table "public"."assignments" add constraint "assignments_course_id_fkey" FOREIGN KEY (course_id) REFERENCES public.courses(id) ON DELETE CASCADE not valid;

alter table "public"."assignments" validate constraint "assignments_course_id_fkey";

alter table "public"."assignments" add constraint "assignments_late_penalty_percent_check" CHECK (((late_penalty_percent >= (0)::numeric) AND (late_penalty_percent <= (100)::numeric))) not valid;

alter table "public"."assignments" validate constraint "assignments_late_penalty_percent_check";

alter table "public"."assignments" add constraint "assignments_max_attempts_check" CHECK ((max_attempts > 0)) not valid;

alter table "public"."assignments" validate constraint "assignments_max_attempts_check";

alter table "public"."assignments" add constraint "assignments_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."assignments" validate constraint "assignments_organization_id_fkey";

alter table "public"."assignments" add constraint "assignments_status_check" CHECK ((status = ANY (ARRAY['draft'::text, 'published'::text, 'archived'::text]))) not valid;

alter table "public"."assignments" validate constraint "assignments_status_check";

alter table "public"."assignments" add constraint "assignments_teacher_id_fkey" FOREIGN KEY (teacher_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."assignments" validate constraint "assignments_teacher_id_fkey";

alter table "public"."attendance" add constraint "attendance_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) not valid;

alter table "public"."attendance" validate constraint "attendance_organization_id_fkey";

alter table "public"."attendance" add constraint "attendance_student_id_attendance_date_key" UNIQUE using index "attendance_student_id_attendance_date_key";

alter table "public"."attendance" add constraint "fk_attendance_recorded_by" FOREIGN KEY (recorded_by) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."attendance" validate constraint "fk_attendance_recorded_by";

alter table "public"."attendance" add constraint "fk_attendance_student" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."attendance" validate constraint "fk_attendance_student";

alter table "public"."attendance_records" add constraint "attendance_records_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.classes(id) ON DELETE CASCADE not valid;

alter table "public"."attendance_records" validate constraint "attendance_records_class_id_fkey";

alter table "public"."attendance_records" add constraint "attendance_records_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."attendance_records" validate constraint "attendance_records_preschool_id_fkey";

alter table "public"."attendance_records" add constraint "attendance_records_status_check" CHECK ((status = ANY (ARRAY['present'::text, 'absent'::text, 'late'::text, 'sick'::text]))) not valid;

alter table "public"."attendance_records" validate constraint "attendance_records_status_check";

alter table "public"."attendance_records" add constraint "attendance_records_student_id_attendance_date_key" UNIQUE using index "attendance_records_student_id_attendance_date_key";

alter table "public"."attendance_records" add constraint "attendance_records_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."attendance_records" validate constraint "attendance_records_student_id_fkey";

alter table "public"."audit_logs" add constraint "audit_logs_actor_id_fkey" FOREIGN KEY (actor_id) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."audit_logs" validate constraint "audit_logs_actor_id_fkey";

alter table "public"."audit_logs" add constraint "audit_logs_actor_organization_id_fkey" FOREIGN KEY (actor_organization_id) REFERENCES public.preschools(id) ON DELETE SET NULL not valid;

alter table "public"."audit_logs" validate constraint "audit_logs_actor_organization_id_fkey";

alter table "public"."audit_logs" add constraint "audit_logs_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."audit_logs" validate constraint "audit_logs_user_id_fkey";

alter table "public"."beta_feedback" add constraint "beta_feedback_category_check" CHECK ((category = ANY (ARRAY['bug'::text, 'feature'::text, 'confusion'::text, 'other'::text]))) not valid;

alter table "public"."beta_feedback" validate constraint "beta_feedback_category_check";

alter table "public"."beta_feedback" add constraint "beta_feedback_persona_check" CHECK ((persona = ANY (ARRAY['principal'::text, 'teacher'::text, 'parent'::text]))) not valid;

alter table "public"."beta_feedback" validate constraint "beta_feedback_persona_check";

alter table "public"."beta_feedback" add constraint "beta_feedback_severity_check" CHECK ((severity = ANY (ARRAY['low'::text, 'medium'::text, 'high'::text, 'critical'::text]))) not valid;

alter table "public"."beta_feedback" validate constraint "beta_feedback_severity_check";

alter table "public"."beta_feedback" add constraint "beta_feedback_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."beta_feedback" validate constraint "beta_feedback_user_id_fkey";

alter table "public"."beta_feedback_attachments" add constraint "beta_feedback_attachments_feedback_id_fkey" FOREIGN KEY (feedback_id) REFERENCES public.beta_feedback(id) ON DELETE CASCADE not valid;

alter table "public"."beta_feedback_attachments" validate constraint "beta_feedback_attachments_feedback_id_fkey";

alter table "public"."billing_cycles" add constraint "billing_cycles_billing_period_check" CHECK (((billing_period)::text = ANY ((ARRAY['monthly'::character varying, 'yearly'::character varying])::text[]))) not valid;

alter table "public"."billing_cycles" validate constraint "billing_cycles_billing_period_check";

alter table "public"."billing_cycles" add constraint "billing_cycles_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."billing_cycles" validate constraint "billing_cycles_preschool_id_fkey";

alter table "public"."billing_cycles" add constraint "billing_cycles_status_check" CHECK (((status)::text = ANY ((ARRAY['active'::character varying, 'cancelled'::character varying, 'expired'::character varying, 'suspended'::character varying])::text[]))) not valid;

alter table "public"."billing_cycles" validate constraint "billing_cycles_status_check";

alter table "public"."billing_invoices" add constraint "billing_invoices_invoice_number_key" UNIQUE using index "billing_invoices_invoice_number_key";

alter table "public"."billing_invoices" add constraint "billing_invoices_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."billing_invoices" validate constraint "billing_invoices_school_id_fkey";

alter table "public"."billing_invoices" add constraint "billing_invoices_status_check" CHECK ((status = ANY (ARRAY['draft'::text, 'pending'::text, 'paid'::text, 'failed'::text, 'cancelled'::text]))) not valid;

alter table "public"."billing_invoices" validate constraint "billing_invoices_status_check";

alter table "public"."billing_plans" add constraint "billing_plans_name_key" UNIQUE using index "billing_plans_name_key";

alter table "public"."billing_preferences" add constraint "billing_preferences_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."billing_preferences" validate constraint "billing_preferences_user_id_fkey";

alter table "public"."blocked_content" add constraint "blocked_content_author_id_fkey" FOREIGN KEY (author_id) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."blocked_content" validate constraint "blocked_content_author_id_fkey";

alter table "public"."blocked_content" add constraint "blocked_content_blocker_id_fkey" FOREIGN KEY (blocker_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."blocked_content" validate constraint "blocked_content_blocker_id_fkey";

alter table "public"."blocked_content" add constraint "blocked_content_content_type_check" CHECK (((content_type)::text = ANY ((ARRAY['lesson'::character varying, 'homework'::character varying, 'message'::character varying, 'comment'::character varying, 'announcement'::character varying, 'activity'::character varying, 'assessment'::character varying])::text[]))) not valid;

alter table "public"."blocked_content" validate constraint "blocked_content_content_type_check";

alter table "public"."blocked_content" add constraint "blocked_content_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.preschools(id) ON DELETE SET NULL not valid;

alter table "public"."blocked_content" validate constraint "blocked_content_school_id_fkey";

alter table "public"."blocked_content" add constraint "blocked_content_unique" UNIQUE using index "blocked_content_unique";

alter table "public"."calendar_event_mappings" add constraint "calendar_event_mappings_created_by_user_id_fkey" FOREIGN KEY (created_by_user_id) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."calendar_event_mappings" validate constraint "calendar_event_mappings_created_by_user_id_fkey";

alter table "public"."calendar_event_mappings" add constraint "calendar_event_mappings_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."calendar_event_mappings" validate constraint "calendar_event_mappings_preschool_id_fkey";

alter table "public"."calendar_event_mappings" add constraint "calendar_event_mappings_provider_check" CHECK ((provider = ANY (ARRAY['google'::text, 'microsoft'::text]))) not valid;

alter table "public"."calendar_event_mappings" validate constraint "calendar_event_mappings_provider_check";

alter table "public"."calendar_event_mappings" add constraint "calendar_event_mappings_provider_external_event_id_key" UNIQUE using index "calendar_event_mappings_provider_external_event_id_key";

alter table "public"."calendar_event_mappings" add constraint "calendar_event_mappings_sync_direction_check" CHECK ((sync_direction = ANY (ARRAY['to_external'::text, 'from_external'::text, 'bidirectional'::text]))) not valid;

alter table "public"."calendar_event_mappings" validate constraint "calendar_event_mappings_sync_direction_check";

alter table "public"."call_signals" add constraint "call_signals_from_user_id_fkey" FOREIGN KEY (from_user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."call_signals" validate constraint "call_signals_from_user_id_fkey";

alter table "public"."call_signals" add constraint "call_signals_signal_type_check" CHECK ((signal_type = ANY (ARRAY['offer'::text, 'answer'::text, 'ice-candidate'::text, 'call-ended'::text, 'call-rejected'::text, 'call-busy'::text]))) not valid;

alter table "public"."call_signals" validate constraint "call_signals_signal_type_check";

alter table "public"."call_signals" add constraint "call_signals_to_user_id_fkey" FOREIGN KEY (to_user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."call_signals" validate constraint "call_signals_to_user_id_fkey";

alter table "public"."campaign_redemptions" add constraint "campaign_redemptions_campaign_id_fkey" FOREIGN KEY (campaign_id) REFERENCES public.marketing_campaigns(id) ON DELETE CASCADE not valid;

alter table "public"."campaign_redemptions" validate constraint "campaign_redemptions_campaign_id_fkey";

alter table "public"."campaign_redemptions" add constraint "campaign_redemptions_campaign_id_registration_request_id_key" UNIQUE using index "campaign_redemptions_campaign_id_registration_request_id_key";

alter table "public"."campaign_redemptions" add constraint "campaign_redemptions_registration_request_id_fkey" FOREIGN KEY (registration_request_id) REFERENCES public.registration_requests(id) ON DELETE CASCADE not valid;

alter table "public"."campaign_redemptions" validate constraint "campaign_redemptions_registration_request_id_fkey";

alter table "public"."candidate_profiles" add constraint "candidate_profiles_email_key" UNIQUE using index "candidate_profiles_email_key";

alter table "public"."candidate_profiles" add constraint "candidate_profiles_willing_to_commute_km_check" CHECK (((willing_to_commute_km >= 0) AND (willing_to_commute_km <= 200))) not valid;

alter table "public"."candidate_profiles" validate constraint "candidate_profiles_willing_to_commute_km_check";

alter table "public"."caps_chunks" add constraint "caps_chunks_document_id_fkey" FOREIGN KEY (document_id) REFERENCES public.caps_documents(id) ON DELETE CASCADE not valid;

alter table "public"."caps_chunks" validate constraint "caps_chunks_document_id_fkey";

alter table "public"."caps_content_chunks" add constraint "caps_content_chunks_document_id_chunk_index_key" UNIQUE using index "caps_content_chunks_document_id_chunk_index_key";

alter table "public"."caps_content_chunks" add constraint "caps_content_chunks_document_id_fkey" FOREIGN KEY (document_id) REFERENCES public.caps_documents(id) ON DELETE CASCADE not valid;

alter table "public"."caps_content_chunks" validate constraint "caps_content_chunks_document_id_fkey";

alter table "public"."caps_documents" add constraint "caps_documents_document_type_check" CHECK (((document_type)::text = ANY ((ARRAY['curriculum'::character varying, 'exam'::character varying, 'exemplar'::character varying, 'guideline'::character varying, 'teaching_plan'::character varying, 'memorandum'::character varying, 'policy'::character varying])::text[]))) not valid;

alter table "public"."caps_documents" validate constraint "caps_documents_document_type_check";

alter table "public"."caps_documents" add constraint "caps_documents_term_check" CHECK (((term >= 1) AND (term <= 4))) not valid;

alter table "public"."caps_documents" validate constraint "caps_documents_term_check";

alter table "public"."caps_exam_patterns" add constraint "caps_exam_patterns_grade_subject_topic_key" UNIQUE using index "caps_exam_patterns_grade_subject_topic_key";

alter table "public"."caps_exam_questions" add constraint "caps_exam_questions_difficulty_check" CHECK (((difficulty)::text = ANY ((ARRAY['easy'::character varying, 'medium'::character varying, 'hard'::character varying, 'challenging'::character varying])::text[]))) not valid;

alter table "public"."caps_exam_questions" validate constraint "caps_exam_questions_difficulty_check";

alter table "public"."caps_exam_questions" add constraint "caps_exam_questions_document_id_fkey" FOREIGN KEY (document_id) REFERENCES public.caps_documents(id) ON DELETE CASCADE not valid;

alter table "public"."caps_exam_questions" validate constraint "caps_exam_questions_document_id_fkey";

alter table "public"."caps_textbook_mapping" add constraint "caps_textbook_mapping_alignment_score_check" CHECK (((alignment_score >= 1) AND (alignment_score <= 5))) not valid;

alter table "public"."caps_textbook_mapping" validate constraint "caps_textbook_mapping_alignment_score_check";

alter table "public"."caps_textbook_mapping" add constraint "caps_textbook_mapping_caps_topic_id_fkey" FOREIGN KEY (caps_topic_id) REFERENCES public.caps_topics(id) ON DELETE CASCADE not valid;

alter table "public"."caps_textbook_mapping" validate constraint "caps_textbook_mapping_caps_topic_id_fkey";

alter table "public"."caps_textbook_mapping" add constraint "caps_textbook_mapping_caps_topic_id_textbook_content_id_key" UNIQUE using index "caps_textbook_mapping_caps_topic_id_textbook_content_id_key";

alter table "public"."caps_textbook_mapping" add constraint "caps_textbook_mapping_coverage_percentage_check" CHECK (((coverage_percentage >= 1) AND (coverage_percentage <= 100))) not valid;

alter table "public"."caps_textbook_mapping" validate constraint "caps_textbook_mapping_coverage_percentage_check";

alter table "public"."caps_textbook_mapping" add constraint "caps_textbook_mapping_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."caps_textbook_mapping" validate constraint "caps_textbook_mapping_created_by_fkey";

alter table "public"."caps_textbook_mapping" add constraint "caps_textbook_mapping_status_check" CHECK (((status)::text = ANY ((ARRAY['draft'::character varying, 'verified'::character varying, 'approved'::character varying, 'outdated'::character varying])::text[]))) not valid;

alter table "public"."caps_textbook_mapping" validate constraint "caps_textbook_mapping_status_check";

alter table "public"."caps_textbook_mapping" add constraint "caps_textbook_mapping_textbook_content_id_fkey" FOREIGN KEY (textbook_content_id) REFERENCES public.textbook_content(id) ON DELETE CASCADE not valid;

alter table "public"."caps_textbook_mapping" validate constraint "caps_textbook_mapping_textbook_content_id_fkey";

alter table "public"."caps_textbook_mapping" add constraint "caps_textbook_mapping_verified_by_fkey" FOREIGN KEY (verified_by) REFERENCES auth.users(id) not valid;

alter table "public"."caps_textbook_mapping" validate constraint "caps_textbook_mapping_verified_by_fkey";

alter table "public"."caps_topics" add constraint "caps_topics_grade_subject_topic_code_key" UNIQUE using index "caps_topics_grade_subject_topic_code_key";

alter table "public"."caps_topics" add constraint "caps_topics_term_check" CHECK (((term >= 1) AND (term <= 4))) not valid;

alter table "public"."caps_topics" validate constraint "caps_topics_term_check";

alter table "public"."chat_images" add constraint "chat_images_hash_key" UNIQUE using index "chat_images_hash_key";

alter table "public"."chat_images" add constraint "fk_chat_images_user" FOREIGN KEY (uploaded_by) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."chat_images" validate constraint "fk_chat_images_user";

alter table "public"."child_registration_requests" add constraint "child_registration_requests_child_gender_check" CHECK ((child_gender = ANY (ARRAY['male'::text, 'female'::text, 'other'::text]))) not valid;

alter table "public"."child_registration_requests" validate constraint "child_registration_requests_child_gender_check";

alter table "public"."child_registration_requests" add constraint "child_registration_requests_parent_id_fkey" FOREIGN KEY (parent_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."child_registration_requests" validate constraint "child_registration_requests_parent_id_fkey";

alter table "public"."child_registration_requests" add constraint "child_registration_requests_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."child_registration_requests" validate constraint "child_registration_requests_preschool_id_fkey";

alter table "public"."child_registration_requests" add constraint "child_registration_requests_reviewed_by_fkey" FOREIGN KEY (reviewed_by) REFERENCES public.profiles(id) not valid;

alter table "public"."child_registration_requests" validate constraint "child_registration_requests_reviewed_by_fkey";

alter table "public"."child_registration_requests" add constraint "child_registration_requests_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'approved'::text, 'rejected'::text, 'withdrawn'::text]))) not valid;

alter table "public"."child_registration_requests" validate constraint "child_registration_requests_status_check";

alter table "public"."class_assignments" add constraint "class_assignments_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.classes(id) ON DELETE CASCADE not valid;

alter table "public"."class_assignments" validate constraint "class_assignments_class_id_fkey";

alter table "public"."class_assignments" add constraint "class_assignments_status_check" CHECK ((status = ANY (ARRAY['active'::text, 'inactive'::text, 'transferred'::text]))) not valid;

alter table "public"."class_assignments" validate constraint "class_assignments_status_check";

alter table "public"."class_assignments" add constraint "class_assignments_student_id_class_id_key" UNIQUE using index "class_assignments_student_id_class_id_key";

alter table "public"."class_assignments" add constraint "class_assignments_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."class_assignments" validate constraint "class_assignments_student_id_fkey";

alter table "public"."class_events" add constraint "class_events_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.classes(id) ON DELETE CASCADE not valid;

alter table "public"."class_events" validate constraint "class_events_class_id_fkey";

alter table "public"."class_events" add constraint "class_events_event_type_check" CHECK ((event_type = ANY (ARRAY['lesson'::text, 'activity'::text, 'field_trip'::text, 'meeting'::text, 'exam'::text, 'celebration'::text, 'other'::text]))) not valid;

alter table "public"."class_events" validate constraint "class_events_event_type_check";

alter table "public"."class_events" add constraint "class_events_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."class_events" validate constraint "class_events_preschool_id_fkey";

alter table "public"."class_events" add constraint "class_events_status_check" CHECK ((status = ANY (ARRAY['scheduled'::text, 'in_progress'::text, 'completed'::text, 'cancelled'::text, 'postponed'::text]))) not valid;

alter table "public"."class_events" validate constraint "class_events_status_check";

alter table "public"."class_events" add constraint "class_events_teacher_id_fkey" FOREIGN KEY (teacher_id) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."class_events" validate constraint "class_events_teacher_id_fkey";

alter table "public"."classes" add constraint "classes_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) not valid;

alter table "public"."classes" validate constraint "classes_organization_id_fkey";

alter table "public"."classroom_reports" add constraint "classroom_reports_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.classes(id) ON DELETE SET NULL not valid;

alter table "public"."classroom_reports" validate constraint "classroom_reports_class_id_fkey";

alter table "public"."classroom_reports" add constraint "classroom_reports_mood_rating_check" CHECK (((mood_rating >= 1) AND (mood_rating <= 5))) not valid;

alter table "public"."classroom_reports" validate constraint "classroom_reports_mood_rating_check";

alter table "public"."classroom_reports" add constraint "classroom_reports_participation_level_check" CHECK (((participation_level)::text = ANY ((ARRAY['low'::character varying, 'moderate'::character varying, 'high'::character varying, 'excellent'::character varying])::text[]))) not valid;

alter table "public"."classroom_reports" validate constraint "classroom_reports_participation_level_check";

alter table "public"."classroom_reports" add constraint "classroom_reports_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."classroom_reports" validate constraint "classroom_reports_preschool_id_fkey";

alter table "public"."classroom_reports" add constraint "classroom_reports_report_type_check" CHECK (((report_type)::text = ANY ((ARRAY['daily'::character varying, 'weekly'::character varying, 'monthly'::character varying])::text[]))) not valid;

alter table "public"."classroom_reports" validate constraint "classroom_reports_report_type_check";

alter table "public"."classroom_reports" add constraint "classroom_reports_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."classroom_reports" validate constraint "classroom_reports_student_id_fkey";

alter table "public"."classroom_reports" add constraint "classroom_reports_teacher_id_fkey" FOREIGN KEY (teacher_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."classroom_reports" validate constraint "classroom_reports_teacher_id_fkey";

alter table "public"."config_kv" add constraint "config_kv_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) not valid;

alter table "public"."config_kv" validate constraint "config_kv_preschool_id_fkey";

alter table "public"."contact_discovery_settings" add constraint "contact_discovery_settings_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."contact_discovery_settings" validate constraint "contact_discovery_settings_user_id_fkey";

alter table "public"."contact_suggestions" add constraint "contact_suggestions_confidence_score_check" CHECK (((confidence_score >= 0) AND (confidence_score <= 100))) not valid;

alter table "public"."contact_suggestions" validate constraint "contact_suggestions_confidence_score_check";

alter table "public"."contact_suggestions" add constraint "contact_suggestions_reason_check" CHECK (((reason)::text = ANY ((ARRAY['phone_contact'::character varying, 'mutual_friends'::character varying, 'same_school'::character varying, 'nearby'::character varying, 'frequent_interaction'::character varying])::text[]))) not valid;

alter table "public"."contact_suggestions" validate constraint "contact_suggestions_reason_check";

alter table "public"."contact_suggestions" add constraint "contact_suggestions_suggested_user_id_fkey" FOREIGN KEY (suggested_user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."contact_suggestions" validate constraint "contact_suggestions_suggested_user_id_fkey";

alter table "public"."contact_suggestions" add constraint "contact_suggestions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."contact_suggestions" validate constraint "contact_suggestions_user_id_fkey";

alter table "public"."contact_suggestions" add constraint "contact_suggestions_user_id_suggested_user_id_key" UNIQUE using index "contact_suggestions_user_id_suggested_user_id_key";

alter table "public"."content_reports" add constraint "content_reports_author_id_fkey" FOREIGN KEY (author_id) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."content_reports" validate constraint "content_reports_author_id_fkey";

alter table "public"."content_reports" add constraint "content_reports_content_type_check" CHECK (((content_type)::text = ANY ((ARRAY['lesson'::character varying, 'homework'::character varying, 'message'::character varying, 'comment'::character varying, 'announcement'::character varying, 'activity'::character varying, 'assessment'::character varying])::text[]))) not valid;

alter table "public"."content_reports" validate constraint "content_reports_content_type_check";

alter table "public"."content_reports" add constraint "content_reports_reporter_id_fkey" FOREIGN KEY (reporter_id) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."content_reports" validate constraint "content_reports_reporter_id_fkey";

alter table "public"."content_reports" add constraint "content_reports_reviewed_by_fkey" FOREIGN KEY (reviewed_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."content_reports" validate constraint "content_reports_reviewed_by_fkey";

alter table "public"."content_reports" add constraint "content_reports_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.preschools(id) ON DELETE SET NULL not valid;

alter table "public"."content_reports" validate constraint "content_reports_school_id_fkey";

alter table "public"."content_reports" add constraint "content_reports_severity_check" CHECK (((severity)::text = ANY ((ARRAY['low'::character varying, 'medium'::character varying, 'high'::character varying, 'critical'::character varying])::text[]))) not valid;

alter table "public"."content_reports" validate constraint "content_reports_severity_check";

alter table "public"."content_reports" add constraint "content_reports_status_check" CHECK (((status)::text = ANY ((ARRAY['pending'::character varying, 'reviewing'::character varying, 'resolved'::character varying, 'dismissed'::character varying])::text[]))) not valid;

alter table "public"."content_reports" validate constraint "content_reports_status_check";

alter table "public"."content_reports" add constraint "content_reports_unique" UNIQUE using index "content_reports_unique";

alter table "public"."conversation_members" add constraint "conversation_members_conversation_id_fkey" FOREIGN KEY (conversation_id) REFERENCES public.conversations(id) ON DELETE CASCADE not valid;

alter table "public"."conversation_members" validate constraint "conversation_members_conversation_id_fkey";

alter table "public"."conversation_members" add constraint "conversation_members_conversation_id_user_id_key" UNIQUE using index "conversation_members_conversation_id_user_id_key";

alter table "public"."conversation_members" add constraint "conversation_members_role_check" CHECK ((role = ANY (ARRAY['owner'::text, 'admin'::text, 'member'::text]))) not valid;

alter table "public"."conversation_members" validate constraint "conversation_members_role_check";

alter table "public"."conversation_members" add constraint "conversation_members_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."conversation_members" validate constraint "conversation_members_user_id_fkey";

alter table "public"."conversations" add constraint "conversations_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.classes(id) ON DELETE SET NULL not valid;

alter table "public"."conversations" validate constraint "conversations_class_id_fkey";

alter table "public"."conversations" add constraint "conversations_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."conversations" validate constraint "conversations_created_by_fkey";

alter table "public"."conversations" add constraint "conversations_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."conversations" validate constraint "conversations_preschool_id_fkey";

alter table "public"."conversations" add constraint "conversations_type_check" CHECK ((type = ANY (ARRAY['direct'::text, 'group'::text, 'announcement'::text]))) not valid;

alter table "public"."conversations" validate constraint "conversations_type_check";

alter table "public"."course_grades" add constraint "course_grades_calculated_by_fkey" FOREIGN KEY (calculated_by) REFERENCES public.profiles(id) ON DELETE RESTRICT not valid;

alter table "public"."course_grades" validate constraint "course_grades_calculated_by_fkey";

alter table "public"."course_grades" add constraint "course_grades_calculation_method_check" CHECK ((calculation_method = ANY (ARRAY['points'::text, 'weighted'::text, 'category_weighted'::text]))) not valid;

alter table "public"."course_grades" validate constraint "course_grades_calculation_method_check";

alter table "public"."course_grades" add constraint "course_grades_course_id_fkey" FOREIGN KEY (course_id) REFERENCES public.courses(id) ON DELETE CASCADE not valid;

alter table "public"."course_grades" validate constraint "course_grades_course_id_fkey";

alter table "public"."course_grades" add constraint "course_grades_course_id_student_id_key" UNIQUE using index "course_grades_course_id_student_id_key";

alter table "public"."course_grades" add constraint "course_grades_final_grade_check" CHECK (((final_grade >= (0)::numeric) AND (final_grade <= (100)::numeric))) not valid;

alter table "public"."course_grades" validate constraint "course_grades_final_grade_check";

alter table "public"."course_grades" add constraint "course_grades_gpa_points_check" CHECK (((gpa_points >= (0)::numeric) AND (gpa_points <= (4)::numeric))) not valid;

alter table "public"."course_grades" validate constraint "course_grades_gpa_points_check";

alter table "public"."course_grades" add constraint "course_grades_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."course_grades" validate constraint "course_grades_student_id_fkey";

alter table "public"."course_join_requests" add constraint "course_join_requests_course_id_fkey" FOREIGN KEY (course_id) REFERENCES public.courses(id) ON DELETE CASCADE not valid;

alter table "public"."course_join_requests" validate constraint "course_join_requests_course_id_fkey";

alter table "public"."course_join_requests" add constraint "course_join_requests_processed_by_fkey" FOREIGN KEY (processed_by) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."course_join_requests" validate constraint "course_join_requests_processed_by_fkey";

alter table "public"."course_join_requests" add constraint "course_join_requests_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'approved'::text, 'rejected'::text, 'cancelled'::text]))) not valid;

alter table "public"."course_join_requests" validate constraint "course_join_requests_status_check";

alter table "public"."course_join_requests" add constraint "course_join_requests_student_id_course_id_key" UNIQUE using index "course_join_requests_student_id_course_id_key";

alter table "public"."course_join_requests" add constraint "course_join_requests_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."course_join_requests" validate constraint "course_join_requests_student_id_fkey";

alter table "public"."course_join_requests" add constraint "join_request_process_check" CHECK ((((status = 'pending'::text) AND (processed_by IS NULL) AND (processed_at IS NULL)) OR ((status <> 'pending'::text) AND (processed_by IS NOT NULL) AND (processed_at IS NOT NULL)))) not valid;

alter table "public"."course_join_requests" validate constraint "join_request_process_check";

alter table "public"."courses" add constraint "courses_check" CHECK (((end_date IS NULL) OR (end_date > start_date))) not valid;

alter table "public"."courses" validate constraint "courses_check";

alter table "public"."courses" add constraint "courses_course_code_check" CHECK ((length(course_code) <= 20)) not valid;

alter table "public"."courses" validate constraint "courses_course_code_check";

alter table "public"."courses" add constraint "courses_dates_check" CHECK (((start_date IS NULL) OR (end_date IS NULL) OR (end_date > start_date))) not valid;

alter table "public"."courses" validate constraint "courses_dates_check";

alter table "public"."courses" add constraint "courses_instructor_id_fkey" FOREIGN KEY (instructor_id) REFERENCES public.profiles(id) ON DELETE RESTRICT not valid;

alter table "public"."courses" validate constraint "courses_instructor_id_fkey";

alter table "public"."courses" add constraint "courses_join_code_check" CHECK (((join_code IS NULL) OR (length(join_code) >= 6))) not valid;

alter table "public"."courses" validate constraint "courses_join_code_check";

alter table "public"."courses" add constraint "courses_join_code_key" UNIQUE using index "courses_join_code_key";

alter table "public"."courses" add constraint "courses_max_students_check" CHECK ((max_students > 0)) not valid;

alter table "public"."courses" validate constraint "courses_max_students_check";

alter table "public"."courses" add constraint "courses_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."courses" validate constraint "courses_organization_id_fkey";

alter table "public"."courses" add constraint "courses_title_check" CHECK (((length(title) >= 1) AND (length(title) <= 255))) not valid;

alter table "public"."courses" validate constraint "courses_title_check";

alter table "public"."cv_templates" add constraint "cv_templates_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."cv_templates" validate constraint "cv_templates_organization_id_fkey";

alter table "public"."cv_uploads" add constraint "cv_uploads_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."cv_uploads" validate constraint "cv_uploads_organization_id_fkey";

alter table "public"."cv_uploads" add constraint "cv_uploads_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'processed'::text, 'failed'::text]))) not valid;

alter table "public"."cv_uploads" validate constraint "cv_uploads_status_check";

alter table "public"."cv_uploads" add constraint "cv_uploads_uploaded_by_fkey" FOREIGN KEY (uploaded_by) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."cv_uploads" validate constraint "cv_uploads_uploaded_by_fkey";

alter table "public"."daily_activities" add constraint "fk_daily_activity_class" FOREIGN KEY (class_id) REFERENCES public.classes(id) ON DELETE CASCADE not valid;

alter table "public"."daily_activities" validate constraint "fk_daily_activity_class";

alter table "public"."daily_activities" add constraint "fk_daily_activity_created_by" FOREIGN KEY (created_by) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."daily_activities" validate constraint "fk_daily_activity_created_by";

alter table "public"."dash_agent_instances" add constraint "dash_agent_instances_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."dash_agent_instances" validate constraint "dash_agent_instances_preschool_id_fkey";

alter table "public"."dash_agent_instances" add constraint "dash_agent_instances_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."dash_agent_instances" validate constraint "dash_agent_instances_user_id_fkey";

alter table "public"."dash_conversation_facts" add constraint "dash_conversation_facts_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."dash_conversation_facts" validate constraint "dash_conversation_facts_preschool_id_fkey";

alter table "public"."dash_conversation_facts" add constraint "dash_conversation_facts_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."dash_conversation_facts" validate constraint "dash_conversation_facts_user_id_fkey";

alter table "public"."dash_curriculum_memory" add constraint "dash_curriculum_memory_memory_type_check" CHECK (((memory_type)::text = ANY ((ARRAY['curriculum_insight'::character varying, 'teaching_tip'::character varying, 'common_misconception'::character varying, 'assessment_note'::character varying, 'connection'::character varying, 'resource_link'::character varying])::text[]))) not valid;

alter table "public"."dash_curriculum_memory" validate constraint "dash_curriculum_memory_memory_type_check";

alter table "public"."dash_reminders" add constraint "dash_reminders_future_check" CHECK ((schedule_at > (now() - '01:00:00'::interval))) not valid;

alter table "public"."dash_reminders" validate constraint "dash_reminders_future_check";

alter table "public"."dash_reminders" add constraint "dash_reminders_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."dash_reminders" validate constraint "dash_reminders_preschool_id_fkey";

alter table "public"."dash_reminders" add constraint "dash_reminders_status_check" CHECK ((status = ANY (ARRAY['active'::text, 'triggered'::text, 'dismissed'::text, 'snoozed'::text]))) not valid;

alter table "public"."dash_reminders" validate constraint "dash_reminders_status_check";

alter table "public"."dash_reminders" add constraint "dash_reminders_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."dash_reminders" validate constraint "dash_reminders_user_id_fkey";

alter table "public"."dash_storage" add constraint "dash_storage_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."dash_storage" validate constraint "dash_storage_preschool_id_fkey";

alter table "public"."dash_storage" add constraint "dash_storage_preschool_id_user_id_storage_key_key" UNIQUE using index "dash_storage_preschool_id_user_id_storage_key_key";

alter table "public"."dash_storage" add constraint "dash_storage_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."dash_storage" validate constraint "dash_storage_user_id_fkey";

alter table "public"."dash_user_contexts" add constraint "dash_user_contexts_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."dash_user_contexts" validate constraint "dash_user_contexts_preschool_id_fkey";

alter table "public"."dash_user_contexts" add constraint "dash_user_contexts_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."dash_user_contexts" validate constraint "dash_user_contexts_user_id_fkey";

alter table "public"."dash_user_contexts" add constraint "dash_user_contexts_user_id_key" UNIQUE using index "dash_user_contexts_user_id_key";

alter table "public"."dashboard_voice_notes" add constraint "dashboard_voice_notes_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."dashboard_voice_notes" validate constraint "dashboard_voice_notes_user_id_fkey";

alter table "public"."dashboard_voice_notes" add constraint "positive_duration" CHECK ((duration_seconds >= 0)) not valid;

alter table "public"."dashboard_voice_notes" validate constraint "positive_duration";

alter table "public"."dashboard_voice_notes" add constraint "positive_file_size" CHECK (((file_size IS NULL) OR (file_size >= 0))) not valid;

alter table "public"."dashboard_voice_notes" validate constraint "positive_file_size";

alter table "public"."deletion_requests" add constraint "deletion_requests_processed_by_fkey" FOREIGN KEY (processed_by) REFERENCES auth.users(id) not valid;

alter table "public"."deletion_requests" validate constraint "deletion_requests_processed_by_fkey";

alter table "public"."deletion_requests" add constraint "deletion_requests_request_id_key" UNIQUE using index "deletion_requests_request_id_key";

alter table "public"."deletion_requests" add constraint "deletion_requests_role_check" CHECK ((role = ANY (ARRAY['principal'::text, 'teacher'::text, 'parent'::text, 'student'::text]))) not valid;

alter table "public"."deletion_requests" validate constraint "deletion_requests_role_check";

alter table "public"."deletion_requests" add constraint "deletion_requests_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'verified'::text, 'processing'::text, 'completed'::text, 'cancelled'::text]))) not valid;

alter table "public"."deletion_requests" validate constraint "deletion_requests_status_check";

alter table "public"."deletion_requests" add constraint "deletion_requests_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."deletion_requests" validate constraint "deletion_requests_user_id_fkey";

alter table "public"."delivery_providers" add constraint "delivery_providers_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."delivery_providers" validate constraint "delivery_providers_created_by_fkey";

alter table "public"."delivery_providers" add constraint "delivery_providers_provider_name_key" UNIQUE using index "delivery_providers_provider_name_key";

alter table "public"."delivery_providers" add constraint "delivery_providers_updated_by_fkey" FOREIGN KEY (updated_by) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."delivery_providers" validate constraint "delivery_providers_updated_by_fkey";

alter table "public"."delivery_providers" add constraint "one_primary_per_channel" CHECK (true) not valid;

alter table "public"."delivery_providers" validate constraint "one_primary_per_channel";

alter table "public"."delivery_providers" add constraint "valid_priority" CHECK ((priority >= 0)) not valid;

alter table "public"."delivery_providers" validate constraint "valid_priority";

alter table "public"."delivery_providers" add constraint "valid_quotas" CHECK ((((daily_quota IS NULL) OR (daily_quota > 0)) AND ((monthly_quota IS NULL) OR (monthly_quota > 0)))) not valid;

alter table "public"."delivery_providers" validate constraint "valid_quotas";

alter table "public"."delivery_providers" add constraint "valid_usage" CHECK (((current_daily_usage >= 0) AND (current_monthly_usage >= 0))) not valid;

alter table "public"."delivery_providers" validate constraint "valid_usage";

alter table "public"."delivery_retry_queue" add constraint "delivery_retry_queue_delivery_id_fkey" FOREIGN KEY (delivery_id) REFERENCES public.notification_deliveries(id) ON DELETE CASCADE not valid;

alter table "public"."delivery_retry_queue" validate constraint "delivery_retry_queue_delivery_id_fkey";

alter table "public"."delivery_retry_queue" add constraint "future_schedule" CHECK ((scheduled_at > created_at)) not valid;

alter table "public"."delivery_retry_queue" validate constraint "future_schedule";

alter table "public"."delivery_retry_queue" add constraint "valid_retry_attempt" CHECK ((retry_attempt > 0)) not valid;

alter table "public"."delivery_retry_queue" validate constraint "valid_retry_attempt";

alter table "public"."delivery_webhooks" add constraint "delivery_webhooks_delivery_id_fkey" FOREIGN KEY (delivery_id) REFERENCES public.notification_deliveries(id) ON DELETE CASCADE not valid;

alter table "public"."delivery_webhooks" validate constraint "delivery_webhooks_delivery_id_fkey";

alter table "public"."delivery_webhooks" add constraint "valid_event_type" CHECK ((event_type ~ '^[a-z][a-z0-9_]*$'::text)) not valid;

alter table "public"."delivery_webhooks" validate constraint "valid_event_type";

alter table "public"."dm_settings" add constraint "dm_settings_partner_user_id_fkey" FOREIGN KEY (partner_user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."dm_settings" validate constraint "dm_settings_partner_user_id_fkey";

alter table "public"."dm_settings" add constraint "dm_settings_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."dm_settings" validate constraint "dm_settings_user_id_fkey";

alter table "public"."dm_settings" add constraint "dm_settings_user_id_partner_user_id_key" UNIQUE using index "dm_settings_user_id_partner_user_id_key";

alter table "public"."early_access_signups" add constraint "early_access_signups_email_key" UNIQUE using index "early_access_signups_email_key";

alter table "public"."email_logs" add constraint "email_logs_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."email_logs" validate constraint "email_logs_organization_id_fkey";

alter table "public"."email_logs" add constraint "email_logs_status_check" CHECK ((status = ANY (ARRAY['sent'::text, 'failed'::text, 'test_mode'::text, 'queued'::text]))) not valid;

alter table "public"."email_logs" validate constraint "email_logs_status_check";

alter table "public"."email_logs" add constraint "email_logs_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."email_logs" validate constraint "email_logs_user_id_fkey";

alter table "public"."email_preferences" add constraint "email_preferences_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."email_preferences" validate constraint "email_preferences_user_id_fkey";

alter table "public"."email_preferences" add constraint "email_preferences_user_id_key" UNIQUE using index "email_preferences_user_id_key";

alter table "public"."email_templates" add constraint "email_templates_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) not valid;

alter table "public"."email_templates" validate constraint "email_templates_created_by_fkey";

alter table "public"."email_templates" add constraint "email_templates_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."email_templates" validate constraint "email_templates_preschool_id_fkey";

alter table "public"."email_templates" add constraint "email_templates_preschool_id_name_template_type_key" UNIQUE using index "email_templates_preschool_id_name_template_type_key";

alter table "public"."email_templates" add constraint "email_templates_template_type_check" CHECK ((template_type = ANY (ARRAY['progress_report'::text, 'newsletter'::text, 'event_reminder'::text, 'invoice'::text, 'welcome'::text, 'custom'::text]))) not valid;

alter table "public"."email_templates" validate constraint "email_templates_template_type_check";

alter table "public"."emergency_contacts" add constraint "emergency_contacts_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."emergency_contacts" validate constraint "emergency_contacts_student_id_fkey";

alter table "public"."enrollment_applications" add constraint "enrollment_applications_child_gender_check" CHECK ((child_gender = ANY (ARRAY['male'::text, 'female'::text, 'other'::text]))) not valid;

alter table "public"."enrollment_applications" validate constraint "enrollment_applications_child_gender_check";

alter table "public"."enrollment_applications" add constraint "enrollment_applications_preferred_class_id_fkey" FOREIGN KEY (preferred_class_id) REFERENCES public.classes(id) not valid;

alter table "public"."enrollment_applications" validate constraint "enrollment_applications_preferred_class_id_fkey";

alter table "public"."enrollment_applications" add constraint "enrollment_applications_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."enrollment_applications" validate constraint "enrollment_applications_preschool_id_fkey";

alter table "public"."enrollment_applications" add constraint "enrollment_applications_reviewed_by_fkey" FOREIGN KEY (reviewed_by) REFERENCES public.users(id) not valid;

alter table "public"."enrollment_applications" validate constraint "enrollment_applications_reviewed_by_fkey";

alter table "public"."enrollment_applications" add constraint "enrollment_applications_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'approved'::text, 'rejected'::text, 'waitlisted'::text]))) not valid;

alter table "public"."enrollment_applications" validate constraint "enrollment_applications_status_check";

alter table "public"."enrollments" add constraint "enrollments_course_id_fkey" FOREIGN KEY (course_id) REFERENCES public.courses(id) ON DELETE CASCADE not valid;

alter table "public"."enrollments" validate constraint "enrollments_course_id_fkey";

alter table "public"."enrollments" add constraint "enrollments_drop_check" CHECK ((((is_active = true) AND (dropped_at IS NULL)) OR ((is_active = false) AND (dropped_at IS NOT NULL)))) not valid;

alter table "public"."enrollments" validate constraint "enrollments_drop_check";

alter table "public"."enrollments" add constraint "enrollments_enrollment_method_check" CHECK ((enrollment_method = ANY (ARRAY['manual'::text, 'join_code'::text, 'admin_assigned'::text, 'imported'::text]))) not valid;

alter table "public"."enrollments" validate constraint "enrollments_enrollment_method_check";

alter table "public"."enrollments" add constraint "enrollments_student_id_course_id_key" UNIQUE using index "enrollments_student_id_course_id_key";

alter table "public"."enrollments" add constraint "enrollments_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."enrollments" validate constraint "enrollments_student_id_fkey";

alter table "public"."error_logs" add constraint "error_logs_level_check" CHECK ((level = ANY (ARRAY['error'::text, 'warning'::text, 'info'::text]))) not valid;

alter table "public"."error_logs" validate constraint "error_logs_level_check";

alter table "public"."error_logs" add constraint "error_logs_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."error_logs" validate constraint "error_logs_user_id_fkey";

alter table "public"."event_attendees" add constraint "event_attendees_event_id_fkey" FOREIGN KEY (event_id) REFERENCES public.member_events(id) ON DELETE CASCADE not valid;

alter table "public"."event_attendees" validate constraint "event_attendees_event_id_fkey";

alter table "public"."event_attendees" add constraint "event_attendees_event_id_member_id_key" UNIQUE using index "event_attendees_event_id_member_id_key";

alter table "public"."event_attendees" add constraint "event_attendees_member_id_fkey" FOREIGN KEY (member_id) REFERENCES public.organization_members(id) ON DELETE CASCADE not valid;

alter table "public"."event_attendees" validate constraint "event_attendees_member_id_fkey";

alter table "public"."event_attendees" add constraint "event_attendees_status_check" CHECK (((status)::text = ANY ((ARRAY['registered'::character varying, 'confirmed'::character varying, 'attended'::character varying, 'cancelled'::character varying, 'no_show'::character varying])::text[]))) not valid;

alter table "public"."event_attendees" validate constraint "event_attendees_status_check";

alter table "public"."event_audiences" add constraint "event_audiences_event_id_fkey" FOREIGN KEY (event_id) REFERENCES public.events(id) ON DELETE CASCADE not valid;

alter table "public"."event_audiences" validate constraint "event_audiences_event_id_fkey";

alter table "public"."event_invitations" add constraint "event_invitations_event_id_fkey" FOREIGN KEY (event_id) REFERENCES public.events(id) ON DELETE CASCADE not valid;

alter table "public"."event_invitations" validate constraint "event_invitations_event_id_fkey";

alter table "public"."event_invitations" add constraint "event_invitations_event_id_invitee_id_key" UNIQUE using index "event_invitations_event_id_invitee_id_key";

alter table "public"."event_invitations" add constraint "event_invitations_invitee_id_fkey" FOREIGN KEY (invitee_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."event_invitations" validate constraint "event_invitations_invitee_id_fkey";

alter table "public"."event_invitations" add constraint "event_invitations_inviter_id_fkey" FOREIGN KEY (inviter_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."event_invitations" validate constraint "event_invitations_inviter_id_fkey";

alter table "public"."event_media" add constraint "event_media_event_id_fkey" FOREIGN KEY (event_id) REFERENCES public.events(id) ON DELETE CASCADE not valid;

alter table "public"."event_media" validate constraint "event_media_event_id_fkey";

alter table "public"."event_media" add constraint "event_media_update_id_fkey" FOREIGN KEY (update_id) REFERENCES public.event_updates(id) ON DELETE CASCADE not valid;

alter table "public"."event_media" validate constraint "event_media_update_id_fkey";

alter table "public"."event_media" add constraint "event_media_uploader_id_fkey" FOREIGN KEY (uploader_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."event_media" validate constraint "event_media_uploader_id_fkey";

alter table "public"."event_notifications" add constraint "event_notifications_event_id_fkey" FOREIGN KEY (event_id) REFERENCES public.events(id) ON DELETE CASCADE not valid;

alter table "public"."event_notifications" validate constraint "event_notifications_event_id_fkey";

alter table "public"."event_notifications" add constraint "event_notifications_recipient_id_fkey" FOREIGN KEY (recipient_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."event_notifications" validate constraint "event_notifications_recipient_id_fkey";

alter table "public"."event_notifications" add constraint "event_notifications_update_id_fkey" FOREIGN KEY (update_id) REFERENCES public.event_updates(id) ON DELETE CASCADE not valid;

alter table "public"."event_notifications" validate constraint "event_notifications_update_id_fkey";

alter table "public"."event_participants" add constraint "event_participants_event_id_fkey" FOREIGN KEY (event_id) REFERENCES public.events(id) ON DELETE CASCADE not valid;

alter table "public"."event_participants" validate constraint "event_participants_event_id_fkey";

alter table "public"."event_participants" add constraint "event_participants_event_id_user_id_student_id_key" UNIQUE using index "event_participants_event_id_user_id_student_id_key";

alter table "public"."event_participants" add constraint "event_participants_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."event_participants" validate constraint "event_participants_student_id_fkey";

alter table "public"."event_participants" add constraint "event_participants_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."event_participants" validate constraint "event_participants_user_id_fkey";

alter table "public"."event_reactions" add constraint "event_reactions_event_id_fkey" FOREIGN KEY (event_id) REFERENCES public.events(id) ON DELETE CASCADE not valid;

alter table "public"."event_reactions" validate constraint "event_reactions_event_id_fkey";

alter table "public"."event_reactions" add constraint "event_reactions_parent_reaction_id_fkey" FOREIGN KEY (parent_reaction_id) REFERENCES public.event_reactions(id) ON DELETE CASCADE not valid;

alter table "public"."event_reactions" validate constraint "event_reactions_parent_reaction_id_fkey";

alter table "public"."event_reactions" add constraint "event_reactions_update_id_fkey" FOREIGN KEY (update_id) REFERENCES public.event_updates(id) ON DELETE CASCADE not valid;

alter table "public"."event_reactions" validate constraint "event_reactions_update_id_fkey";

alter table "public"."event_reactions" add constraint "event_reactions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."event_reactions" validate constraint "event_reactions_user_id_fkey";

alter table "public"."event_rsvps" add constraint "event_rsvps_event_id_fkey" FOREIGN KEY (event_id) REFERENCES public.school_events(id) ON DELETE CASCADE not valid;

alter table "public"."event_rsvps" validate constraint "event_rsvps_event_id_fkey";

alter table "public"."event_rsvps" add constraint "event_rsvps_event_id_user_id_key" UNIQUE using index "event_rsvps_event_id_user_id_key";

alter table "public"."event_rsvps" add constraint "event_rsvps_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."event_rsvps" validate constraint "event_rsvps_preschool_id_fkey";

alter table "public"."event_rsvps" add constraint "event_rsvps_status_check" CHECK ((status = ANY (ARRAY['attending'::text, 'not_attending'::text, 'maybe'::text, 'pending'::text]))) not valid;

alter table "public"."event_rsvps" validate constraint "event_rsvps_status_check";

alter table "public"."event_rsvps" add constraint "event_rsvps_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."event_rsvps" validate constraint "event_rsvps_user_id_fkey";

alter table "public"."event_updates" add constraint "event_updates_author_id_fkey" FOREIGN KEY (author_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."event_updates" validate constraint "event_updates_author_id_fkey";

alter table "public"."event_updates" add constraint "event_updates_event_id_fkey" FOREIGN KEY (event_id) REFERENCES public.events(id) ON DELETE CASCADE not valid;

alter table "public"."event_updates" validate constraint "event_updates_event_id_fkey";

alter table "public"."events" add constraint "events_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."events" validate constraint "events_created_by_fkey";

alter table "public"."events" add constraint "events_event_type_check" CHECK ((event_type = ANY (ARRAY['field_trip'::text, 'meeting'::text, 'performance'::text, 'holiday'::text, 'other'::text]))) not valid;

alter table "public"."events" validate constraint "events_event_type_check";

alter table "public"."events" add constraint "events_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."events" validate constraint "events_preschool_id_fkey";

alter table "public"."events" add constraint "events_status_check" CHECK (((status IS NULL) OR ((status)::text = ANY ((ARRAY['pending'::character varying, 'proposed'::character varying, 'draft'::character varying, 'scheduled'::character varying, 'ongoing'::character varying, 'completed'::character varying, 'cancelled'::character varying, 'published'::character varying, 'unpublished'::character varying])::text[])))) not valid;

alter table "public"."events" validate constraint "events_status_check";

alter table "public"."exam_assignments" add constraint "exam_assignments_exam_generation_id_fkey" FOREIGN KEY (exam_generation_id) REFERENCES public.exam_generations(id) ON DELETE CASCADE not valid;

alter table "public"."exam_assignments" validate constraint "exam_assignments_exam_generation_id_fkey";

alter table "public"."exam_assignments" add constraint "exam_assignments_status_check" CHECK ((status = ANY (ARRAY['active'::text, 'closed'::text, 'draft'::text]))) not valid;

alter table "public"."exam_assignments" validate constraint "exam_assignments_status_check";

alter table "public"."exam_assignments" add constraint "exam_assignments_teacher_id_fkey" FOREIGN KEY (teacher_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."exam_assignments" validate constraint "exam_assignments_teacher_id_fkey";

alter table "public"."exam_attempts" add constraint "exam_attempts_exam_paper_id_fkey" FOREIGN KEY (exam_paper_id) REFERENCES public.exam_papers(id) ON DELETE CASCADE not valid;

alter table "public"."exam_attempts" validate constraint "exam_attempts_exam_paper_id_fkey";

alter table "public"."exam_attempts" add constraint "exam_attempts_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."exam_attempts" validate constraint "exam_attempts_student_id_fkey";

alter table "public"."exam_attempts" add constraint "exam_attempts_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."exam_attempts" validate constraint "exam_attempts_user_id_fkey";

alter table "public"."exam_generations" add constraint "exam_generations_exam_type_check" CHECK ((exam_type = ANY (ARRAY['practice_test'::text, 'revision_notes'::text, 'study_guide'::text, 'flashcards'::text]))) not valid;

alter table "public"."exam_generations" validate constraint "exam_generations_exam_type_check";

alter table "public"."exam_generations" add constraint "exam_generations_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'generating'::text, 'completed'::text, 'failed'::text]))) not valid;

alter table "public"."exam_generations" validate constraint "exam_generations_status_check";

alter table "public"."exam_generations" add constraint "exam_generations_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."exam_generations" validate constraint "exam_generations_user_id_fkey";

alter table "public"."exam_papers" add constraint "exam_papers_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."exam_papers" validate constraint "exam_papers_created_by_fkey";

alter table "public"."exam_submissions" add constraint "exam_submissions_assignment_id_fkey" FOREIGN KEY (assignment_id) REFERENCES public.exam_assignments(id) ON DELETE CASCADE not valid;

alter table "public"."exam_submissions" validate constraint "exam_submissions_assignment_id_fkey";

alter table "public"."exam_submissions" add constraint "exam_submissions_assignment_id_student_id_attempt_number_key" UNIQUE using index "exam_submissions_assignment_id_student_id_attempt_number_key";

alter table "public"."exam_submissions" add constraint "exam_submissions_graded_by_fkey" FOREIGN KEY (graded_by) REFERENCES public.profiles(id) not valid;

alter table "public"."exam_submissions" validate constraint "exam_submissions_graded_by_fkey";

alter table "public"."exam_submissions" add constraint "exam_submissions_status_check" CHECK ((status = ANY (ARRAY['in_progress'::text, 'submitted'::text, 'graded'::text]))) not valid;

alter table "public"."exam_submissions" validate constraint "exam_submissions_status_check";

alter table "public"."exam_submissions" add constraint "exam_submissions_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."exam_submissions" validate constraint "exam_submissions_student_id_fkey";

alter table "public"."exam_user_progress" add constraint "exam_user_progress_check" CHECK (((past_paper_id IS NOT NULL) OR (exam_generation_id IS NOT NULL))) not valid;

alter table "public"."exam_user_progress" validate constraint "exam_user_progress_check";

alter table "public"."exam_user_progress" add constraint "exam_user_progress_exam_generation_id_fkey" FOREIGN KEY (exam_generation_id) REFERENCES public.exam_generations(id) ON DELETE SET NULL not valid;

alter table "public"."exam_user_progress" validate constraint "exam_user_progress_exam_generation_id_fkey";

alter table "public"."exam_user_progress" add constraint "exam_user_progress_past_paper_id_fkey" FOREIGN KEY (past_paper_id) REFERENCES public.past_papers(id) ON DELETE SET NULL not valid;

alter table "public"."exam_user_progress" validate constraint "exam_user_progress_past_paper_id_fkey";

alter table "public"."exam_user_progress" add constraint "exam_user_progress_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."exam_user_progress" validate constraint "exam_user_progress_user_id_fkey";

alter table "public"."expense_categories" add constraint "expense_categories_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."expense_categories" validate constraint "expense_categories_created_by_fkey";

alter table "public"."expense_categories" add constraint "expense_categories_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."expense_categories" validate constraint "expense_categories_preschool_id_fkey";

alter table "public"."expense_categories" add constraint "expense_categories_preschool_id_name_key" UNIQUE using index "expense_categories_preschool_id_name_key";

alter table "public"."feature_flags" add constraint "feature_flags_feature_key_key" UNIQUE using index "feature_flags_feature_key_key";

alter table "public"."fee_payments" add constraint "fee_payments_amount_cents_check" CHECK ((amount_cents > 0)) not valid;

alter table "public"."fee_payments" validate constraint "fee_payments_amount_cents_check";

alter table "public"."fee_payments" add constraint "fee_payments_payfast_payment_id_key" UNIQUE using index "fee_payments_payfast_payment_id_key";

alter table "public"."fee_payments" add constraint "fee_payments_payment_method_check" CHECK ((payment_method = ANY (ARRAY['payfast'::text, 'cash'::text, 'eft'::text, 'card'::text, 'other'::text]))) not valid;

alter table "public"."fee_payments" validate constraint "fee_payments_payment_method_check";

alter table "public"."fee_payments" add constraint "fee_payments_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."fee_payments" validate constraint "fee_payments_preschool_id_fkey";

alter table "public"."fee_payments" add constraint "fee_payments_processed_by_fkey" FOREIGN KEY (processed_by) REFERENCES public.profiles(id) not valid;

alter table "public"."fee_payments" validate constraint "fee_payments_processed_by_fkey";

alter table "public"."fee_payments" add constraint "fee_payments_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'completed'::text, 'failed'::text, 'refunded'::text]))) not valid;

alter table "public"."fee_payments" validate constraint "fee_payments_status_check";

alter table "public"."fee_payments" add constraint "fee_payments_student_fee_assignment_id_fkey" FOREIGN KEY (student_fee_assignment_id) REFERENCES public.student_fee_assignments(id) ON DELETE CASCADE not valid;

alter table "public"."fee_payments" validate constraint "fee_payments_student_fee_assignment_id_fkey";

alter table "public"."fee_payments" add constraint "fee_payments_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."fee_payments" validate constraint "fee_payments_student_id_fkey";

alter table "public"."fee_structures" add constraint "fee_structures_amount_check" CHECK ((amount >= (0)::numeric)) not valid;

alter table "public"."fee_structures" validate constraint "fee_structures_amount_check";

alter table "public"."fee_structures" add constraint "fee_structures_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."fee_structures" validate constraint "fee_structures_created_by_fkey";

alter table "public"."fee_structures" add constraint "fee_structures_frequency_check" CHECK ((frequency = ANY (ARRAY['one_time'::text, 'monthly'::text, 'quarterly'::text, 'yearly'::text]))) not valid;

alter table "public"."fee_structures" validate constraint "fee_structures_frequency_check";

alter table "public"."fee_structures" add constraint "fee_structures_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."fee_structures" validate constraint "fee_structures_preschool_id_fkey";

alter table "public"."fee_structures" add constraint "fee_structures_preschool_id_name_key" UNIQUE using index "fee_structures_preschool_id_name_key";

alter table "public"."financial_transactions" add constraint "financial_transactions_amount_check" CHECK ((amount > (0)::numeric)) not valid;

alter table "public"."financial_transactions" validate constraint "financial_transactions_amount_check";

alter table "public"."financial_transactions" add constraint "financial_transactions_approved_by_fkey" FOREIGN KEY (approved_by) REFERENCES auth.users(id) not valid;

alter table "public"."financial_transactions" validate constraint "financial_transactions_approved_by_fkey";

alter table "public"."financial_transactions" add constraint "financial_transactions_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."financial_transactions" validate constraint "financial_transactions_created_by_fkey";

alter table "public"."financial_transactions" add constraint "financial_transactions_payment_method_check" CHECK ((payment_method = ANY (ARRAY['cash'::text, 'bank_transfer'::text, 'eft'::text, 'card'::text, 'mobile_payment'::text, 'cheque'::text, 'other'::text]))) not valid;

alter table "public"."financial_transactions" validate constraint "financial_transactions_payment_method_check";

alter table "public"."financial_transactions" add constraint "financial_transactions_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."financial_transactions" validate constraint "financial_transactions_preschool_id_fkey";

alter table "public"."financial_transactions" add constraint "financial_transactions_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'completed'::text, 'failed'::text, 'cancelled'::text]))) not valid;

alter table "public"."financial_transactions" validate constraint "financial_transactions_status_check";

alter table "public"."financial_transactions" add constraint "financial_transactions_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."financial_transactions" validate constraint "financial_transactions_student_id_fkey";

alter table "public"."financial_transactions" add constraint "financial_transactions_type_check" CHECK ((type = ANY (ARRAY['fee_payment'::text, 'expense'::text, 'refund'::text, 'adjustment'::text]))) not valid;

alter table "public"."financial_transactions" validate constraint "financial_transactions_type_check";

alter table "public"."financial_transactions" add constraint "fk_financial_transactions_expense_category" FOREIGN KEY (expense_category_id) REFERENCES public.expense_categories(id) not valid;

alter table "public"."financial_transactions" validate constraint "fk_financial_transactions_expense_category";

alter table "public"."gradebook_entries" add constraint "gradebook_entries_course_id_fkey" FOREIGN KEY (course_id) REFERENCES public.courses(id) ON DELETE CASCADE not valid;

alter table "public"."gradebook_entries" validate constraint "gradebook_entries_course_id_fkey";

alter table "public"."gradebook_entries" add constraint "gradebook_entries_course_id_student_id_key" UNIQUE using index "gradebook_entries_course_id_student_id_key";

alter table "public"."gradebook_entries" add constraint "gradebook_entries_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."gradebook_entries" validate constraint "gradebook_entries_student_id_fkey";

alter table "public"."gradebook_entries" add constraint "gradebook_entries_total_points_earned_check" CHECK ((total_points_earned >= (0)::numeric)) not valid;

alter table "public"."gradebook_entries" validate constraint "gradebook_entries_total_points_earned_check";

alter table "public"."gradebook_entries" add constraint "gradebook_entries_total_points_possible_check" CHECK ((total_points_possible >= (0)::numeric)) not valid;

alter table "public"."gradebook_entries" validate constraint "gradebook_entries_total_points_possible_check";

alter table "public"."grades" add constraint "grades_graded_by_fkey" FOREIGN KEY (graded_by) REFERENCES public.profiles(id) ON DELETE RESTRICT not valid;

alter table "public"."grades" validate constraint "grades_graded_by_fkey";

alter table "public"."grades" add constraint "grades_letter_grade_check" CHECK ((letter_grade ~ '^[A-F][+-]?$|^Pass$|^Fail$|^Incomplete$'::text)) not valid;

alter table "public"."grades" validate constraint "grades_letter_grade_check";

alter table "public"."grades" add constraint "grades_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) not valid;

alter table "public"."grades" validate constraint "grades_organization_id_fkey";

alter table "public"."grades" add constraint "grades_points_check" CHECK ((points_earned <= points_possible)) not valid;

alter table "public"."grades" validate constraint "grades_points_check";

alter table "public"."grades" add constraint "grades_points_earned_check" CHECK ((points_earned >= (0)::numeric)) not valid;

alter table "public"."grades" validate constraint "grades_points_earned_check";

alter table "public"."grades" add constraint "grades_points_possible_check" CHECK ((points_possible > (0)::numeric)) not valid;

alter table "public"."grades" validate constraint "grades_points_possible_check";

alter table "public"."grades" add constraint "grades_submission_id_fkey" FOREIGN KEY (submission_id) REFERENCES public.submissions(id) ON DELETE CASCADE not valid;

alter table "public"."grades" validate constraint "grades_submission_id_fkey";

alter table "public"."grades" add constraint "grades_submission_id_key" UNIQUE using index "grades_submission_id_key";

alter table "public"."group_invitations" add constraint "group_invitations_group_id_fkey" FOREIGN KEY (group_id) REFERENCES public.principal_groups(id) ON DELETE CASCADE not valid;

alter table "public"."group_invitations" validate constraint "group_invitations_group_id_fkey";

alter table "public"."group_invitations" add constraint "group_invitations_group_id_invitee_id_key" UNIQUE using index "group_invitations_group_id_invitee_id_key";

alter table "public"."group_invitations" add constraint "group_invitations_invitee_id_fkey" FOREIGN KEY (invitee_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."group_invitations" validate constraint "group_invitations_invitee_id_fkey";

alter table "public"."group_invitations" add constraint "group_invitations_inviter_id_fkey" FOREIGN KEY (inviter_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."group_invitations" validate constraint "group_invitations_inviter_id_fkey";

alter table "public"."group_members" add constraint "group_members_group_id_fkey" FOREIGN KEY (group_id) REFERENCES public.principal_groups(id) ON DELETE CASCADE not valid;

alter table "public"."group_members" validate constraint "group_members_group_id_fkey";

alter table "public"."group_members" add constraint "group_members_group_id_user_id_key" UNIQUE using index "group_members_group_id_user_id_key";

alter table "public"."group_members" add constraint "group_members_invited_by_fkey" FOREIGN KEY (invited_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."group_members" validate constraint "group_members_invited_by_fkey";

alter table "public"."group_members" add constraint "group_members_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."group_members" validate constraint "group_members_user_id_fkey";

alter table "public"."groups" add constraint "fk_groups_organization_id" FOREIGN KEY (organization_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."groups" validate constraint "fk_groups_organization_id";

alter table "public"."groups" add constraint "groups_course_id_fkey" FOREIGN KEY (course_id) REFERENCES public.courses(id) ON DELETE CASCADE not valid;

alter table "public"."groups" validate constraint "groups_course_id_fkey";

alter table "public"."groups" add constraint "groups_course_id_name_key" UNIQUE using index "groups_course_id_name_key";

alter table "public"."groups" add constraint "groups_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.profiles(id) ON DELETE RESTRICT not valid;

alter table "public"."groups" validate constraint "groups_created_by_fkey";

alter table "public"."groups" add constraint "groups_max_members_check" CHECK ((max_members > 0)) not valid;

alter table "public"."groups" validate constraint "groups_max_members_check";

alter table "public"."groups" add constraint "groups_name_check" CHECK (((length(name) >= 1) AND (length(name) <= 100))) not valid;

alter table "public"."groups" validate constraint "groups_name_check";

alter table "public"."guardian_requests" add constraint "guardian_requests_approved_by_fkey" FOREIGN KEY (approved_by) REFERENCES auth.users(id) not valid;

alter table "public"."guardian_requests" validate constraint "guardian_requests_approved_by_fkey";

alter table "public"."guardian_requests" add constraint "guardian_requests_parent_auth_id_fkey" FOREIGN KEY (parent_auth_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."guardian_requests" validate constraint "guardian_requests_parent_auth_id_fkey";

alter table "public"."guardian_requests" add constraint "guardian_requests_relationship_check" CHECK ((relationship = ANY (ARRAY['mother'::text, 'father'::text, 'guardian'::text, 'other'::text]))) not valid;

alter table "public"."guardian_requests" validate constraint "guardian_requests_relationship_check";

alter table "public"."guardian_requests" add constraint "guardian_requests_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."guardian_requests" validate constraint "guardian_requests_school_id_fkey";

alter table "public"."guardian_requests" add constraint "guardian_requests_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'approved'::text, 'rejected'::text, 'cancelled'::text]))) not valid;

alter table "public"."guardian_requests" validate constraint "guardian_requests_status_check";

alter table "public"."guardian_requests" add constraint "guardian_requests_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE SET NULL not valid;

alter table "public"."guardian_requests" validate constraint "guardian_requests_student_id_fkey";

alter table "public"."homework_activity_log" add constraint "homework_activity_log_actor_id_fkey" FOREIGN KEY (actor_id) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."homework_activity_log" validate constraint "homework_activity_log_actor_id_fkey";

alter table "public"."homework_activity_log" add constraint "homework_activity_log_assignment_id_fkey" FOREIGN KEY (assignment_id) REFERENCES public.homework_assignments(id) ON DELETE CASCADE not valid;

alter table "public"."homework_activity_log" validate constraint "homework_activity_log_assignment_id_fkey";

alter table "public"."homework_activity_log" add constraint "homework_activity_log_event_source_check" CHECK ((event_source = ANY (ARRAY['teacher'::text, 'parent'::text, 'system'::text, 'ai'::text]))) not valid;

alter table "public"."homework_activity_log" validate constraint "homework_activity_log_event_source_check";

alter table "public"."homework_activity_log" add constraint "homework_activity_log_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."homework_activity_log" validate constraint "homework_activity_log_preschool_id_fkey";

alter table "public"."homework_activity_log" add constraint "homework_activity_log_submission_id_fkey" FOREIGN KEY (submission_id) REFERENCES public.homework_submissions(id) ON DELETE CASCADE not valid;

alter table "public"."homework_activity_log" validate constraint "homework_activity_log_submission_id_fkey";

alter table "public"."homework_assignment_targets" add constraint "homework_assignment_targets_assignment_id_fkey" FOREIGN KEY (assignment_id) REFERENCES public.homework_assignments(id) ON DELETE CASCADE not valid;

alter table "public"."homework_assignment_targets" validate constraint "homework_assignment_targets_assignment_id_fkey";

alter table "public"."homework_assignment_targets" add constraint "homework_assignment_targets_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.classes(id) ON DELETE SET NULL not valid;

alter table "public"."homework_assignment_targets" validate constraint "homework_assignment_targets_class_id_fkey";

alter table "public"."homework_assignment_targets" add constraint "homework_assignment_targets_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."homework_assignment_targets" validate constraint "homework_assignment_targets_preschool_id_fkey";

alter table "public"."homework_assignment_targets" add constraint "homework_assignment_targets_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'notified'::text, 'viewed'::text, 'submitted'::text, 'overdue'::text, 'completed'::text]))) not valid;

alter table "public"."homework_assignment_targets" validate constraint "homework_assignment_targets_status_check";

alter table "public"."homework_assignment_targets" add constraint "homework_assignment_targets_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."homework_assignment_targets" validate constraint "homework_assignment_targets_student_id_fkey";

alter table "public"."homework_assignment_targets" add constraint "homework_assignment_targets_submission_id_fkey" FOREIGN KEY (submission_id) REFERENCES public.homework_submissions(id) ON DELETE SET NULL not valid;

alter table "public"."homework_assignment_targets" validate constraint "homework_assignment_targets_submission_id_fkey";

alter table "public"."homework_assignment_targets" add constraint "homework_assignment_targets_target_required" CHECK (((class_id IS NOT NULL) OR (student_id IS NOT NULL))) not valid;

alter table "public"."homework_assignment_targets" validate constraint "homework_assignment_targets_target_required";

alter table "public"."homework_assignments" add constraint "homework_assignments_ai_plan_id_fkey" FOREIGN KEY (ai_plan_id) REFERENCES public.ai_task_runs(id) ON DELETE SET NULL not valid;

alter table "public"."homework_assignments" validate constraint "homework_assignments_ai_plan_id_fkey";

alter table "public"."homework_assignments" add constraint "homework_assignments_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.classes(id) ON DELETE CASCADE not valid;

alter table "public"."homework_assignments" validate constraint "homework_assignments_class_id_fkey";

alter table "public"."homework_assignments" add constraint "homework_assignments_difficulty_level_check" CHECK (((difficulty_level IS NULL) OR ((difficulty_level >= 1) AND (difficulty_level <= 5)))) not valid;

alter table "public"."homework_assignments" validate constraint "homework_assignments_difficulty_level_check";

alter table "public"."homework_assignments" add constraint "homework_assignments_lesson_id_fkey" FOREIGN KEY (lesson_id) REFERENCES public.lessons(id) ON DELETE SET NULL not valid;

alter table "public"."homework_assignments" validate constraint "homework_assignments_lesson_id_fkey";

alter table "public"."homework_assignments" add constraint "homework_assignments_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."homework_assignments" validate constraint "homework_assignments_preschool_id_fkey";

alter table "public"."homework_assignments" add constraint "homework_assignments_status_check" CHECK ((status = ANY (ARRAY['draft'::text, 'active'::text, 'assigned'::text, 'closed'::text, 'archived'::text]))) not valid;

alter table "public"."homework_assignments" validate constraint "homework_assignments_status_check";

alter table "public"."homework_assignments" add constraint "homework_assignments_teacher_id_fkey" FOREIGN KEY (teacher_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."homework_assignments" validate constraint "homework_assignments_teacher_id_fkey";

alter table "public"."homework_notifications" add constraint "homework_notifications_assignment_id_fkey" FOREIGN KEY (assignment_id) REFERENCES public.homework_assignments(id) ON DELETE CASCADE not valid;

alter table "public"."homework_notifications" validate constraint "homework_notifications_assignment_id_fkey";

alter table "public"."homework_notifications" add constraint "homework_notifications_channel_check" CHECK ((channel = ANY (ARRAY['in_app'::text, 'email'::text, 'push'::text, 'whatsapp'::text]))) not valid;

alter table "public"."homework_notifications" validate constraint "homework_notifications_channel_check";

alter table "public"."homework_notifications" add constraint "homework_notifications_parent_id_fkey" FOREIGN KEY (parent_id) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."homework_notifications" validate constraint "homework_notifications_parent_id_fkey";

alter table "public"."homework_notifications" add constraint "homework_notifications_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."homework_notifications" validate constraint "homework_notifications_preschool_id_fkey";

alter table "public"."homework_notifications" add constraint "homework_notifications_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'sent'::text, 'failed'::text, 'skipped'::text]))) not valid;

alter table "public"."homework_notifications" validate constraint "homework_notifications_status_check";

alter table "public"."homework_notifications" add constraint "homework_notifications_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."homework_notifications" validate constraint "homework_notifications_student_id_fkey";

alter table "public"."homework_notifications" add constraint "homework_notifications_target_id_fkey" FOREIGN KEY (target_id) REFERENCES public.homework_assignment_targets(id) ON DELETE CASCADE not valid;

alter table "public"."homework_notifications" validate constraint "homework_notifications_target_id_fkey";

alter table "public"."homework_submissions" add constraint "homework_submissions_ai_grade_id_fkey" FOREIGN KEY (ai_grade_id) REFERENCES public.ai_task_runs(id) ON DELETE SET NULL not valid;

alter table "public"."homework_submissions" validate constraint "homework_submissions_ai_grade_id_fkey";

alter table "public"."homework_submissions" add constraint "homework_submissions_assignment_id_fkey" FOREIGN KEY (assignment_id) REFERENCES public.homework_assignments(id) ON DELETE CASCADE not valid;

alter table "public"."homework_submissions" validate constraint "homework_submissions_assignment_id_fkey";

alter table "public"."homework_submissions" add constraint "homework_submissions_assignment_id_student_id_key" UNIQUE using index "homework_submissions_assignment_id_student_id_key";

alter table "public"."homework_submissions" add constraint "homework_submissions_content_type_check" CHECK ((content_type = ANY (ARRAY['text'::text, 'audio'::text, 'image'::text, 'video'::text, 'pdf'::text, 'link'::text, 'mixed'::text]))) not valid;

alter table "public"."homework_submissions" validate constraint "homework_submissions_content_type_check";

alter table "public"."homework_submissions" add constraint "homework_submissions_graded_by_fkey" FOREIGN KEY (graded_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."homework_submissions" validate constraint "homework_submissions_graded_by_fkey";

alter table "public"."homework_submissions" add constraint "homework_submissions_homework_assignment_id_fkey" FOREIGN KEY (homework_assignment_id) REFERENCES public.homework_assignments(id) ON DELETE CASCADE not valid;

alter table "public"."homework_submissions" validate constraint "homework_submissions_homework_assignment_id_fkey";

alter table "public"."homework_submissions" add constraint "homework_submissions_homework_assignment_id_student_id_key" UNIQUE using index "homework_submissions_homework_assignment_id_student_id_key";

alter table "public"."homework_submissions" add constraint "homework_submissions_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."homework_submissions" validate constraint "homework_submissions_preschool_id_fkey";

alter table "public"."homework_submissions" add constraint "homework_submissions_status_check" CHECK ((status = ANY (ARRAY['draft'::text, 'submitted'::text, 'in_review'::text, 'returned'::text, 'graded'::text, 'published'::text]))) not valid;

alter table "public"."homework_submissions" validate constraint "homework_submissions_status_check";

alter table "public"."homework_submissions" add constraint "homework_submissions_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."homework_submissions" validate constraint "homework_submissions_student_id_fkey";

alter table "public"."homework_submissions" add constraint "homework_submissions_submission_type_check" CHECK ((submission_type = ANY (ARRAY['text'::text, 'photo'::text, 'video'::text, 'audio'::text, 'file'::text, 'drawing'::text]))) not valid;

alter table "public"."homework_submissions" validate constraint "homework_submissions_submission_type_check";

alter table "public"."homework_submissions" add constraint "homework_submissions_submitted_by_fkey" FOREIGN KEY (submitted_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."homework_submissions" validate constraint "homework_submissions_submitted_by_fkey";

alter table "public"."in_app_notifications" add constraint "in_app_notifications_type_check" CHECK ((type = ANY (ARRAY['info'::text, 'success'::text, 'warning'::text, 'error'::text, 'live-lesson'::text, 'scheduled-lesson'::text, 'homework'::text, 'grade'::text, 'announcement'::text, 'message'::text, 'attendance'::text, 'registration'::text, 'billing'::text, 'calendar'::text, 'birthday'::text, 'call'::text, 'system'::text]))) not valid;

alter table "public"."in_app_notifications" validate constraint "in_app_notifications_type_check";

alter table "public"."in_app_notifications" add constraint "in_app_notifications_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."in_app_notifications" validate constraint "in_app_notifications_user_id_fkey";

alter table "public"."independent_children" add constraint "independent_children_parent_id_fkey" FOREIGN KEY (parent_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."independent_children" validate constraint "independent_children_parent_id_fkey";

alter table "public"."independent_content_library" add constraint "independent_content_library_content_type_check" CHECK ((content_type = ANY (ARRAY['lesson'::text, 'activity'::text, 'worksheet'::text, 'video'::text]))) not valid;

alter table "public"."independent_content_library" validate constraint "independent_content_library_content_type_check";

alter table "public"."integration_audit_log" add constraint "integration_audit_log_integration_type_check" CHECK ((integration_type = ANY (ARRAY['google_calendar'::text, 'microsoft_teams'::text, 'twilio_sms'::text, 'stripe_payment'::text]))) not valid;

alter table "public"."integration_audit_log" validate constraint "integration_audit_log_integration_type_check";

alter table "public"."integration_audit_log" add constraint "integration_audit_log_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."integration_audit_log" validate constraint "integration_audit_log_preschool_id_fkey";

alter table "public"."integration_audit_log" add constraint "integration_audit_log_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."integration_audit_log" validate constraint "integration_audit_log_user_id_fkey";

alter table "public"."interactive_activities" add constraint "interactive_activities_activity_type_check" CHECK ((activity_type = ANY (ARRAY['matching'::text, 'coloring'::text, 'tracing'::text, 'counting'::text, 'sorting'::text, 'puzzle'::text, 'memory'::text, 'sequence'::text, 'drawing'::text, 'quiz'::text]))) not valid;

alter table "public"."interactive_activities" validate constraint "interactive_activities_activity_type_check";

alter table "public"."interactive_activities" add constraint "interactive_activities_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."interactive_activities" validate constraint "interactive_activities_created_by_fkey";

alter table "public"."interactive_activities" add constraint "interactive_activities_difficulty_level_check" CHECK (((difficulty_level >= 1) AND (difficulty_level <= 5))) not valid;

alter table "public"."interactive_activities" validate constraint "interactive_activities_difficulty_level_check";

alter table "public"."interactive_activities" add constraint "interactive_activities_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."interactive_activities" validate constraint "interactive_activities_preschool_id_fkey";

alter table "public"."interactive_activities" add constraint "interactive_activities_stem_category_check" CHECK ((stem_category = ANY (ARRAY['ai'::text, 'robotics'::text, 'computer_literacy'::text, 'none'::text]))) not valid;

alter table "public"."interactive_activities" validate constraint "interactive_activities_stem_category_check";

alter table "public"."interactive_activities" add constraint "interactive_activities_teacher_id_fkey" FOREIGN KEY (teacher_id) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."interactive_activities" validate constraint "interactive_activities_teacher_id_fkey";

alter table "public"."interview_schedules" add constraint "interview_schedules_application_id_fkey" FOREIGN KEY (application_id) REFERENCES public.job_applications(id) ON DELETE CASCADE not valid;

alter table "public"."interview_schedules" validate constraint "interview_schedules_application_id_fkey";

alter table "public"."interview_schedules" add constraint "interview_schedules_scheduled_by_fkey" FOREIGN KEY (scheduled_by) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."interview_schedules" validate constraint "interview_schedules_scheduled_by_fkey";

alter table "public"."interview_schedules" add constraint "interview_schedules_status_check" CHECK ((status = ANY (ARRAY['scheduled'::text, 'completed'::text, 'cancelled'::text, 'rescheduled'::text]))) not valid;

alter table "public"."interview_schedules" validate constraint "interview_schedules_status_check";

alter table "public"."invitation_codes" add constraint "invitation_codes_code_key" UNIQUE using index "invitation_codes_code_key";

alter table "public"."invitation_codes" add constraint "invitation_codes_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."invitation_codes" validate constraint "invitation_codes_created_by_fkey";

alter table "public"."invitation_codes" add constraint "invitation_codes_invited_by_fkey" FOREIGN KEY (invited_by) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."invitation_codes" validate constraint "invitation_codes_invited_by_fkey";

alter table "public"."invitation_codes" add constraint "invitation_codes_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."invitation_codes" validate constraint "invitation_codes_preschool_id_fkey";

alter table "public"."invitation_codes" add constraint "invitation_codes_role_check" CHECK ((role = ANY (ARRAY['teacher'::text, 'parent'::text]))) not valid;

alter table "public"."invitation_codes" validate constraint "invitation_codes_role_check";

alter table "public"."invitation_codes" add constraint "invitation_codes_used_by_fkey" FOREIGN KEY (used_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."invitation_codes" validate constraint "invitation_codes_used_by_fkey";

alter table "public"."invitations" add constraint "invitations_accepted_by_fkey" FOREIGN KEY (accepted_by) REFERENCES auth.users(id) not valid;

alter table "public"."invitations" validate constraint "invitations_accepted_by_fkey";

alter table "public"."invitations" add constraint "invitations_code_key" UNIQUE using index "invitations_code_key";

alter table "public"."invitations" add constraint "invitations_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."invitations" validate constraint "invitations_created_by_fkey";

alter table "public"."invitations" add constraint "invitations_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."invitations" validate constraint "invitations_organization_id_fkey";

alter table "public"."invitations" add constraint "invitations_role_check" CHECK ((role = ANY (ARRAY['parent'::text, 'teacher'::text]))) not valid;

alter table "public"."invitations" validate constraint "invitations_role_check";

alter table "public"."invitations" add constraint "invitations_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'accepted'::text, 'expired'::text, 'revoked'::text]))) not valid;

alter table "public"."invitations" validate constraint "invitations_status_check";

alter table "public"."invite_logs" add constraint "invite_logs_invitation_type_check" CHECK ((invitation_type = ANY (ARRAY['sms'::text, 'email'::text, 'whatsapp'::text]))) not valid;

alter table "public"."invite_logs" validate constraint "invite_logs_invitation_type_check";

alter table "public"."invite_logs" add constraint "invite_logs_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."invite_logs" validate constraint "invite_logs_preschool_id_fkey";

alter table "public"."invite_logs" add constraint "invite_logs_sender_id_fkey" FOREIGN KEY (sender_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."invite_logs" validate constraint "invite_logs_sender_id_fkey";

alter table "public"."invite_logs" add constraint "invite_logs_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'sent'::text, 'delivered'::text, 'failed'::text, 'clicked'::text]))) not valid;

alter table "public"."invite_logs" validate constraint "invite_logs_status_check";

alter table "public"."invoice_audit_log" add constraint "invoice_audit_log_invoice_id_fkey" FOREIGN KEY (invoice_id) REFERENCES public.invoices(id) ON DELETE CASCADE not valid;

alter table "public"."invoice_audit_log" validate constraint "invoice_audit_log_invoice_id_fkey";

alter table "public"."invoice_audit_log" add constraint "invoice_audit_log_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."invoice_audit_log" validate constraint "invoice_audit_log_user_id_fkey";

alter table "public"."invoice_items" add constraint "invoice_items_invoice_id_fkey" FOREIGN KEY (invoice_id) REFERENCES public.invoices(id) ON DELETE CASCADE not valid;

alter table "public"."invoice_items" validate constraint "invoice_items_invoice_id_fkey";

alter table "public"."invoice_items" add constraint "positive_quantity" CHECK ((quantity > (0)::numeric)) not valid;

alter table "public"."invoice_items" validate constraint "positive_quantity";

alter table "public"."invoice_items" add constraint "positive_unit_price" CHECK ((unit_price >= (0)::numeric)) not valid;

alter table "public"."invoice_items" validate constraint "positive_unit_price";

alter table "public"."invoice_items" add constraint "valid_tax_rate" CHECK (((tax_rate >= (0)::numeric) AND (tax_rate <= (100)::numeric))) not valid;

alter table "public"."invoice_items" validate constraint "valid_tax_rate";

alter table "public"."invoice_payments" add constraint "invoice_payments_invoice_id_fkey" FOREIGN KEY (invoice_id) REFERENCES public.invoices(id) ON DELETE CASCADE not valid;

alter table "public"."invoice_payments" validate constraint "invoice_payments_invoice_id_fkey";

alter table "public"."invoice_payments" add constraint "invoice_payments_payment_method_check" CHECK (((payment_method)::text = ANY ((ARRAY['cash'::character varying, 'card'::character varying, 'bank_transfer'::character varying, 'eft'::character varying, 'payfast'::character varying, 'other'::character varying])::text[]))) not valid;

alter table "public"."invoice_payments" validate constraint "invoice_payments_payment_method_check";

alter table "public"."invoice_payments" add constraint "invoice_payments_recorded_by_fkey" FOREIGN KEY (recorded_by) REFERENCES auth.users(id) not valid;

alter table "public"."invoice_payments" validate constraint "invoice_payments_recorded_by_fkey";

alter table "public"."invoice_payments" add constraint "invoice_payments_verified_by_fkey" FOREIGN KEY (verified_by) REFERENCES auth.users(id) not valid;

alter table "public"."invoice_payments" validate constraint "invoice_payments_verified_by_fkey";

alter table "public"."invoice_payments" add constraint "positive_payment_amount" CHECK ((amount > (0)::numeric)) not valid;

alter table "public"."invoice_payments" validate constraint "positive_payment_amount";

alter table "public"."invoice_templates" add constraint "invoice_templates_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."invoice_templates" validate constraint "invoice_templates_created_by_fkey";

alter table "public"."invoice_templates" add constraint "invoice_templates_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."invoice_templates" validate constraint "invoice_templates_preschool_id_fkey";

alter table "public"."invoices" add constraint "invoices_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."invoices" validate constraint "invoices_created_by_fkey";

alter table "public"."invoices" add constraint "invoices_payment_status_check" CHECK (((payment_status)::text = ANY ((ARRAY['unpaid'::character varying, 'partial'::character varying, 'paid'::character varying, 'refunded'::character varying])::text[]))) not valid;

alter table "public"."invoices" validate constraint "invoices_payment_status_check";

alter table "public"."invoices" add constraint "invoices_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."invoices" validate constraint "invoices_preschool_id_fkey";

alter table "public"."invoices" add constraint "invoices_status_check" CHECK (((status)::text = ANY ((ARRAY['draft'::character varying, 'sent'::character varying, 'viewed'::character varying, 'paid'::character varying, 'partial'::character varying, 'overdue'::character varying, 'cancelled'::character varying])::text[]))) not valid;

alter table "public"."invoices" validate constraint "invoices_status_check";

alter table "public"."invoices" add constraint "invoices_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE SET NULL not valid;

alter table "public"."invoices" validate constraint "invoices_student_id_fkey";

alter table "public"."invoices" add constraint "invoices_template_id_fkey" FOREIGN KEY (template_id) REFERENCES public.invoice_templates(id) ON DELETE SET NULL not valid;

alter table "public"."invoices" validate constraint "invoices_template_id_fkey";

alter table "public"."invoices" add constraint "positive_amounts" CHECK (((subtotal >= (0)::numeric) AND (tax_amount >= (0)::numeric) AND (discount_amount >= (0)::numeric) AND (total_amount >= (0)::numeric) AND (paid_amount >= (0)::numeric))) not valid;

alter table "public"."invoices" validate constraint "positive_amounts";

alter table "public"."invoices" add constraint "unique_invoice_number_per_school" UNIQUE using index "unique_invoice_number_per_school";

alter table "public"."invoices" add constraint "valid_due_date" CHECK ((due_date >= issue_date)) not valid;

alter table "public"."invoices" validate constraint "valid_due_date";

alter table "public"."invoices" add constraint "valid_paid_amount" CHECK ((paid_amount <= total_amount)) not valid;

alter table "public"."invoices" validate constraint "valid_paid_amount";

alter table "public"."job_alerts" add constraint "job_alerts_candidate_profile_id_fkey" FOREIGN KEY (candidate_profile_id) REFERENCES public.candidate_profiles(id) ON DELETE CASCADE not valid;

alter table "public"."job_alerts" validate constraint "job_alerts_candidate_profile_id_fkey";

alter table "public"."job_alerts" add constraint "unique_alert_per_candidate" UNIQUE using index "unique_alert_per_candidate";

alter table "public"."job_applications" add constraint "job_applications_candidate_profile_id_fkey" FOREIGN KEY (candidate_profile_id) REFERENCES public.candidate_profiles(id) ON DELETE CASCADE not valid;

alter table "public"."job_applications" validate constraint "job_applications_candidate_profile_id_fkey";

alter table "public"."job_applications" add constraint "job_applications_job_posting_id_fkey" FOREIGN KEY (job_posting_id) REFERENCES public.job_postings(id) ON DELETE CASCADE not valid;

alter table "public"."job_applications" validate constraint "job_applications_job_posting_id_fkey";

alter table "public"."job_applications" add constraint "job_applications_reviewed_by_fkey" FOREIGN KEY (reviewed_by) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."job_applications" validate constraint "job_applications_reviewed_by_fkey";

alter table "public"."job_applications" add constraint "job_applications_status_check" CHECK ((status = ANY (ARRAY['new'::text, 'under_review'::text, 'shortlisted'::text, 'interview_scheduled'::text, 'offered'::text, 'accepted'::text, 'rejected'::text]))) not valid;

alter table "public"."job_applications" validate constraint "job_applications_status_check";

alter table "public"."job_applications" add constraint "unique_application_per_job" UNIQUE using index "unique_application_per_job";

alter table "public"."job_distributions" add constraint "job_distributions_channel_check" CHECK ((channel = ANY (ARRAY['whatsapp'::text, 'email'::text, 'sms'::text, 'social_media'::text, 'public_board'::text]))) not valid;

alter table "public"."job_distributions" validate constraint "job_distributions_channel_check";

alter table "public"."job_distributions" add constraint "job_distributions_distributed_by_fkey" FOREIGN KEY (distributed_by) REFERENCES auth.users(id) not valid;

alter table "public"."job_distributions" validate constraint "job_distributions_distributed_by_fkey";

alter table "public"."job_distributions" add constraint "job_distributions_job_posting_id_fkey" FOREIGN KEY (job_posting_id) REFERENCES public.job_postings(id) ON DELETE CASCADE not valid;

alter table "public"."job_distributions" validate constraint "job_distributions_job_posting_id_fkey";

alter table "public"."job_postings" add constraint "job_postings_commute_radius_km_check" CHECK (((commute_radius_km >= 0) AND (commute_radius_km <= 200))) not valid;

alter table "public"."job_postings" validate constraint "job_postings_commute_radius_km_check";

alter table "public"."job_postings" add constraint "job_postings_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."job_postings" validate constraint "job_postings_created_by_fkey";

alter table "public"."job_postings" add constraint "job_postings_employment_type_check" CHECK ((employment_type = ANY (ARRAY['full-time'::text, 'part-time'::text, 'contract'::text, 'temporary'::text]))) not valid;

alter table "public"."job_postings" validate constraint "job_postings_employment_type_check";

alter table "public"."job_postings" add constraint "job_postings_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."job_postings" validate constraint "job_postings_preschool_id_fkey";

alter table "public"."job_postings" add constraint "job_postings_status_check" CHECK ((status = ANY (ARRAY['active'::text, 'closed'::text, 'draft'::text]))) not valid;

alter table "public"."job_postings" validate constraint "job_postings_status_check";

alter table "public"."job_postings" add constraint "valid_salary_range" CHECK (((salary_range_min IS NULL) OR (salary_range_max IS NULL) OR (salary_range_min <= salary_range_max))) not valid;

alter table "public"."job_postings" validate constraint "valid_salary_range";

alter table "public"."join_requests" add constraint "join_requests_invite_code_key" UNIQUE using index "join_requests_invite_code_key";

alter table "public"."join_requests" add constraint "join_requests_invited_by_fkey" FOREIGN KEY (invited_by) REFERENCES auth.users(id) not valid;

alter table "public"."join_requests" validate constraint "join_requests_invited_by_fkey";

alter table "public"."join_requests" add constraint "join_requests_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."join_requests" validate constraint "join_requests_organization_id_fkey";

alter table "public"."join_requests" add constraint "join_requests_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."join_requests" validate constraint "join_requests_preschool_id_fkey";

alter table "public"."join_requests" add constraint "join_requests_region_id_fkey" FOREIGN KEY (region_id) REFERENCES public.organization_regions(id) not valid;

alter table "public"."join_requests" validate constraint "join_requests_region_id_fkey";

alter table "public"."join_requests" add constraint "join_requests_requester_id_fkey" FOREIGN KEY (requester_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."join_requests" validate constraint "join_requests_requester_id_fkey";

alter table "public"."join_requests" add constraint "join_requests_reviewed_by_fkey" FOREIGN KEY (reviewed_by) REFERENCES auth.users(id) not valid;

alter table "public"."join_requests" validate constraint "join_requests_reviewed_by_fkey";

alter table "public"."join_requests" add constraint "join_requests_target_student_id_fkey" FOREIGN KEY (target_student_id) REFERENCES public.students(id) ON DELETE SET NULL not valid;

alter table "public"."join_requests" validate constraint "join_requests_target_student_id_fkey";

alter table "public"."join_requests" add constraint "valid_requester" CHECK (((requester_id IS NOT NULL) OR (requester_email IS NOT NULL) OR (requester_phone IS NOT NULL))) not valid;

alter table "public"."join_requests" validate constraint "valid_requester";

alter table "public"."join_requests" add constraint "valid_target" CHECK (((organization_id IS NOT NULL) OR (preschool_id IS NOT NULL))) not valid;

alter table "public"."join_requests" validate constraint "valid_target";

alter table "public"."learner_connections" add constraint "learner_connections_connection_id_fkey" FOREIGN KEY (connection_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."learner_connections" validate constraint "learner_connections_connection_id_fkey";

alter table "public"."learner_connections" add constraint "learner_connections_connection_type_check" CHECK ((connection_type = ANY (ARRAY['peer'::text, 'instructor'::text]))) not valid;

alter table "public"."learner_connections" validate constraint "learner_connections_connection_type_check";

alter table "public"."learner_connections" add constraint "learner_connections_learner_id_connection_id_key" UNIQUE using index "learner_connections_learner_id_connection_id_key";

alter table "public"."learner_connections" add constraint "learner_connections_learner_id_fkey" FOREIGN KEY (learner_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."learner_connections" validate constraint "learner_connections_learner_id_fkey";

alter table "public"."learner_connections" add constraint "learner_connections_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'accepted'::text, 'blocked'::text]))) not valid;

alter table "public"."learner_connections" validate constraint "learner_connections_status_check";

alter table "public"."learner_connections" add constraint "no_self_connection" CHECK ((learner_id <> connection_id)) not valid;

alter table "public"."learner_connections" validate constraint "no_self_connection";

alter table "public"."learner_cvs" add constraint "learner_cvs_learner_id_fkey" FOREIGN KEY (learner_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."learner_cvs" validate constraint "learner_cvs_learner_id_fkey";

alter table "public"."learning_activities" add constraint "learning_activities_age_group_id_fkey" FOREIGN KEY (age_group_id) REFERENCES public.age_groups(id) not valid;

alter table "public"."learning_activities" validate constraint "learning_activities_age_group_id_fkey";

alter table "public"."lesson_activities" add constraint "lesson_activities_activity_type_check" CHECK ((activity_type = ANY (ARRAY['quiz'::text, 'video'::text, 'reading'::text, 'exercise'::text, 'game'::text, 'assignment'::text]))) not valid;

alter table "public"."lesson_activities" validate constraint "lesson_activities_activity_type_check";

alter table "public"."lesson_activities" add constraint "lesson_activities_lesson_id_fkey" FOREIGN KEY (lesson_id) REFERENCES public.lessons(id) ON DELETE CASCADE not valid;

alter table "public"."lesson_activities" validate constraint "lesson_activities_lesson_id_fkey";

alter table "public"."lesson_approvals" add constraint "lesson_approvals_lesson_id_fkey" FOREIGN KEY (lesson_id) REFERENCES public.lessons(id) ON DELETE CASCADE not valid;

alter table "public"."lesson_approvals" validate constraint "lesson_approvals_lesson_id_fkey";

alter table "public"."lesson_approvals" add constraint "lesson_approvals_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."lesson_approvals" validate constraint "lesson_approvals_preschool_id_fkey";

alter table "public"."lesson_approvals" add constraint "lesson_approvals_reviewed_by_fkey" FOREIGN KEY (reviewed_by) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."lesson_approvals" validate constraint "lesson_approvals_reviewed_by_fkey";

alter table "public"."lesson_approvals" add constraint "lesson_approvals_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'approved'::text, 'rejected'::text, 'needs_revision'::text]))) not valid;

alter table "public"."lesson_approvals" validate constraint "lesson_approvals_status_check";

alter table "public"."lesson_approvals" add constraint "lesson_approvals_submitted_by_fkey" FOREIGN KEY (submitted_by) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."lesson_approvals" validate constraint "lesson_approvals_submitted_by_fkey";

alter table "public"."lesson_assignments" add constraint "lesson_assignments_interactive_activity_id_fkey" FOREIGN KEY (interactive_activity_id) REFERENCES public.interactive_activities(id) ON DELETE SET NULL not valid;

alter table "public"."lesson_assignments" validate constraint "lesson_assignments_interactive_activity_id_fkey";

alter table "public"."lesson_assignments" add constraint "lesson_assignments_lesson_type_check" CHECK ((lesson_type = ANY (ARRAY['standard'::text, 'interactive'::text, 'ai_enhanced'::text, 'robotics'::text, 'computer_literacy'::text]))) not valid;

alter table "public"."lesson_assignments" validate constraint "lesson_assignments_lesson_type_check";

alter table "public"."lesson_assignments" add constraint "lesson_assignments_stem_category_check" CHECK ((stem_category = ANY (ARRAY['ai'::text, 'robotics'::text, 'computer_literacy'::text, 'none'::text]))) not valid;

alter table "public"."lesson_assignments" validate constraint "lesson_assignments_stem_category_check";

alter table "public"."lesson_progress" add constraint "lesson_progress_user_id_lesson_id_key" UNIQUE using index "lesson_progress_user_id_lesson_id_key";

alter table "public"."lessons" add constraint "lessons_age_group_check" CHECK ((age_group = ANY (ARRAY['3-4'::text, '4-5'::text, '5-6'::text, '3-6'::text]))) not valid;

alter table "public"."lessons" validate constraint "lessons_age_group_check";

alter table "public"."lessons" add constraint "lessons_category_id_fkey" FOREIGN KEY (category_id) REFERENCES public.lesson_categories(id) ON DELETE SET NULL not valid;

alter table "public"."lessons" validate constraint "lessons_category_id_fkey";

alter table "public"."lessons" add constraint "lessons_completion_count_check" CHECK ((completion_count >= 0)) not valid;

alter table "public"."lessons" validate constraint "lessons_completion_count_check";

alter table "public"."lessons" add constraint "lessons_difficulty_level_check" CHECK ((difficulty_level = ANY (ARRAY['beginner'::text, 'intermediate'::text, 'advanced'::text]))) not valid;

alter table "public"."lessons" validate constraint "lessons_difficulty_level_check";

alter table "public"."lessons" add constraint "lessons_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."lessons" validate constraint "lessons_preschool_id_fkey";

alter table "public"."lessons" add constraint "lessons_rating_check" CHECK (((rating >= (0)::numeric) AND (rating <= (5)::numeric))) not valid;

alter table "public"."lessons" validate constraint "lessons_rating_check";

alter table "public"."lessons" add constraint "lessons_status_check" CHECK ((status = ANY (ARRAY['draft'::text, 'active'::text, 'archived'::text, 'published'::text]))) not valid;

alter table "public"."lessons" validate constraint "lessons_status_check";

alter table "public"."lessons" add constraint "lessons_subject_check" CHECK ((subject = ANY (ARRAY['mathematics'::text, 'literacy'::text, 'science'::text, 'art'::text, 'music'::text, 'physical'::text, 'general'::text]))) not valid;

alter table "public"."lessons" validate constraint "lessons_subject_check";

alter table "public"."lessons" add constraint "lessons_teacher_id_fkey" FOREIGN KEY (teacher_id) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."lessons" validate constraint "lessons_teacher_id_fkey";

alter table "public"."marketing_campaigns" add constraint "marketing_campaigns_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."marketing_campaigns" validate constraint "marketing_campaigns_organization_id_fkey";

alter table "public"."marketing_campaigns" add constraint "marketing_campaigns_promo_code_key" UNIQUE using index "marketing_campaigns_promo_code_key";

alter table "public"."media_uploads" add constraint "media_uploads_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."media_uploads" validate constraint "media_uploads_preschool_id_fkey";

alter table "public"."media_uploads" add constraint "media_uploads_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."media_uploads" validate constraint "media_uploads_user_id_fkey";

alter table "public"."meeting_action_items" add constraint "meeting_action_items_assigned_to_fkey" FOREIGN KEY (assigned_to) REFERENCES auth.users(id) not valid;

alter table "public"."meeting_action_items" validate constraint "meeting_action_items_assigned_to_fkey";

alter table "public"."meeting_action_items" add constraint "meeting_action_items_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."meeting_action_items" validate constraint "meeting_action_items_created_by_fkey";

alter table "public"."meeting_action_items" add constraint "meeting_action_items_priority_check" CHECK ((priority = ANY (ARRAY['low'::text, 'medium'::text, 'high'::text, 'urgent'::text]))) not valid;

alter table "public"."meeting_action_items" validate constraint "meeting_action_items_priority_check";

alter table "public"."meeting_action_items" add constraint "meeting_action_items_session_id_fkey" FOREIGN KEY (session_id) REFERENCES public.meeting_sessions(id) ON DELETE CASCADE not valid;

alter table "public"."meeting_action_items" validate constraint "meeting_action_items_session_id_fkey";

alter table "public"."meeting_action_items" add constraint "meeting_action_items_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'in_progress'::text, 'completed'::text, 'cancelled'::text]))) not valid;

alter table "public"."meeting_action_items" validate constraint "meeting_action_items_status_check";

alter table "public"."meeting_participants" add constraint "meeting_participants_invitation_status_check" CHECK ((invitation_status = ANY (ARRAY['pending'::text, 'accepted'::text, 'declined'::text, 'attended'::text]))) not valid;

alter table "public"."meeting_participants" validate constraint "meeting_participants_invitation_status_check";

alter table "public"."meeting_participants" add constraint "meeting_participants_invited_by_fkey" FOREIGN KEY (invited_by) REFERENCES auth.users(id) not valid;

alter table "public"."meeting_participants" validate constraint "meeting_participants_invited_by_fkey";

alter table "public"."meeting_participants" add constraint "meeting_participants_role_check" CHECK ((role = ANY (ARRAY['host'::text, 'co_host'::text, 'presenter'::text, 'participant'::text, 'observer'::text]))) not valid;

alter table "public"."meeting_participants" validate constraint "meeting_participants_role_check";

alter table "public"."meeting_participants" add constraint "meeting_participants_session_id_fkey" FOREIGN KEY (session_id) REFERENCES public.meeting_sessions(id) ON DELETE CASCADE not valid;

alter table "public"."meeting_participants" validate constraint "meeting_participants_session_id_fkey";

alter table "public"."meeting_participants" add constraint "meeting_participants_session_id_user_id_key" UNIQUE using index "meeting_participants_session_id_user_id_key";

alter table "public"."meeting_participants" add constraint "meeting_participants_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."meeting_participants" validate constraint "meeting_participants_user_id_fkey";

alter table "public"."meeting_rooms" add constraint "meeting_rooms_access_type_check" CHECK ((access_type = ANY (ARRAY['public'::text, 'organization'::text, 'invited_only'::text]))) not valid;

alter table "public"."meeting_rooms" validate constraint "meeting_rooms_access_type_check";

alter table "public"."meeting_rooms" add constraint "meeting_rooms_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."meeting_rooms" validate constraint "meeting_rooms_created_by_fkey";

alter table "public"."meeting_rooms" add constraint "meeting_rooms_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."meeting_rooms" validate constraint "meeting_rooms_organization_id_fkey";

alter table "public"."meeting_rooms" add constraint "meeting_rooms_room_type_check" CHECK ((room_type = ANY (ARRAY['principal_hub'::text, 'teacher_collaboration'::text, 'parent_meeting'::text, 'student_conference'::text]))) not valid;

alter table "public"."meeting_rooms" validate constraint "meeting_rooms_room_type_check";

alter table "public"."meeting_sessions" add constraint "meeting_sessions_host_id_fkey" FOREIGN KEY (host_id) REFERENCES auth.users(id) not valid;

alter table "public"."meeting_sessions" validate constraint "meeting_sessions_host_id_fkey";

alter table "public"."meeting_sessions" add constraint "meeting_sessions_room_id_fkey" FOREIGN KEY (room_id) REFERENCES public.meeting_rooms(id) ON DELETE CASCADE not valid;

alter table "public"."meeting_sessions" validate constraint "meeting_sessions_room_id_fkey";

alter table "public"."meeting_sessions" add constraint "meeting_sessions_status_check" CHECK ((status = ANY (ARRAY['scheduled'::text, 'active'::text, 'ended'::text, 'cancelled'::text]))) not valid;

alter table "public"."meeting_sessions" validate constraint "meeting_sessions_status_check";

alter table "public"."meeting_shared_resources" add constraint "meeting_shared_resources_check" CHECK ((((resource_id IS NOT NULL) AND (file_url IS NULL)) OR ((resource_id IS NULL) AND (file_url IS NOT NULL)))) not valid;

alter table "public"."meeting_shared_resources" validate constraint "meeting_shared_resources_check";

alter table "public"."meeting_shared_resources" add constraint "meeting_shared_resources_resource_id_fkey" FOREIGN KEY (resource_id) REFERENCES public.resources(id) ON DELETE CASCADE not valid;

alter table "public"."meeting_shared_resources" validate constraint "meeting_shared_resources_resource_id_fkey";

alter table "public"."meeting_shared_resources" add constraint "meeting_shared_resources_session_id_fkey" FOREIGN KEY (session_id) REFERENCES public.meeting_sessions(id) ON DELETE CASCADE not valid;

alter table "public"."meeting_shared_resources" validate constraint "meeting_shared_resources_session_id_fkey";

alter table "public"."meeting_shared_resources" add constraint "meeting_shared_resources_shared_by_fkey" FOREIGN KEY (shared_by) REFERENCES auth.users(id) not valid;

alter table "public"."meeting_shared_resources" validate constraint "meeting_shared_resources_shared_by_fkey";

alter table "public"."member_events" add constraint "member_events_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."member_events" validate constraint "member_events_created_by_fkey";

alter table "public"."member_events" add constraint "member_events_event_type_check" CHECK (((event_type)::text = ANY ((ARRAY['meeting'::character varying, 'workshop'::character varying, 'training'::character varying, 'social'::character varying, 'fundraiser'::character varying, 'conference'::character varying, 'other'::character varying])::text[]))) not valid;

alter table "public"."member_events" validate constraint "member_events_event_type_check";

alter table "public"."member_events" add constraint "member_events_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."member_events" validate constraint "member_events_organization_id_fkey";

alter table "public"."member_events" add constraint "member_events_region_id_fkey" FOREIGN KEY (region_id) REFERENCES public.organization_regions(id) ON DELETE SET NULL not valid;

alter table "public"."member_events" validate constraint "member_events_region_id_fkey";

alter table "public"."member_events" add constraint "member_events_status_check" CHECK (((status)::text = ANY ((ARRAY['draft'::character varying, 'scheduled'::character varying, 'ongoing'::character varying, 'completed'::character varying, 'cancelled'::character varying, 'postponed'::character varying])::text[]))) not valid;

alter table "public"."member_events" validate constraint "member_events_status_check";

alter table "public"."member_fees" add constraint "member_fees_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."member_fees" validate constraint "member_fees_created_by_fkey";

alter table "public"."member_fees" add constraint "member_fees_fee_structure_id_fkey" FOREIGN KEY (fee_structure_id) REFERENCES public.membership_fee_structure(id) ON DELETE SET NULL not valid;

alter table "public"."member_fees" validate constraint "member_fees_fee_structure_id_fkey";

alter table "public"."member_fees" add constraint "member_fees_member_id_fkey" FOREIGN KEY (member_id) REFERENCES public.organization_members(id) ON DELETE CASCADE not valid;

alter table "public"."member_fees" validate constraint "member_fees_member_id_fkey";

alter table "public"."member_fees" add constraint "member_fees_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."member_fees" validate constraint "member_fees_organization_id_fkey";

alter table "public"."member_fees" add constraint "member_fees_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'partial'::text, 'paid'::text, 'overdue'::text, 'waived'::text, 'cancelled'::text, 'refunded'::text]))) not valid;

alter table "public"."member_fees" validate constraint "member_fees_status_check";

alter table "public"."member_fees" add constraint "member_fees_transaction_id_fkey" FOREIGN KEY (transaction_id) REFERENCES public.organization_transactions(id) ON DELETE SET NULL not valid;

alter table "public"."member_fees" validate constraint "member_fees_transaction_id_fkey";

alter table "public"."member_id_cards" add constraint "member_id_cards_member_id_fkey" FOREIGN KEY (member_id) REFERENCES public.organization_members(id) ON DELETE CASCADE not valid;

alter table "public"."member_id_cards" validate constraint "member_id_cards_member_id_fkey";

alter table "public"."member_id_cards" add constraint "member_id_cards_organization_id_card_number_key" UNIQUE using index "member_id_cards_organization_id_card_number_key";

alter table "public"."member_id_cards" add constraint "member_id_cards_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."member_id_cards" validate constraint "member_id_cards_organization_id_fkey";

alter table "public"."member_id_cards" add constraint "member_id_cards_status_check" CHECK (((status)::text = ANY ((ARRAY['active'::character varying, 'suspended'::character varying, 'revoked'::character varying, 'expired'::character varying, 'replacement_requested'::character varying])::text[]))) not valid;

alter table "public"."member_id_cards" validate constraint "member_id_cards_status_check";

alter table "public"."member_invoices" add constraint "member_invoices_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."member_invoices" validate constraint "member_invoices_created_by_fkey";

alter table "public"."member_invoices" add constraint "member_invoices_member_id_fkey" FOREIGN KEY (member_id) REFERENCES public.organization_members(id) ON DELETE CASCADE not valid;

alter table "public"."member_invoices" validate constraint "member_invoices_member_id_fkey";

alter table "public"."member_invoices" add constraint "member_invoices_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."member_invoices" validate constraint "member_invoices_organization_id_fkey";

alter table "public"."member_invoices" add constraint "member_invoices_organization_id_invoice_number_key" UNIQUE using index "member_invoices_organization_id_invoice_number_key";

alter table "public"."member_invoices" add constraint "member_invoices_status_check" CHECK (((status)::text = ANY ((ARRAY['draft'::character varying, 'sent'::character varying, 'paid'::character varying, 'partially_paid'::character varying, 'overdue'::character varying, 'cancelled'::character varying, 'refunded'::character varying])::text[]))) not valid;

alter table "public"."member_invoices" validate constraint "member_invoices_status_check";

alter table "public"."membership_fee_structure" add constraint "membership_fee_structure_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."membership_fee_structure" validate constraint "membership_fee_structure_created_by_fkey";

alter table "public"."membership_fee_structure" add constraint "membership_fee_structure_fee_type_check" CHECK ((fee_type = ANY (ARRAY['registration'::text, 'annual'::text, 'monthly'::text, 'programme'::text, 'event'::text, 'id_card'::text, 'replacement_card'::text]))) not valid;

alter table "public"."membership_fee_structure" validate constraint "membership_fee_structure_fee_type_check";

alter table "public"."membership_fee_structure" add constraint "membership_fee_structure_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."membership_fee_structure" validate constraint "membership_fee_structure_organization_id_fkey";

alter table "public"."membership_fee_structure" add constraint "unique_fee_code" UNIQUE using index "unique_fee_code";

alter table "public"."membership_pop_uploads" add constraint "membership_pop_uploads_member_fee_id_fkey" FOREIGN KEY (member_fee_id) REFERENCES public.member_fees(id) ON DELETE SET NULL not valid;

alter table "public"."membership_pop_uploads" validate constraint "membership_pop_uploads_member_fee_id_fkey";

alter table "public"."membership_pop_uploads" add constraint "membership_pop_uploads_member_id_fkey" FOREIGN KEY (member_id) REFERENCES public.organization_members(id) ON DELETE CASCADE not valid;

alter table "public"."membership_pop_uploads" validate constraint "membership_pop_uploads_member_id_fkey";

alter table "public"."membership_pop_uploads" add constraint "membership_pop_uploads_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."membership_pop_uploads" validate constraint "membership_pop_uploads_organization_id_fkey";

alter table "public"."membership_pop_uploads" add constraint "membership_pop_uploads_payment_method_check" CHECK ((payment_method = ANY (ARRAY['bank_transfer'::text, 'cash_deposit'::text, 'card'::text, 'payfast'::text, 'other'::text]))) not valid;

alter table "public"."membership_pop_uploads" validate constraint "membership_pop_uploads_payment_method_check";

alter table "public"."membership_pop_uploads" add constraint "membership_pop_uploads_reviewed_by_fkey" FOREIGN KEY (reviewed_by) REFERENCES auth.users(id) not valid;

alter table "public"."membership_pop_uploads" validate constraint "membership_pop_uploads_reviewed_by_fkey";

alter table "public"."membership_pop_uploads" add constraint "membership_pop_uploads_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'approved'::text, 'rejected'::text, 'requires_clarification'::text]))) not valid;

alter table "public"."membership_pop_uploads" validate constraint "membership_pop_uploads_status_check";

alter table "public"."membership_pop_uploads" add constraint "membership_pop_uploads_upload_type_check" CHECK ((upload_type = ANY (ARRAY['proof_of_payment'::text, 'bank_confirmation'::text, 'receipt'::text]))) not valid;

alter table "public"."membership_pop_uploads" validate constraint "membership_pop_uploads_upload_type_check";

alter table "public"."membership_pop_uploads" add constraint "membership_pop_uploads_uploaded_by_fkey" FOREIGN KEY (uploaded_by) REFERENCES auth.users(id) not valid;

alter table "public"."membership_pop_uploads" validate constraint "membership_pop_uploads_uploaded_by_fkey";

alter table "public"."message_drafts" add constraint "message_drafts_sender_id_fkey" FOREIGN KEY (sender_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."message_drafts" validate constraint "message_drafts_sender_id_fkey";

alter table "public"."message_participants" add constraint "message_participants_role_check" CHECK ((role = ANY (ARRAY['parent'::text, 'teacher'::text, 'principal'::text, 'admin'::text]))) not valid;

alter table "public"."message_participants" validate constraint "message_participants_role_check";

alter table "public"."message_participants" add constraint "message_participants_thread_id_fkey" FOREIGN KEY (thread_id) REFERENCES public.message_threads(id) ON DELETE CASCADE not valid;

alter table "public"."message_participants" validate constraint "message_participants_thread_id_fkey";

alter table "public"."message_participants" add constraint "message_participants_thread_id_user_id_key" UNIQUE using index "message_participants_thread_id_user_id_key";

alter table "public"."message_participants" add constraint "message_participants_thread_user_unique" UNIQUE using index "message_participants_thread_user_unique";

alter table "public"."message_participants" add constraint "message_participants_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."message_participants" validate constraint "message_participants_user_id_fkey";

alter table "public"."message_reactions" add constraint "message_reactions_message_id_fkey" FOREIGN KEY (message_id) REFERENCES public.messages(id) ON DELETE CASCADE not valid;

alter table "public"."message_reactions" validate constraint "message_reactions_message_id_fkey";

alter table "public"."message_reactions" add constraint "message_reactions_message_id_user_id_emoji_key" UNIQUE using index "message_reactions_message_id_user_id_emoji_key";

alter table "public"."message_reactions" add constraint "message_reactions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."message_reactions" validate constraint "message_reactions_user_id_fkey";

alter table "public"."message_recipients" add constraint "message_recipients_message_id_recipient_id_key" UNIQUE using index "message_recipients_message_id_recipient_id_key";

alter table "public"."message_recipients" add constraint "message_recipients_recipient_id_fkey" FOREIGN KEY (recipient_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."message_recipients" validate constraint "message_recipients_recipient_id_fkey";

alter table "public"."message_threads" add constraint "message_threads_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.classes(id) ON DELETE SET NULL not valid;

alter table "public"."message_threads" validate constraint "message_threads_class_id_fkey";

alter table "public"."message_threads" add constraint "message_threads_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."message_threads" validate constraint "message_threads_created_by_fkey";

alter table "public"."message_threads" add constraint "message_threads_group_type_check" CHECK ((group_type = ANY (ARRAY['class_group'::text, 'parent_group'::text, 'teacher_group'::text, 'announcement'::text, 'custom'::text]))) not valid;

alter table "public"."message_threads" validate constraint "message_threads_group_type_check";

alter table "public"."message_threads" add constraint "message_threads_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."message_threads" validate constraint "message_threads_preschool_id_fkey";

alter table "public"."message_threads" add constraint "message_threads_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE SET NULL not valid;

alter table "public"."message_threads" validate constraint "message_threads_student_id_fkey";

alter table "public"."message_threads" add constraint "message_threads_type_check" CHECK ((type = ANY (ARRAY['parent-teacher'::text, 'parent-principal'::text, 'general'::text]))) not valid;

alter table "public"."message_threads" validate constraint "message_threads_type_check";

alter table "public"."messages" add constraint "messages_content_type_check" CHECK ((content_type = ANY (ARRAY['text'::text, 'system'::text, 'voice'::text, 'image'::text]))) not valid;

alter table "public"."messages" validate constraint "messages_content_type_check";

alter table "public"."messages" add constraint "messages_forwarded_from_id_fkey" FOREIGN KEY (forwarded_from_id) REFERENCES public.messages(id) ON DELETE SET NULL not valid;

alter table "public"."messages" validate constraint "messages_forwarded_from_id_fkey";

alter table "public"."messages" add constraint "messages_reply_to_id_fkey" FOREIGN KEY (reply_to_id) REFERENCES public.messages(id) ON DELETE SET NULL not valid;

alter table "public"."messages" validate constraint "messages_reply_to_id_fkey";

alter table "public"."messages" add constraint "messages_sender_id_fkey" FOREIGN KEY (sender_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."messages" validate constraint "messages_sender_id_fkey";

alter table "public"."messages" add constraint "messages_thread_id_fkey" FOREIGN KEY (thread_id) REFERENCES public.message_threads(id) ON DELETE CASCADE not valid;

alter table "public"."messages" validate constraint "messages_thread_id_fkey";

alter table "public"."migration_logs" add constraint "migration_logs_version_key" UNIQUE using index "migration_logs_version_key";

alter table "public"."moderation_actions" add constraint "moderation_actions_action_check" CHECK (((action)::text = ANY ((ARRAY['approve'::character varying, 'reject'::character varying, 'flag'::character varying, 'escalate'::character varying, 'warn_author'::character varying, 'suspend_user'::character varying])::text[]))) not valid;

alter table "public"."moderation_actions" validate constraint "moderation_actions_action_check";

alter table "public"."moderation_actions" add constraint "moderation_actions_moderator_id_fkey" FOREIGN KEY (moderator_id) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."moderation_actions" validate constraint "moderation_actions_moderator_id_fkey";

alter table "public"."moderation_actions" add constraint "moderation_actions_queue_item_id_fkey" FOREIGN KEY (queue_item_id) REFERENCES public.moderation_queue(id) ON DELETE CASCADE not valid;

alter table "public"."moderation_actions" validate constraint "moderation_actions_queue_item_id_fkey";

alter table "public"."moderation_queue" add constraint "moderation_queue_author_id_fkey" FOREIGN KEY (author_id) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."moderation_queue" validate constraint "moderation_queue_author_id_fkey";

alter table "public"."moderation_queue" add constraint "moderation_queue_content_type_check" CHECK (((content_type)::text = ANY ((ARRAY['lesson'::character varying, 'homework'::character varying, 'message'::character varying, 'comment'::character varying, 'announcement'::character varying, 'activity'::character varying, 'assessment'::character varying])::text[]))) not valid;

alter table "public"."moderation_queue" validate constraint "moderation_queue_content_type_check";

alter table "public"."moderation_queue" add constraint "moderation_queue_priority_check" CHECK (((priority >= 1) AND (priority <= 5))) not valid;

alter table "public"."moderation_queue" validate constraint "moderation_queue_priority_check";

alter table "public"."moderation_queue" add constraint "moderation_queue_reviewed_by_fkey" FOREIGN KEY (reviewed_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."moderation_queue" validate constraint "moderation_queue_reviewed_by_fkey";

alter table "public"."moderation_queue" add constraint "moderation_queue_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.preschools(id) ON DELETE SET NULL not valid;

alter table "public"."moderation_queue" validate constraint "moderation_queue_school_id_fkey";

alter table "public"."moderation_queue" add constraint "moderation_queue_severity_check" CHECK (((severity)::text = ANY ((ARRAY['low'::character varying, 'medium'::character varying, 'high'::character varying, 'critical'::character varying])::text[]))) not valid;

alter table "public"."moderation_queue" validate constraint "moderation_queue_severity_check";

alter table "public"."moderation_queue" add constraint "moderation_queue_status_check" CHECK (((status)::text = ANY ((ARRAY['pending'::character varying, 'reviewing'::character varying, 'approved'::character varying, 'rejected'::character varying, 'escalated'::character varying])::text[]))) not valid;

alter table "public"."moderation_queue" validate constraint "moderation_queue_status_check";

alter table "public"."newsletter_recipients" add constraint "newsletter_recipients_newsletter_id_fkey" FOREIGN KEY (newsletter_id) REFERENCES public.newsletters(id) ON DELETE CASCADE not valid;

alter table "public"."newsletter_recipients" validate constraint "newsletter_recipients_newsletter_id_fkey";

alter table "public"."newsletter_recipients" add constraint "newsletter_recipients_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'sent'::text, 'failed'::text, 'bounced'::text]))) not valid;

alter table "public"."newsletter_recipients" validate constraint "newsletter_recipients_status_check";

alter table "public"."newsletter_recipients" add constraint "newsletter_recipients_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) not valid;

alter table "public"."newsletter_recipients" validate constraint "newsletter_recipients_user_id_fkey";

alter table "public"."newsletters" add constraint "newsletters_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) not valid;

alter table "public"."newsletters" validate constraint "newsletters_created_by_fkey";

alter table "public"."newsletters" add constraint "newsletters_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."newsletters" validate constraint "newsletters_preschool_id_fkey";

alter table "public"."newsletters" add constraint "newsletters_status_check" CHECK ((status = ANY (ARRAY['draft'::text, 'scheduled'::text, 'sending'::text, 'sent'::text, 'failed'::text]))) not valid;

alter table "public"."newsletters" validate constraint "newsletters_status_check";

alter table "public"."notification_deliveries" add constraint "channel_recipient_match" CHECK (
CASE channel
    WHEN 'email'::public.delivery_method_enum THEN (recipient_email IS NOT NULL)
    WHEN 'sms'::public.delivery_method_enum THEN (recipient_phone IS NOT NULL)
    WHEN 'push_notification'::public.delivery_method_enum THEN (recipient_device_token IS NOT NULL)
    ELSE true
END) not valid;

alter table "public"."notification_deliveries" validate constraint "channel_recipient_match";

alter table "public"."notification_deliveries" add constraint "notification_deliveries_notification_id_fkey" FOREIGN KEY (notification_id) REFERENCES public.superadmin_notifications(id) ON DELETE CASCADE not valid;

alter table "public"."notification_deliveries" validate constraint "notification_deliveries_notification_id_fkey";

alter table "public"."notification_deliveries" add constraint "notification_deliveries_provider_id_fkey" FOREIGN KEY (provider_id) REFERENCES public.delivery_providers(id) ON DELETE SET NULL not valid;

alter table "public"."notification_deliveries" validate constraint "notification_deliveries_provider_id_fkey";

alter table "public"."notification_deliveries" add constraint "notification_deliveries_recipient_id_fkey" FOREIGN KEY (recipient_id) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."notification_deliveries" validate constraint "notification_deliveries_recipient_id_fkey";

alter table "public"."notification_deliveries" add constraint "notification_deliveries_template_id_fkey" FOREIGN KEY (template_id) REFERENCES public.notification_templates(id) ON DELETE SET NULL not valid;

alter table "public"."notification_deliveries" validate constraint "notification_deliveries_template_id_fkey";

alter table "public"."notification_deliveries" add constraint "valid_costs" CHECK ((((estimated_cost IS NULL) OR (estimated_cost >= (0)::numeric)) AND ((actual_cost IS NULL) OR (actual_cost >= (0)::numeric)))) not valid;

alter table "public"."notification_deliveries" validate constraint "valid_costs";

alter table "public"."notification_deliveries" add constraint "valid_priority" CHECK ((priority >= 0)) not valid;

alter table "public"."notification_deliveries" validate constraint "valid_priority";

alter table "public"."notification_deliveries" add constraint "valid_retry_attempts" CHECK (((delivery_attempts >= 0) AND (max_retry_attempts >= 0) AND (delivery_attempts <= (max_retry_attempts + 5)))) not valid;

alter table "public"."notification_deliveries" validate constraint "valid_retry_attempts";

alter table "public"."notification_deliveries" add constraint "valid_timing" CHECK (((send_at IS NOT NULL) AND ((expires_at IS NULL) OR (expires_at > send_at)))) not valid;

alter table "public"."notification_deliveries" validate constraint "valid_timing";

alter table "public"."notification_templates" add constraint "email_subject_required" CHECK (((category <> 'email'::public.template_category_enum) OR (subject_template IS NOT NULL))) not valid;

alter table "public"."notification_templates" validate constraint "email_subject_required";

alter table "public"."notification_templates" add constraint "notification_templates_approved_by_fkey" FOREIGN KEY (approved_by) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."notification_templates" validate constraint "notification_templates_approved_by_fkey";

alter table "public"."notification_templates" add constraint "notification_templates_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."notification_templates" validate constraint "notification_templates_created_by_fkey";

alter table "public"."notification_templates" add constraint "notification_templates_template_key_key" UNIQUE using index "notification_templates_template_key_key";

alter table "public"."notification_templates" add constraint "notification_templates_updated_by_fkey" FOREIGN KEY (updated_by) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."notification_templates" validate constraint "notification_templates_updated_by_fkey";

alter table "public"."notification_templates" add constraint "valid_template_key" CHECK ((template_key ~ '^[a-z][a-z0-9_]*$'::text)) not valid;

alter table "public"."notification_templates" validate constraint "valid_template_key";

alter table "public"."notification_templates" add constraint "valid_version" CHECK ((version > 0)) not valid;

alter table "public"."notification_templates" validate constraint "valid_version";

alter table "public"."notifications" add constraint "notifications_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."notifications" validate constraint "notifications_preschool_id_fkey";

alter table "public"."oauth_tokens" add constraint "oauth_tokens_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."oauth_tokens" validate constraint "oauth_tokens_preschool_id_fkey";

alter table "public"."oauth_tokens" add constraint "oauth_tokens_provider_check" CHECK ((provider = ANY (ARRAY['google'::text, 'microsoft'::text, 'stripe'::text]))) not valid;

alter table "public"."oauth_tokens" validate constraint "oauth_tokens_provider_check";

alter table "public"."oauth_tokens" add constraint "oauth_tokens_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."oauth_tokens" validate constraint "oauth_tokens_user_id_fkey";

alter table "public"."oauth_tokens" add constraint "oauth_tokens_user_id_provider_key" UNIQUE using index "oauth_tokens_user_id_provider_key";

alter table "public"."offer_letters" add constraint "offer_letters_application_id_fkey" FOREIGN KEY (application_id) REFERENCES public.job_applications(id) ON DELETE CASCADE not valid;

alter table "public"."offer_letters" validate constraint "offer_letters_application_id_fkey";

alter table "public"."offer_letters" add constraint "offer_letters_employment_type_check" CHECK ((employment_type = ANY (ARRAY['full-time'::text, 'part-time'::text, 'contract'::text, 'temporary'::text]))) not valid;

alter table "public"."offer_letters" validate constraint "offer_letters_employment_type_check";

alter table "public"."offer_letters" add constraint "offer_letters_generated_by_fkey" FOREIGN KEY (generated_by) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."offer_letters" validate constraint "offer_letters_generated_by_fkey";

alter table "public"."offer_letters" add constraint "offer_letters_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'accepted'::text, 'declined'::text, 'expired'::text]))) not valid;

alter table "public"."offer_letters" validate constraint "offer_letters_status_check";

alter table "public"."offer_letters" add constraint "one_offer_per_application" UNIQUE using index "one_offer_per_application";

alter table "public"."onboarding_progress" add constraint "onboarding_progress_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) not valid;

alter table "public"."onboarding_progress" validate constraint "onboarding_progress_created_by_fkey";

alter table "public"."onboarding_progress" add constraint "onboarding_progress_flow_type_check" CHECK (((flow_type)::text = ANY ((ARRAY['self_service'::character varying, 'superadmin_invite'::character varying, 'migration'::character varying])::text[]))) not valid;

alter table "public"."onboarding_progress" validate constraint "onboarding_progress_flow_type_check";

alter table "public"."onboarding_progress" add constraint "onboarding_progress_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."onboarding_progress" validate constraint "onboarding_progress_school_id_fkey";

alter table "public"."onboarding_progress" add constraint "onboarding_progress_school_id_flow_type_key" UNIQUE using index "onboarding_progress_school_id_flow_type_key";

alter table "public"."onboarding_requests" add constraint "onboarding_requests_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'approved'::text, 'rejected'::text]))) not valid;

alter table "public"."onboarding_requests" validate constraint "onboarding_requests_status_check";

alter table "public"."org_invites" add constraint "org_invites_accepted_by_fkey" FOREIGN KEY (accepted_by) REFERENCES public.users(id) not valid;

alter table "public"."org_invites" validate constraint "org_invites_accepted_by_fkey";

alter table "public"."org_invites" add constraint "org_invites_invite_token_key" UNIQUE using index "org_invites_invite_token_key";

alter table "public"."org_invites" add constraint "org_invites_invited_by_fkey" FOREIGN KEY (invited_by) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."org_invites" validate constraint "org_invites_invited_by_fkey";

alter table "public"."org_invites" add constraint "org_invites_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."org_invites" validate constraint "org_invites_preschool_id_fkey";

alter table "public"."org_invites" add constraint "org_invites_role_check" CHECK ((role = ANY (ARRAY['principal'::text, 'teacher'::text, 'parent'::text]))) not valid;

alter table "public"."org_invites" validate constraint "org_invites_role_check";

alter table "public"."org_invites" add constraint "org_invites_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'accepted'::text, 'expired'::text, 'cancelled'::text]))) not valid;

alter table "public"."org_invites" validate constraint "org_invites_status_check";

alter table "public"."organization_announcement_recipients" add constraint "organization_announcement_reci_announcement_id_recipient_id_key" UNIQUE using index "organization_announcement_reci_announcement_id_recipient_id_key";

alter table "public"."organization_announcement_recipients" add constraint "organization_announcement_recipients_announcement_id_fkey" FOREIGN KEY (announcement_id) REFERENCES public.organization_announcements(id) ON DELETE CASCADE not valid;

alter table "public"."organization_announcement_recipients" validate constraint "organization_announcement_recipients_announcement_id_fkey";

alter table "public"."organization_announcement_recipients" add constraint "organization_announcement_recipients_notification_method_check" CHECK ((notification_method = ANY (ARRAY['push'::text, 'email'::text, 'sms'::text, 'in_app'::text]))) not valid;

alter table "public"."organization_announcement_recipients" validate constraint "organization_announcement_recipients_notification_method_check";

alter table "public"."organization_announcement_recipients" add constraint "organization_announcement_recipients_recipient_id_fkey" FOREIGN KEY (recipient_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."organization_announcement_recipients" validate constraint "organization_announcement_recipients_recipient_id_fkey";

alter table "public"."organization_announcements" add constraint "organization_announcements_announcement_type_check" CHECK ((announcement_type = ANY (ARRAY['general'::text, 'policy'::text, 'event'::text, 'financial'::text, 'strategic'::text, 'emergency'::text]))) not valid;

alter table "public"."organization_announcements" validate constraint "organization_announcements_announcement_type_check";

alter table "public"."organization_announcements" add constraint "organization_announcements_author_id_fkey" FOREIGN KEY (author_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."organization_announcements" validate constraint "organization_announcements_author_id_fkey";

alter table "public"."organization_announcements" add constraint "organization_announcements_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."organization_announcements" validate constraint "organization_announcements_organization_id_fkey";

alter table "public"."organization_announcements" add constraint "organization_announcements_priority_check" CHECK ((priority = ANY (ARRAY['low'::text, 'normal'::text, 'high'::text, 'urgent'::text]))) not valid;

alter table "public"."organization_announcements" validate constraint "organization_announcements_priority_check";

alter table "public"."organization_announcements" add constraint "organization_announcements_target_audience_check" CHECK ((target_audience = ANY (ARRAY['all'::text, 'regional_managers'::text, 'branch_managers'::text, 'members'::text]))) not valid;

alter table "public"."organization_announcements" validate constraint "organization_announcements_target_audience_check";

alter table "public"."organization_announcements" add constraint "organization_announcements_target_region_id_fkey" FOREIGN KEY (target_region_id) REFERENCES public.organization_regions(id) ON DELETE SET NULL not valid;

alter table "public"."organization_announcements" validate constraint "organization_announcements_target_region_id_fkey";

alter table "public"."organization_bank_accounts" add constraint "organization_bank_accounts_account_type_check" CHECK ((account_type = ANY (ARRAY['main_operating'::text, 'membership_fees'::text, 'programmes'::text, 'regional_float'::text, 'youth_wing'::text, 'women_league'::text, 'veterans_league'::text, 'petty_cash'::text, 'cheque'::text, 'savings'::text, 'current'::text, 'business'::text, 'school_fees'::text, 'donations'::text, 'transmission'::text]))) not valid;

alter table "public"."organization_bank_accounts" validate constraint "organization_bank_accounts_account_type_check";

alter table "public"."organization_bank_accounts" add constraint "organization_bank_accounts_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."organization_bank_accounts" validate constraint "organization_bank_accounts_created_by_fkey";

alter table "public"."organization_bank_accounts" add constraint "organization_bank_accounts_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."organization_bank_accounts" validate constraint "organization_bank_accounts_organization_id_fkey";

alter table "public"."organization_bank_accounts" add constraint "organization_bank_accounts_region_id_fkey" FOREIGN KEY (region_id) REFERENCES public.organization_regions(id) ON DELETE SET NULL not valid;

alter table "public"."organization_bank_accounts" validate constraint "organization_bank_accounts_region_id_fkey";

alter table "public"."organization_bank_accounts" add constraint "organization_bank_accounts_wing_id_fkey" FOREIGN KEY (wing_id) REFERENCES public.organization_wings(id) ON DELETE SET NULL not valid;

alter table "public"."organization_bank_accounts" validate constraint "organization_bank_accounts_wing_id_fkey";

alter table "public"."organization_board_positions" add constraint "organization_board_positions_appointed_by_fkey" FOREIGN KEY (appointed_by) REFERENCES public.organization_members(id) ON DELETE SET NULL not valid;

alter table "public"."organization_board_positions" validate constraint "organization_board_positions_appointed_by_fkey";

alter table "public"."organization_board_positions" add constraint "organization_board_positions_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."organization_board_positions" validate constraint "organization_board_positions_created_by_fkey";

alter table "public"."organization_board_positions" add constraint "organization_board_positions_member_id_fkey" FOREIGN KEY (member_id) REFERENCES public.organization_members(id) ON DELETE SET NULL not valid;

alter table "public"."organization_board_positions" validate constraint "organization_board_positions_member_id_fkey";

alter table "public"."organization_board_positions" add constraint "organization_board_positions_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."organization_board_positions" validate constraint "organization_board_positions_organization_id_fkey";

alter table "public"."organization_board_positions" add constraint "organization_board_positions_position_code_check" CHECK ((position_code = ANY (ARRAY['president'::text, 'vice_president'::text, 'vice_chairperson'::text, 'secretary'::text, 'treasurer'::text, 'board_member'::text]))) not valid;

alter table "public"."organization_board_positions" validate constraint "organization_board_positions_position_code_check";

alter table "public"."organization_budgets" add constraint "organization_budgets_approved_by_fkey" FOREIGN KEY (approved_by) REFERENCES auth.users(id) not valid;

alter table "public"."organization_budgets" validate constraint "organization_budgets_approved_by_fkey";

alter table "public"."organization_budgets" add constraint "organization_budgets_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."organization_budgets" validate constraint "organization_budgets_created_by_fkey";

alter table "public"."organization_budgets" add constraint "organization_budgets_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."organization_budgets" validate constraint "organization_budgets_organization_id_fkey";

alter table "public"."organization_budgets" add constraint "organization_budgets_period_type_check" CHECK ((period_type = ANY (ARRAY['monthly'::text, 'quarterly'::text, 'annual'::text]))) not valid;

alter table "public"."organization_budgets" validate constraint "organization_budgets_period_type_check";

alter table "public"."organization_budgets" add constraint "organization_budgets_region_id_fkey" FOREIGN KEY (region_id) REFERENCES public.organization_regions(id) ON DELETE SET NULL not valid;

alter table "public"."organization_budgets" validate constraint "organization_budgets_region_id_fkey";

alter table "public"."organization_budgets" add constraint "organization_budgets_status_check" CHECK ((status = ANY (ARRAY['draft'::text, 'proposed'::text, 'approved'::text, 'active'::text, 'frozen'::text, 'closed'::text]))) not valid;

alter table "public"."organization_budgets" validate constraint "organization_budgets_status_check";

alter table "public"."organization_budgets" add constraint "organization_budgets_wing_id_fkey" FOREIGN KEY (wing_id) REFERENCES public.organization_wings(id) ON DELETE SET NULL not valid;

alter table "public"."organization_budgets" validate constraint "organization_budgets_wing_id_fkey";

alter table "public"."organization_document_access" add constraint "organization_document_access_document_id_fkey" FOREIGN KEY (document_id) REFERENCES public.organization_documents(id) ON DELETE CASCADE not valid;

alter table "public"."organization_document_access" validate constraint "organization_document_access_document_id_fkey";

alter table "public"."organization_document_access" add constraint "organization_document_access_granted_by_fkey" FOREIGN KEY (granted_by) REFERENCES auth.users(id) not valid;

alter table "public"."organization_document_access" validate constraint "organization_document_access_granted_by_fkey";

alter table "public"."organization_document_access" add constraint "organization_document_access_grantee_region_id_fkey" FOREIGN KEY (grantee_region_id) REFERENCES public.organization_regions(id) ON DELETE CASCADE not valid;

alter table "public"."organization_document_access" validate constraint "organization_document_access_grantee_region_id_fkey";

alter table "public"."organization_document_access" add constraint "organization_document_access_grantee_user_id_fkey" FOREIGN KEY (grantee_user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."organization_document_access" validate constraint "organization_document_access_grantee_user_id_fkey";

alter table "public"."organization_document_access" add constraint "organization_document_access_permission_check" CHECK ((permission = ANY (ARRAY['view'::text, 'download'::text, 'edit'::text, 'admin'::text]))) not valid;

alter table "public"."organization_document_access" validate constraint "organization_document_access_permission_check";

alter table "public"."organization_document_access" add constraint "organization_document_access_revoked_by_fkey" FOREIGN KEY (revoked_by) REFERENCES auth.users(id) not valid;

alter table "public"."organization_document_access" validate constraint "organization_document_access_revoked_by_fkey";

alter table "public"."organization_document_access" add constraint "valid_grantee" CHECK (((grantee_user_id IS NOT NULL) OR (grantee_role IS NOT NULL) OR (grantee_region_id IS NOT NULL))) not valid;

alter table "public"."organization_document_access" validate constraint "valid_grantee";

alter table "public"."organization_document_access_requests" add constraint "organization_document_access_request_requested_permission_check" CHECK ((requested_permission = ANY (ARRAY['view'::text, 'download'::text, 'edit'::text]))) not valid;

alter table "public"."organization_document_access_requests" validate constraint "organization_document_access_request_requested_permission_check";

alter table "public"."organization_document_access_requests" add constraint "organization_document_access_requests_access_grant_id_fkey" FOREIGN KEY (access_grant_id) REFERENCES public.organization_document_access(id) not valid;

alter table "public"."organization_document_access_requests" validate constraint "organization_document_access_requests_access_grant_id_fkey";

alter table "public"."organization_document_access_requests" add constraint "organization_document_access_requests_document_id_fkey" FOREIGN KEY (document_id) REFERENCES public.organization_documents(id) ON DELETE CASCADE not valid;

alter table "public"."organization_document_access_requests" validate constraint "organization_document_access_requests_document_id_fkey";

alter table "public"."organization_document_access_requests" add constraint "organization_document_access_requests_requester_id_fkey" FOREIGN KEY (requester_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."organization_document_access_requests" validate constraint "organization_document_access_requests_requester_id_fkey";

alter table "public"."organization_document_access_requests" add constraint "organization_document_access_requests_reviewed_by_fkey" FOREIGN KEY (reviewed_by) REFERENCES auth.users(id) not valid;

alter table "public"."organization_document_access_requests" validate constraint "organization_document_access_requests_reviewed_by_fkey";

alter table "public"."organization_document_access_requests" add constraint "organization_document_access_requests_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'approved'::text, 'denied'::text, 'expired'::text]))) not valid;

alter table "public"."organization_document_access_requests" validate constraint "organization_document_access_requests_status_check";

alter table "public"."organization_document_audit_log" add constraint "organization_document_audit_log_action_check" CHECK ((action = ANY (ARRAY['view'::text, 'download'::text, 'upload'::text, 'update'::text, 'delete'::text, 'restore'::text, 'share'::text, 'revoke_access'::text, 'request_access'::text, 'approve_access'::text, 'deny_access'::text, 'encrypt'::text, 'decrypt'::text, 'print'::text, 'export'::text]))) not valid;

alter table "public"."organization_document_audit_log" validate constraint "organization_document_audit_log_action_check";

alter table "public"."organization_document_audit_log" add constraint "organization_document_audit_log_document_id_fkey" FOREIGN KEY (document_id) REFERENCES public.organization_documents(id) ON DELETE CASCADE not valid;

alter table "public"."organization_document_audit_log" validate constraint "organization_document_audit_log_document_id_fkey";

alter table "public"."organization_document_audit_log" add constraint "organization_document_audit_log_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."organization_document_audit_log" validate constraint "organization_document_audit_log_user_id_fkey";

alter table "public"."organization_document_folders" add constraint "organization_document_folders_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."organization_document_folders" validate constraint "organization_document_folders_created_by_fkey";

alter table "public"."organization_document_folders" add constraint "organization_document_folders_default_access_level_check" CHECK ((default_access_level = ANY (ARRAY['public'::text, 'members'::text, 'managers'::text, 'executives'::text, 'admin_only'::text]))) not valid;

alter table "public"."organization_document_folders" validate constraint "organization_document_folders_default_access_level_check";

alter table "public"."organization_document_folders" add constraint "organization_document_folders_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."organization_document_folders" validate constraint "organization_document_folders_organization_id_fkey";

alter table "public"."organization_document_folders" add constraint "organization_document_folders_organization_id_folder_path_n_key" UNIQUE using index "organization_document_folders_organization_id_folder_path_n_key";

alter table "public"."organization_document_folders" add constraint "organization_document_folders_parent_folder_id_fkey" FOREIGN KEY (parent_folder_id) REFERENCES public.organization_document_folders(id) ON DELETE CASCADE not valid;

alter table "public"."organization_document_folders" validate constraint "organization_document_folders_parent_folder_id_fkey";

alter table "public"."organization_documents" add constraint "organization_documents_access_level_check" CHECK ((access_level = ANY (ARRAY['public'::text, 'members'::text, 'managers'::text, 'executives'::text, 'admin_only'::text, 'custom'::text]))) not valid;

alter table "public"."organization_documents" validate constraint "organization_documents_access_level_check";

alter table "public"."organization_documents" add constraint "organization_documents_approved_by_fkey" FOREIGN KEY (approved_by) REFERENCES auth.users(id) not valid;

alter table "public"."organization_documents" validate constraint "organization_documents_approved_by_fkey";

alter table "public"."organization_documents" add constraint "organization_documents_deleted_by_fkey" FOREIGN KEY (deleted_by) REFERENCES auth.users(id) not valid;

alter table "public"."organization_documents" validate constraint "organization_documents_deleted_by_fkey";

alter table "public"."organization_documents" add constraint "organization_documents_document_type_check" CHECK ((document_type = ANY (ARRAY['general'::text, 'policy'::text, 'legal'::text, 'financial'::text, 'governance'::text, 'disciplinary'::text, 'template'::text, 'certificate'::text, 'report'::text, 'confidential'::text]))) not valid;

alter table "public"."organization_documents" validate constraint "organization_documents_document_type_check";

alter table "public"."organization_documents" add constraint "organization_documents_folder_id_fkey" FOREIGN KEY (folder_id) REFERENCES public.organization_document_folders(id) ON DELETE SET NULL not valid;

alter table "public"."organization_documents" validate constraint "organization_documents_folder_id_fkey";

alter table "public"."organization_documents" add constraint "organization_documents_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."organization_documents" validate constraint "organization_documents_organization_id_fkey";

alter table "public"."organization_documents" add constraint "organization_documents_previous_version_id_fkey" FOREIGN KEY (previous_version_id) REFERENCES public.organization_documents(id) not valid;

alter table "public"."organization_documents" validate constraint "organization_documents_previous_version_id_fkey";

alter table "public"."organization_documents" add constraint "organization_documents_uploaded_by_fkey" FOREIGN KEY (uploaded_by) REFERENCES auth.users(id) not valid;

alter table "public"."organization_documents" validate constraint "organization_documents_uploaded_by_fkey";

alter table "public"."organization_members" add constraint "fk_org_members_region" FOREIGN KEY (region_id) REFERENCES public.organization_regions(id) ON DELETE SET NULL not valid;

alter table "public"."organization_members" validate constraint "fk_org_members_region";

alter table "public"."organization_members" add constraint "organization_members_appointed_by_fkey" FOREIGN KEY (appointed_by) REFERENCES public.organization_members(id) ON DELETE SET NULL not valid;

alter table "public"."organization_members" validate constraint "organization_members_appointed_by_fkey";

alter table "public"."organization_members" add constraint "organization_members_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."organization_members" validate constraint "organization_members_created_by_fkey";

alter table "public"."organization_members" add constraint "organization_members_invited_by_fkey" FOREIGN KEY (invited_by) REFERENCES auth.users(id) not valid;

alter table "public"."organization_members" validate constraint "organization_members_invited_by_fkey";

alter table "public"."organization_members" add constraint "organization_members_member_type_check" CHECK (((member_type)::text = ANY ((ARRAY['learner'::character varying, 'mentor'::character varying, 'facilitator'::character varying, 'staff'::character varying, 'admin'::character varying, 'regional_manager'::character varying, 'national_admin'::character varying, 'youth_president'::character varying, 'youth_deputy'::character varying, 'youth_secretary'::character varying, 'youth_treasurer'::character varying, 'youth_coordinator'::character varying, 'youth_facilitator'::character varying, 'youth_mentor'::character varying, 'youth_member'::character varying, 'women_president'::character varying, 'women_deputy'::character varying, 'women_secretary'::character varying, 'women_treasurer'::character varying, 'women_coordinator'::character varying, 'women_facilitator'::character varying, 'women_mentor'::character varying, 'women_member'::character varying, 'veterans_president'::character varying, 'veterans_coordinator'::character varying, 'veterans_member'::character varying, 'ceo'::character varying, 'president'::character varying, 'executive'::character varying, 'board_member'::character varying, 'volunteer'::character varying, 'secretary_general'::character varying, 'deputy_president'::character varying, 'treasurer'::character varying])::text[]))) not valid;

alter table "public"."organization_members" validate constraint "organization_members_member_type_check";

alter table "public"."organization_members" add constraint "organization_members_org_email_unique" UNIQUE using index "organization_members_org_email_unique";

alter table "public"."organization_members" add constraint "organization_members_org_id_number_unique" UNIQUE using index "organization_members_org_id_number_unique";

alter table "public"."organization_members" add constraint "organization_members_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."organization_members" validate constraint "organization_members_organization_id_fkey";

alter table "public"."organization_members" add constraint "organization_members_seat_status_check" CHECK ((seat_status = ANY (ARRAY['active'::text, 'inactive'::text, 'pending'::text, 'revoked'::text]))) not valid;

alter table "public"."organization_members" validate constraint "organization_members_seat_status_check";

alter table "public"."organization_members" add constraint "organization_members_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."organization_members" validate constraint "organization_members_user_id_fkey";

alter table "public"."organization_members" add constraint "organization_members_user_id_organization_id_key" UNIQUE using index "organization_members_user_id_organization_id_key";

alter table "public"."organization_members" add constraint "organization_members_wing_check" CHECK ((wing = ANY (ARRAY['main'::text, 'youth'::text, 'women'::text, 'veterans'::text]))) not valid;

alter table "public"."organization_members" validate constraint "organization_members_wing_check";

alter table "public"."organization_payment_methods" add constraint "organization_payment_methods_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."organization_payment_methods" validate constraint "organization_payment_methods_organization_id_fkey";

alter table "public"."organization_petty_cash" add constraint "organization_petty_cash_custodian_id_fkey" FOREIGN KEY (custodian_id) REFERENCES public.organization_members(id) ON DELETE SET NULL not valid;

alter table "public"."organization_petty_cash" validate constraint "organization_petty_cash_custodian_id_fkey";

alter table "public"."organization_petty_cash" add constraint "organization_petty_cash_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."organization_petty_cash" validate constraint "organization_petty_cash_organization_id_fkey";

alter table "public"."organization_petty_cash" add constraint "organization_petty_cash_region_id_fkey" FOREIGN KEY (region_id) REFERENCES public.organization_regions(id) ON DELETE SET NULL not valid;

alter table "public"."organization_petty_cash" validate constraint "organization_petty_cash_region_id_fkey";

alter table "public"."organization_petty_cash" add constraint "organization_petty_cash_wing_id_fkey" FOREIGN KEY (wing_id) REFERENCES public.organization_wings(id) ON DELETE SET NULL not valid;

alter table "public"."organization_petty_cash" validate constraint "organization_petty_cash_wing_id_fkey";

alter table "public"."organization_regions" add constraint "organization_regions_manager_id_fkey" FOREIGN KEY (manager_id) REFERENCES auth.users(id) not valid;

alter table "public"."organization_regions" validate constraint "organization_regions_manager_id_fkey";

alter table "public"."organization_regions" add constraint "organization_regions_organization_id_code_key" UNIQUE using index "organization_regions_organization_id_code_key";

alter table "public"."organization_roles" add constraint "organization_roles_hierarchy_positive" CHECK ((hierarchy_level >= 0)) not valid;

alter table "public"."organization_roles" validate constraint "organization_roles_hierarchy_positive";

alter table "public"."organization_roles" add constraint "organization_roles_name_not_empty" CHECK ((length(TRIM(BOTH FROM role_name)) > 0)) not valid;

alter table "public"."organization_roles" validate constraint "organization_roles_name_not_empty";

alter table "public"."organization_roles" add constraint "organization_roles_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."organization_roles" validate constraint "organization_roles_organization_id_fkey";

alter table "public"."organization_roles" add constraint "organization_roles_unique_role" UNIQUE using index "organization_roles_unique_role";

alter table "public"."organization_transactions" add constraint "organization_transactions_account_id_fkey" FOREIGN KEY (account_id) REFERENCES public.organization_bank_accounts(id) ON DELETE SET NULL not valid;

alter table "public"."organization_transactions" validate constraint "organization_transactions_account_id_fkey";

alter table "public"."organization_transactions" add constraint "organization_transactions_approved_by_fkey" FOREIGN KEY (approved_by) REFERENCES auth.users(id) not valid;

alter table "public"."organization_transactions" validate constraint "organization_transactions_approved_by_fkey";

alter table "public"."organization_transactions" add constraint "organization_transactions_member_id_fkey" FOREIGN KEY (member_id) REFERENCES public.organization_members(id) ON DELETE SET NULL not valid;

alter table "public"."organization_transactions" validate constraint "organization_transactions_member_id_fkey";

alter table "public"."organization_transactions" add constraint "organization_transactions_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."organization_transactions" validate constraint "organization_transactions_organization_id_fkey";

alter table "public"."organization_transactions" add constraint "organization_transactions_payment_method_check" CHECK ((payment_method = ANY (ARRAY['eft'::text, 'cash'::text, 'cheque'::text, 'card'::text, 'mobile_money'::text, 'payfast'::text, 'other'::text]))) not valid;

alter table "public"."organization_transactions" validate constraint "organization_transactions_payment_method_check";

alter table "public"."organization_transactions" add constraint "organization_transactions_reconciled_by_fkey" FOREIGN KEY (reconciled_by) REFERENCES auth.users(id) not valid;

alter table "public"."organization_transactions" validate constraint "organization_transactions_reconciled_by_fkey";

alter table "public"."organization_transactions" add constraint "organization_transactions_region_id_fkey" FOREIGN KEY (region_id) REFERENCES public.organization_regions(id) ON DELETE SET NULL not valid;

alter table "public"."organization_transactions" validate constraint "organization_transactions_region_id_fkey";

alter table "public"."organization_transactions" add constraint "organization_transactions_status_check" CHECK ((status = ANY (ARRAY['draft'::text, 'pending'::text, 'submitted'::text, 'approved'::text, 'rejected'::text, 'paid'::text, 'cancelled'::text, 'reconciled'::text]))) not valid;

alter table "public"."organization_transactions" validate constraint "organization_transactions_status_check";

alter table "public"."organization_transactions" add constraint "organization_transactions_submitted_by_fkey" FOREIGN KEY (submitted_by) REFERENCES auth.users(id) not valid;

alter table "public"."organization_transactions" validate constraint "organization_transactions_submitted_by_fkey";

alter table "public"."organization_transactions" add constraint "organization_transactions_transaction_type_check" CHECK ((transaction_type = ANY (ARRAY['income'::text, 'expense'::text, 'transfer_in'::text, 'transfer_out'::text, 'allocation'::text, 'refund'::text, 'adjustment'::text, 'membership_fee'::text]))) not valid;

alter table "public"."organization_transactions" validate constraint "organization_transactions_transaction_type_check";

alter table "public"."organization_transactions" add constraint "organization_transactions_wing_id_fkey" FOREIGN KEY (wing_id) REFERENCES public.organization_wings(id) ON DELETE SET NULL not valid;

alter table "public"."organization_transactions" validate constraint "organization_transactions_wing_id_fkey";

alter table "public"."organization_wings" add constraint "organization_wings_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."organization_wings" validate constraint "organization_wings_created_by_fkey";

alter table "public"."organization_wings" add constraint "organization_wings_deputy_id_fkey" FOREIGN KEY (deputy_id) REFERENCES public.organization_members(id) ON DELETE SET NULL not valid;

alter table "public"."organization_wings" validate constraint "organization_wings_deputy_id_fkey";

alter table "public"."organization_wings" add constraint "organization_wings_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."organization_wings" validate constraint "organization_wings_organization_id_fkey";

alter table "public"."organization_wings" add constraint "organization_wings_president_id_fkey" FOREIGN KEY (president_id) REFERENCES public.organization_members(id) ON DELETE SET NULL not valid;

alter table "public"."organization_wings" validate constraint "organization_wings_president_id_fkey";

alter table "public"."organization_wings" add constraint "organization_wings_secretary_id_fkey" FOREIGN KEY (secretary_id) REFERENCES public.organization_members(id) ON DELETE SET NULL not valid;

alter table "public"."organization_wings" validate constraint "organization_wings_secretary_id_fkey";

alter table "public"."organization_wings" add constraint "organization_wings_treasurer_id_fkey" FOREIGN KEY (treasurer_id) REFERENCES public.organization_members(id) ON DELETE SET NULL not valid;

alter table "public"."organization_wings" validate constraint "organization_wings_treasurer_id_fkey";

alter table "public"."organization_wings" add constraint "organization_wings_wing_code_check" CHECK ((wing_code = ANY (ARRAY['youth'::text, 'women'::text, 'veterans'::text]))) not valid;

alter table "public"."organization_wings" validate constraint "organization_wings_wing_code_check";

alter table "public"."organization_wings" add constraint "unique_org_wing" UNIQUE using index "unique_org_wing";

alter table "public"."organizations" add constraint "organizations_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.profiles(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."organizations" validate constraint "organizations_created_by_fkey";

alter table "public"."organizations" add constraint "organizations_plan_tier_check" CHECK ((plan_tier = ANY (ARRAY['free'::text, 'starter'::text, 'professional'::text, 'enterprise'::text, 'parent-starter'::text, 'parent-plus'::text]))) not valid;

alter table "public"."organizations" validate constraint "organizations_plan_tier_check";

alter table "public"."organizations" add constraint "organizations_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE SET NULL not valid;

alter table "public"."organizations" validate constraint "organizations_preschool_id_fkey";

alter table "public"."organizations" add constraint "organizations_principal_id_fkey" FOREIGN KEY (principal_id) REFERENCES auth.users(id) not valid;

alter table "public"."organizations" validate constraint "organizations_principal_id_fkey";

alter table "public"."organizations" add constraint "organizations_school_code_key" UNIQUE using index "organizations_school_code_key";

alter table "public"."organizations" add constraint "organizations_slug_format_check" CHECK (((slug IS NULL) OR ((slug)::text ~ '^[a-z0-9-]+$'::text))) not valid;

alter table "public"."organizations" validate constraint "organizations_slug_format_check";

alter table "public"."organizations" add constraint "organizations_type_check" CHECK (((organization_type)::text = ANY ((ARRAY['preschool'::character varying, 'daycare'::character varying, 'primary_school'::character varying, 'k12'::character varying, 'skills'::character varying, 'tertiary'::character varying, 'org'::character varying, 'other'::character varying])::text[]))) not valid;

alter table "public"."organizations" validate constraint "organizations_type_check";

alter table "public"."overage_billing_records" add constraint "overage_billing_records_usage_tracking_id_fkey" FOREIGN KEY (usage_tracking_id) REFERENCES public.user_usage_tracking(id) ON DELETE CASCADE not valid;

alter table "public"."overage_billing_records" validate constraint "overage_billing_records_usage_tracking_id_fkey";

alter table "public"."overage_billing_records" add constraint "overage_billing_records_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."overage_billing_records" validate constraint "overage_billing_records_user_id_fkey";

alter table "public"."overage_notifications" add constraint "overage_notifications_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."overage_notifications" validate constraint "overage_notifications_user_id_fkey";

alter table "public"."parent_access_codes" add constraint "parent_access_codes_code_key" UNIQUE using index "parent_access_codes_code_key";

alter table "public"."parent_access_codes" add constraint "parent_access_codes_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."parent_access_codes" validate constraint "parent_access_codes_created_by_fkey";

alter table "public"."parent_access_codes" add constraint "parent_access_codes_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."parent_access_codes" validate constraint "parent_access_codes_preschool_id_fkey";

alter table "public"."parent_access_codes" add constraint "parent_access_codes_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."parent_access_codes" validate constraint "parent_access_codes_student_id_fkey";

alter table "public"."parent_access_codes" add constraint "parent_access_codes_used_by_fkey" FOREIGN KEY (used_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."parent_access_codes" validate constraint "parent_access_codes_used_by_fkey";

alter table "public"."parent_child_links" add constraint "parent_child_links_check" CHECK ((parent_id <> child_id)) not valid;

alter table "public"."parent_child_links" validate constraint "parent_child_links_check";

alter table "public"."parent_child_links" add constraint "parent_child_links_child_id_fkey" FOREIGN KEY (child_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."parent_child_links" validate constraint "parent_child_links_child_id_fkey";

alter table "public"."parent_child_links" add constraint "parent_child_links_parent_id_child_id_key" UNIQUE using index "parent_child_links_parent_id_child_id_key";

alter table "public"."parent_child_links" add constraint "parent_child_links_parent_id_fkey" FOREIGN KEY (parent_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."parent_child_links" validate constraint "parent_child_links_parent_id_fkey";

alter table "public"."parent_child_links" add constraint "parent_child_links_relationship_check" CHECK ((relationship = ANY (ARRAY['parent'::text, 'guardian'::text, 'caregiver'::text, 'grandparent'::text]))) not valid;

alter table "public"."parent_child_links" validate constraint "parent_child_links_relationship_check";

alter table "public"."parent_join_requests" add constraint "parent_join_requests_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."parent_join_requests" validate constraint "parent_join_requests_organization_id_fkey";

alter table "public"."parent_join_requests" add constraint "parent_join_requests_parent_id_fkey" FOREIGN KEY (parent_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."parent_join_requests" validate constraint "parent_join_requests_parent_id_fkey";

alter table "public"."parent_join_requests" add constraint "parent_join_requests_parent_id_organization_id_key" UNIQUE using index "parent_join_requests_parent_id_organization_id_key";

alter table "public"."parent_join_requests" add constraint "parent_join_requests_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."parent_join_requests" validate constraint "parent_join_requests_preschool_id_fkey";

alter table "public"."parent_join_requests" add constraint "parent_join_requests_reviewed_by_fkey" FOREIGN KEY (reviewed_by) REFERENCES auth.users(id) not valid;

alter table "public"."parent_join_requests" validate constraint "parent_join_requests_reviewed_by_fkey";

alter table "public"."parent_join_requests" add constraint "parent_join_requests_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'approved'::text, 'rejected'::text]))) not valid;

alter table "public"."parent_join_requests" validate constraint "parent_join_requests_status_check";

alter table "public"."parent_payments" add constraint "parent_payments_amount_cents_check" CHECK ((amount_cents >= 0)) not valid;

alter table "public"."parent_payments" validate constraint "parent_payments_amount_cents_check";

alter table "public"."parent_payments" add constraint "parent_payments_parent_id_fkey" FOREIGN KEY (parent_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."parent_payments" validate constraint "parent_payments_parent_id_fkey";

alter table "public"."parent_payments" add constraint "parent_payments_payment_method_check" CHECK ((payment_method = ANY (ARRAY['payfast'::text, 'eft'::text, 'cash'::text, 'card'::text, 'bank_transfer'::text]))) not valid;

alter table "public"."parent_payments" validate constraint "parent_payments_payment_method_check";

alter table "public"."parent_payments" add constraint "parent_payments_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."parent_payments" validate constraint "parent_payments_preschool_id_fkey";

alter table "public"."parent_payments" add constraint "parent_payments_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'processing'::text, 'completed'::text, 'failed'::text, 'refunded'::text, 'cancelled'::text]))) not valid;

alter table "public"."parent_payments" validate constraint "parent_payments_status_check";

alter table "public"."past_papers" add constraint "past_papers_exam_type_check" CHECK ((exam_type = ANY (ARRAY['past_paper'::text, 'mock_exam'::text, 'practice_test'::text]))) not valid;

alter table "public"."past_papers" validate constraint "past_papers_exam_type_check";

alter table "public"."past_papers" add constraint "past_papers_paper_number_check" CHECK (((paper_number >= 1) AND (paper_number <= 3))) not valid;

alter table "public"."past_papers" validate constraint "past_papers_paper_number_check";

alter table "public"."past_papers" add constraint "past_papers_term_check" CHECK (((term >= 1) AND (term <= 4))) not valid;

alter table "public"."past_papers" validate constraint "past_papers_term_check";

alter table "public"."payfast_itn_logs" add constraint "payfast_itn_logs_related_payment_id_fkey" FOREIGN KEY (related_payment_id) REFERENCES public.parent_payments(id) not valid;

alter table "public"."payfast_itn_logs" validate constraint "payfast_itn_logs_related_payment_id_fkey";

alter table "public"."payment_reminders" add constraint "payment_reminders_communication_method_check" CHECK ((communication_method = ANY (ARRAY['email'::text, 'sms'::text, 'whatsapp'::text, 'in_app'::text]))) not valid;

alter table "public"."payment_reminders" validate constraint "payment_reminders_communication_method_check";

alter table "public"."payment_reminders" add constraint "payment_reminders_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."payment_reminders" validate constraint "payment_reminders_created_by_fkey";

alter table "public"."payment_reminders" add constraint "payment_reminders_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."payment_reminders" validate constraint "payment_reminders_preschool_id_fkey";

alter table "public"."payment_reminders" add constraint "payment_reminders_status_check" CHECK ((status = ANY (ARRAY['sent'::text, 'delivered'::text, 'failed'::text, 'opened'::text]))) not valid;

alter table "public"."payment_reminders" validate constraint "payment_reminders_status_check";

alter table "public"."payment_reminders" add constraint "payment_reminders_student_fee_id_fkey" FOREIGN KEY (student_fee_id) REFERENCES public.student_fees(id) ON DELETE CASCADE not valid;

alter table "public"."payment_reminders" validate constraint "payment_reminders_student_fee_id_fkey";

alter table "public"."payment_reminders" add constraint "payment_reminders_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."payment_reminders" validate constraint "payment_reminders_student_id_fkey";

alter table "public"."payment_reminders" add constraint "payment_reminders_type_check" CHECK ((type = ANY (ARRAY['upcoming_due'::text, 'overdue'::text, 'final_notice'::text]))) not valid;

alter table "public"."payment_reminders" validate constraint "payment_reminders_type_check";

alter table "public"."payment_transactions" add constraint "payment_transactions_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."payment_transactions" validate constraint "payment_transactions_school_id_fkey";

alter table "public"."payment_transactions" add constraint "payment_transactions_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'completed'::text, 'failed'::text, 'cancelled'::text, 'refunded'::text]))) not valid;

alter table "public"."payment_transactions" validate constraint "payment_transactions_status_check";

alter table "public"."payments" add constraint "payments_parent_id_fkey" FOREIGN KEY (parent_id) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."payments" validate constraint "payments_parent_id_fkey";

alter table "public"."payments" add constraint "payments_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."payments" validate constraint "payments_preschool_id_fkey";

alter table "public"."payments" add constraint "payments_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'completed'::text, 'failed'::text, 'refunded'::text, 'proof_submitted'::text, 'under_review'::text, 'approved'::text, 'rejected'::text]))) not valid;

alter table "public"."payments" validate constraint "payments_status_check";

alter table "public"."payments" add constraint "payments_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE SET NULL not valid;

alter table "public"."payments" validate constraint "payments_student_id_fkey";

alter table "public"."pdf_custom_templates" add constraint "pdf_custom_templates_document_type_check" CHECK ((document_type = ANY (ARRAY['report'::text, 'letter'::text, 'invoice'::text, 'study_guide'::text, 'lesson_plan'::text, 'progress_report'::text, 'assessment'::text, 'certificate'::text, 'newsletter'::text, 'worksheet'::text, 'general'::text]))) not valid;

alter table "public"."pdf_custom_templates" validate constraint "pdf_custom_templates_document_type_check";

alter table "public"."pdf_custom_templates" add constraint "pdf_custom_templates_owner_user_id_fkey" FOREIGN KEY (owner_user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."pdf_custom_templates" validate constraint "pdf_custom_templates_owner_user_id_fkey";

alter table "public"."pdf_documents" add constraint "pdf_documents_document_type_check" CHECK ((document_type = ANY (ARRAY['report'::text, 'letter'::text, 'invoice'::text, 'study_guide'::text, 'lesson_plan'::text, 'progress_report'::text, 'assessment'::text, 'certificate'::text, 'newsletter'::text, 'worksheet'::text, 'general'::text]))) not valid;

alter table "public"."pdf_documents" validate constraint "pdf_documents_document_type_check";

alter table "public"."pdf_documents" add constraint "pdf_documents_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."pdf_documents" validate constraint "pdf_documents_user_id_fkey";

alter table "public"."pdf_user_preferences" add constraint "pdf_user_preferences_default_theme_check" CHECK ((default_theme = ANY (ARRAY['professional'::text, 'colorful'::text, 'minimalist'::text]))) not valid;

alter table "public"."pdf_user_preferences" validate constraint "pdf_user_preferences_default_theme_check";

alter table "public"."pdf_user_preferences" add constraint "pdf_user_preferences_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."pdf_user_preferences" validate constraint "pdf_user_preferences_user_id_fkey";

alter table "public"."pdf_user_preferences" add constraint "pdf_user_preferences_user_id_key" UNIQUE using index "pdf_user_preferences_user_id_key";

alter table "public"."petty_cash_accounts" add constraint "petty_cash_accounts_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."petty_cash_accounts" validate constraint "petty_cash_accounts_created_by_fkey";

alter table "public"."petty_cash_accounts" add constraint "petty_cash_accounts_name_preschool_unique" UNIQUE using index "petty_cash_accounts_name_preschool_unique";

alter table "public"."petty_cash_accounts" add constraint "petty_cash_accounts_preschool_id_fkey" FOREIGN KEY (school_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."petty_cash_accounts" validate constraint "petty_cash_accounts_preschool_id_fkey";

alter table "public"."petty_cash_receipts" add constraint "petty_cash_receipts_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."petty_cash_receipts" validate constraint "petty_cash_receipts_created_by_fkey";

alter table "public"."petty_cash_receipts" add constraint "petty_cash_receipts_positive_size" CHECK (((size_bytes IS NULL) OR (size_bytes > 0))) not valid;

alter table "public"."petty_cash_receipts" validate constraint "petty_cash_receipts_positive_size";

alter table "public"."petty_cash_receipts" add constraint "petty_cash_receipts_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."petty_cash_receipts" validate constraint "petty_cash_receipts_school_id_fkey";

alter table "public"."petty_cash_receipts" add constraint "petty_cash_receipts_transaction_id_fkey" FOREIGN KEY (transaction_id) REFERENCES public.petty_cash_transactions(id) ON DELETE CASCADE not valid;

alter table "public"."petty_cash_receipts" validate constraint "petty_cash_receipts_transaction_id_fkey";

alter table "public"."petty_cash_reconciliations" add constraint "petty_cash_reconciliations_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."petty_cash_reconciliations" validate constraint "petty_cash_reconciliations_preschool_id_fkey";

alter table "public"."petty_cash_reconciliations" add constraint "petty_cash_reconciliations_reconciled_by_fkey" FOREIGN KEY (reconciled_by) REFERENCES auth.users(id) not valid;

alter table "public"."petty_cash_reconciliations" validate constraint "petty_cash_reconciliations_reconciled_by_fkey";

alter table "public"."petty_cash_transactions" add constraint "petty_cash_transactions_account_id_fkey" FOREIGN KEY (account_id) REFERENCES public.petty_cash_accounts(id) ON DELETE CASCADE not valid;

alter table "public"."petty_cash_transactions" validate constraint "petty_cash_transactions_account_id_fkey";

alter table "public"."petty_cash_transactions" add constraint "petty_cash_transactions_approved_by_fkey" FOREIGN KEY (approved_by) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."petty_cash_transactions" validate constraint "petty_cash_transactions_approved_by_fkey";

alter table "public"."petty_cash_transactions" add constraint "petty_cash_transactions_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."petty_cash_transactions" validate constraint "petty_cash_transactions_created_by_fkey";

alter table "public"."petty_cash_transactions" add constraint "petty_cash_transactions_preschool_id_fkey" FOREIGN KEY (school_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."petty_cash_transactions" validate constraint "petty_cash_transactions_preschool_id_fkey";

alter table "public"."petty_cash_transactions" add constraint "petty_cash_transactions_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'approved'::text, 'rejected'::text]))) not valid;

alter table "public"."petty_cash_transactions" validate constraint "petty_cash_transactions_status_check";

alter table "public"."petty_cash_transactions" add constraint "petty_cash_transactions_transaction_type_check" CHECK (((transaction_type)::text = ANY ((ARRAY['deposit'::character varying, 'withdrawal'::character varying, 'transfer'::character varying])::text[]))) not valid;

alter table "public"."petty_cash_transactions" validate constraint "petty_cash_transactions_transaction_type_check";

alter table "public"."petty_cash_transactions" add constraint "petty_cash_transactions_type_check" CHECK ((type = ANY (ARRAY['expense'::text, 'replenishment'::text]))) not valid;

alter table "public"."petty_cash_transactions" validate constraint "petty_cash_transactions_type_check";

alter table "public"."phone_verification_logs" add constraint "phone_verification_logs_status_check" CHECK (((status)::text = ANY ((ARRAY['pending'::character varying, 'verified'::character varying, 'expired'::character varying, 'failed'::character varying])::text[]))) not valid;

alter table "public"."phone_verification_logs" validate constraint "phone_verification_logs_status_check";

alter table "public"."phone_verification_logs" add constraint "phone_verification_logs_user_phone_id_fkey" FOREIGN KEY (user_phone_id) REFERENCES public.user_phone_numbers(id) ON DELETE CASCADE not valid;

alter table "public"."phone_verification_logs" validate constraint "phone_verification_logs_user_phone_id_fkey";

alter table "public"."plan_quotas" add constraint "plan_quotas_plan_tier_quota_type_key" UNIQUE using index "plan_quotas_plan_tier_quota_type_key";

alter table "public"."platform_collected_payments" add constraint "platform_collected_payments_destination_organization_id_fkey" FOREIGN KEY (destination_organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."platform_collected_payments" validate constraint "platform_collected_payments_destination_organization_id_fkey";

alter table "public"."platform_collected_payments" add constraint "platform_collected_payments_disbursement_status_check" CHECK ((disbursement_status = ANY (ARRAY['pending'::text, 'scheduled'::text, 'processing'::text, 'completed'::text, 'failed'::text]))) not valid;

alter table "public"."platform_collected_payments" validate constraint "platform_collected_payments_disbursement_status_check";

alter table "public"."platform_collected_payments" add constraint "platform_collected_payments_payer_member_id_fkey" FOREIGN KEY (payer_member_id) REFERENCES public.organization_members(id) not valid;

alter table "public"."platform_collected_payments" validate constraint "platform_collected_payments_payer_member_id_fkey";

alter table "public"."platform_collected_payments" add constraint "platform_collected_payments_payer_profile_id_fkey" FOREIGN KEY (payer_profile_id) REFERENCES public.profiles(id) not valid;

alter table "public"."platform_collected_payments" validate constraint "platform_collected_payments_payer_profile_id_fkey";

alter table "public"."platform_collected_payments" add constraint "platform_collected_payments_payer_type_check" CHECK ((payer_type = ANY (ARRAY['member'::text, 'parent'::text, 'student'::text, 'organization'::text]))) not valid;

alter table "public"."platform_collected_payments" validate constraint "platform_collected_payments_payer_type_check";

alter table "public"."platform_collected_payments" add constraint "platform_collected_payments_payer_user_id_fkey" FOREIGN KEY (payer_user_id) REFERENCES auth.users(id) not valid;

alter table "public"."platform_collected_payments" validate constraint "platform_collected_payments_payer_user_id_fkey";

alter table "public"."platform_collected_payments" add constraint "platform_collected_payments_payment_method_check" CHECK ((payment_method = ANY (ARRAY['payfast'::text, 'bank_transfer'::text, 'card'::text, 'manual'::text]))) not valid;

alter table "public"."platform_collected_payments" validate constraint "platform_collected_payments_payment_method_check";

alter table "public"."platform_collected_payments" add constraint "platform_collected_payments_payment_purpose_check" CHECK ((payment_purpose = ANY (ARRAY['membership_fee'::text, 'school_fee'::text, 'course_fee'::text, 'event_fee'::text, 'donation'::text, 'other'::text]))) not valid;

alter table "public"."platform_collected_payments" validate constraint "platform_collected_payments_payment_purpose_check";

alter table "public"."platform_collected_payments" add constraint "platform_collected_payments_related_invoice_id_fkey" FOREIGN KEY (related_invoice_id) REFERENCES public.member_invoices(id) not valid;

alter table "public"."platform_collected_payments" validate constraint "platform_collected_payments_related_invoice_id_fkey";

alter table "public"."platform_collected_payments" add constraint "platform_collected_payments_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'completed'::text, 'failed'::text, 'refunded'::text, 'cancelled'::text]))) not valid;

alter table "public"."platform_collected_payments" validate constraint "platform_collected_payments_status_check";

alter table "public"."platform_disbursements" add constraint "platform_disbursements_bank_account_id_fkey" FOREIGN KEY (bank_account_id) REFERENCES public.organization_bank_accounts(id) not valid;

alter table "public"."platform_disbursements" validate constraint "platform_disbursements_bank_account_id_fkey";

alter table "public"."platform_disbursements" add constraint "platform_disbursements_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."platform_disbursements" validate constraint "platform_disbursements_created_by_fkey";

alter table "public"."platform_disbursements" add constraint "platform_disbursements_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."platform_disbursements" validate constraint "platform_disbursements_organization_id_fkey";

alter table "public"."platform_disbursements" add constraint "platform_disbursements_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'scheduled'::text, 'processing'::text, 'completed'::text, 'failed'::text, 'cancelled'::text]))) not valid;

alter table "public"."platform_disbursements" validate constraint "platform_disbursements_status_check";

alter table "public"."platform_subscriptions" add constraint "platform_subscriptions_billing_interval_check" CHECK ((billing_interval = ANY (ARRAY['monthly'::text, 'annual'::text]))) not valid;

alter table "public"."platform_subscriptions" validate constraint "platform_subscriptions_billing_interval_check";

alter table "public"."platform_subscriptions" add constraint "platform_subscriptions_payment_provider_check" CHECK ((payment_provider = ANY (ARRAY['paypal'::text, 'stripe'::text, 'payfast'::text]))) not valid;

alter table "public"."platform_subscriptions" validate constraint "platform_subscriptions_payment_provider_check";

alter table "public"."platform_subscriptions" add constraint "platform_subscriptions_status_check" CHECK ((status = ANY (ARRAY['trial'::text, 'active'::text, 'past_due'::text, 'canceled'::text, 'paused'::text, 'expired'::text]))) not valid;

alter table "public"."platform_subscriptions" validate constraint "platform_subscriptions_status_check";

alter table "public"."pop_uploads" add constraint "pop_uploads_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."pop_uploads" validate constraint "pop_uploads_preschool_id_fkey";

alter table "public"."pop_uploads" add constraint "pop_uploads_reviewed_by_fkey" FOREIGN KEY (reviewed_by) REFERENCES auth.users(id) not valid;

alter table "public"."pop_uploads" validate constraint "pop_uploads_reviewed_by_fkey";

alter table "public"."pop_uploads" add constraint "pop_uploads_status_check" CHECK (((status)::text = ANY ((ARRAY['pending'::character varying, 'approved'::character varying, 'rejected'::character varying, 'needs_revision'::character varying])::text[]))) not valid;

alter table "public"."pop_uploads" validate constraint "pop_uploads_status_check";

alter table "public"."pop_uploads" add constraint "pop_uploads_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."pop_uploads" validate constraint "pop_uploads_student_id_fkey";

alter table "public"."pop_uploads" add constraint "pop_uploads_upload_type_check" CHECK (((upload_type)::text = ANY ((ARRAY['proof_of_payment'::character varying, 'picture_of_progress'::character varying])::text[]))) not valid;

alter table "public"."pop_uploads" validate constraint "pop_uploads_upload_type_check";

alter table "public"."pop_uploads" add constraint "pop_uploads_uploaded_by_fkey" FOREIGN KEY (uploaded_by) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."pop_uploads" validate constraint "pop_uploads_uploaded_by_fkey";

alter table "public"."pop_uploads" add constraint "valid_amount" CHECK (((payment_amount IS NULL) OR (payment_amount > (0)::numeric))) not valid;

alter table "public"."pop_uploads" validate constraint "valid_amount";

alter table "public"."pop_uploads" add constraint "valid_file_size" CHECK (((file_size > 0) AND (file_size <= 50000000))) not valid;

alter table "public"."pop_uploads" validate constraint "valid_file_size";

alter table "public"."pop_uploads" add constraint "valid_payment_fields" CHECK (((((upload_type)::text = 'proof_of_payment'::text) AND (payment_amount IS NOT NULL) AND (payment_date IS NOT NULL)) OR (((upload_type)::text = 'picture_of_progress'::text) AND (subject IS NOT NULL)))) not valid;

alter table "public"."pop_uploads" validate constraint "valid_payment_fields";

alter table "public"."portfolio_items" add constraint "portfolio_items_learner_id_fkey" FOREIGN KEY (learner_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."portfolio_items" validate constraint "portfolio_items_learner_id_fkey";

alter table "public"."portfolio_items" add constraint "portfolio_items_program_id_fkey" FOREIGN KEY (program_id) REFERENCES public.courses(id) ON DELETE SET NULL not valid;

alter table "public"."portfolio_items" validate constraint "portfolio_items_program_id_fkey";

alter table "public"."preschool_onboarding_requests" add constraint "preschool_onboarding_requests_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'approved'::text, 'rejected'::text]))) not valid;

alter table "public"."preschool_onboarding_requests" validate constraint "preschool_onboarding_requests_status_check";

alter table "public"."preschool_settings" add constraint "preschool_settings_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."preschool_settings" validate constraint "preschool_settings_preschool_id_fkey";

alter table "public"."preschool_settings" add constraint "preschool_settings_preschool_id_key" UNIQUE using index "preschool_settings_preschool_id_key";

alter table "public"."preschool_voice_usage" add constraint "preschool_voice_usage_period_type_check" CHECK ((period_type = ANY (ARRAY['daily'::text, 'monthly'::text]))) not valid;

alter table "public"."preschool_voice_usage" validate constraint "preschool_voice_usage_period_type_check";

alter table "public"."preschool_voice_usage" add constraint "preschool_voice_usage_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."preschool_voice_usage" validate constraint "preschool_voice_usage_preschool_id_fkey";

alter table "public"."preschool_voice_usage" add constraint "preschool_voice_usage_preschool_id_period_type_period_start_key" UNIQUE using index "preschool_voice_usage_preschool_id_period_type_period_start_key";

alter table "public"."preschool_voice_usage" add constraint "preschool_voice_usage_subscription_tier_check" CHECK ((subscription_tier = ANY (ARRAY['free'::text, 'starter'::text, 'professional'::text, 'enterprise'::text, 'parent-starter'::text, 'parent-plus'::text]))) not valid;

alter table "public"."preschool_voice_usage" validate constraint "preschool_voice_usage_subscription_tier_check";

alter table "public"."preschools" add constraint "preschools_approved_by_fkey" FOREIGN KEY (approved_by) REFERENCES public.profiles(id) not valid;

alter table "public"."preschools" validate constraint "preschools_approved_by_fkey";

alter table "public"."preschools" add constraint "preschools_onboarding_flow_check" CHECK (((onboarding_flow)::text = ANY ((ARRAY['self_service'::character varying, 'superadmin_invite'::character varying, 'migration'::character varying, 'legacy'::character varying])::text[]))) not valid;

alter table "public"."preschools" validate constraint "preschools_onboarding_flow_check";

alter table "public"."preschools" add constraint "preschools_onboarding_status_check" CHECK (((onboarding_status)::text = ANY (ARRAY[('requested'::character varying)::text, ('approved'::character varying)::text, ('setup'::character varying)::text, ('completed'::character varying)::text]))) not valid;

alter table "public"."preschools" validate constraint "preschools_onboarding_status_check";

alter table "public"."preschools" add constraint "preschools_principal_id_fkey" FOREIGN KEY (principal_id) REFERENCES auth.users(id) not valid;

alter table "public"."preschools" validate constraint "preschools_principal_id_fkey";

alter table "public"."preschools" add constraint "preschools_registration_number_key" UNIQUE using index "preschools_registration_number_key";

alter table "public"."preschools" add constraint "preschools_school_type_check" CHECK ((school_type = ANY (ARRAY['preschool'::text, 'primary'::text, 'secondary'::text, 'combined'::text]))) not valid;

alter table "public"."preschools" validate constraint "preschools_school_type_check";

alter table "public"."preschools" add constraint "preschools_subscription_plan_check" CHECK (((subscription_plan)::text = ANY (ARRAY[('trial'::character varying)::text, ('basic'::character varying)::text, ('premium'::character varying)::text, ('enterprise'::character varying)::text]))) not valid;

alter table "public"."preschools" validate constraint "preschools_subscription_plan_check";

alter table "public"."preschools" add constraint "preschools_subscription_status_check" CHECK (((subscription_status)::text = ANY (ARRAY[('pending'::character varying)::text, ('active'::character varying)::text, ('inactive'::character varying)::text, ('cancelled'::character varying)::text]))) not valid;

alter table "public"."preschools" validate constraint "preschools_subscription_status_check";

alter table "public"."preschools" add constraint "preschools_subscription_tier_check" CHECK ((subscription_tier = ANY (ARRAY['free'::text, 'starter'::text, 'professional'::text, 'enterprise'::text, 'parent-starter'::text, 'parent-plus'::text]))) not valid;

alter table "public"."preschools" validate constraint "preschools_subscription_tier_check";

alter table "public"."preschools" add constraint "preschools_verification_status_check" CHECK (((verification_status)::text = ANY ((ARRAY['pending'::character varying, 'verified'::character varying, 'failed'::character varying, 'manual_override'::character varying])::text[]))) not valid;

alter table "public"."preschools" validate constraint "preschools_verification_status_check";

alter table "public"."principal_groups" add constraint "principal_groups_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."principal_groups" validate constraint "principal_groups_created_by_fkey";

alter table "public"."principal_groups" add constraint "principal_groups_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."principal_groups" validate constraint "principal_groups_preschool_id_fkey";

alter table "public"."principal_groups" add constraint "principal_groups_preschool_id_name_key" UNIQUE using index "principal_groups_preschool_id_name_key";

alter table "public"."profiles" add constraint "profiles_assigned_teacher_id_fkey" FOREIGN KEY (assigned_teacher_id) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."profiles" validate constraint "profiles_assigned_teacher_id_fkey";

alter table "public"."profiles" add constraint "profiles_guardian_profile_id_fkey" FOREIGN KEY (guardian_profile_id) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."profiles" validate constraint "profiles_guardian_profile_id_fkey";

alter table "public"."profiles" add constraint "profiles_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_id_fkey";

alter table "public"."profiles" add constraint "profiles_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) not valid;

alter table "public"."profiles" validate constraint "profiles_organization_id_fkey";

alter table "public"."profiles" add constraint "profiles_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) not valid;

alter table "public"."profiles" validate constraint "profiles_preschool_id_fkey";

alter table "public"."profiles" add constraint "profiles_role_check" CHECK ((role = ANY (ARRAY['parent'::text, 'teacher'::text, 'principal'::text, 'superadmin'::text, 'admin'::text, 'instructor'::text, 'student'::text]))) not valid;

alter table "public"."profiles" validate constraint "profiles_role_check";

alter table "public"."profiles" add constraint "profiles_seat_status_check" CHECK ((seat_status = ANY (ARRAY['active'::text, 'pending'::text, 'inactive'::text]))) not valid;

alter table "public"."profiles" validate constraint "profiles_seat_status_check";

alter table "public"."profiles" add constraint "profiles_usage_type_check" CHECK ((usage_type = ANY (ARRAY['preschool'::text, 'k12_school'::text, 'homeschool'::text, 'aftercare'::text, 'supplemental'::text, 'exploring'::text, 'independent'::text]))) not valid;

alter table "public"."profiles" validate constraint "profiles_usage_type_check";

alter table "public"."progress_reports" add constraint "progress_reports_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."progress_reports" validate constraint "progress_reports_preschool_id_fkey";

alter table "public"."progress_reports" add constraint "progress_reports_report_category_check" CHECK ((report_category = ANY (ARRAY['general'::text, 'school_readiness'::text]))) not valid;

alter table "public"."progress_reports" validate constraint "progress_reports_report_category_check";

alter table "public"."progress_reports" add constraint "progress_reports_report_type_check" CHECK ((report_type = ANY (ARRAY['weekly'::text, 'monthly'::text, 'quarterly'::text, 'annual'::text]))) not valid;

alter table "public"."progress_reports" validate constraint "progress_reports_report_type_check";

alter table "public"."progress_reports" add constraint "progress_reports_reviewed_by_fkey" FOREIGN KEY (reviewed_by) REFERENCES public.users(id) not valid;

alter table "public"."progress_reports" validate constraint "progress_reports_reviewed_by_fkey";

alter table "public"."progress_reports" add constraint "progress_reports_status_check" CHECK ((status = ANY (ARRAY['draft'::text, 'pending_review'::text, 'approved'::text, 'rejected'::text, 'sent'::text]))) not valid;

alter table "public"."progress_reports" validate constraint "progress_reports_status_check";

alter table "public"."progress_reports" add constraint "progress_reports_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."progress_reports" validate constraint "progress_reports_student_id_fkey";

alter table "public"."progress_reports" add constraint "progress_reports_student_id_report_period_key" UNIQUE using index "progress_reports_student_id_report_period_key";

alter table "public"."progress_reports" add constraint "progress_reports_teacher_id_fkey" FOREIGN KEY (teacher_id) REFERENCES public.users(id) not valid;

alter table "public"."progress_reports" validate constraint "progress_reports_teacher_id_fkey";

alter table "public"."progress_reports" add constraint "progress_reports_transition_readiness_level_check" CHECK ((transition_readiness_level = ANY (ARRAY['not_ready'::text, 'developing'::text, 'ready'::text, 'exceeds_expectations'::text]))) not valid;

alter table "public"."progress_reports" validate constraint "progress_reports_transition_readiness_level_check";

alter table "public"."promotional_campaigns" add constraint "chk_product_type" CHECK ((product_type = ANY (ARRAY['subscription'::text, 'registration'::text, 'fee'::text, 'all'::text]))) not valid;

alter table "public"."promotional_campaigns" validate constraint "chk_product_type";

alter table "public"."promotional_campaigns" add constraint "promotional_campaigns_code_key" UNIQUE using index "promotional_campaigns_code_key";

alter table "public"."promotional_campaigns" add constraint "promotional_campaigns_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."promotional_campaigns" validate constraint "promotional_campaigns_created_by_fkey";

alter table "public"."promotional_campaigns" add constraint "promotional_campaigns_discount_type_check" CHECK ((discount_type = ANY (ARRAY['percentage'::text, 'fixed_amount'::text, 'fixed_price'::text]))) not valid;

alter table "public"."promotional_campaigns" validate constraint "promotional_campaigns_discount_type_check";

alter table "public"."promotional_campaigns" add constraint "promotional_campaigns_user_type_check" CHECK ((user_type = ANY (ARRAY['parent'::text, 'teacher'::text, 'principal'::text, 'all'::text]))) not valid;

alter table "public"."promotional_campaigns" validate constraint "promotional_campaigns_user_type_check";

alter table "public"."push_device_tokens" add constraint "push_device_tokens_platform_check" CHECK ((platform = ANY (ARRAY['ios'::text, 'android'::text]))) not valid;

alter table "public"."push_device_tokens" validate constraint "push_device_tokens_platform_check";

alter table "public"."push_device_tokens" add constraint "push_device_tokens_user_id_expo_push_token_key" UNIQUE using index "push_device_tokens_user_id_expo_push_token_key";

alter table "public"."push_device_tokens" add constraint "push_device_tokens_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."push_device_tokens" validate constraint "push_device_tokens_user_id_fkey";

alter table "public"."push_devices" add constraint "push_devices_language_check" CHECK ((language = ANY (ARRAY['en'::text, 'af'::text, 'zu'::text, 'st'::text]))) not valid;

alter table "public"."push_devices" validate constraint "push_devices_language_check";

alter table "public"."push_devices" add constraint "push_devices_platform_check" CHECK ((platform = ANY (ARRAY['web'::text, 'ios'::text, 'android'::text]))) not valid;

alter table "public"."push_devices" validate constraint "push_devices_platform_check";

alter table "public"."push_devices" add constraint "push_devices_user_device_unique" UNIQUE using index "push_devices_user_device_unique";

alter table "public"."push_devices" add constraint "push_devices_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."push_devices" validate constraint "push_devices_user_id_fkey";

alter table "public"."push_notification_queue" add constraint "push_notification_queue_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'sent'::text, 'failed'::text]))) not valid;

alter table "public"."push_notification_queue" validate constraint "push_notification_queue_status_check";

alter table "public"."push_notification_queue" add constraint "push_notification_queue_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."push_notification_queue" validate constraint "push_notification_queue_user_id_fkey";

alter table "public"."push_notifications" add constraint "push_notifications_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE SET NULL not valid;

alter table "public"."push_notifications" validate constraint "push_notifications_preschool_id_fkey";

alter table "public"."push_notifications" add constraint "push_notifications_recipient_user_id_fkey" FOREIGN KEY (recipient_user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."push_notifications" validate constraint "push_notifications_recipient_user_id_fkey";

alter table "public"."push_notifications" add constraint "push_notifications_status_check" CHECK ((status = ANY (ARRAY['sent'::text, 'failed'::text, 'delivered'::text, 'error'::text]))) not valid;

alter table "public"."push_notifications" validate constraint "push_notifications_status_check";

alter table "public"."push_subscriptions" add constraint "push_subscriptions_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) not valid;

alter table "public"."push_subscriptions" validate constraint "push_subscriptions_preschool_id_fkey";

alter table "public"."push_subscriptions" add constraint "push_subscriptions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."push_subscriptions" validate constraint "push_subscriptions_user_id_fkey";

alter table "public"."push_subscriptions" add constraint "user_or_system_subscription" CHECK (((user_id IS NOT NULL) OR ((user_id IS NULL) AND ('updates'::text = ANY (topics))))) not valid;

alter table "public"."push_subscriptions" validate constraint "user_or_system_subscription";

alter table "public"."rag_chunks" add constraint "rag_chunks_attachment_id_fkey" FOREIGN KEY (attachment_id) REFERENCES public.ai_attachments(id) ON DELETE CASCADE not valid;

alter table "public"."rag_chunks" validate constraint "rag_chunks_attachment_id_fkey";

alter table "public"."rag_chunks" add constraint "rag_chunks_document_id_fkey" FOREIGN KEY (document_id) REFERENCES public.rag_documents(id) ON DELETE CASCADE not valid;

alter table "public"."rag_chunks" validate constraint "rag_chunks_document_id_fkey";

alter table "public"."rag_chunks" add constraint "rag_chunks_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."rag_chunks" validate constraint "rag_chunks_user_id_fkey";

alter table "public"."rag_documents" add constraint "rag_documents_attachment_id_fkey" FOREIGN KEY (attachment_id) REFERENCES public.ai_attachments(id) ON DELETE CASCADE not valid;

alter table "public"."rag_documents" validate constraint "rag_documents_attachment_id_fkey";

alter table "public"."rag_documents" add constraint "rag_documents_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."rag_documents" validate constraint "rag_documents_user_id_fkey";

alter table "public"."rag_ingestion_logs" add constraint "rag_ingestion_logs_attachment_id_fkey" FOREIGN KEY (attachment_id) REFERENCES public.ai_attachments(id) ON DELETE CASCADE not valid;

alter table "public"."rag_ingestion_logs" validate constraint "rag_ingestion_logs_attachment_id_fkey";

alter table "public"."reading_progress" add constraint "reading_progress_textbook_id_fkey" FOREIGN KEY (textbook_id) REFERENCES public.textbooks(id) ON DELETE CASCADE not valid;

alter table "public"."reading_progress" validate constraint "reading_progress_textbook_id_fkey";

alter table "public"."reading_progress" add constraint "reading_progress_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."reading_progress" validate constraint "reading_progress_user_id_fkey";

alter table "public"."reading_progress" add constraint "reading_progress_user_id_textbook_id_key" UNIQUE using index "reading_progress_user_id_textbook_id_key";

alter table "public"."region_invite_codes" add constraint "region_invite_codes_code_key" UNIQUE using index "region_invite_codes_code_key";

alter table "public"."region_invite_codes" add constraint "region_invite_codes_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."region_invite_codes" validate constraint "region_invite_codes_created_by_fkey";

alter table "public"."region_invite_codes" add constraint "region_invite_codes_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."region_invite_codes" validate constraint "region_invite_codes_organization_id_fkey";

alter table "public"."region_invite_codes" add constraint "region_invite_codes_region_id_fkey" FOREIGN KEY (region_id) REFERENCES public.organization_regions(id) ON DELETE CASCADE not valid;

alter table "public"."region_invite_codes" validate constraint "region_invite_codes_region_id_fkey";

alter table "public"."registration_requests" add constraint "registration_requests_edudash_parent_id_fkey" FOREIGN KEY (edudash_parent_id) REFERENCES public.profiles(id) not valid;

alter table "public"."registration_requests" validate constraint "registration_requests_edudash_parent_id_fkey";

alter table "public"."registration_requests" add constraint "registration_requests_edudash_student_id_fkey" FOREIGN KEY (edudash_student_id) REFERENCES public.students(id) not valid;

alter table "public"."registration_requests" validate constraint "registration_requests_edudash_student_id_fkey";

alter table "public"."registration_requests" add constraint "registration_requests_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."registration_requests" validate constraint "registration_requests_organization_id_fkey";

alter table "public"."registration_requests" add constraint "registration_requests_payment_verified_by_fkey" FOREIGN KEY (payment_verified_by) REFERENCES auth.users(id) not valid;

alter table "public"."registration_requests" validate constraint "registration_requests_payment_verified_by_fkey";

alter table "public"."registration_requests" add constraint "registration_requests_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'approved'::text, 'rejected'::text]))) not valid;

alter table "public"."registration_requests" validate constraint "registration_requests_status_check";

alter table "public"."registration_requests" add constraint "registration_requests_student_gender_check" CHECK ((student_gender = ANY (ARRAY['male'::text, 'female'::text, 'other'::text]))) not valid;

alter table "public"."registration_requests" validate constraint "registration_requests_student_gender_check";

alter table "public"."resource_categories" add constraint "resource_categories_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."resource_categories" validate constraint "resource_categories_organization_id_fkey";

alter table "public"."resource_categories" add constraint "resource_categories_parent_category_id_fkey" FOREIGN KEY (parent_category_id) REFERENCES public.resource_categories(id) ON DELETE CASCADE not valid;

alter table "public"."resource_categories" validate constraint "resource_categories_parent_category_id_fkey";

alter table "public"."resource_permissions" add constraint "resource_permissions_check" CHECK ((((user_id IS NOT NULL) AND (role IS NULL) AND (class_id IS NULL)) OR ((user_id IS NULL) AND (role IS NOT NULL) AND (class_id IS NULL)) OR ((user_id IS NULL) AND (role IS NULL) AND (class_id IS NOT NULL)))) not valid;

alter table "public"."resource_permissions" validate constraint "resource_permissions_check";

alter table "public"."resource_permissions" add constraint "resource_permissions_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.classes(id) ON DELETE CASCADE not valid;

alter table "public"."resource_permissions" validate constraint "resource_permissions_class_id_fkey";

alter table "public"."resource_permissions" add constraint "resource_permissions_permission_type_check" CHECK ((permission_type = ANY (ARRAY['view'::text, 'download'::text, 'edit'::text, 'admin'::text]))) not valid;

alter table "public"."resource_permissions" validate constraint "resource_permissions_permission_type_check";

alter table "public"."resource_permissions" add constraint "resource_permissions_resource_id_fkey" FOREIGN KEY (resource_id) REFERENCES public.resources(id) ON DELETE CASCADE not valid;

alter table "public"."resource_permissions" validate constraint "resource_permissions_resource_id_fkey";

alter table "public"."resource_permissions" add constraint "resource_permissions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."resource_permissions" validate constraint "resource_permissions_user_id_fkey";

alter table "public"."resource_reviews" add constraint "resource_reviews_rating_check" CHECK (((rating >= 1) AND (rating <= 5))) not valid;

alter table "public"."resource_reviews" validate constraint "resource_reviews_rating_check";

alter table "public"."resource_reviews" add constraint "resource_reviews_resource_id_fkey" FOREIGN KEY (resource_id) REFERENCES public.resources(id) ON DELETE CASCADE not valid;

alter table "public"."resource_reviews" validate constraint "resource_reviews_resource_id_fkey";

alter table "public"."resource_reviews" add constraint "resource_reviews_resource_id_user_id_key" UNIQUE using index "resource_reviews_resource_id_user_id_key";

alter table "public"."resource_reviews" add constraint "resource_reviews_student_engagement_rating_check" CHECK (((student_engagement_rating >= 1) AND (student_engagement_rating <= 5))) not valid;

alter table "public"."resource_reviews" validate constraint "resource_reviews_student_engagement_rating_check";

alter table "public"."resource_reviews" add constraint "resource_reviews_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."resource_reviews" validate constraint "resource_reviews_user_id_fkey";

alter table "public"."resources" add constraint "resources_category_id_fkey" FOREIGN KEY (category_id) REFERENCES public.resource_categories(id) ON DELETE SET NULL not valid;

alter table "public"."resources" validate constraint "resources_category_id_fkey";

alter table "public"."resources" add constraint "resources_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."resources" validate constraint "resources_created_by_fkey";

alter table "public"."resources" add constraint "resources_moderation_status_check" CHECK ((moderation_status = ANY (ARRAY['pending'::text, 'approved'::text, 'rejected'::text]))) not valid;

alter table "public"."resources" validate constraint "resources_moderation_status_check";

alter table "public"."resources" add constraint "resources_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."resources" validate constraint "resources_organization_id_fkey";

alter table "public"."resources" add constraint "resources_resource_type_check" CHECK ((resource_type = ANY (ARRAY['document'::text, 'video'::text, 'image'::text, 'link'::text, 'lesson_plan'::text, 'presentation'::text, 'activity'::text, 'other'::text]))) not valid;

alter table "public"."resources" validate constraint "resources_resource_type_check";

alter table "public"."resources" add constraint "resources_visibility_check" CHECK ((visibility = ANY (ARRAY['private'::text, 'organization'::text, 'public'::text]))) not valid;

alter table "public"."resources" validate constraint "resources_visibility_check";

alter table "public"."revenuecat_webhook_events" add constraint "revenuecat_webhook_events_event_id_key" UNIQUE using index "revenuecat_webhook_events_event_id_key";

alter table "public"."rubric_grades" add constraint "rubric_grades_grade_id_fkey" FOREIGN KEY (grade_id) REFERENCES public.assignment_grades(id) ON DELETE CASCADE not valid;

alter table "public"."rubric_grades" validate constraint "rubric_grades_grade_id_fkey";

alter table "public"."rubric_grades" add constraint "rubric_grades_grade_id_rubric_id_key" UNIQUE using index "rubric_grades_grade_id_rubric_id_key";

alter table "public"."rubric_grades" add constraint "rubric_grades_rubric_id_fkey" FOREIGN KEY (rubric_id) REFERENCES public.assignment_rubrics(id) ON DELETE CASCADE not valid;

alter table "public"."rubric_grades" validate constraint "rubric_grades_rubric_id_fkey";

alter table "public"."scheduled_lessons" add constraint "scheduled_lessons_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.classes(id) ON DELETE CASCADE not valid;

alter table "public"."scheduled_lessons" validate constraint "scheduled_lessons_class_id_fkey";

alter table "public"."scheduled_lessons" add constraint "scheduled_lessons_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."scheduled_lessons" validate constraint "scheduled_lessons_preschool_id_fkey";

alter table "public"."scheduled_lessons" add constraint "scheduled_lessons_status_check" CHECK ((status = ANY (ARRAY['scheduled'::text, 'started'::text, 'completed'::text, 'cancelled'::text]))) not valid;

alter table "public"."scheduled_lessons" validate constraint "scheduled_lessons_status_check";

alter table "public"."scheduled_lessons" add constraint "scheduled_lessons_teacher_id_fkey" FOREIGN KEY (teacher_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."scheduled_lessons" validate constraint "scheduled_lessons_teacher_id_fkey";

alter table "public"."scheduled_tasks" add constraint "scheduled_tasks_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.profiles(id) ON DELETE RESTRICT not valid;

alter table "public"."scheduled_tasks" validate constraint "scheduled_tasks_created_by_fkey";

alter table "public"."scheduled_tasks" add constraint "scheduled_tasks_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."scheduled_tasks" validate constraint "scheduled_tasks_organization_id_fkey";

alter table "public"."scheduled_tasks" add constraint "scheduled_tasks_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'running'::text, 'completed'::text, 'failed'::text, 'cancelled'::text]))) not valid;

alter table "public"."scheduled_tasks" validate constraint "scheduled_tasks_status_check";

alter table "public"."scheduled_tasks" add constraint "scheduled_tasks_type_check" CHECK ((type = ANY (ARRAY['assignment_release'::text, 'grade_reminder'::text, 'due_date_reminder'::text, 'progress_report'::text, 'bulk_enrollment'::text, 'grade_aggregation'::text]))) not valid;

alter table "public"."scheduled_tasks" validate constraint "scheduled_tasks_type_check";

alter table "public"."school_ai_subscriptions" add constraint "allocated_within_total" CHECK (((((allocated_quotas ->> 'claude_messages'::text))::integer <= ((total_quotas ->> 'claude_messages'::text))::integer) AND (((allocated_quotas ->> 'content_generation'::text))::integer <= ((total_quotas ->> 'content_generation'::text))::integer) AND (((allocated_quotas ->> 'assessment_ai'::text))::integer <= ((total_quotas ->> 'assessment_ai'::text))::integer))) not valid;

alter table "public"."school_ai_subscriptions" validate constraint "allocated_within_total";

alter table "public"."school_ai_subscriptions" add constraint "positive_quotas" CHECK (((((total_quotas ->> 'claude_messages'::text))::integer >= 0) AND (((total_quotas ->> 'content_generation'::text))::integer >= 0) AND (((total_quotas ->> 'assessment_ai'::text))::integer >= 0))) not valid;

alter table "public"."school_ai_subscriptions" validate constraint "positive_quotas";

alter table "public"."school_ai_subscriptions" add constraint "school_ai_subscriptions_org_type_check" CHECK ((org_type = ANY (ARRAY['preschool'::text, 'k12'::text, 'individual'::text]))) not valid;

alter table "public"."school_ai_subscriptions" validate constraint "school_ai_subscriptions_org_type_check";

alter table "public"."school_ai_subscriptions" add constraint "school_ai_subscriptions_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."school_ai_subscriptions" validate constraint "school_ai_subscriptions_preschool_id_fkey";

alter table "public"."school_ai_subscriptions" add constraint "school_ai_subscriptions_preschool_id_key" UNIQUE using index "school_ai_subscriptions_preschool_id_key";

alter table "public"."school_ai_subscriptions" add constraint "school_ai_subscriptions_subscription_tier_check" CHECK ((subscription_tier = ANY (ARRAY['free'::text, 'basic'::text, 'pro'::text, 'premium'::text, 'enterprise'::text, 'parent-starter'::text, 'parent-plus'::text]))) not valid;

alter table "public"."school_ai_subscriptions" validate constraint "school_ai_subscriptions_subscription_tier_check";

alter table "public"."school_ai_subscriptions" add constraint "school_ai_subscriptions_updated_by_fkey" FOREIGN KEY (updated_by) REFERENCES auth.users(id) not valid;

alter table "public"."school_ai_subscriptions" validate constraint "school_ai_subscriptions_updated_by_fkey";

alter table "public"."school_branding" add constraint "school_branding_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."school_branding" validate constraint "school_branding_preschool_id_fkey";

alter table "public"."school_branding" add constraint "unique_preschool_branding" UNIQUE using index "unique_preschool_branding";

alter table "public"."school_branding" add constraint "valid_accent_color" CHECK (((accent_color)::text ~ '^#[0-9A-Fa-f]{6}$'::text)) not valid;

alter table "public"."school_branding" validate constraint "valid_accent_color";

alter table "public"."school_branding" add constraint "valid_primary_color" CHECK (((primary_color)::text ~ '^#[0-9A-Fa-f]{6}$'::text)) not valid;

alter table "public"."school_branding" validate constraint "valid_primary_color";

alter table "public"."school_branding" add constraint "valid_secondary_color" CHECK (((secondary_color)::text ~ '^#[0-9A-Fa-f]{6}$'::text)) not valid;

alter table "public"."school_branding" validate constraint "valid_secondary_color";

alter table "public"."school_events" add constraint "school_events_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."school_events" validate constraint "school_events_created_by_fkey";

alter table "public"."school_events" add constraint "school_events_event_type_check" CHECK ((event_type = ANY (ARRAY['holiday'::text, 'parent_meeting'::text, 'field_trip'::text, 'assembly'::text, 'sports_day'::text, 'graduation'::text, 'fundraiser'::text, 'workshop'::text, 'staff_meeting'::text, 'open_house'::text, 'other'::text]))) not valid;

alter table "public"."school_events" validate constraint "school_events_event_type_check";

alter table "public"."school_events" add constraint "school_events_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."school_events" validate constraint "school_events_preschool_id_fkey";

alter table "public"."school_events" add constraint "school_events_status_check" CHECK ((status = ANY (ARRAY['scheduled'::text, 'ongoing'::text, 'completed'::text, 'cancelled'::text]))) not valid;

alter table "public"."school_events" validate constraint "school_events_status_check";

alter table "public"."school_fee_structures" add constraint "school_fee_structures_amount_cents_check" CHECK ((amount_cents >= 0)) not valid;

alter table "public"."school_fee_structures" validate constraint "school_fee_structures_amount_cents_check";

alter table "public"."school_fee_structures" add constraint "school_fee_structures_billing_frequency_check" CHECK ((billing_frequency = ANY (ARRAY['once_off'::text, 'daily'::text, 'weekly'::text, 'monthly'::text, 'quarterly'::text, 'annual'::text]))) not valid;

alter table "public"."school_fee_structures" validate constraint "school_fee_structures_billing_frequency_check";

alter table "public"."school_fee_structures" add constraint "school_fee_structures_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.profiles(id) not valid;

alter table "public"."school_fee_structures" validate constraint "school_fee_structures_created_by_fkey";

alter table "public"."school_fee_structures" add constraint "school_fee_structures_due_day_of_month_check" CHECK (((due_day_of_month >= 1) AND (due_day_of_month <= 31))) not valid;

alter table "public"."school_fee_structures" validate constraint "school_fee_structures_due_day_of_month_check";

alter table "public"."school_fee_structures" add constraint "school_fee_structures_fee_category_check" CHECK ((fee_category = ANY (ARRAY['tuition'::text, 'registration'::text, 'deposit'::text, 'transport'::text, 'meals'::text, 'activities'::text, 'uniform'::text, 'books'::text, 'other'::text]))) not valid;

alter table "public"."school_fee_structures" validate constraint "school_fee_structures_fee_category_check";

alter table "public"."school_fee_structures" add constraint "school_fee_structures_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."school_fee_structures" validate constraint "school_fee_structures_preschool_id_fkey";

alter table "public"."school_invitation_codes" add constraint "school_invitation_codes_code_key" UNIQUE using index "school_invitation_codes_code_key";

alter table "public"."school_invitation_codes" add constraint "school_invitation_codes_invitation_type_check" CHECK (((invitation_type)::text = ANY (ARRAY[('principal'::character varying)::text, ('teacher'::character varying)::text, ('parent'::character varying)::text]))) not valid;

alter table "public"."school_invitation_codes" validate constraint "school_invitation_codes_invitation_type_check";

alter table "public"."school_invitation_codes" add constraint "school_invitation_codes_invited_by_fkey" FOREIGN KEY (invited_by) REFERENCES public.profiles(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."school_invitation_codes" validate constraint "school_invitation_codes_invited_by_fkey";

alter table "public"."school_invitation_codes" add constraint "school_invitation_codes_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."school_invitation_codes" validate constraint "school_invitation_codes_preschool_id_fkey";

alter table "public"."school_invitation_codes" add constraint "school_invitation_codes_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."school_invitation_codes" validate constraint "school_invitation_codes_school_id_fkey";

alter table "public"."school_invitation_codes" add constraint "school_invitation_codes_used_by_fkey" FOREIGN KEY (used_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."school_invitation_codes" validate constraint "school_invitation_codes_used_by_fkey";

alter table "public"."school_settings" add constraint "school_settings_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."school_settings" validate constraint "school_settings_preschool_id_fkey";

alter table "public"."school_settings" add constraint "school_settings_preschool_id_key" UNIQUE using index "school_settings_preschool_id_key";

alter table "public"."school_verifications" add constraint "school_verifications_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."school_verifications" validate constraint "school_verifications_school_id_fkey";

alter table "public"."school_verifications" add constraint "school_verifications_status_check" CHECK (((status)::text = ANY ((ARRAY['pending'::character varying, 'verified'::character varying, 'failed'::character varying, 'expired'::character varying])::text[]))) not valid;

alter table "public"."school_verifications" validate constraint "school_verifications_status_check";

alter table "public"."school_verifications" add constraint "school_verifications_verification_type_check" CHECK (((verification_type)::text = ANY ((ARRAY['email'::character varying, 'phone'::character varying, 'document'::character varying, 'manual'::character varying, 'api'::character varying])::text[]))) not valid;

alter table "public"."school_verifications" validate constraint "school_verifications_verification_type_check";

alter table "public"."school_verifications" add constraint "school_verifications_verified_by_fkey" FOREIGN KEY (verified_by) REFERENCES public.users(id) not valid;

alter table "public"."school_verifications" validate constraint "school_verifications_verified_by_fkey";

alter table "public"."schools" add constraint "schools_principal_id_fkey" FOREIGN KEY (principal_id) REFERENCES auth.users(id) not valid;

alter table "public"."schools" validate constraint "schools_principal_id_fkey";

alter table "public"."schools" add constraint "schools_status_check" CHECK ((status = ANY (ARRAY['active'::text, 'inactive'::text, 'pending'::text]))) not valid;

alter table "public"."schools" validate constraint "schools_status_check";

alter table "public"."seats" add constraint "fk_seats_preschool_id" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."seats" validate constraint "fk_seats_preschool_id";

alter table "public"."seats" add constraint "seats_seat_type_check" CHECK ((seat_type = ANY (ARRAY['teacher'::text, 'student'::text]))) not valid;

alter table "public"."seats" validate constraint "seats_seat_type_check";

alter table "public"."seats" add constraint "seats_subscription_id_user_id_key" UNIQUE using index "seats_subscription_id_user_id_key";

alter table "public"."seats" add constraint "seats_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."seats" validate constraint "seats_user_id_fkey";

alter table "public"."security_events" add constraint "security_events_event_type_check" CHECK ((event_type = ANY (ARRAY['login_success'::text, 'login_failure'::text, 'invitation_sent'::text, 'password_reset'::text, 'account_locked'::text, 'mfa_enabled'::text, 'mfa_disabled'::text, 'role_changed'::text]))) not valid;

alter table "public"."security_events" validate constraint "security_events_event_type_check";

alter table "public"."security_events" add constraint "security_events_risk_level_check" CHECK ((risk_level = ANY (ARRAY['low'::text, 'medium'::text, 'high'::text, 'critical'::text]))) not valid;

alter table "public"."security_events" validate constraint "security_events_risk_level_check";

alter table "public"."security_events" add constraint "security_events_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."security_events" validate constraint "security_events_user_id_fkey";

alter table "public"."service_alert_config" add constraint "service_alert_config_budget_usd_check" CHECK ((budget_usd >= (0)::numeric)) not valid;

alter table "public"."service_alert_config" validate constraint "service_alert_config_budget_usd_check";

alter table "public"."service_alert_config" add constraint "service_alert_config_downtime_threshold_minutes_check" CHECK ((downtime_threshold_minutes > 0)) not valid;

alter table "public"."service_alert_config" validate constraint "service_alert_config_downtime_threshold_minutes_check";

alter table "public"."service_alert_config" add constraint "service_alert_config_error_rate_threshold_percent_check" CHECK (((error_rate_threshold_percent >= (0)::numeric) AND (error_rate_threshold_percent <= (100)::numeric))) not valid;

alter table "public"."service_alert_config" validate constraint "service_alert_config_error_rate_threshold_percent_check";

alter table "public"."service_alert_config" add constraint "service_alert_config_response_time_threshold_ms_check" CHECK ((response_time_threshold_ms > 0)) not valid;

alter table "public"."service_alert_config" validate constraint "service_alert_config_response_time_threshold_ms_check";

alter table "public"."service_alerts" add constraint "service_alerts_channel_check" CHECK ((channel = ANY (ARRAY['email'::text, 'sms'::text, 'in_app'::text]))) not valid;

alter table "public"."service_alerts" validate constraint "service_alerts_channel_check";

alter table "public"."service_alerts" add constraint "service_alerts_dedupe_key_triggered_at_key" UNIQUE using index "service_alerts_dedupe_key_triggered_at_key";

alter table "public"."service_alerts" add constraint "service_alerts_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'sent'::text, 'failed'::text, 'resolved'::text]))) not valid;

alter table "public"."service_alerts" validate constraint "service_alerts_status_check";

alter table "public"."service_api_keys" add constraint "service_api_keys_service_name_key" UNIQUE using index "service_api_keys_service_name_key";

alter table "public"."service_api_keys" add constraint "service_api_keys_status_check" CHECK ((status = ANY (ARRAY['active'::text, 'expiring'::text, 'expired'::text, 'invalid'::text, 'unknown'::text]))) not valid;

alter table "public"."service_api_keys" validate constraint "service_api_keys_status_check";

alter table "public"."service_cost_tracking" add constraint "service_cost_tracking_cost_usd_check" CHECK ((cost_usd >= (0)::numeric)) not valid;

alter table "public"."service_cost_tracking" validate constraint "service_cost_tracking_cost_usd_check";

alter table "public"."service_cost_tracking" add constraint "service_cost_tracking_cost_zar_check" CHECK ((cost_zar >= (0)::numeric)) not valid;

alter table "public"."service_cost_tracking" validate constraint "service_cost_tracking_cost_zar_check";

alter table "public"."service_cost_tracking" add constraint "service_cost_tracking_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."service_cost_tracking" validate constraint "service_cost_tracking_preschool_id_fkey";

alter table "public"."service_cost_tracking" add constraint "service_cost_tracking_preschool_id_service_name_period_mont_key" UNIQUE using index "service_cost_tracking_preschool_id_service_name_period_mont_key";

alter table "public"."service_health_status" add constraint "service_health_status_circuit_state_check" CHECK ((circuit_state = ANY (ARRAY['closed'::text, 'open'::text, 'half_open'::text]))) not valid;

alter table "public"."service_health_status" validate constraint "service_health_status_circuit_state_check";

alter table "public"."service_health_status" add constraint "service_health_status_consecutive_failures_check" CHECK ((consecutive_failures >= 0)) not valid;

alter table "public"."service_health_status" validate constraint "service_health_status_consecutive_failures_check";

alter table "public"."service_health_status" add constraint "service_health_status_error_rate_percent_check" CHECK (((error_rate_percent >= (0)::numeric) AND (error_rate_percent <= (100)::numeric))) not valid;

alter table "public"."service_health_status" validate constraint "service_health_status_error_rate_percent_check";

alter table "public"."service_health_status" add constraint "service_health_status_service_category_check" CHECK ((service_category = ANY (ARRAY['infrastructure'::text, 'ai'::text, 'voice'::text, 'payment'::text, 'communication'::text, 'monitoring'::text, 'development'::text]))) not valid;

alter table "public"."service_health_status" validate constraint "service_health_status_service_category_check";

alter table "public"."service_health_status" add constraint "service_health_status_service_name_key" UNIQUE using index "service_health_status_service_name_key";

alter table "public"."service_health_status" add constraint "service_health_status_status_check" CHECK ((status = ANY (ARRAY['healthy'::text, 'degraded'::text, 'down'::text, 'maintenance'::text, 'unknown'::text]))) not valid;

alter table "public"."service_health_status" validate constraint "service_health_status_status_check";

alter table "public"."service_incidents" add constraint "service_incidents_severity_check" CHECK ((severity = ANY (ARRAY['critical'::text, 'high'::text, 'medium'::text, 'low'::text]))) not valid;

alter table "public"."service_incidents" validate constraint "service_incidents_severity_check";

alter table "public"."service_incidents" add constraint "service_incidents_status_check" CHECK ((status = ANY (ARRAY['ongoing'::text, 'resolved'::text, 'investigating'::text]))) not valid;

alter table "public"."service_incidents" validate constraint "service_incidents_status_check";

alter table "public"."service_usage_limits" add constraint "service_usage_limits_check" CHECK ((hard_limit >= soft_limit)) not valid;

alter table "public"."service_usage_limits" validate constraint "service_usage_limits_check";

alter table "public"."service_usage_limits" add constraint "service_usage_limits_check1" CHECK ((period_end > period_start)) not valid;

alter table "public"."service_usage_limits" validate constraint "service_usage_limits_check1";

alter table "public"."service_usage_limits" add constraint "service_usage_limits_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."service_usage_limits" validate constraint "service_usage_limits_preschool_id_fkey";

alter table "public"."service_usage_limits" add constraint "service_usage_limits_preschool_id_service_name_period_start_key" UNIQUE using index "service_usage_limits_preschool_id_service_name_period_start_key";

alter table "public"."service_usage_limits" add constraint "service_usage_limits_soft_limit_check" CHECK ((soft_limit >= 0)) not valid;

alter table "public"."service_usage_limits" validate constraint "service_usage_limits_soft_limit_check";

alter table "public"."service_usage_limits" add constraint "service_usage_limits_usage_this_period_check" CHECK ((usage_this_period >= 0)) not valid;

alter table "public"."service_usage_limits" validate constraint "service_usage_limits_usage_this_period_check";

alter table "public"."sms_messages" add constraint "sms_messages_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."sms_messages" validate constraint "sms_messages_preschool_id_fkey";

alter table "public"."sms_messages" add constraint "sms_messages_provider_check" CHECK ((provider = ANY (ARRAY['twilio'::text, 'clicksend'::text]))) not valid;

alter table "public"."sms_messages" validate constraint "sms_messages_provider_check";

alter table "public"."sms_messages" add constraint "sms_messages_sent_by_user_id_fkey" FOREIGN KEY (sent_by_user_id) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."sms_messages" validate constraint "sms_messages_sent_by_user_id_fkey";

alter table "public"."sms_messages" add constraint "sms_messages_status_check" CHECK ((status = ANY (ARRAY['queued'::text, 'sending'::text, 'sent'::text, 'delivered'::text, 'failed'::text, 'undelivered'::text]))) not valid;

alter table "public"."sms_messages" validate constraint "sms_messages_status_check";

alter table "public"."sms_opt_outs" add constraint "sms_opt_outs_opt_out_method_check" CHECK ((opt_out_method = ANY (ARRAY['sms_reply'::text, 'app_settings'::text, 'admin'::text]))) not valid;

alter table "public"."sms_opt_outs" validate constraint "sms_opt_outs_opt_out_method_check";

alter table "public"."sms_opt_outs" add constraint "sms_opt_outs_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."sms_opt_outs" validate constraint "sms_opt_outs_preschool_id_fkey";

alter table "public"."sms_opt_outs" add constraint "sms_opt_outs_preschool_id_phone_number_key" UNIQUE using index "sms_opt_outs_preschool_id_phone_number_key";

alter table "public"."sound_alert_settings" add constraint "sound_alert_settings_alert_type_check" CHECK ((alert_type = ANY (ARRAY['message'::text, 'notification'::text, 'homework'::text, 'reminder'::text]))) not valid;

alter table "public"."sound_alert_settings" validate constraint "sound_alert_settings_alert_type_check";

alter table "public"."sound_alert_settings" add constraint "sound_alert_settings_user_id_alert_type_key" UNIQUE using index "sound_alert_settings_user_id_alert_type_key";

alter table "public"."sound_alert_settings" add constraint "sound_alert_settings_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."sound_alert_settings" validate constraint "sound_alert_settings_user_id_fkey";

alter table "public"."sound_alert_settings" add constraint "sound_alert_settings_volume_check" CHECK (((volume >= 0) AND (volume <= 100))) not valid;

alter table "public"."sound_alert_settings" validate constraint "sound_alert_settings_volume_check";

alter table "public"."standalone_users" add constraint "standalone_users_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."standalone_users" validate constraint "standalone_users_profile_id_fkey";

alter table "public"."standalone_users" add constraint "standalone_users_profile_id_key" UNIQUE using index "standalone_users_profile_id_key";

alter table "public"."standalone_users" add constraint "standalone_users_subscription_status_check" CHECK ((subscription_status = ANY (ARRAY['active'::text, 'cancelled'::text, 'expired'::text, 'suspended'::text]))) not valid;

alter table "public"."standalone_users" validate constraint "standalone_users_subscription_status_check";

alter table "public"."standalone_users" add constraint "standalone_users_subscription_tier_check" CHECK ((subscription_tier = ANY (ARRAY['free'::text, 'starter'::text, 'plus'::text, 'premium'::text, 'pro'::text]))) not valid;

alter table "public"."standalone_users" validate constraint "standalone_users_subscription_tier_check";

alter table "public"."standalone_users" add constraint "standalone_users_usage_type_check" CHECK ((usage_type = ANY (ARRAY['standalone'::text, 'freelance'::text, 'homeschool'::text, 'personal'::text, 'independent'::text]))) not valid;

alter table "public"."standalone_users" validate constraint "standalone_users_usage_type_check";

alter table "public"."standalone_users" add constraint "standalone_users_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."standalone_users" validate constraint "standalone_users_user_id_fkey";

alter table "public"."standalone_users" add constraint "standalone_users_user_id_key" UNIQUE using index "standalone_users_user_id_key";

alter table "public"."standalone_users" add constraint "standalone_users_user_type_check" CHECK ((user_type = ANY (ARRAY['parent'::text, 'teacher'::text, 'tutor'::text, 'student'::text, 'homeschool'::text, 'admin'::text]))) not valid;

alter table "public"."standalone_users" validate constraint "standalone_users_user_type_check";

alter table "public"."stem_progress" add constraint "stem_progress_category_check" CHECK ((category = ANY (ARRAY['ai'::text, 'robotics'::text, 'computer_literacy'::text]))) not valid;

alter table "public"."stem_progress" validate constraint "stem_progress_category_check";

alter table "public"."stem_progress" add constraint "stem_progress_engagement_score_check" CHECK (((engagement_score >= (0)::numeric) AND (engagement_score <= (100)::numeric))) not valid;

alter table "public"."stem_progress" validate constraint "stem_progress_engagement_score_check";

alter table "public"."stem_progress" add constraint "stem_progress_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."stem_progress" validate constraint "stem_progress_preschool_id_fkey";

alter table "public"."stem_progress" add constraint "stem_progress_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."stem_progress" validate constraint "stem_progress_student_id_fkey";

alter table "public"."stem_progress" add constraint "stem_progress_student_id_preschool_id_category_key" UNIQUE using index "stem_progress_student_id_preschool_id_category_key";

alter table "public"."student_achievements" add constraint "student_achievements_achievement_type_check" CHECK ((achievement_type = ANY (ARRAY['star'::text, 'badge'::text, 'sticker'::text, 'streak'::text, 'certificate'::text, 'level_up'::text, 'milestone'::text]))) not valid;

alter table "public"."student_achievements" validate constraint "student_achievements_achievement_type_check";

alter table "public"."student_achievements" add constraint "student_achievements_awarded_by_fkey" FOREIGN KEY (awarded_by) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."student_achievements" validate constraint "student_achievements_awarded_by_fkey";

alter table "public"."student_achievements" add constraint "student_achievements_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."student_achievements" validate constraint "student_achievements_preschool_id_fkey";

alter table "public"."student_achievements" add constraint "student_achievements_related_lesson_id_fkey" FOREIGN KEY (related_lesson_id) REFERENCES public.lessons(id) ON DELETE SET NULL not valid;

alter table "public"."student_achievements" validate constraint "student_achievements_related_lesson_id_fkey";

alter table "public"."student_achievements" add constraint "student_achievements_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."student_achievements" validate constraint "student_achievements_student_id_fkey";

alter table "public"."student_activity_feed" add constraint "student_activity_feed_activity_type_check" CHECK ((activity_type = ANY (ARRAY['learning'::text, 'play'::text, 'meal'::text, 'rest'::text, 'special'::text, 'milestone'::text, 'outdoor'::text, 'art'::text, 'music'::text, 'story'::text, 'social'::text]))) not valid;

alter table "public"."student_activity_feed" validate constraint "student_activity_feed_activity_type_check";

alter table "public"."student_activity_feed" add constraint "student_activity_feed_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.classes(id) ON DELETE SET NULL not valid;

alter table "public"."student_activity_feed" validate constraint "student_activity_feed_class_id_fkey";

alter table "public"."student_activity_feed" add constraint "student_activity_feed_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."student_activity_feed" validate constraint "student_activity_feed_preschool_id_fkey";

alter table "public"."student_activity_feed" add constraint "student_activity_feed_teacher_id_fkey" FOREIGN KEY (teacher_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."student_activity_feed" validate constraint "student_activity_feed_teacher_id_fkey";

alter table "public"."student_activity_feed" add constraint "student_activity_feed_visibility_check" CHECK ((visibility = ANY (ARRAY['parent_only'::text, 'class_parents'::text, 'all_parents'::text, 'private'::text]))) not valid;

alter table "public"."student_activity_feed" validate constraint "student_activity_feed_visibility_check";

alter table "public"."student_enrollments" add constraint "student_enrollments_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.classes(id) ON DELETE CASCADE not valid;

alter table "public"."student_enrollments" validate constraint "student_enrollments_class_id_fkey";

alter table "public"."student_enrollments" add constraint "student_enrollments_student_id_class_id_key" UNIQUE using index "student_enrollments_student_id_class_id_key";

alter table "public"."student_enrollments" add constraint "student_enrollments_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."student_enrollments" validate constraint "student_enrollments_student_id_fkey";

alter table "public"."student_fee_assignments" add constraint "student_fee_assignments_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.profiles(id) not valid;

alter table "public"."student_fee_assignments" validate constraint "student_fee_assignments_created_by_fkey";

alter table "public"."student_fee_assignments" add constraint "student_fee_assignments_fee_structure_id_fkey" FOREIGN KEY (fee_structure_id) REFERENCES public.school_fee_structures(id) ON DELETE CASCADE not valid;

alter table "public"."student_fee_assignments" validate constraint "student_fee_assignments_fee_structure_id_fkey";

alter table "public"."student_fee_assignments" add constraint "student_fee_assignments_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."student_fee_assignments" validate constraint "student_fee_assignments_preschool_id_fkey";

alter table "public"."student_fee_assignments" add constraint "student_fee_assignments_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'partial'::text, 'paid'::text, 'overdue'::text, 'waived'::text]))) not valid;

alter table "public"."student_fee_assignments" validate constraint "student_fee_assignments_status_check";

alter table "public"."student_fee_assignments" add constraint "student_fee_assignments_student_id_fee_structure_id_assigne_key" UNIQUE using index "student_fee_assignments_student_id_fee_structure_id_assigne_key";

alter table "public"."student_fee_assignments" add constraint "student_fee_assignments_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."student_fee_assignments" validate constraint "student_fee_assignments_student_id_fkey";

alter table "public"."student_fees" add constraint "student_fees_fee_structure_id_fkey" FOREIGN KEY (fee_structure_id) REFERENCES public.fee_structures(id) ON DELETE CASCADE not valid;

alter table "public"."student_fees" validate constraint "student_fees_fee_structure_id_fkey";

alter table "public"."student_fees" add constraint "student_fees_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'partially_paid'::text, 'paid'::text, 'overdue'::text, 'waived'::text]))) not valid;

alter table "public"."student_fees" validate constraint "student_fees_status_check";

alter table "public"."student_fees" add constraint "student_fees_student_id_fee_structure_id_due_date_key" UNIQUE using index "student_fees_student_id_fee_structure_id_due_date_key";

alter table "public"."student_fees" add constraint "student_fees_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."student_fees" validate constraint "student_fees_student_id_fkey";

alter table "public"."student_groups" add constraint "student_groups_added_by_fkey" FOREIGN KEY (added_by) REFERENCES public.profiles(id) ON DELETE RESTRICT not valid;

alter table "public"."student_groups" validate constraint "student_groups_added_by_fkey";

alter table "public"."student_groups" add constraint "student_groups_group_id_fkey" FOREIGN KEY (group_id) REFERENCES public.groups(id) ON DELETE CASCADE not valid;

alter table "public"."student_groups" validate constraint "student_groups_group_id_fkey";

alter table "public"."student_groups" add constraint "student_groups_group_role_check" CHECK ((group_role = ANY (ARRAY['member'::text, 'leader'::text, 'coordinator'::text]))) not valid;

alter table "public"."student_groups" validate constraint "student_groups_group_role_check";

alter table "public"."student_groups" add constraint "student_groups_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."student_groups" validate constraint "student_groups_student_id_fkey";

alter table "public"."student_groups" add constraint "student_groups_student_id_group_id_key" UNIQUE using index "student_groups_student_id_group_id_key";

alter table "public"."student_parent_relationships" add constraint "fk_parent" FOREIGN KEY (parent_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."student_parent_relationships" validate constraint "fk_parent";

alter table "public"."student_parent_relationships" add constraint "fk_student" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."student_parent_relationships" validate constraint "fk_student";

alter table "public"."student_parent_relationships" add constraint "student_parent_relationships_student_id_parent_id_key" UNIQUE using index "student_parent_relationships_student_id_parent_id_key";

alter table "public"."student_progress" add constraint "student_progress_alert_level_check" CHECK ((alert_level = ANY (ARRAY['none'::text, 'low'::text, 'medium'::text, 'high'::text]))) not valid;

alter table "public"."student_progress" validate constraint "student_progress_alert_level_check";

alter table "public"."student_progress" add constraint "student_progress_assignments_completed_check" CHECK ((assignments_completed >= 0)) not valid;

alter table "public"."student_progress" validate constraint "student_progress_assignments_completed_check";

alter table "public"."student_progress" add constraint "student_progress_assignments_late_check" CHECK ((assignments_late >= 0)) not valid;

alter table "public"."student_progress" validate constraint "student_progress_assignments_late_check";

alter table "public"."student_progress" add constraint "student_progress_assignments_missing_check" CHECK ((assignments_missing >= 0)) not valid;

alter table "public"."student_progress" validate constraint "student_progress_assignments_missing_check";

alter table "public"."student_progress" add constraint "student_progress_assignments_total_check" CHECK ((assignments_total >= 0)) not valid;

alter table "public"."student_progress" validate constraint "student_progress_assignments_total_check";

alter table "public"."student_progress" add constraint "student_progress_average_grade_check" CHECK (((average_grade >= (0)::numeric) AND (average_grade <= (100)::numeric))) not valid;

alter table "public"."student_progress" validate constraint "student_progress_average_grade_check";

alter table "public"."student_progress" add constraint "student_progress_calculated_by_fkey" FOREIGN KEY (calculated_by) REFERENCES public.profiles(id) ON DELETE RESTRICT not valid;

alter table "public"."student_progress" validate constraint "student_progress_calculated_by_fkey";

alter table "public"."student_progress" add constraint "student_progress_course_id_fkey" FOREIGN KEY (course_id) REFERENCES public.courses(id) ON DELETE CASCADE not valid;

alter table "public"."student_progress" validate constraint "student_progress_course_id_fkey";

alter table "public"."student_progress" add constraint "student_progress_course_id_student_id_key" UNIQUE using index "student_progress_course_id_student_id_key";

alter table "public"."student_progress" add constraint "student_progress_engagement_score_check" CHECK (((engagement_score >= 0) AND (engagement_score <= 100))) not valid;

alter table "public"."student_progress" validate constraint "student_progress_engagement_score_check";

alter table "public"."student_progress" add constraint "student_progress_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."student_progress" validate constraint "student_progress_student_id_fkey";

alter table "public"."student_progress" add constraint "student_progress_trend_direction_check" CHECK ((trend_direction = ANY (ARRAY['improving'::text, 'declining'::text, 'stable'::text]))) not valid;

alter table "public"."student_progress" validate constraint "student_progress_trend_direction_check";

alter table "public"."student_streaks" add constraint "student_streaks_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."student_streaks" validate constraint "student_streaks_preschool_id_fkey";

alter table "public"."student_streaks" add constraint "student_streaks_streak_type_check" CHECK ((streak_type = ANY (ARRAY['attendance'::text, 'homework'::text, 'activity'::text, 'login'::text]))) not valid;

alter table "public"."student_streaks" validate constraint "student_streaks_streak_type_check";

alter table "public"."student_streaks" add constraint "student_streaks_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."student_streaks" validate constraint "student_streaks_student_id_fkey";

alter table "public"."student_streaks" add constraint "student_streaks_student_id_streak_type_key" UNIQUE using index "student_streaks_student_id_streak_type_key";

alter table "public"."students" add constraint "students_age_group_id_fkey" FOREIGN KEY (age_group_id) REFERENCES public.age_groups(id) ON DELETE SET NULL not valid;

alter table "public"."students" validate constraint "students_age_group_id_fkey";

alter table "public"."students" add constraint "students_age_group_ref_fkey" FOREIGN KEY (age_group_ref) REFERENCES public.age_groups(id) not valid;

alter table "public"."students" validate constraint "students_age_group_ref_fkey";

alter table "public"."students" add constraint "students_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.classes(id) ON DELETE SET NULL not valid;

alter table "public"."students" validate constraint "students_class_id_fkey";

alter table "public"."students" add constraint "students_guardian_id_fkey" FOREIGN KEY (guardian_id) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."students" validate constraint "students_guardian_id_fkey";

alter table "public"."students" add constraint "students_must_have_tenant" CHECK (((preschool_id IS NOT NULL) OR (organization_id IS NOT NULL))) not valid;

alter table "public"."students" validate constraint "students_must_have_tenant";

alter table "public"."students" add constraint "students_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."students" validate constraint "students_organization_id_fkey";

alter table "public"."students" add constraint "students_parent_id_fkey" FOREIGN KEY (parent_id) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."students" validate constraint "students_parent_id_fkey";

alter table "public"."students" add constraint "students_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."students" validate constraint "students_preschool_id_fkey";

alter table "public"."students" add constraint "students_status_check" CHECK ((status = ANY (ARRAY['active'::text, 'inactive'::text, 'graduated'::text, 'withdrawn'::text]))) not valid;

alter table "public"."students" validate constraint "students_status_check";

alter table "public"."students" add constraint "students_student_id_key" UNIQUE using index "students_student_id_key";

alter table "public"."study_groups" add constraint "study_groups_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."study_groups" validate constraint "study_groups_created_by_fkey";

alter table "public"."study_groups" add constraint "study_groups_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."study_groups" validate constraint "study_groups_organization_id_fkey";

alter table "public"."study_groups" add constraint "study_groups_program_id_fkey" FOREIGN KEY (program_id) REFERENCES public.courses(id) ON DELETE SET NULL not valid;

alter table "public"."study_groups" validate constraint "study_groups_program_id_fkey";

alter table "public"."submissions" add constraint "submissions_assignment_id_fkey" FOREIGN KEY (assignment_id) REFERENCES public.assignments(id) ON DELETE CASCADE not valid;

alter table "public"."submissions" validate constraint "submissions_assignment_id_fkey";

alter table "public"."submissions" add constraint "submissions_assignment_id_student_id_attempt_number_key" UNIQUE using index "submissions_assignment_id_student_id_attempt_number_key";

alter table "public"."submissions" add constraint "submissions_attempt_number_check" CHECK ((attempt_number > 0)) not valid;

alter table "public"."submissions" validate constraint "submissions_attempt_number_check";

alter table "public"."submissions" add constraint "submissions_content_check" CHECK ((((submission_type = 'text'::text) AND (content IS NOT NULL)) OR ((submission_type = ANY (ARRAY['file'::text, 'url'::text, 'multiple'::text])) AND (attachments <> '[]'::jsonb)) OR (is_draft = true))) not valid;

alter table "public"."submissions" validate constraint "submissions_content_check";

alter table "public"."submissions" add constraint "submissions_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."submissions" validate constraint "submissions_student_id_fkey";

alter table "public"."submissions" add constraint "submissions_submission_type_check" CHECK ((submission_type = ANY (ARRAY['text'::text, 'file'::text, 'url'::text, 'multiple'::text]))) not valid;

alter table "public"."submissions" validate constraint "submissions_submission_type_check";

alter table "public"."subscription_plans" add constraint "subscription_plans_tier_key" UNIQUE using index "subscription_plans_tier_key";

alter table "public"."subscription_seats" add constraint "fk_subscription_seats_preschool_id" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."subscription_seats" validate constraint "fk_subscription_seats_preschool_id";

alter table "public"."subscription_seats" add constraint "subscription_seats_assigned_by_fkey" FOREIGN KEY (assigned_by) REFERENCES public.users(id) not valid;

alter table "public"."subscription_seats" validate constraint "subscription_seats_assigned_by_fkey";

alter table "public"."subscription_seats" add constraint "subscription_seats_revoked_by_fkey" FOREIGN KEY (revoked_by) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."subscription_seats" validate constraint "subscription_seats_revoked_by_fkey";

alter table "public"."subscription_seats" add constraint "subscription_seats_revoked_consistency" CHECK (((revoked_at IS NULL) OR (revoked_by IS NOT NULL))) not valid;

alter table "public"."subscription_seats" validate constraint "subscription_seats_revoked_consistency";

alter table "public"."subscription_seats" add constraint "subscription_seats_subscription_id_fkey" FOREIGN KEY (subscription_id) REFERENCES public.subscriptions(id) ON DELETE CASCADE not valid;

alter table "public"."subscription_seats" validate constraint "subscription_seats_subscription_id_fkey";

alter table "public"."subscription_seats" add constraint "subscription_seats_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."subscription_seats" validate constraint "subscription_seats_user_id_fkey";

alter table "public"."subscription_usage" add constraint "subscription_usage_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."subscription_usage" validate constraint "subscription_usage_school_id_fkey";

alter table "public"."subscription_usage" add constraint "subscription_usage_subscription_id_fkey" FOREIGN KEY (subscription_id) REFERENCES public.subscriptions(id) ON DELETE CASCADE not valid;

alter table "public"."subscription_usage" validate constraint "subscription_usage_subscription_id_fkey";

alter table "public"."subscription_usage" add constraint "subscription_usage_subscription_id_usage_type_period_start_key" UNIQUE using index "subscription_usage_subscription_id_usage_type_period_start_key";

alter table "public"."subscriptions" add constraint "subscriptions_end_date_check" CHECK (((end_date IS NULL) OR (end_date > start_date))) not valid;

alter table "public"."subscriptions" validate constraint "subscriptions_end_date_check";

alter table "public"."subscriptions" add constraint "subscriptions_owner_check" CHECK ((((owner_type = 'school'::text) AND (school_id IS NOT NULL) AND (user_id IS NULL)) OR ((owner_type = 'user'::text) AND (user_id IS NOT NULL) AND (school_id IS NULL)))) not valid;

alter table "public"."subscriptions" validate constraint "subscriptions_owner_check";

alter table "public"."subscriptions" add constraint "subscriptions_owner_type_check" CHECK ((owner_type = ANY (ARRAY['school'::text, 'user'::text]))) not valid;

alter table "public"."subscriptions" validate constraint "subscriptions_owner_type_check";

alter table "public"."subscriptions" add constraint "subscriptions_plan_id_fkey" FOREIGN KEY (plan_id) REFERENCES public.subscription_plans(id) not valid;

alter table "public"."subscriptions" validate constraint "subscriptions_plan_id_fkey";

alter table "public"."subscriptions" add constraint "subscriptions_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."subscriptions" validate constraint "subscriptions_school_id_fkey";

alter table "public"."subscriptions" add constraint "subscriptions_seats_check" CHECK ((seats_used <= seats_total)) not valid;

alter table "public"."subscriptions" validate constraint "subscriptions_seats_check";

alter table "public"."subscriptions" add constraint "subscriptions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."subscriptions" validate constraint "subscriptions_user_id_fkey";

alter table "public"."superadmin_agent_executions" add constraint "superadmin_agent_executions_agent_id_fkey" FOREIGN KEY (agent_id) REFERENCES public.superadmin_ai_agents(id) ON DELETE CASCADE not valid;

alter table "public"."superadmin_agent_executions" validate constraint "superadmin_agent_executions_agent_id_fkey";

alter table "public"."superadmin_agent_executions" add constraint "superadmin_agent_executions_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'running'::text, 'completed'::text, 'failed'::text, 'cancelled'::text, 'timeout'::text]))) not valid;

alter table "public"."superadmin_agent_executions" validate constraint "superadmin_agent_executions_status_check";

alter table "public"."superadmin_agent_executions" add constraint "superadmin_agent_executions_trigger_check" CHECK ((trigger_type = ANY (ARRAY['manual'::text, 'scheduled'::text, 'webhook'::text, 'system'::text, 'cascade'::text]))) not valid;

alter table "public"."superadmin_agent_executions" validate constraint "superadmin_agent_executions_trigger_check";

alter table "public"."superadmin_agent_executions" add constraint "superadmin_agent_executions_triggered_by_fkey" FOREIGN KEY (triggered_by) REFERENCES auth.users(id) not valid;

alter table "public"."superadmin_agent_executions" validate constraint "superadmin_agent_executions_triggered_by_fkey";

alter table "public"."superadmin_ai_agents" add constraint "superadmin_ai_agents_status_check" CHECK ((status = ANY (ARRAY['active'::text, 'idle'::text, 'running'::text, 'error'::text, 'disabled'::text, 'maintenance'::text]))) not valid;

alter table "public"."superadmin_ai_agents" validate constraint "superadmin_ai_agents_status_check";

alter table "public"."superadmin_ai_agents" add constraint "superadmin_ai_agents_type_check" CHECK ((agent_type = ANY (ARRAY['content_moderation'::text, 'usage_optimization'::text, 'churn_prediction'::text, 'revenue_forecasting'::text, 'support_automation'::text, 'security_scanning'::text, 'database_maintenance'::text, 'backup_management'::text, 'deployment_automation'::text, 'code_analysis'::text, 'custom'::text]))) not valid;

alter table "public"."superadmin_ai_agents" validate constraint "superadmin_ai_agents_type_check";

alter table "public"."superadmin_audit_log" add constraint "superadmin_audit_log_superadmin_user_id_fkey" FOREIGN KEY (superadmin_user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."superadmin_audit_log" validate constraint "superadmin_audit_log_superadmin_user_id_fkey";

alter table "public"."superadmin_autonomous_tasks" add constraint "superadmin_autonomous_tasks_status_check" CHECK (((last_execution_status IS NULL) OR (last_execution_status = ANY (ARRAY['success'::text, 'pending'::text, 'failed'::text, 'running'::text, 'skipped'::text])))) not valid;

alter table "public"."superadmin_autonomous_tasks" validate constraint "superadmin_autonomous_tasks_status_check";

alter table "public"."superadmin_autonomous_tasks" add constraint "superadmin_autonomous_tasks_type_check" CHECK ((task_type = ANY (ARRAY['database_backup'::text, 'analytics_report'::text, 'quota_rebalance'::text, 'session_cleanup'::text, 'usage_alerts'::text, 'security_scan'::text, 'content_review'::text, 'performance_optimization'::text, 'log_rotation'::text, 'cache_purge'::text, 'custom'::text]))) not valid;

alter table "public"."superadmin_autonomous_tasks" validate constraint "superadmin_autonomous_tasks_type_check";

alter table "public"."superadmin_command_log" add constraint "superadmin_command_log_admin_id_fkey" FOREIGN KEY (admin_id) REFERENCES auth.users(id) not valid;

alter table "public"."superadmin_command_log" validate constraint "superadmin_command_log_admin_id_fkey";

alter table "public"."superadmin_command_log" add constraint "superadmin_command_log_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'processing'::text, 'completed'::text, 'failed'::text, 'cancelled'::text]))) not valid;

alter table "public"."superadmin_command_log" validate constraint "superadmin_command_log_status_check";

alter table "public"."superadmin_command_log" add constraint "superadmin_command_log_type_check" CHECK ((command_type = ANY (ARRAY['query'::text, 'analysis'::text, 'modification'::text, 'bulk_operation'::text, 'deployment'::text, 'code_change'::text, 'database_operation'::text, 'agent_control'::text, 'system_config'::text, 'report_generation'::text]))) not valid;

alter table "public"."superadmin_command_log" validate constraint "superadmin_command_log_type_check";

alter table "public"."superadmin_compliance_reports" add constraint "superadmin_compliance_reports_generated_by_fkey" FOREIGN KEY (generated_by) REFERENCES auth.users(id) ON DELETE RESTRICT not valid;

alter table "public"."superadmin_compliance_reports" validate constraint "superadmin_compliance_reports_generated_by_fkey";

alter table "public"."superadmin_compliance_reports" add constraint "superadmin_compliance_reports_tenant_id_fkey" FOREIGN KEY (tenant_id) REFERENCES public.tenants(id) ON DELETE CASCADE not valid;

alter table "public"."superadmin_compliance_reports" validate constraint "superadmin_compliance_reports_tenant_id_fkey";

alter table "public"."superadmin_compliance_reports" add constraint "valid_date_range" CHECK ((date_range_end > date_range_start)) not valid;

alter table "public"."superadmin_compliance_reports" validate constraint "valid_date_range";

alter table "public"."superadmin_compliance_reports" add constraint "valid_generation_time" CHECK (((generated_at IS NULL) OR (generated_at >= created_at))) not valid;

alter table "public"."superadmin_compliance_reports" validate constraint "valid_generation_time";

alter table "public"."superadmin_integrations" add constraint "superadmin_integrations_type_check" CHECK ((integration_type = ANY (ARRAY['github'::text, 'eas_expo'::text, 'vercel'::text, 'sentry'::text, 'posthog'::text, 'stripe'::text, 'payfast'::text, 'whatsapp'::text, 'sendgrid'::text, 'custom'::text]))) not valid;

alter table "public"."superadmin_integrations" validate constraint "superadmin_integrations_type_check";

alter table "public"."superadmin_notification_deliveries" add constraint "superadmin_notification_deliveries_notification_id_fkey" FOREIGN KEY (notification_id) REFERENCES public.superadmin_notifications(id) ON DELETE CASCADE not valid;

alter table "public"."superadmin_notification_deliveries" validate constraint "superadmin_notification_deliveries_notification_id_fkey";

alter table "public"."superadmin_notification_rules" add constraint "superadmin_notification_rules_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.profiles(id) not valid;

alter table "public"."superadmin_notification_rules" validate constraint "superadmin_notification_rules_created_by_fkey";

alter table "public"."superadmin_notification_rules" add constraint "superadmin_notification_rules_rule_name_key" UNIQUE using index "superadmin_notification_rules_rule_name_key";

alter table "public"."superadmin_notifications" add constraint "superadmin_notifications_admin_id_fkey" FOREIGN KEY (admin_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."superadmin_notifications" validate constraint "superadmin_notifications_admin_id_fkey";

alter table "public"."superadmin_notifications" add constraint "superadmin_notifications_tenant_id_fkey" FOREIGN KEY (tenant_id) REFERENCES public.tenants(id) ON DELETE CASCADE not valid;

alter table "public"."superadmin_notifications" validate constraint "superadmin_notifications_tenant_id_fkey";

alter table "public"."superadmin_platform_insights" add constraint "superadmin_platform_insights_dismissed_by_fkey" FOREIGN KEY (dismissed_by) REFERENCES auth.users(id) not valid;

alter table "public"."superadmin_platform_insights" validate constraint "superadmin_platform_insights_dismissed_by_fkey";

alter table "public"."superadmin_platform_insights" add constraint "superadmin_platform_insights_priority_check" CHECK ((priority = ANY (ARRAY['critical'::text, 'high'::text, 'medium'::text, 'low'::text]))) not valid;

alter table "public"."superadmin_platform_insights" validate constraint "superadmin_platform_insights_priority_check";

alter table "public"."superadmin_platform_insights" add constraint "superadmin_platform_insights_type_check" CHECK ((insight_type = ANY (ARRAY['warning'::text, 'opportunity'::text, 'action'::text, 'info'::text, 'critical'::text, 'success'::text]))) not valid;

alter table "public"."superadmin_platform_insights" validate constraint "superadmin_platform_insights_type_check";

alter table "public"."superadmin_role_assignments" add constraint "active_role_not_revoked" CHECK (((is_active = false) OR (revoked_at IS NULL))) not valid;

alter table "public"."superadmin_role_assignments" validate constraint "active_role_not_revoked";

alter table "public"."superadmin_role_assignments" add constraint "superadmin_role_assignments_admin_id_fkey" FOREIGN KEY (admin_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."superadmin_role_assignments" validate constraint "superadmin_role_assignments_admin_id_fkey";

alter table "public"."superadmin_role_assignments" add constraint "superadmin_role_assignments_assigned_by_fkey" FOREIGN KEY (assigned_by) REFERENCES auth.users(id) ON DELETE RESTRICT not valid;

alter table "public"."superadmin_role_assignments" validate constraint "superadmin_role_assignments_assigned_by_fkey";

alter table "public"."superadmin_role_assignments" add constraint "superadmin_role_assignments_revoked_by_fkey" FOREIGN KEY (revoked_by) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."superadmin_role_assignments" validate constraint "superadmin_role_assignments_revoked_by_fkey";

alter table "public"."superadmin_role_assignments" add constraint "superadmin_role_assignments_tenant_id_fkey" FOREIGN KEY (tenant_id) REFERENCES public.tenants(id) ON DELETE CASCADE not valid;

alter table "public"."superadmin_role_assignments" validate constraint "superadmin_role_assignments_tenant_id_fkey";

alter table "public"."superadmin_role_assignments" add constraint "valid_assignment_period" CHECK (((valid_until IS NULL) OR (valid_until > valid_from))) not valid;

alter table "public"."superadmin_role_assignments" validate constraint "valid_assignment_period";

alter table "public"."superadmin_session_management" add constraint "superadmin_session_management_admin_id_fkey" FOREIGN KEY (admin_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."superadmin_session_management" validate constraint "superadmin_session_management_admin_id_fkey";

alter table "public"."superadmin_session_management" add constraint "superadmin_session_management_tenant_id_fkey" FOREIGN KEY (tenant_id) REFERENCES public.tenants(id) ON DELETE CASCADE not valid;

alter table "public"."superadmin_session_management" validate constraint "superadmin_session_management_tenant_id_fkey";

alter table "public"."superadmin_session_management" add constraint "superadmin_session_management_terminated_by_fkey" FOREIGN KEY (terminated_by) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."superadmin_session_management" validate constraint "superadmin_session_management_terminated_by_fkey";

alter table "public"."superadmin_user_actions" add constraint "superadmin_user_actions_admin_id_fkey" FOREIGN KEY (admin_id) REFERENCES auth.users(id) ON DELETE RESTRICT not valid;

alter table "public"."superadmin_user_actions" validate constraint "superadmin_user_actions_admin_id_fkey";

alter table "public"."superadmin_user_actions" add constraint "superadmin_user_actions_target_user_id_fkey" FOREIGN KEY (target_user_id) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."superadmin_user_actions" validate constraint "superadmin_user_actions_target_user_id_fkey";

alter table "public"."superadmin_user_actions" add constraint "superadmin_user_actions_tenant_id_fkey" FOREIGN KEY (tenant_id) REFERENCES public.tenants(id) ON DELETE CASCADE not valid;

alter table "public"."superadmin_user_actions" validate constraint "superadmin_user_actions_tenant_id_fkey";

alter table "public"."superadmin_user_deletion_requests" add constraint "superadmin_user_deletion_requests_requester_id_fkey" FOREIGN KEY (requester_id) REFERENCES auth.users(id) ON DELETE RESTRICT not valid;

alter table "public"."superadmin_user_deletion_requests" validate constraint "superadmin_user_deletion_requests_requester_id_fkey";

alter table "public"."superadmin_user_deletion_requests" add constraint "superadmin_user_deletion_requests_tenant_id_fkey" FOREIGN KEY (tenant_id) REFERENCES public.tenants(id) ON DELETE CASCADE not valid;

alter table "public"."superadmin_user_deletion_requests" validate constraint "superadmin_user_deletion_requests_tenant_id_fkey";

alter table "public"."superadmin_user_deletion_requests" add constraint "superadmin_user_deletion_requests_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."superadmin_user_deletion_requests" validate constraint "superadmin_user_deletion_requests_user_id_fkey";

alter table "public"."superadmin_user_deletion_requests" add constraint "valid_completion_time" CHECK (((completed_at IS NULL) OR (completed_at >= started_at))) not valid;

alter table "public"."superadmin_user_deletion_requests" validate constraint "valid_completion_time";

alter table "public"."superadmin_user_deletion_requests" add constraint "valid_scheduled_time" CHECK (((scheduled_for IS NULL) OR (scheduled_for > now()))) not valid;

alter table "public"."superadmin_user_deletion_requests" validate constraint "valid_scheduled_time";

alter table "public"."superadmin_user_risk_assessments" add constraint "superadmin_user_risk_assessments_assessed_by_fkey" FOREIGN KEY (assessed_by) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."superadmin_user_risk_assessments" validate constraint "superadmin_user_risk_assessments_assessed_by_fkey";

alter table "public"."superadmin_user_risk_assessments" add constraint "superadmin_user_risk_assessments_risk_score_check" CHECK (((risk_score >= 0) AND (risk_score <= 100))) not valid;

alter table "public"."superadmin_user_risk_assessments" validate constraint "superadmin_user_risk_assessments_risk_score_check";

alter table "public"."superadmin_user_risk_assessments" add constraint "superadmin_user_risk_assessments_tenant_id_fkey" FOREIGN KEY (tenant_id) REFERENCES public.tenants(id) ON DELETE CASCADE not valid;

alter table "public"."superadmin_user_risk_assessments" validate constraint "superadmin_user_risk_assessments_tenant_id_fkey";

alter table "public"."superadmin_user_risk_assessments" add constraint "superadmin_user_risk_assessments_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."superadmin_user_risk_assessments" validate constraint "superadmin_user_risk_assessments_user_id_fkey";

alter table "public"."support_tickets" add constraint "support_tickets_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE SET NULL not valid;

alter table "public"."support_tickets" validate constraint "support_tickets_preschool_id_fkey";

alter table "public"."support_tickets" add constraint "support_tickets_priority_check" CHECK ((priority = ANY (ARRAY['low'::text, 'medium'::text, 'high'::text, 'urgent'::text]))) not valid;

alter table "public"."support_tickets" validate constraint "support_tickets_priority_check";

alter table "public"."support_tickets" add constraint "support_tickets_status_check" CHECK ((status = ANY (ARRAY['open'::text, 'in_progress'::text, 'resolved'::text, 'closed'::text]))) not valid;

alter table "public"."support_tickets" validate constraint "support_tickets_status_check";

alter table "public"."support_tickets" add constraint "support_tickets_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."support_tickets" validate constraint "support_tickets_user_id_fkey";

alter table "public"."sync_logs" add constraint "sync_logs_sync_direction_check" CHECK ((sync_direction = ANY (ARRAY['edusite_to_edudash'::text, 'edudash_to_edusite'::text]))) not valid;

alter table "public"."sync_logs" validate constraint "sync_logs_sync_direction_check";

alter table "public"."sync_logs" add constraint "sync_logs_sync_type_check" CHECK ((sync_type = ANY (ARRAY['new_registration'::text, 'status_update'::text, 'manual_sync'::text]))) not valid;

alter table "public"."sync_logs" validate constraint "sync_logs_sync_type_check";

alter table "public"."system_settings" add constraint "system_settings_key_key" UNIQUE using index "system_settings_key_key";

alter table "public"."teacher_ai_allocations" add constraint "positive_allocations" CHECK (((((allocated_quotas ->> 'claude_messages'::text))::integer >= 0) AND (((allocated_quotas ->> 'content_generation'::text))::integer >= 0) AND (((allocated_quotas ->> 'assessment_ai'::text))::integer >= 0))) not valid;

alter table "public"."teacher_ai_allocations" validate constraint "positive_allocations";

alter table "public"."teacher_ai_allocations" add constraint "teacher_ai_allocations_allocated_by_fkey" FOREIGN KEY (allocated_by) REFERENCES public.users(id) not valid;

alter table "public"."teacher_ai_allocations" validate constraint "teacher_ai_allocations_allocated_by_fkey";

alter table "public"."teacher_ai_allocations" add constraint "teacher_ai_allocations_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."teacher_ai_allocations" validate constraint "teacher_ai_allocations_preschool_id_fkey";

alter table "public"."teacher_ai_allocations" add constraint "teacher_ai_allocations_preschool_id_user_id_period_start_key" UNIQUE using index "teacher_ai_allocations_preschool_id_user_id_period_start_key";

alter table "public"."teacher_ai_allocations" add constraint "teacher_ai_allocations_priority_level_check" CHECK ((priority_level = ANY (ARRAY['low'::text, 'normal'::text, 'high'::text]))) not valid;

alter table "public"."teacher_ai_allocations" validate constraint "teacher_ai_allocations_priority_level_check";

alter table "public"."teacher_ai_allocations" add constraint "teacher_ai_allocations_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."teacher_ai_allocations" validate constraint "teacher_ai_allocations_user_id_fkey";

alter table "public"."teacher_ai_allocations" add constraint "usage_within_allocation" CHECK (((((used_quotas ->> 'claude_messages'::text))::integer <= ((allocated_quotas ->> 'claude_messages'::text))::integer) AND (((used_quotas ->> 'content_generation'::text))::integer <= ((allocated_quotas ->> 'content_generation'::text))::integer) AND (((used_quotas ->> 'assessment_ai'::text))::integer <= ((allocated_quotas ->> 'assessment_ai'::text))::integer))) not valid;

alter table "public"."teacher_ai_allocations" validate constraint "usage_within_allocation";

alter table "public"."teacher_class_codes" add constraint "teacher_class_codes_code_key" UNIQUE using index "teacher_class_codes_code_key";

alter table "public"."teacher_class_codes" add constraint "teacher_class_codes_teacher_id_fkey" FOREIGN KEY (teacher_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."teacher_class_codes" validate constraint "teacher_class_codes_teacher_id_fkey";

alter table "public"."teacher_invitations" add constraint "teacher_invitations_invitation_code_key" UNIQUE using index "teacher_invitations_invitation_code_key";

alter table "public"."teacher_invitations" add constraint "teacher_invitations_invited_by_fkey" FOREIGN KEY (invited_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."teacher_invitations" validate constraint "teacher_invitations_invited_by_fkey";

alter table "public"."teacher_invitations" add constraint "teacher_invitations_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."teacher_invitations" validate constraint "teacher_invitations_preschool_id_fkey";

alter table "public"."teacher_invitations" add constraint "teacher_invitations_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'accepted'::text, 'expired'::text, 'cancelled'::text]))) not valid;

alter table "public"."teacher_invitations" validate constraint "teacher_invitations_status_check";

alter table "public"."teacher_invites" add constraint "teacher_invites_accepted_by_fkey" FOREIGN KEY (accepted_by) REFERENCES auth.users(id) not valid;

alter table "public"."teacher_invites" validate constraint "teacher_invites_accepted_by_fkey";

alter table "public"."teacher_invites" add constraint "teacher_invites_invited_by_fkey" FOREIGN KEY (invited_by) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."teacher_invites" validate constraint "teacher_invites_invited_by_fkey";

alter table "public"."teacher_invites" add constraint "teacher_invites_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."teacher_invites" validate constraint "teacher_invites_school_id_fkey";

alter table "public"."teacher_invites" add constraint "teacher_invites_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'accepted'::text, 'revoked'::text, 'expired'::text]))) not valid;

alter table "public"."teacher_invites" validate constraint "teacher_invites_status_check";

alter table "public"."teacher_invites" add constraint "teacher_invites_token_key" UNIQUE using index "teacher_invites_token_key";

alter table "public"."teacher_performance_metrics" add constraint "teacher_performance_metrics_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."teacher_performance_metrics" validate constraint "teacher_performance_metrics_preschool_id_fkey";

alter table "public"."teacher_performance_metrics" add constraint "teacher_performance_metrics_recorded_by_fkey" FOREIGN KEY (recorded_by) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."teacher_performance_metrics" validate constraint "teacher_performance_metrics_recorded_by_fkey";

alter table "public"."teacher_performance_metrics" add constraint "teacher_performance_metrics_teacher_id_fkey" FOREIGN KEY (teacher_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."teacher_performance_metrics" validate constraint "teacher_performance_metrics_teacher_id_fkey";

alter table "public"."teacher_performance_metrics" add constraint "teacher_performance_metrics_teacher_id_metric_period_start__key" UNIQUE using index "teacher_performance_metrics_teacher_id_metric_period_start__key";

alter table "public"."teacher_student_notes" add constraint "teacher_student_notes_acknowledged_by_fkey" FOREIGN KEY (acknowledged_by) REFERENCES auth.users(id) not valid;

alter table "public"."teacher_student_notes" validate constraint "teacher_student_notes_acknowledged_by_fkey";

alter table "public"."teacher_student_notes" add constraint "teacher_student_notes_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.classes(id) ON DELETE SET NULL not valid;

alter table "public"."teacher_student_notes" validate constraint "teacher_student_notes_class_id_fkey";

alter table "public"."teacher_student_notes" add constraint "teacher_student_notes_note_type_check" CHECK ((note_type = ANY (ARRAY['highlight'::text, 'concern'::text, 'achievement'::text, 'reminder'::text, 'general'::text]))) not valid;

alter table "public"."teacher_student_notes" validate constraint "teacher_student_notes_note_type_check";

alter table "public"."teacher_student_notes" add constraint "teacher_student_notes_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."teacher_student_notes" validate constraint "teacher_student_notes_preschool_id_fkey";

alter table "public"."teacher_student_notes" add constraint "teacher_student_notes_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."teacher_student_notes" validate constraint "teacher_student_notes_student_id_fkey";

alter table "public"."teacher_student_notes" add constraint "teacher_student_notes_teacher_id_fkey" FOREIGN KEY (teacher_id) REFERENCES auth.users(id) not valid;

alter table "public"."teacher_student_notes" validate constraint "teacher_student_notes_teacher_id_fkey";

alter table "public"."teachers" add constraint "teachers_auth_user_id_fkey" FOREIGN KEY (auth_user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."teachers" validate constraint "teachers_auth_user_id_fkey";

alter table "public"."teachers" add constraint "teachers_contracts_uploaded_by_fkey" FOREIGN KEY (contracts_uploaded_by) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."teachers" validate constraint "teachers_contracts_uploaded_by_fkey";

alter table "public"."teachers" add constraint "teachers_cv_uploaded_by_fkey" FOREIGN KEY (cv_uploaded_by) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."teachers" validate constraint "teachers_cv_uploaded_by_fkey";

alter table "public"."teachers" add constraint "teachers_id_copy_uploaded_by_fkey" FOREIGN KEY (id_copy_uploaded_by) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."teachers" validate constraint "teachers_id_copy_uploaded_by_fkey";

alter table "public"."teachers" add constraint "teachers_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."teachers" validate constraint "teachers_preschool_id_fkey";

alter table "public"."teachers" add constraint "teachers_qualifications_uploaded_by_fkey" FOREIGN KEY (qualifications_uploaded_by) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."teachers" validate constraint "teachers_qualifications_uploaded_by_fkey";

alter table "public"."teachers" add constraint "teachers_role_check" CHECK ((role = ANY (ARRAY['teacher'::text, 'principal'::text, 'admin'::text, 'assistant'::text]))) not valid;

alter table "public"."teachers" validate constraint "teachers_role_check";

alter table "public"."teachers" add constraint "teachers_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."teachers" validate constraint "teachers_user_id_fkey";

alter table "public"."template_approvals" add constraint "approval_requires_reviewer" CHECK (((status = 'pending'::public.template_approval_status_enum) OR (reviewed_by IS NOT NULL))) not valid;

alter table "public"."template_approvals" validate constraint "approval_requires_reviewer";

alter table "public"."template_approvals" add constraint "reviewed_at_required" CHECK (((status = 'pending'::public.template_approval_status_enum) OR (reviewed_at IS NOT NULL))) not valid;

alter table "public"."template_approvals" validate constraint "reviewed_at_required";

alter table "public"."template_approvals" add constraint "template_approvals_requested_by_fkey" FOREIGN KEY (requested_by) REFERENCES auth.users(id) ON DELETE RESTRICT not valid;

alter table "public"."template_approvals" validate constraint "template_approvals_requested_by_fkey";

alter table "public"."template_approvals" add constraint "template_approvals_reviewed_by_fkey" FOREIGN KEY (reviewed_by) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."template_approvals" validate constraint "template_approvals_reviewed_by_fkey";

alter table "public"."template_approvals" add constraint "template_approvals_template_id_fkey" FOREIGN KEY (template_id) REFERENCES public.notification_templates(id) ON DELETE CASCADE not valid;

alter table "public"."template_approvals" validate constraint "template_approvals_template_id_fkey";

alter table "public"."template_usage_logs" add constraint "template_usage_logs_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."template_usage_logs" validate constraint "template_usage_logs_created_by_fkey";

alter table "public"."template_usage_logs" add constraint "template_usage_logs_notification_id_fkey" FOREIGN KEY (notification_id) REFERENCES public.superadmin_notifications(id) ON DELETE SET NULL not valid;

alter table "public"."template_usage_logs" validate constraint "template_usage_logs_notification_id_fkey";

alter table "public"."template_usage_logs" add constraint "template_usage_logs_template_id_fkey" FOREIGN KEY (template_id) REFERENCES public.notification_templates(id) ON DELETE CASCADE not valid;

alter table "public"."template_usage_logs" validate constraint "template_usage_logs_template_id_fkey";

alter table "public"."template_variables" add constraint "template_variables_template_id_fkey" FOREIGN KEY (template_id) REFERENCES public.notification_templates(id) ON DELETE CASCADE not valid;

alter table "public"."template_variables" validate constraint "template_variables_template_id_fkey";

alter table "public"."template_variables" add constraint "template_variables_template_id_variable_name_key" UNIQUE using index "template_variables_template_id_variable_name_key";

alter table "public"."template_variables" add constraint "valid_length_constraints" CHECK (((min_length IS NULL) OR (max_length IS NULL) OR (min_length <= max_length))) not valid;

alter table "public"."template_variables" validate constraint "valid_length_constraints";

alter table "public"."template_variables" add constraint "valid_variable_name" CHECK ((variable_name ~ '^[a-zA-Z][a-zA-Z0-9_]*$'::text)) not valid;

alter table "public"."template_variables" validate constraint "valid_variable_name";

alter table "public"."tester_feedback" add constraint "tester_feedback_feedback_text_check" CHECK ((length(TRIM(BOTH FROM feedback_text)) > 0)) not valid;

alter table "public"."tester_feedback" validate constraint "tester_feedback_feedback_text_check";

alter table "public"."tester_feedback" add constraint "tester_feedback_platform_check" CHECK ((platform = ANY (ARRAY['android'::text, 'ios'::text, 'web'::text]))) not valid;

alter table "public"."tester_feedback" validate constraint "tester_feedback_platform_check";

alter table "public"."tester_feedback" add constraint "tester_feedback_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."tester_feedback" validate constraint "tester_feedback_preschool_id_fkey";

alter table "public"."tester_feedback" add constraint "tester_feedback_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."tester_feedback" validate constraint "tester_feedback_user_id_fkey";

alter table "public"."textbook_chapters" add constraint "textbook_chapters_difficulty_level_check" CHECK ((difficulty_level = ANY (ARRAY['foundation'::text, 'intermediate'::text, 'advanced'::text]))) not valid;

alter table "public"."textbook_chapters" validate constraint "textbook_chapters_difficulty_level_check";

alter table "public"."textbook_chapters" add constraint "textbook_chapters_textbook_id_chapter_number_key" UNIQUE using index "textbook_chapters_textbook_id_chapter_number_key";

alter table "public"."textbook_chapters" add constraint "textbook_chapters_textbook_id_fkey" FOREIGN KEY (textbook_id) REFERENCES public.textbooks(id) ON DELETE CASCADE not valid;

alter table "public"."textbook_chapters" validate constraint "textbook_chapters_textbook_id_fkey";

alter table "public"."textbook_content" add constraint "textbook_content_check" CHECK ((page_end >= page_start)) not valid;

alter table "public"."textbook_content" validate constraint "textbook_content_check";

alter table "public"."textbook_content" add constraint "textbook_content_content_type_check" CHECK (((content_type)::text = ANY ((ARRAY['chapter'::character varying, 'section'::character varying, 'subsection'::character varying, 'activity'::character varying, 'exercise'::character varying, 'example'::character varying, 'revision'::character varying, 'assessment'::character varying])::text[]))) not valid;

alter table "public"."textbook_content" validate constraint "textbook_content_content_type_check";

alter table "public"."textbook_content" add constraint "textbook_content_parent_id_fkey" FOREIGN KEY (parent_id) REFERENCES public.textbook_content(id) not valid;

alter table "public"."textbook_content" validate constraint "textbook_content_parent_id_fkey";

alter table "public"."textbook_content" add constraint "textbook_content_textbook_id_fkey" FOREIGN KEY (textbook_id) REFERENCES public.textbooks(id) ON DELETE CASCADE not valid;

alter table "public"."textbook_content" validate constraint "textbook_content_textbook_id_fkey";

alter table "public"."textbook_pages" add constraint "textbook_pages_chapter_id_fkey" FOREIGN KEY (chapter_id) REFERENCES public.textbook_chapters(id) ON DELETE SET NULL not valid;

alter table "public"."textbook_pages" validate constraint "textbook_pages_chapter_id_fkey";

alter table "public"."textbook_pages" add constraint "textbook_pages_content_type_check" CHECK ((content_type = ANY (ARRAY['text'::text, 'diagram'::text, 'table'::text, 'mixed'::text, 'exercises'::text]))) not valid;

alter table "public"."textbook_pages" validate constraint "textbook_pages_content_type_check";

alter table "public"."textbook_pages" add constraint "textbook_pages_textbook_id_fkey" FOREIGN KEY (textbook_id) REFERENCES public.textbooks(id) ON DELETE CASCADE not valid;

alter table "public"."textbook_pages" validate constraint "textbook_pages_textbook_id_fkey";

alter table "public"."textbook_pages" add constraint "textbook_pages_textbook_id_page_number_key" UNIQUE using index "textbook_pages_textbook_id_page_number_key";

alter table "public"."textbooks" add constraint "textbooks_format_check" CHECK (((format)::text = ANY ((ARRAY['print'::character varying, 'digital'::character varying, 'hybrid'::character varying])::text[]))) not valid;

alter table "public"."textbooks" validate constraint "textbooks_format_check";

alter table "public"."textbooks" add constraint "textbooks_isbn_edition_key" UNIQUE using index "textbooks_isbn_edition_key";

alter table "public"."trial_usage_log" add constraint "at_least_one_identifier" CHECK (((email IS NOT NULL) OR (phone IS NOT NULL) OR (device_fingerprint IS NOT NULL))) not valid;

alter table "public"."trial_usage_log" validate constraint "at_least_one_identifier";

alter table "public"."tts_audio_cache" add constraint "tts_audio_cache_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."tts_audio_cache" validate constraint "tts_audio_cache_created_by_fkey";

alter table "public"."tts_audio_cache" add constraint "tts_audio_cache_hash_key" UNIQUE using index "tts_audio_cache_hash_key";

alter table "public"."tts_audio_cache" add constraint "tts_audio_cache_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."tts_audio_cache" validate constraint "tts_audio_cache_preschool_id_fkey";

alter table "public"."typing_indicators" add constraint "typing_indicators_thread_id_fkey" FOREIGN KEY (thread_id) REFERENCES public.message_threads(id) ON DELETE CASCADE not valid;

alter table "public"."typing_indicators" validate constraint "typing_indicators_thread_id_fkey";

alter table "public"."typing_indicators" add constraint "typing_indicators_thread_id_user_id_key" UNIQUE using index "typing_indicators_thread_id_user_id_key";

alter table "public"."typing_indicators" add constraint "typing_indicators_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."typing_indicators" validate constraint "typing_indicators_user_id_fkey";

alter table "public"."user_ai_tiers" add constraint "user_ai_tiers_assigned_by_fkey" FOREIGN KEY (assigned_by) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."user_ai_tiers" validate constraint "user_ai_tiers_assigned_by_fkey";

alter table "public"."user_ai_tiers" add constraint "user_ai_tiers_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."user_ai_tiers" validate constraint "user_ai_tiers_user_id_fkey";

alter table "public"."user_ai_tiers" add constraint "user_ai_tiers_user_id_key" UNIQUE using index "user_ai_tiers_user_id_key";

alter table "public"."user_ai_usage" add constraint "user_ai_usage_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_ai_usage" validate constraint "user_ai_usage_user_id_fkey";

alter table "public"."user_ai_usage" add constraint "user_ai_usage_user_id_key" UNIQUE using index "user_ai_usage_user_id_key";

alter table "public"."user_blocks" add constraint "user_blocks_block_type_check" CHECK (((block_type)::text = ANY ((ARRAY['user'::character varying, 'content'::character varying, 'communication'::character varying])::text[]))) not valid;

alter table "public"."user_blocks" validate constraint "user_blocks_block_type_check";

alter table "public"."user_blocks" add constraint "user_blocks_blocked_id_fkey" FOREIGN KEY (blocked_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_blocks" validate constraint "user_blocks_blocked_id_fkey";

alter table "public"."user_blocks" add constraint "user_blocks_blocker_id_fkey" FOREIGN KEY (blocker_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_blocks" validate constraint "user_blocks_blocker_id_fkey";

alter table "public"."user_blocks" add constraint "user_blocks_no_self_block" CHECK ((blocker_id <> blocked_id)) not valid;

alter table "public"."user_blocks" validate constraint "user_blocks_no_self_block";

alter table "public"."user_blocks" add constraint "user_blocks_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.preschools(id) ON DELETE SET NULL not valid;

alter table "public"."user_blocks" validate constraint "user_blocks_school_id_fkey";

alter table "public"."user_blocks" add constraint "user_blocks_unique" UNIQUE using index "user_blocks_unique";

alter table "public"."user_bookmarks" add constraint "user_bookmarks_textbook_id_fkey" FOREIGN KEY (textbook_id) REFERENCES public.textbooks(id) ON DELETE CASCADE not valid;

alter table "public"."user_bookmarks" validate constraint "user_bookmarks_textbook_id_fkey";

alter table "public"."user_bookmarks" add constraint "user_bookmarks_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_bookmarks" validate constraint "user_bookmarks_user_id_fkey";

alter table "public"."user_bookmarks" add constraint "user_bookmarks_user_id_textbook_id_key" UNIQUE using index "user_bookmarks_user_id_textbook_id_key";

alter table "public"."user_connections" add constraint "user_connections_addressee_id_fkey" FOREIGN KEY (addressee_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_connections" validate constraint "user_connections_addressee_id_fkey";

alter table "public"."user_connections" add constraint "user_connections_check" CHECK ((requester_id <> addressee_id)) not valid;

alter table "public"."user_connections" validate constraint "user_connections_check";

alter table "public"."user_connections" add constraint "user_connections_connection_type_check" CHECK (((connection_type)::text = ANY ((ARRAY['cross_school'::character varying, 'same_school'::character varying, 'family'::character varying, 'colleague'::character varying])::text[]))) not valid;

alter table "public"."user_connections" validate constraint "user_connections_connection_type_check";

alter table "public"."user_connections" add constraint "user_connections_requester_id_addressee_id_key" UNIQUE using index "user_connections_requester_id_addressee_id_key";

alter table "public"."user_connections" add constraint "user_connections_requester_id_fkey" FOREIGN KEY (requester_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_connections" validate constraint "user_connections_requester_id_fkey";

alter table "public"."user_connections" add constraint "user_connections_status_check" CHECK (((status)::text = ANY ((ARRAY['pending'::character varying, 'accepted'::character varying, 'declined'::character varying, 'blocked'::character varying])::text[]))) not valid;

alter table "public"."user_connections" validate constraint "user_connections_status_check";

alter table "public"."user_contacts" add constraint "user_contacts_matched_user_id_fkey" FOREIGN KEY (matched_user_id) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."user_contacts" validate constraint "user_contacts_matched_user_id_fkey";

alter table "public"."user_contacts" add constraint "user_contacts_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_contacts" validate constraint "user_contacts_user_id_fkey";

alter table "public"."user_contacts" add constraint "user_contacts_user_id_phone_number_hash_key" UNIQUE using index "user_contacts_user_id_phone_number_hash_key";

alter table "public"."user_invitations" add constraint "user_invitations_invited_by_fkey" FOREIGN KEY (invited_by) REFERENCES auth.users(id) not valid;

alter table "public"."user_invitations" validate constraint "user_invitations_invited_by_fkey";

alter table "public"."user_invitations" add constraint "user_invitations_role_check" CHECK ((role = ANY (ARRAY['teacher'::text, 'parent'::text, 'principal'::text, 'superadmin'::text]))) not valid;

alter table "public"."user_invitations" validate constraint "user_invitations_role_check";

alter table "public"."user_invitations" add constraint "user_invitations_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'accepted'::text, 'expired'::text, 'cancelled'::text]))) not valid;

alter table "public"."user_invitations" validate constraint "user_invitations_status_check";

alter table "public"."user_invitations" add constraint "user_invitations_token_key" UNIQUE using index "user_invitations_token_key";

alter table "public"."user_phone_numbers" add constraint "user_phone_numbers_phone_number_check" CHECK (((phone_number)::text ~ '^\+[1-9]\d{1,14}$'::text)) not valid;

alter table "public"."user_phone_numbers" validate constraint "user_phone_numbers_phone_number_check";

alter table "public"."user_phone_numbers" add constraint "user_phone_numbers_phone_number_key" UNIQUE using index "user_phone_numbers_phone_number_key";

alter table "public"."user_phone_numbers" add constraint "user_phone_numbers_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_phone_numbers" validate constraint "user_phone_numbers_user_id_fkey";

alter table "public"."user_preferences" add constraint "user_preferences_theme_check" CHECK ((theme = ANY (ARRAY['light'::text, 'dark'::text, 'auto'::text]))) not valid;

alter table "public"."user_preferences" validate constraint "user_preferences_theme_check";

alter table "public"."user_preferences" add constraint "user_preferences_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_preferences" validate constraint "user_preferences_user_id_fkey";

alter table "public"."user_preferences" add constraint "user_preferences_user_id_key" UNIQUE using index "user_preferences_user_id_key";

alter table "public"."user_presence" add constraint "user_presence_status_check" CHECK ((status = ANY (ARRAY['online'::text, 'offline'::text, 'away'::text]))) not valid;

alter table "public"."user_presence" validate constraint "user_presence_status_check";

alter table "public"."user_presence" add constraint "user_presence_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_presence" validate constraint "user_presence_user_id_fkey";

alter table "public"."user_promotional_subscriptions" add constraint "user_promotional_subscriptions_campaign_id_fkey" FOREIGN KEY (campaign_id) REFERENCES public.promotional_campaigns(id) ON DELETE RESTRICT not valid;

alter table "public"."user_promotional_subscriptions" validate constraint "user_promotional_subscriptions_campaign_id_fkey";

alter table "public"."user_promotional_subscriptions" add constraint "user_promotional_subscriptions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_promotional_subscriptions" validate constraint "user_promotional_subscriptions_user_id_fkey";

alter table "public"."user_promotional_subscriptions" add constraint "user_promotional_subscriptions_user_id_tier_key" UNIQUE using index "user_promotional_subscriptions_user_id_tier_key";

alter table "public"."user_usage_tracking" add constraint "user_usage_tracking_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_usage_tracking" validate constraint "user_usage_tracking_user_id_fkey";

alter table "public"."user_usage_tracking" add constraint "user_usage_tracking_user_id_quota_type_usage_period_start_key" UNIQUE using index "user_usage_tracking_user_id_quota_type_usage_period_start_key";

alter table "public"."user_voice_usage" add constraint "user_voice_usage_period_type_check" CHECK ((period_type = ANY (ARRAY['daily'::text, 'monthly'::text]))) not valid;

alter table "public"."user_voice_usage" validate constraint "user_voice_usage_period_type_check";

alter table "public"."user_voice_usage" add constraint "user_voice_usage_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."user_voice_usage" validate constraint "user_voice_usage_preschool_id_fkey";

alter table "public"."user_voice_usage" add constraint "user_voice_usage_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_voice_usage" validate constraint "user_voice_usage_user_id_fkey";

alter table "public"."user_voice_usage" add constraint "user_voice_usage_user_id_period_type_period_start_key" UNIQUE using index "user_voice_usage_user_id_period_type_period_start_key";

alter table "public"."users" add constraint "users_auth_user_id_fkey" FOREIGN KEY (auth_user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."users" validate constraint "users_auth_user_id_fkey";

alter table "public"."users" add constraint "users_auth_user_id_key" UNIQUE using index "users_auth_user_id_key";

alter table "public"."users" add constraint "users_auth_user_id_unique" UNIQUE using index "users_auth_user_id_unique";

alter table "public"."users" add constraint "users_email_key" UNIQUE using index "users_email_key";

alter table "public"."users" add constraint "users_employment_status_check" CHECK ((employment_status = ANY (ARRAY['full_time'::text, 'part_time'::text, 'contract'::text, 'substitute'::text, 'intern'::text]))) not valid;

alter table "public"."users" validate constraint "users_employment_status_check";

alter table "public"."users" add constraint "users_gender_check" CHECK ((gender = ANY (ARRAY['male'::text, 'female'::text, 'other'::text, 'prefer_not_to_say'::text]))) not valid;

alter table "public"."users" validate constraint "users_gender_check";

alter table "public"."users" add constraint "users_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."users" validate constraint "users_organization_id_fkey";

alter table "public"."users" add constraint "users_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE SET NULL not valid;

alter table "public"."users" validate constraint "users_preschool_id_fkey";

alter table "public"."users" add constraint "users_profile_completion_status_check" CHECK ((profile_completion_status = ANY (ARRAY['incomplete'::text, 'complete'::text]))) not valid;

alter table "public"."users" validate constraint "users_profile_completion_status_check";

alter table "public"."users" add constraint "users_role_check" CHECK ((role = ANY (ARRAY['superadmin'::text, 'principal'::text, 'preschool_admin'::text, 'admin'::text, 'teacher'::text, 'parent'::text]))) not valid;

alter table "public"."users" validate constraint "users_role_check";

alter table "public"."users" add constraint "users_subscription_status_check" CHECK ((subscription_status = ANY (ARRAY['active'::text, 'canceled'::text, 'past_due'::text, 'unpaid'::text, 'incomplete'::text]))) not valid;

alter table "public"."users" validate constraint "users_subscription_status_check";

alter table "public"."users" add constraint "users_subscription_tier_check" CHECK ((subscription_tier = ANY (ARRAY['free'::text, 'premium'::text, 'enterprise'::text]))) not valid;

alter table "public"."users" validate constraint "users_subscription_tier_check";

alter table "public"."video_call_participants" add constraint "video_call_participants_call_id_fkey" FOREIGN KEY (call_id) REFERENCES public.video_calls(id) ON DELETE CASCADE not valid;

alter table "public"."video_call_participants" validate constraint "video_call_participants_call_id_fkey";

alter table "public"."video_call_participants" add constraint "video_call_participants_call_id_user_id_key" UNIQUE using index "video_call_participants_call_id_user_id_key";

alter table "public"."video_call_participants" add constraint "video_call_participants_status_check" CHECK ((status = ANY (ARRAY['invited'::text, 'joined'::text, 'left'::text, 'removed'::text]))) not valid;

alter table "public"."video_call_participants" validate constraint "video_call_participants_status_check";

alter table "public"."video_call_participants" add constraint "video_call_participants_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."video_call_participants" validate constraint "video_call_participants_student_id_fkey";

alter table "public"."video_calls" add constraint "video_calls_meeting_id_key" UNIQUE using index "video_calls_meeting_id_key";

alter table "public"."video_calls" add constraint "video_calls_status_check" CHECK ((status = ANY (ARRAY['scheduled'::text, 'live'::text, 'ended'::text, 'cancelled'::text]))) not valid;

alter table "public"."video_calls" validate constraint "video_calls_status_check";

alter table "public"."voice_notes" add constraint "voice_notes_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."voice_notes" validate constraint "voice_notes_created_by_fkey";

alter table "public"."voice_preferences" add constraint "voice_preferences_language_code_check" CHECK ((language_code = ANY (ARRAY['en'::text, 'af'::text, 'zu'::text, 'xh'::text, 'st'::text, 'nso'::text]))) not valid;

alter table "public"."voice_preferences" validate constraint "voice_preferences_language_code_check";

alter table "public"."voice_preferences" add constraint "voice_preferences_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."voice_preferences" validate constraint "voice_preferences_preschool_id_fkey";

alter table "public"."voice_preferences" add constraint "voice_preferences_preschool_id_user_id_key" UNIQUE using index "voice_preferences_preschool_id_user_id_key";

alter table "public"."voice_preferences" add constraint "voice_preferences_role_check" CHECK ((role = ANY (ARRAY['superadmin'::text, 'principal'::text, 'teacher'::text, 'parent'::text, 'student'::text]))) not valid;

alter table "public"."voice_preferences" validate constraint "voice_preferences_role_check";

alter table "public"."voice_preferences" add constraint "voice_preferences_tts_pitch_check" CHECK (((tts_pitch >= '-50'::integer) AND (tts_pitch <= 50))) not valid;

alter table "public"."voice_preferences" validate constraint "voice_preferences_tts_pitch_check";

alter table "public"."voice_preferences" add constraint "voice_preferences_tts_rate_check" CHECK (((tts_rate >= '-50'::integer) AND (tts_rate <= 50))) not valid;

alter table "public"."voice_preferences" validate constraint "voice_preferences_tts_rate_check";

alter table "public"."voice_preferences" add constraint "voice_preferences_tts_style_check" CHECK ((tts_style = ANY (ARRAY['friendly'::text, 'empathetic'::text, 'professional'::text, 'cheerful'::text]))) not valid;

alter table "public"."voice_preferences" validate constraint "voice_preferences_tts_style_check";

alter table "public"."voice_preferences" add constraint "voice_preferences_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."voice_preferences" validate constraint "voice_preferences_user_id_fkey";

alter table "public"."voice_usage_logs" add constraint "voice_usage_logs_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."voice_usage_logs" validate constraint "voice_usage_logs_preschool_id_fkey";

alter table "public"."voice_usage_logs" add constraint "voice_usage_logs_service_check" CHECK ((service = ANY (ARRAY['tts'::text, 'stt'::text]))) not valid;

alter table "public"."voice_usage_logs" validate constraint "voice_usage_logs_service_check";

alter table "public"."voice_usage_logs" add constraint "voice_usage_logs_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."voice_usage_logs" validate constraint "voice_usage_logs_user_id_fkey";

alter table "public"."voice_usage_quotas" add constraint "voice_usage_quotas_subscription_tier_check" CHECK ((subscription_tier = ANY (ARRAY['free'::text, 'starter'::text, 'professional'::text, 'enterprise'::text, 'parent-starter'::text, 'parent-plus'::text]))) not valid;

alter table "public"."voice_usage_quotas" validate constraint "voice_usage_quotas_subscription_tier_check";

alter table "public"."voice_usage_quotas" add constraint "voice_usage_quotas_subscription_tier_key" UNIQUE using index "voice_usage_quotas_subscription_tier_key";

alter table "public"."webhook_logs" add constraint "webhook_logs_status_check" CHECK ((status = ANY (ARRAY['success'::text, 'error'::text, 'ignored'::text]))) not valid;

alter table "public"."webhook_logs" validate constraint "webhook_logs_status_check";

alter table "public"."whatsapp_contacts" add constraint "whatsapp_contacts_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."whatsapp_contacts" validate constraint "whatsapp_contacts_preschool_id_fkey";

alter table "public"."whatsapp_contacts" add constraint "whatsapp_contacts_unique_user_per_school" UNIQUE using index "whatsapp_contacts_unique_user_per_school";

alter table "public"."whatsapp_contacts" add constraint "whatsapp_contacts_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."whatsapp_contacts" validate constraint "whatsapp_contacts_user_id_fkey";

alter table "public"."wing_regional_coordinators" add constraint "unique_wing_region" UNIQUE using index "unique_wing_region";

alter table "public"."wing_regional_coordinators" add constraint "wing_regional_coordinators_appointed_by_fkey" FOREIGN KEY (appointed_by) REFERENCES public.organization_members(id) ON DELETE SET NULL not valid;

alter table "public"."wing_regional_coordinators" validate constraint "wing_regional_coordinators_appointed_by_fkey";

alter table "public"."wing_regional_coordinators" add constraint "wing_regional_coordinators_coordinator_id_fkey" FOREIGN KEY (coordinator_id) REFERENCES public.organization_members(id) ON DELETE SET NULL not valid;

alter table "public"."wing_regional_coordinators" validate constraint "wing_regional_coordinators_coordinator_id_fkey";

alter table "public"."wing_regional_coordinators" add constraint "wing_regional_coordinators_region_id_fkey" FOREIGN KEY (region_id) REFERENCES public.organization_regions(id) ON DELETE CASCADE not valid;

alter table "public"."wing_regional_coordinators" validate constraint "wing_regional_coordinators_region_id_fkey";

alter table "public"."wing_regional_coordinators" add constraint "wing_regional_coordinators_wing_id_fkey" FOREIGN KEY (wing_id) REFERENCES public.organization_wings(id) ON DELETE CASCADE not valid;

alter table "public"."wing_regional_coordinators" validate constraint "wing_regional_coordinators_wing_id_fkey";

alter table "public"."academic_terms" add constraint "academic_terms_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."academic_terms" validate constraint "academic_terms_created_by_fkey";

alter table "public"."academic_terms" add constraint "academic_terms_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."academic_terms" validate constraint "academic_terms_preschool_id_fkey";

alter table "public"."activity_comments" add constraint "activity_comments_activity_id_fkey" FOREIGN KEY (activity_id) REFERENCES public.student_activity_feed(id) ON DELETE CASCADE not valid;

alter table "public"."activity_comments" validate constraint "activity_comments_activity_id_fkey";

alter table "public"."activity_comments" add constraint "activity_comments_parent_id_fkey" FOREIGN KEY (parent_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."activity_comments" validate constraint "activity_comments_parent_id_fkey";

alter table "public"."activity_progress" add constraint "activity_progress_activity_id_fkey" FOREIGN KEY (activity_id) REFERENCES public.activities(id) ON DELETE CASCADE not valid;

alter table "public"."activity_progress" validate constraint "activity_progress_activity_id_fkey";

alter table "public"."activity_progress" add constraint "activity_progress_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."activity_progress" validate constraint "activity_progress_student_id_fkey";

alter table "public"."activity_reactions" add constraint "activity_reactions_activity_id_fkey" FOREIGN KEY (activity_id) REFERENCES public.student_activity_feed(id) ON DELETE CASCADE not valid;

alter table "public"."activity_reactions" validate constraint "activity_reactions_activity_id_fkey";

alter table "public"."activity_reactions" add constraint "activity_reactions_parent_id_fkey" FOREIGN KEY (parent_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."activity_reactions" validate constraint "activity_reactions_parent_id_fkey";

alter table "public"."activity_templates" add constraint "activity_templates_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."activity_templates" validate constraint "activity_templates_created_by_fkey";

alter table "public"."activity_templates" add constraint "activity_templates_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."activity_templates" validate constraint "activity_templates_preschool_id_fkey";

alter table "public"."birthday_donation_days" add constraint "birthday_donation_days_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."birthday_donation_days" validate constraint "birthday_donation_days_organization_id_fkey";

alter table "public"."birthday_donations" add constraint "birthday_donations_birthday_student_id_fkey" FOREIGN KEY (birthday_student_id) REFERENCES public.students(id) ON DELETE SET NULL not valid;

alter table "public"."birthday_donations" validate constraint "birthday_donations_birthday_student_id_fkey";

alter table "public"."birthday_donations" add constraint "birthday_donations_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.classes(id) ON DELETE SET NULL not valid;

alter table "public"."birthday_donations" validate constraint "birthday_donations_class_id_fkey";

alter table "public"."birthday_donations" add constraint "birthday_donations_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."birthday_donations" validate constraint "birthday_donations_organization_id_fkey";

alter table "public"."birthday_donations" add constraint "birthday_donations_payer_student_id_fkey" FOREIGN KEY (payer_student_id) REFERENCES public.students(id) ON DELETE SET NULL not valid;

alter table "public"."birthday_donations" validate constraint "birthday_donations_payer_student_id_fkey";

alter table "public"."child_registration_requests" add constraint "child_registration_requests_payment_verified_by_fkey" FOREIGN KEY (payment_verified_by) REFERENCES public.profiles(id) not valid;

alter table "public"."child_registration_requests" validate constraint "child_registration_requests_payment_verified_by_fkey";

alter table "public"."classes" add constraint "classes_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."classes" validate constraint "classes_preschool_id_fkey";

alter table "public"."curriculum_themes" add constraint "curriculum_themes_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."curriculum_themes" validate constraint "curriculum_themes_created_by_fkey";

alter table "public"."curriculum_themes" add constraint "curriculum_themes_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."curriculum_themes" validate constraint "curriculum_themes_preschool_id_fkey";

alter table "public"."curriculum_themes" add constraint "curriculum_themes_term_id_fkey" FOREIGN KEY (term_id) REFERENCES public.academic_terms(id) ON DELETE SET NULL not valid;

alter table "public"."curriculum_themes" validate constraint "curriculum_themes_term_id_fkey";

alter table "public"."dash_ai_tutor_attempts" add constraint "dash_ai_tutor_attempts_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE SET NULL not valid;

alter table "public"."dash_ai_tutor_attempts" validate constraint "dash_ai_tutor_attempts_student_id_fkey";

alter table "public"."lesson_assignments" add constraint "lesson_assignments_assigned_by_fkey" FOREIGN KEY (assigned_by) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."lesson_assignments" validate constraint "lesson_assignments_assigned_by_fkey";

alter table "public"."lesson_assignments" add constraint "lesson_assignments_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.classes(id) ON DELETE CASCADE not valid;

alter table "public"."lesson_assignments" validate constraint "lesson_assignments_class_id_fkey";

alter table "public"."lesson_assignments" add constraint "lesson_assignments_lesson_id_fkey" FOREIGN KEY (lesson_id) REFERENCES public.lessons(id) ON DELETE CASCADE not valid;

alter table "public"."lesson_assignments" validate constraint "lesson_assignments_lesson_id_fkey";

alter table "public"."lesson_assignments" add constraint "lesson_assignments_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."lesson_assignments" validate constraint "lesson_assignments_preschool_id_fkey";

alter table "public"."lesson_assignments" add constraint "lesson_assignments_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."lesson_assignments" validate constraint "lesson_assignments_student_id_fkey";

alter table "public"."lesson_completions" add constraint "lesson_completions_assignment_id_fkey" FOREIGN KEY (assignment_id) REFERENCES public.lesson_assignments(id) ON DELETE CASCADE not valid;

alter table "public"."lesson_completions" validate constraint "lesson_completions_assignment_id_fkey";

alter table "public"."lesson_completions" add constraint "lesson_completions_lesson_id_fkey" FOREIGN KEY (lesson_id) REFERENCES public.lessons(id) ON DELETE CASCADE not valid;

alter table "public"."lesson_completions" validate constraint "lesson_completions_lesson_id_fkey";

alter table "public"."lesson_completions" add constraint "lesson_completions_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."lesson_completions" validate constraint "lesson_completions_preschool_id_fkey";

alter table "public"."lesson_completions" add constraint "lesson_completions_reviewed_by_fkey" FOREIGN KEY (reviewed_by) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."lesson_completions" validate constraint "lesson_completions_reviewed_by_fkey";

alter table "public"."lesson_completions" add constraint "lesson_completions_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."lesson_completions" validate constraint "lesson_completions_student_id_fkey";

alter table "public"."lesson_progress" add constraint "lesson_progress_lesson_id_fkey" FOREIGN KEY (lesson_id) REFERENCES public.lessons(id) ON DELETE CASCADE not valid;

alter table "public"."lesson_progress" validate constraint "lesson_progress_lesson_id_fkey";

alter table "public"."lesson_progress" add constraint "lesson_progress_status_check" CHECK ((status = ANY (ARRAY['not_started'::text, 'in_progress'::text, 'completed'::text]))) not valid;

alter table "public"."lesson_progress" validate constraint "lesson_progress_status_check";

alter table "public"."lesson_templates" add constraint "lesson_templates_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."lesson_templates" validate constraint "lesson_templates_created_by_fkey";

alter table "public"."lesson_templates" add constraint "lesson_templates_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."lesson_templates" validate constraint "lesson_templates_preschool_id_fkey";

alter table "public"."notifications" add constraint "notifications_type_check" CHECK (((type IS NULL) OR (type = ANY (ARRAY['general'::text, 'homework'::text, 'announcement'::text, 'payment'::text, 'emergency'::text, 'reminder'::text, 'message'::text])))) not valid;

alter table "public"."notifications" validate constraint "notifications_type_check";

alter table "public"."notifications" add constraint "notifications_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."notifications" validate constraint "notifications_user_id_fkey";

alter table "public"."organization_regions" add constraint "organization_regions_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."organization_regions" validate constraint "organization_regions_organization_id_fkey";

alter table "public"."school_excursions" add constraint "school_excursions_approved_by_fkey" FOREIGN KEY (approved_by) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."school_excursions" validate constraint "school_excursions_approved_by_fkey";

alter table "public"."school_excursions" add constraint "school_excursions_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."school_excursions" validate constraint "school_excursions_created_by_fkey";

alter table "public"."school_excursions" add constraint "school_excursions_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."school_excursions" validate constraint "school_excursions_preschool_id_fkey";

alter table "public"."school_excursions" add constraint "school_excursions_term_id_fkey" FOREIGN KEY (term_id) REFERENCES public.academic_terms(id) ON DELETE SET NULL not valid;

alter table "public"."school_excursions" validate constraint "school_excursions_term_id_fkey";

alter table "public"."school_excursions" add constraint "school_excursions_theme_id_fkey" FOREIGN KEY (theme_id) REFERENCES public.curriculum_themes(id) ON DELETE SET NULL not valid;

alter table "public"."school_excursions" validate constraint "school_excursions_theme_id_fkey";

alter table "public"."school_meetings" add constraint "school_meetings_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."school_meetings" validate constraint "school_meetings_created_by_fkey";

alter table "public"."school_meetings" add constraint "school_meetings_parent_meeting_id_fkey" FOREIGN KEY (parent_meeting_id) REFERENCES public.school_meetings(id) ON DELETE SET NULL not valid;

alter table "public"."school_meetings" validate constraint "school_meetings_parent_meeting_id_fkey";

alter table "public"."school_meetings" add constraint "school_meetings_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."school_meetings" validate constraint "school_meetings_preschool_id_fkey";

alter table "public"."student_activity_feed" add constraint "student_activity_feed_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."student_activity_feed" validate constraint "student_activity_feed_student_id_fkey";

alter table "public"."student_progress_summary" add constraint "student_progress_summary_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."student_progress_summary" validate constraint "student_progress_summary_preschool_id_fkey";

alter table "public"."student_progress_summary" add constraint "student_progress_summary_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."student_progress_summary" validate constraint "student_progress_summary_student_id_fkey";

alter table "public"."teacher_approvals" add constraint "teacher_approvals_invite_id_fkey" FOREIGN KEY (invite_id) REFERENCES public.teacher_invites(id) ON DELETE SET NULL not valid;

alter table "public"."teacher_approvals" validate constraint "teacher_approvals_invite_id_fkey";

alter table "public"."teacher_approvals" add constraint "teacher_approvals_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."teacher_approvals" validate constraint "teacher_approvals_preschool_id_fkey";

alter table "public"."teacher_approvals" add constraint "teacher_approvals_reviewed_by_fkey" FOREIGN KEY (reviewed_by) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."teacher_approvals" validate constraint "teacher_approvals_reviewed_by_fkey";

alter table "public"."teacher_approvals" add constraint "teacher_approvals_teacher_id_fkey" FOREIGN KEY (teacher_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."teacher_approvals" validate constraint "teacher_approvals_teacher_id_fkey";

alter table "public"."teacher_reference_requests" add constraint "teacher_reference_requests_candidate_profile_id_fkey" FOREIGN KEY (candidate_profile_id) REFERENCES public.candidate_profiles(id) ON DELETE CASCADE not valid;

alter table "public"."teacher_reference_requests" validate constraint "teacher_reference_requests_candidate_profile_id_fkey";

alter table "public"."teacher_references" add constraint "teacher_references_candidate_profile_id_fkey" FOREIGN KEY (candidate_profile_id) REFERENCES public.candidate_profiles(id) ON DELETE CASCADE not valid;

alter table "public"."teacher_references" validate constraint "teacher_references_candidate_profile_id_fkey";

alter table "public"."uniform_requests" add constraint "uniform_requests_parent_id_fkey" FOREIGN KEY (parent_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."uniform_requests" validate constraint "uniform_requests_parent_id_fkey";

alter table "public"."uniform_requests" add constraint "uniform_requests_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."uniform_requests" validate constraint "uniform_requests_preschool_id_fkey";

alter table "public"."uniform_requests" add constraint "uniform_requests_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."uniform_requests" validate constraint "uniform_requests_student_id_fkey";

alter table "public"."video_call_participants" add constraint "video_call_participants_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."video_call_participants" validate constraint "video_call_participants_user_id_fkey";

alter table "public"."video_calls" add constraint "video_calls_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.classes(id) ON DELETE SET NULL not valid;

alter table "public"."video_calls" validate constraint "video_calls_class_id_fkey";

alter table "public"."video_calls" add constraint "video_calls_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."video_calls" validate constraint "video_calls_preschool_id_fkey";

alter table "public"."video_calls" add constraint "video_calls_teacher_id_fkey" FOREIGN KEY (teacher_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."video_calls" validate constraint "video_calls_teacher_id_fkey";

alter table "public"."weekly_learning_reports" add constraint "weekly_learning_reports_parent_id_fkey" FOREIGN KEY (parent_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."weekly_learning_reports" validate constraint "weekly_learning_reports_parent_id_fkey";

alter table "public"."weekly_learning_reports" add constraint "weekly_learning_reports_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."weekly_learning_reports" validate constraint "weekly_learning_reports_preschool_id_fkey";

alter table "public"."weekly_learning_reports" add constraint "weekly_learning_reports_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."weekly_learning_reports" validate constraint "weekly_learning_reports_student_id_fkey";

alter table "public"."weekly_plans" add constraint "weekly_plans_approved_by_fkey" FOREIGN KEY (approved_by) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."weekly_plans" validate constraint "weekly_plans_approved_by_fkey";

alter table "public"."weekly_plans" add constraint "weekly_plans_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.classes(id) ON DELETE SET NULL not valid;

alter table "public"."weekly_plans" validate constraint "weekly_plans_class_id_fkey";

alter table "public"."weekly_plans" add constraint "weekly_plans_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."weekly_plans" validate constraint "weekly_plans_created_by_fkey";

alter table "public"."weekly_plans" add constraint "weekly_plans_preschool_id_fkey" FOREIGN KEY (preschool_id) REFERENCES public.preschools(id) ON DELETE CASCADE not valid;

alter table "public"."weekly_plans" validate constraint "weekly_plans_preschool_id_fkey";

alter table "public"."weekly_plans" add constraint "weekly_plans_term_id_fkey" FOREIGN KEY (term_id) REFERENCES public.academic_terms(id) ON DELETE SET NULL not valid;

alter table "public"."weekly_plans" validate constraint "weekly_plans_term_id_fkey";

alter table "public"."weekly_plans" add constraint "weekly_plans_theme_id_fkey" FOREIGN KEY (theme_id) REFERENCES public.curriculum_themes(id) ON DELETE SET NULL not valid;

alter table "public"."weekly_plans" validate constraint "weekly_plans_theme_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION app.current_user_id()
 RETURNS uuid
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public', 'pg_temp'
AS $function$
  select id
  from public.users
  where auth_user_id = auth.uid()
  order by created_at desc
  limit 1
$function$
;

CREATE OR REPLACE FUNCTION app.is_message_sender(p_message_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public', 'pg_temp'
AS $function$
  SELECT EXISTS (
    SELECT 1
    FROM public.messages m
    WHERE m.id = p_message_id
      AND m.sender_id = app.current_user_id()
  );
$function$
;

CREATE OR REPLACE FUNCTION app_auth.can_access_assignment(p_assignment_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE
AS $function$
  SELECT 
    -- Superadmins can access everything
    app_auth.is_super_admin()
    OR
    -- Teachers who created the assignment
    EXISTS (
      SELECT 1
      FROM homework_assignments ha
      WHERE ha.id = p_assignment_id
        AND ha.teacher_id = app_auth.teacher_id()
        AND ha.preschool_id = app_auth.org_id()
    )
    OR
    -- Teachers who have access to the class
    EXISTS (
      SELECT 1
      FROM homework_assignments ha
      JOIN classes c ON c.id = ha.class_id
      WHERE ha.id = p_assignment_id
        AND c.teacher_id = app_auth.teacher_id()
        AND ha.preschool_id = app_auth.org_id()
        AND c.preschool_id = app_auth.org_id()
    )
    OR
    -- Parents who have children with this assignment (via organization)
    EXISTS (
      SELECT 1
      FROM homework_assignments ha
      JOIN parent_child_links pcl ON pcl.child_id IN (
        SELECT u.id FROM users u WHERE u.role = 'student' AND u.organization_id = ha.preschool_id
      )
      WHERE ha.id = p_assignment_id
        AND pcl.parent_id = app_auth.parent_id()
        AND ha.preschool_id = app_auth.org_id()
    );
$function$
;

CREATE OR REPLACE FUNCTION app_auth.can_access_conversation(p_conversation_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE
AS $function$
  SELECT 
    -- Superadmins can access everything
    app_auth.is_super_admin()
    OR
    -- For now, allow same-org access (refine when conversation tables are implemented)
    true;
$function$
;

CREATE OR REPLACE FUNCTION app_auth.can_access_org(p_org uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE
AS $function$
  SELECT 
    app_auth.is_super_admin() 
    OR p_org = app_auth.org_id()
    OR p_org IS NULL; -- Handle global/system data
$function$
;

CREATE OR REPLACE FUNCTION app_auth.can_access_own_record(record_user_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT 
    app_auth.is_superadmin() 
    OR record_user_id = app_auth.current_user_id();
$function$
;

CREATE OR REPLACE FUNCTION app_auth.can_access_student_in_org(student_org_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT 
    app_auth.is_superadmin() 
    OR app_auth.has_org_access(student_org_id);
$function$
;

CREATE OR REPLACE FUNCTION app_auth.capabilities()
 RETURNS text[]
 LANGUAGE sql
 STABLE
AS $function$
  SELECT COALESCE(
    ARRAY(
      SELECT jsonb_array_elements_text(app_auth.jwt() -> 'capabilities')
    ), 
    ARRAY[]::text[]
  );
$function$
;

CREATE OR REPLACE FUNCTION app_auth.check_superadmin_capabilities()
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
    result jsonb;
    current_user_id uuid;
    current_email text;
    user_role text;
    is_superadmin boolean;
BEGIN
    current_user_id := auth.uid();
    user_role := current_setting('request.jwt.claims', true)::json->>'role';
    
    SELECT email INTO current_email FROM auth.users WHERE id = current_user_id;
    is_superadmin := app_auth.is_service_role_superadmin();
    
    result := jsonb_build_object(
        'user_id', current_user_id,
        'email', current_email,
        'role', user_role,
        'is_service_role_superadmin', is_superadmin,
        'can_bypass_rls', is_superadmin,
        'has_full_table_access', is_superadmin,
        'audit_logging_enabled', true,
        'verified_superadmin_emails', jsonb_build_array(
            'superadmin@edudashpro.org.za',
            'admin@edudashpro.com'
        ),
        'timestamp', now()
    );
    
    RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION app_auth.current_user_email()
 RETURNS text
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT COALESCE(auth.email(), '');
$function$
;

CREATE OR REPLACE FUNCTION app_auth.current_user_id()
 RETURNS uuid
 LANGUAGE sql
 STABLE
AS $function$
  SELECT auth.uid();
$function$
;

CREATE OR REPLACE FUNCTION app_auth.current_user_org_id()
 RETURNS uuid
 LANGUAGE sql
 STABLE
AS $function$
  SELECT COALESCE(
    NULLIF(current_setting('request.jwt.claims', true), '')::jsonb ->> 'organization_id',
    NULLIF(current_setting('request.jwt.claims', true), '')::jsonb ->> 'preschool_id'
  )::uuid;
$function$
;

CREATE OR REPLACE FUNCTION app_auth.current_user_role()
 RETURNS text
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
    user_role text;
BEGIN
    -- If not authenticated, return null
    IF NOT app_auth.is_authenticated() THEN
        RETURN null;
    END IF;
    
    -- Get role from users table
    SELECT role INTO user_role
    FROM public.users
    WHERE id = app_auth.current_user_id();
    
    RETURN COALESCE(user_role, 'unknown');
END;
$function$
;

CREATE OR REPLACE FUNCTION app_auth.debug_claims()
 RETURNS jsonb
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT app_auth.jwt();
$function$
;

CREATE OR REPLACE FUNCTION app_auth.debug_user_status()
 RETURNS jsonb
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
    result jsonb;
BEGIN
    result := jsonb_build_object(
        'authenticated', app_auth.is_authenticated(),
        'user_id', app_auth.current_user_id(),
        'email', app_auth.current_user_email(),
        'role', app_auth.current_user_role(),
        'organization_id', app_auth.current_user_org_id(),
        'is_superadmin', app_auth.is_superadmin(),
        'is_principal', app_auth.is_principal(),
        'is_teacher', app_auth.is_teacher(),
        'is_parent', app_auth.is_parent(),
        'timestamp', now()
    );
    
    RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION app_auth.execute_as_superadmin(operation_type text, target_table text, record_data jsonb DEFAULT NULL::jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
    result jsonb;
    current_user_id uuid;
    current_email text;
BEGIN
    -- Verify superadmin status
    IF NOT app_auth.is_service_role_superadmin() THEN
        RAISE EXCEPTION 'Access denied: Superadmin privileges required';
    END IF;
    
    current_user_id := auth.uid();
    SELECT email INTO current_email FROM auth.users WHERE id = current_user_id;
    
    -- Log the operation
    INSERT INTO public.superadmin_audit_log (
        superadmin_user_id,
        superadmin_email,
        action,
        table_name,
        new_values,
        ip_address,
        user_agent
    ) VALUES (
        current_user_id,
        current_email,
        operation_type,
        target_table,
        record_data,
        inet_client_addr(),
        current_setting('request.headers', true)::json->>'user-agent'
    );
    
    -- Return success result
    RETURN jsonb_build_object(
        'success', true,
        'message', 'Superadmin operation logged successfully',
        'user_id', current_user_id,
        'email', current_email,
        'timestamp', now()
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION app_auth.filter_accessible_assignments(p_assignment_ids uuid[])
 RETURNS uuid[]
 LANGUAGE sql
 STABLE
AS $function$
  SELECT ARRAY(
    SELECT a
    FROM unnest(p_assignment_ids) a
    WHERE app_auth.can_access_assignment(a)
  );
$function$
;

CREATE OR REPLACE FUNCTION app_auth.filter_accessible_students(p_student_ids uuid[])
 RETURNS uuid[]
 LANGUAGE sql
 STABLE
AS $function$
  SELECT ARRAY(
    SELECT s
    FROM unnest(p_student_ids) s
    WHERE (
      app_auth.is_super_admin()
      OR 
      (app_auth.is_teacher() AND app_auth.teacher_can_access_student(s))
      OR
      (app_auth.is_parent() AND app_auth.parent_can_access_student(s))
    )
  );
$function$
;

CREATE OR REPLACE FUNCTION app_auth.has_active_seat()
 RETURNS boolean
 LANGUAGE sql
 STABLE
AS $function$
  SELECT app_auth.seat_status() = 'active';
$function$
;

CREATE OR REPLACE FUNCTION app_auth.has_cap(cap text)
 RETURNS boolean
 LANGUAGE sql
 STABLE
AS $function$
  SELECT cap = ANY(app_auth.capabilities());
$function$
;

CREATE OR REPLACE FUNCTION app_auth.has_org_access(target_org_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
    user_org_id uuid;
BEGIN
    -- Superadmins have access to all organizations
    IF app_auth.is_superadmin() THEN
        RETURN true;
    END IF;
    
    -- Get current user's organization
    user_org_id := app_auth.current_user_org_id();
    
    -- Check if user belongs to the target organization
    RETURN user_org_id = target_org_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION app_auth.has_role_level(min_level integer)
 RETURNS boolean
 LANGUAGE sql
 STABLE
AS $function$
  SELECT CASE app_auth.role()
    WHEN 'super_admin' THEN 4
    WHEN 'principal' THEN 3
    WHEN 'principal_admin' THEN 3
    WHEN 'teacher' THEN 2
    WHEN 'parent' THEN 1
    ELSE 0
  END >= min_level;
$function$
;

CREATE OR REPLACE FUNCTION app_auth.is_authenticated()
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT auth.role() = 'authenticated';
$function$
;

CREATE OR REPLACE FUNCTION app_auth.is_parent()
 RETURNS boolean
 LANGUAGE sql
 STABLE
AS $function$
  SELECT (NULLIF(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role') = 'parent';
$function$
;

CREATE OR REPLACE FUNCTION app_auth.is_principal()
 RETURNS boolean
 LANGUAGE sql
 STABLE
AS $function$
  SELECT (NULLIF(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role') = 'principal';
$function$
;

CREATE OR REPLACE FUNCTION app_auth.is_service_role_superadmin()
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
    user_role text;
    current_user_id uuid;
    user_email text;
BEGIN
    -- Get the current role from JWT
    user_role := current_setting('request.jwt.claims', true)::json->>'role';
    
    -- If already service role, return true
    IF user_role = 'service_role' THEN
        RETURN true;
    END IF;
    
    -- Check if authenticated user is a verified superadmin
    IF user_role = 'authenticated' THEN
        current_user_id := auth.uid();
        
        -- Get user email from auth.users
        SELECT email INTO user_email
        FROM auth.users 
        WHERE id = current_user_id;
        
        -- Check if it's one of our verified superadmin emails
        RETURN user_email IN (
            'superadmin@edudashpro.org.za',
            'admin@edudashpro.com'
        );
    END IF;
    
    RETURN false;
END;
$function$
;

CREATE OR REPLACE FUNCTION app_auth.is_super_admin()
 RETURNS boolean
 LANGUAGE sql
 STABLE
AS $function$
  SELECT app_auth.role() = 'super_admin';
$function$
;

CREATE OR REPLACE FUNCTION app_auth.is_superadmin()
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
        SELECT EXISTS (
          SELECT 1 FROM public.profiles
          WHERE id = auth.uid()
          AND role IN ('superadmin', 'super_admin')
        );
      $function$
;

CREATE OR REPLACE FUNCTION app_auth.is_teacher()
 RETURNS boolean
 LANGUAGE sql
 STABLE
AS $function$
  SELECT (NULLIF(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role') = 'teacher';
$function$
;

CREATE OR REPLACE FUNCTION app_auth.jwt()
 RETURNS jsonb
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'pg_catalog', 'public', 'app_auth'
AS $function$
  SELECT COALESCE(
    current_setting('request.jwt.claims', true)::jsonb,
    '{}'::jsonb
  );
$function$
;

CREATE OR REPLACE FUNCTION app_auth.org_id()
 RETURNS uuid
 LANGUAGE sql
 STABLE
AS $function$ SELECT app_auth.current_user_org_id(); $function$
;

CREATE OR REPLACE FUNCTION app_auth.parent_accessible_students()
 RETURNS uuid[]
 LANGUAGE sql
 STABLE
AS $function$
  SELECT COALESCE(
    ARRAY(
      -- Via parent_child_links only
      SELECT DISTINCT pcl.child_id
      FROM parent_child_links pcl
      WHERE pcl.parent_id = app_auth.parent_id()
    ),
    ARRAY[]::UUID[]
  );
$function$
;

CREATE OR REPLACE FUNCTION app_auth.parent_can_access_student(p_student_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE
AS $function$
  SELECT EXISTS (
    -- Via parent_child_links table
    SELECT 1
    FROM parent_child_links pcl
    WHERE pcl.child_id = p_student_id
      AND pcl.parent_id = app_auth.parent_id()
  );
$function$
;

CREATE OR REPLACE FUNCTION app_auth.parent_id()
 RETURNS uuid
 LANGUAGE sql
 STABLE
AS $function$
  SELECT NULLIF(app_auth.jwt() ->> 'parent_id', '')::uuid;
$function$
;

CREATE OR REPLACE FUNCTION app_auth.plan_tier()
 RETURNS text
 LANGUAGE sql
 STABLE
AS $function$
  SELECT COALESCE(app_auth.jwt() ->> 'plan_tier', 'free');
$function$
;

CREATE OR REPLACE FUNCTION app_auth.profile_id()
 RETURNS uuid
 LANGUAGE sql
 STABLE
AS $function$
  SELECT NULLIF(app_auth.jwt() ->> 'user_id', '')::uuid;
$function$
;

CREATE OR REPLACE FUNCTION app_auth.public_user_id()
 RETURNS uuid
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public', 'pg_catalog'
AS $function$
  SELECT u.id
  FROM public.users u
  WHERE u.auth_user_id = app_auth.user_id()
  LIMIT 1
$function$
;

CREATE OR REPLACE FUNCTION app_auth.role()
 RETURNS text
 LANGUAGE sql
 STABLE
AS $function$
  SELECT COALESCE(app_auth.jwt() ->> 'role', '');
$function$
;

CREATE OR REPLACE FUNCTION app_auth.seat_status()
 RETURNS text
 LANGUAGE sql
 STABLE
AS $function$
  SELECT COALESCE(app_auth.jwt() ->> 'seat_status', 'inactive');
$function$
;

CREATE OR REPLACE FUNCTION app_auth.teacher_accessible_students()
 RETURNS uuid[]
 LANGUAGE sql
 STABLE
AS $function$
  SELECT COALESCE(
    ARRAY(
      SELECT DISTINCT student.id
      FROM users student
      WHERE student.role = 'student'
        AND student.organization_id = app_auth.org_id()
    ),
    ARRAY[]::UUID[]
  );
$function$
;

CREATE OR REPLACE FUNCTION app_auth.teacher_can_access_class(p_class_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE
AS $function$
  SELECT EXISTS (
    -- Direct teacher assignment in classes table
    SELECT 1
    FROM classes c
    WHERE c.id = p_class_id
      AND c.teacher_id = app_auth.teacher_id()
      AND c.preschool_id = app_auth.org_id()
      AND c.is_active = true
  );
$function$
;

CREATE OR REPLACE FUNCTION app_auth.teacher_can_access_student(p_student_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE
AS $function$
  SELECT EXISTS (
    -- For now: teachers can access students in same organization
    SELECT 1 
    FROM users student
    WHERE student.id = p_student_id
      AND student.role = 'student'
      AND student.organization_id = app_auth.org_id()
  );
$function$
;

CREATE OR REPLACE FUNCTION app_auth.teacher_id()
 RETURNS uuid
 LANGUAGE sql
 STABLE
AS $function$
  SELECT NULLIF(app_auth.jwt() ->> 'teacher_id', '')::uuid;
$function$
;

CREATE OR REPLACE FUNCTION app_auth.user_id()
 RETURNS uuid
 LANGUAGE sql
 STABLE
AS $function$
  SELECT NULLIF(app_auth.jwt() ->> 'sub', '')::uuid;
$function$
;

CREATE OR REPLACE FUNCTION app_auth.validate_context()
 RETURNS TABLE(user_id uuid, role text, org_id uuid, capabilities_count integer, has_active_seat boolean, is_valid boolean)
 LANGUAGE sql
 STABLE
AS $function$
  SELECT 
    app_auth.user_id(),
    app_auth.role(),
    app_auth.org_id(),
    array_length(app_auth.capabilities(), 1),
    app_auth.has_active_seat(),
    (app_auth.user_id() IS NOT NULL AND app_auth.role() != '')
$function$
;

CREATE OR REPLACE FUNCTION private.get_current_user_profile()
 RETURNS TABLE(role text, preschool_id uuid)
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
  SELECT role, preschool_id
  FROM public.profiles
  WHERE id = auth.uid();
$function$
;

CREATE OR REPLACE FUNCTION public._touch_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at := now();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.accept_invitation_code(invite_code text, user_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
 SET row_security TO 'off'
AS $function$
DECLARE
  invitation RECORD;
  v_actor_role text := auth.role();
  v_actor_id uuid := auth.uid();
BEGIN
  -- Only allow linking the authenticated user, unless called by service role.
  IF v_actor_role <> 'service_role' AND (v_actor_id IS NULL OR v_actor_id <> user_id) THEN
    RETURN FALSE;
  END IF;

  -- Get invitation
  SELECT * INTO invitation
  FROM invitations i
  WHERE i.code = invite_code
    AND i.status = 'pending'
    AND (i.expires_at IS NULL OR i.expires_at > NOW())
    AND (i.max_uses = -1 OR i.uses_count < i.max_uses)
  FOR UPDATE;

  IF NOT FOUND THEN
    RETURN FALSE;
  END IF;

  -- Update invitation
  UPDATE invitations
  SET
    uses_count = uses_count + 1,
    accepted_by = user_id,
    accepted_at = NOW(),
    status = CASE
      WHEN max_uses = -1 THEN 'pending'  -- Unlimited use
      WHEN uses_count + 1 >= max_uses THEN 'accepted'  -- Max uses reached
      ELSE 'pending'
    END,
    updated_at = NOW()
  WHERE code = invite_code;

  -- Link user to organization
  UPDATE profiles
  SET
    organization_id = invitation.organization_id,
    preschool_id = invitation.organization_id,
    auth_user_id = COALESCE(auth_user_id, id),
    updated_at = NOW()
  WHERE id = user_id;

  RETURN TRUE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.accept_join_request(p_invite_token text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_request join_requests%ROWTYPE;
  v_user_id UUID;
BEGIN
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'Not authenticated');
  END IF;
  
  -- Find the request
  SELECT * INTO v_request
  FROM join_requests
  WHERE invite_token = p_invite_token
    AND status = 'pending'
    AND (expires_at IS NULL OR expires_at > NOW())
  FOR UPDATE;
  
  IF NOT FOUND THEN
    RETURN json_build_object('success', false, 'error', 'Invalid or expired invitation');
  END IF;
  
  -- Verify the user matches the invite
  IF v_request.requester_id IS NOT NULL AND v_request.requester_id != v_user_id THEN
    RETURN json_build_object('success', false, 'error', 'Invitation is for a different user');
  END IF;
  
  IF v_request.requester_email IS NOT NULL THEN
    IF v_request.requester_email != (SELECT email FROM auth.users WHERE id = v_user_id) THEN
      RETURN json_build_object('success', false, 'error', 'Invitation is for a different email address');
    END IF;
  END IF;
  
  -- Update requester_id if it was null (invite accepted by email)
  IF v_request.requester_id IS NULL THEN
    UPDATE join_requests SET requester_id = v_user_id WHERE id = v_request.id;
  END IF;
  
  -- Approve the request (trigger will handle the rest)
  UPDATE join_requests
  SET status = 'approved', reviewed_at = NOW()
  WHERE id = v_request.id;
  
  RETURN json_build_object(
    'success', true,
    'request_type', v_request.request_type,
    'organization_id', v_request.organization_id
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.activate_notification_template(p_template_id uuid)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'auth'
AS $function$
DECLARE
  v_user_id UUID;
  v_is_superadmin BOOLEAN;
  v_template_record notification_templates%ROWTYPE;
  v_approval_id UUID;
BEGIN
  -- Get current user ID
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Authentication required',
      'error_code', 'AUTH_REQUIRED'
    );
  END IF;
  
  -- Check if user is superadmin
  SELECT EXISTS (
    SELECT 1 FROM user_profiles 
    WHERE user_id = v_user_id 
    AND role = 'super_admin' 
    AND is_active = true
  ) INTO v_is_superadmin;
  
  IF NOT v_is_superadmin THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Superadmin privileges required',
      'error_code', 'INSUFFICIENT_PRIVILEGES'
    );
  END IF;
  
  -- Get template
  SELECT * FROM notification_templates 
  WHERE id = p_template_id 
  INTO v_template_record;
  
  IF NOT FOUND THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Template not found',
      'error_code', 'TEMPLATE_NOT_FOUND'
    );
  END IF;
  
  -- Already active
  IF v_template_record.status = 'active' THEN
    RETURN json_build_object(
      'success', true,
      'message', 'Template is already active'
    );
  END IF;
  
  -- For superadmins, auto-approve templates
  UPDATE notification_templates SET
    status = 'active',
    approved_by = v_user_id,
    approved_at = now(),
    updated_by = v_user_id,
    updated_at = now()
  WHERE id = p_template_id;
  
  -- Create approval record
  INSERT INTO template_approvals (
    template_id,
    version,
    status,
    requested_by,
    reviewed_by,
    review_notes,
    reviewed_at
  ) VALUES (
    p_template_id,
    v_template_record.version,
    'auto_approved',
    v_user_id,
    v_user_id,
    'Auto-approved by superadmin',
    now()
  ) RETURNING id INTO v_approval_id;
  
  RETURN json_build_object(
    'success', true,
    'template_id', p_template_id,
    'approval_id', v_approval_id,
    'status', 'active',
    'message', 'Template activated successfully'
  );
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object(
      'success', false,
      'error', SQLERRM,
      'error_code', 'INTERNAL_ERROR'
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.activate_organization_member(member_uuid uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'extensions', 'auth'
AS $function$
DECLARE
  affected_rows INTEGER;
BEGIN
  -- Update member to active status
  UPDATE organization_members
  SET 
    membership_status = 'active',
    seat_status = 'active',
    updated_at = NOW()
  WHERE id = member_uuid
    AND membership_status = 'pending';
  
  GET DIAGNOSTICS affected_rows = ROW_COUNT;
  
  IF affected_rows = 0 THEN
    RAISE NOTICE 'Member % not found or already active', member_uuid;
    RETURN FALSE;
  END IF;
  
  RAISE NOTICE 'Member % successfully activated', member_uuid;
  RETURN TRUE;
END;
$function$
;

create or replace view "public"."activity_logs_view" as  SELECT id,
    activity_type AS action_type,
    description,
    created_at,
    user_name,
    user_id,
    organization_id
   FROM public.activity_logs
  ORDER BY created_at DESC;


CREATE OR REPLACE FUNCTION public.add_group_participants(p_thread_id uuid, p_user_ids uuid[], p_added_by uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_thread_record RECORD;
  v_is_admin BOOLEAN;
BEGIN
  -- Get thread info
  SELECT * INTO v_thread_record FROM message_threads WHERE id = p_thread_id;
  
  IF v_thread_record.id IS NULL OR v_thread_record.is_group != TRUE THEN
    RAISE EXCEPTION 'Thread not found or not a group';
  END IF;

  -- Check if user is admin of the group
  SELECT is_admin INTO v_is_admin
  FROM message_participants
  WHERE thread_id = p_thread_id AND user_id = p_added_by;

  IF v_is_admin != TRUE THEN
    RAISE EXCEPTION 'Only group admins can add participants';
  END IF;

  -- Add participants
  INSERT INTO message_participants (thread_id, user_id, role, is_admin, can_send_messages)
  SELECT 
    p_thread_id, 
    uid,
    COALESCE((SELECT role FROM profiles WHERE id = uid), 'parent'),
    FALSE,
    v_thread_record.allow_replies
  FROM unnest(p_user_ids) AS uid
  ON CONFLICT (thread_id, user_id) DO NOTHING;

  RETURN TRUE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.add_message_attachment(p_message_id uuid, p_file_name text, p_file_url text, p_file_type text, p_file_size integer, p_mime_type text DEFAULT 'application/octet-stream'::text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE 
  v_attachment_id uuid;
  v_sender_id uuid;
BEGIN
  -- Get current user
  v_sender_id := app.current_user_id();
  
  -- Ensure caller is sender of the message
  IF NOT EXISTS (
    SELECT 1 FROM public.messages m 
    WHERE m.id = p_message_id 
    AND m.sender_id = v_sender_id
  ) THEN
    RAISE EXCEPTION 'Not authorized to attach to this message';
  END IF;

  -- Insert attachment record
  INSERT INTO public.message_attachments (
    message_id, 
    file_name, 
    file_url, 
    file_type, 
    file_size, 
    mime_type
  )
  VALUES (
    p_message_id, 
    p_file_name, 
    p_file_url, 
    p_file_type, 
    p_file_size, 
    p_mime_type
  )
  RETURNING id INTO v_attachment_id;

  RETURN v_attachment_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.add_organization_member(p_organization_id uuid, p_user_id uuid DEFAULT NULL::uuid, p_first_name text DEFAULT NULL::text, p_last_name text DEFAULT NULL::text, p_email text DEFAULT NULL::text, p_phone text DEFAULT NULL::text, p_member_type text DEFAULT 'member'::text, p_membership_tier text DEFAULT 'standard'::text, p_role text DEFAULT 'member'::text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_member_id UUID;
  v_member_number TEXT;
BEGIN
  -- Generate member number
  v_member_number := generate_member_number(p_organization_id);
  
  -- Insert the member
  INSERT INTO public.organization_members (
    organization_id,
    user_id,
    first_name,
    last_name,
    email,
    phone,
    member_type,
    membership_tier,
    membership_status,
    member_number,
    role,
    seat_status,
    join_date
  ) VALUES (
    p_organization_id,
    p_user_id,
    p_first_name,
    p_last_name,
    p_email,
    p_phone,
    p_member_type,
    p_membership_tier,
    'active',
    v_member_number,
    p_role,
    'active',
    CURRENT_DATE
  )
  RETURNING id INTO v_member_id;
  
  RETURN v_member_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.admin_create_school_subscription(p_school_id uuid, p_plan_id text, p_billing_frequency text, p_seats_total integer DEFAULT 1, p_start_trial boolean DEFAULT false)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare v_id uuid; v_start timestamptz := now(); v_end timestamptz; v_status text; v_school_tier text; begin
  if not public.app_is_super_admin() then
    raise exception 'not authorized';
  end if;
  if p_billing_frequency not in ('monthly','annual') then
    raise exception 'invalid billing_frequency';
  end if;
  if p_billing_frequency = 'annual' then v_end := v_start + interval '1 year'; else v_end := v_start + interval '1 month'; end if;
  v_status := case when p_start_trial and p_plan_id = 'free' then 'trial' else 'active' end;

  -- Upsert school subscription
  select id into v_id from public.subscriptions where owner_type = 'school' and school_id = p_school_id limit 1;
  if v_id is null then
    insert into public.subscriptions(id, school_id, plan_id, status, owner_type, billing_frequency, start_date, end_date, next_billing_date, trial_end_date, seats_total, seats_used, metadata)
    values (gen_random_uuid(), p_school_id, p_plan_id, v_status, 'school', p_billing_frequency, v_start, v_end, v_end, (case when v_status = 'trial' then v_start + interval '14 days' else null end), greatest(1, coalesce(p_seats_total,1)), 0, jsonb_build_object('created_by','admin_create'))
    returning id into v_id;
  else
    update public.subscriptions
      set plan_id = p_plan_id,
          status = v_status,
          billing_frequency = p_billing_frequency,
          start_date = v_start,
          end_date = v_end,
          next_billing_date = v_end,
          trial_end_date = (case when v_status = 'trial' then v_start + interval '14 days' else null end),
          seats_total = greatest(1, coalesce(p_seats_total,1))
    where id = v_id;
  end if;

  -- Map plan tier to allowed preschools.subscription_tier values
  v_school_tier := case lower(p_plan_id)
    when 'basic' then 'basic'
    when 'premium' then 'premium'
    when 'enterprise' then 'enterprise'
    when 'starter' then 'basic'
    when 'pro' then 'premium'
    when 'free' then 'trial'
    else null
  end;

  if v_school_tier is not null then
    begin
      update public.preschools set subscription_tier = v_school_tier where id = p_school_id;
    exception when others then
      -- In case of constraint issues, ignore but keep subscription upserted
      perform 1;
    end;
  end if;

  return v_id;
end; $function$
;

CREATE OR REPLACE FUNCTION public.app_is_admin(uid uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE
AS $function$
  select exists (
    select 1
    from public.users u
    where u.auth_user_id = uid
      and (u.role = 'superadmin' or u.role = 'preschool_admin')
  );
$function$
;

CREATE OR REPLACE FUNCTION public.apply_late_penalty(original_points numeric, penalty_percent numeric, is_late boolean)
 RETURNS numeric
 LANGUAGE sql
 IMMUTABLE
AS $function$
    SELECT CASE
        WHEN NOT is_late OR penalty_percent <= 0 THEN original_points
        ELSE GREATEST(0.00, original_points - (original_points * penalty_percent / 100.0))
    END;
$function$
;

CREATE OR REPLACE FUNCTION public.appoint_board_member(p_position_id uuid, p_member_id uuid, p_appointed_by uuid DEFAULT NULL::uuid)
 RETURNS public.organization_board_positions
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_result organization_board_positions;
  v_appointer_role TEXT;
BEGIN
  -- Get appointer's role if provided
  IF p_appointed_by IS NOT NULL THEN
    SELECT member_type INTO v_appointer_role
    FROM organization_members
    WHERE id = p_appointed_by;
    
    -- Only president/national_admin can appoint
    IF v_appointer_role NOT IN ('national_admin') THEN
      -- Also check role column
      SELECT role INTO v_appointer_role
      FROM organization_members
      WHERE id = p_appointed_by;
      
      IF v_appointer_role NOT IN ('admin', 'national_admin', 'president', 'ceo') THEN
        RAISE EXCEPTION 'Insufficient permissions to appoint board members';
      END IF;
    END IF;
  END IF;

  UPDATE organization_board_positions
  SET 
    member_id = p_member_id,
    appointed_at = now(),
    appointed_by = p_appointed_by,
    term_start = CURRENT_DATE,
    updated_at = now()
  WHERE id = p_position_id
  RETURNING * INTO v_result;
  
  RETURN v_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.approve_membership_pop(p_pop_id uuid, p_reviewer_notes text DEFAULT NULL::text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_pop RECORD;
  v_fee_id UUID;
BEGIN
  -- Get POP details
  SELECT * INTO v_pop FROM membership_pop_uploads WHERE id = p_pop_id;
  
  IF v_pop IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'POP not found');
  END IF;
  
  -- Update POP status
  UPDATE membership_pop_uploads SET
    status = 'approved',
    reviewed_by = auth.uid(),
    reviewed_at = now(),
    reviewer_notes = p_reviewer_notes,
    updated_at = now()
  WHERE id = p_pop_id;
  
  -- Update related fee to paid
  IF v_pop.member_fee_id IS NOT NULL THEN
    UPDATE member_fees SET
      status = 'paid',
      last_payment_date = COALESCE(v_pop.payment_date, CURRENT_DATE),
      last_payment_amount = v_pop.payment_amount,
      paid_amount = COALESCE(paid_amount, 0) + COALESCE(v_pop.payment_amount, final_amount),
      payment_count = payment_count + 1,
      updated_at = now()
    WHERE id = v_pop.member_fee_id;
    v_fee_id := v_pop.member_fee_id;
  ELSE
    -- Try to match to oldest pending fee for this member
    SELECT id INTO v_fee_id 
    FROM member_fees 
    WHERE member_id = v_pop.member_id 
    AND status IN ('pending', 'overdue', 'partial')
    ORDER BY due_date ASC
    LIMIT 1;
    
    IF v_fee_id IS NOT NULL THEN
      UPDATE member_fees SET
        status = 'paid',
        last_payment_date = COALESCE(v_pop.payment_date, CURRENT_DATE),
        last_payment_amount = v_pop.payment_amount,
        paid_amount = COALESCE(paid_amount, 0) + COALESCE(v_pop.payment_amount, final_amount),
        payment_count = payment_count + 1,
        updated_at = now()
      WHERE id = v_fee_id;
    END IF;
  END IF;
  
  RETURN jsonb_build_object(
    'success', true,
    'pop_id', p_pop_id,
    'fee_id', v_fee_id
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.assign_all_teachers_to_subscription(p_subscription_id uuid, p_school_id uuid)
 RETURNS TABLE(user_id uuid, assigned boolean, reason text)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_sub record;
  v_current_used integer;
  v_teacher_id uuid;
BEGIN
  -- Load subscription
  SELECT * INTO v_sub FROM public.subscriptions WHERE id = p_subscription_id;
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Subscription not found';
  END IF;

  -- Iterate all teacher ids for the school from profiles (preferred)
  FOR v_teacher_id IN
    SELECT p.id
    FROM public.profiles p
    WHERE p.preschool_id = p_school_id
      AND p.role = 'teacher'
  LOOP
    -- Skip if already has active seat
    IF EXISTS (
      SELECT 1 FROM public.subscription_seats s
      WHERE s.subscription_id = p_subscription_id AND s.user_id = v_teacher_id AND s.is_active = true
    ) THEN
      user_id := v_teacher_id; assigned := false; reason := 'already_assigned'; RETURN NEXT;
      CONTINUE;
    END IF;

    -- Capacity check
    SELECT COUNT(*) INTO v_current_used FROM public.subscription_seats s
      WHERE s.subscription_id = p_subscription_id AND s.is_active = true;

    IF COALESCE(v_current_used, 0) >= COALESCE(v_sub.seats_total, 0) THEN
      user_id := v_teacher_id; assigned := false; reason := 'no_capacity'; RETURN NEXT;
      CONTINUE;
    END IF;

    -- Assign
    INSERT INTO public.subscription_seats (subscription_id, user_id, assigned_by)
    VALUES (p_subscription_id, v_teacher_id, (SELECT id FROM public.users WHERE auth_user_id = auth.uid()))
    ON CONFLICT DO NOTHING;

    -- Recount seats_used
    UPDATE public.subscriptions s
      SET seats_used = (
        SELECT COUNT(*) FROM public.subscription_seats ss
        WHERE ss.subscription_id = p_subscription_id AND ss.is_active = true
      ),
      updated_at = now()
    WHERE s.id = p_subscription_id;

    user_id := v_teacher_id; assigned := true; reason := NULL; RETURN NEXT;
  END LOOP;

  RETURN;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.assign_default_tier()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- Insert into user_ai_tiers
  INSERT INTO public.user_ai_tiers (user_id, tier, assigned_reason, is_active)
  VALUES (NEW.id, 'free', 'Auto-assigned on signup', true)
  ON CONFLICT (user_id) DO NOTHING;
  
  -- Insert into user_ai_usage
  INSERT INTO public.user_ai_usage (user_id, current_tier)
  VALUES (NEW.id, 'free')
  ON CONFLICT (user_id) DO NOTHING;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.assign_student_to_class(p_student_id uuid, p_preschool_id uuid, p_date_of_birth date)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_age_years INTEGER;
  v_class_id UUID;
BEGIN
  -- Calculate age in years
  v_age_years := EXTRACT(YEAR FROM AGE(CURRENT_DATE, p_date_of_birth));
  
  -- Find appropriate class based on age
  SELECT id INTO v_class_id
  FROM classes
  WHERE preschool_id = p_preschool_id
    AND active = true
    AND v_age_years >= age_min
    AND v_age_years <= age_max
  ORDER BY age_min
  LIMIT 1;
  
  -- If class found, assign student
  IF v_class_id IS NOT NULL THEN
    UPDATE students
    SET class_id = v_class_id
    WHERE id = p_student_id;
    
    RETURN v_class_id;
  END IF;
  
  RETURN NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.assign_teacher_seat(p_subscription_id uuid, p_user_id uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_subscription_record record;
    v_current_seats_used integer;
    v_seat_id uuid;
    v_result jsonb;
BEGIN
    -- Get subscription details
    SELECT * INTO v_subscription_record
    FROM public.subscriptions
    WHERE id = p_subscription_id;
    
    IF NOT FOUND THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Subscription not found'
        );
    END IF;
    
    -- Check if user already has a seat
    SELECT id INTO v_seat_id
    FROM public.subscription_seats
    WHERE subscription_id = p_subscription_id
    AND user_id = p_user_id
    AND is_active = true;
    
    IF FOUND THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'User already has an active seat'
        );
    END IF;
    
    -- Count current active seats
    SELECT COUNT(*) INTO v_current_seats_used
    FROM public.subscription_seats
    WHERE subscription_id = p_subscription_id
    AND is_active = true;
    
    -- Check if we have available seats
    IF v_current_seats_used >= v_subscription_record.seats_total THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'No available seats remaining'
        );
    END IF;
    
    -- Assign the seat
    INSERT INTO public.subscription_seats (
        subscription_id,
        user_id,
        assigned_by
    ) VALUES (
        p_subscription_id,
        p_user_id,
        (SELECT id FROM public.users WHERE auth_user_id = auth.uid())
    )
    RETURNING id INTO v_seat_id;
    
    -- Update subscription seats_used count
    UPDATE public.subscriptions
    SET 
        seats_used = v_current_seats_used + 1,
        updated_at = now()
    WHERE id = p_subscription_id;
    
    RETURN jsonb_build_object(
        'success', true,
        'seat_id', v_seat_id,
        'seats_used', v_current_seats_used + 1,
        'seats_total', v_subscription_record.seats_total
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.assignment_accepts_submissions(assignment_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
    SELECT EXISTS (
        SELECT 1 FROM assignments a
        JOIN courses c ON c.id = a.course_id
        WHERE a.id = assignment_accepts_submissions.assignment_id
        AND a.deleted_at IS NULL
        AND c.is_active = true
        AND c.deleted_at IS NULL
        AND (a.available_from IS NULL OR a.available_from <= now())
        AND (a.available_until IS NULL OR a.available_until > now() OR a.allow_late_submissions = true)
    );
$function$
;

CREATE OR REPLACE FUNCTION public.assignment_available_to_student(assignment_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
    SELECT EXISTS (
        SELECT 1 FROM assignments a
        WHERE a.id = assignment_id
        AND a.deleted_at IS NULL
        AND (a.available_from IS NULL OR a.available_from <= now())
        AND (a.available_until IS NULL OR a.available_until > now())
    );
$function$
;

CREATE OR REPLACE FUNCTION public.audit_rls_status()
 RETURNS TABLE(table_name text, rls_enabled boolean, policy_count bigint, status text)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    t.tablename::text,
    t.rowsecurity,
    COALESCE(
      (SELECT COUNT(*) 
       FROM pg_policies p 
       WHERE p.schemaname = 'public' 
       AND p.tablename = t.tablename), 0
    ) as policy_count,
    CASE 
      WHEN NOT t.rowsecurity THEN 'RLS_DISABLED'
      WHEN t.rowsecurity AND COALESCE(
        (SELECT COUNT(*) 
         FROM pg_policies p 
         WHERE p.schemaname = 'public' 
         AND p.tablename = t.tablename), 0
      ) = 0 THEN 'NO_POLICIES'
      ELSE 'PROTECTED'
    END as status
  FROM pg_tables t
  WHERE t.schemaname = 'public'
    AND t.tablename NOT LIKE 'pg_%'
    AND t.tablename NOT LIKE 'sql_%'
    AND t.tablename NOT IN (
      -- Exclude system/extension tables that don't need RLS
      'schema_migrations',
      'supabase_migrations_schema_migrations'
    )
  ORDER BY 
    CASE 
      WHEN NOT t.rowsecurity THEN 1
      WHEN t.rowsecurity AND COALESCE(
        (SELECT COUNT(*) 
         FROM pg_policies p 
         WHERE p.schemaname = 'public' 
         AND p.tablename = t.tablename), 0
      ) = 0 THEN 2
      ELSE 3
    END,
    t.tablename;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.audit_user_changes()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
    -- Log all user table changes for security audit
    INSERT INTO public.audit_logs (
        user_id,
        action,
        resource_type,
        resource_id,
        old_values,
        new_values,
        ip_address,
        created_at
    ) VALUES (
        auth.uid(),
        TG_OP,
        'users',
        COALESCE(NEW.id, OLD.id),
        CASE WHEN TG_OP != 'INSERT' THEN to_jsonb(OLD) ELSE NULL END,
        CASE WHEN TG_OP != 'DELETE' THEN to_jsonb(NEW) ELSE NULL END,
        inet_client_addr(),
        now()
    );

    RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.auto_apply_late_penalty()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    assignment_late_penalty DECIMAL(5,2);
    submission_is_late BOOLEAN;
    adjusted_points DECIMAL(8,2);
BEGIN
    -- Get assignment late penalty and check if submission is late
    SELECT 
        a.late_penalty_percent,
        s.is_late
    INTO assignment_late_penalty, submission_is_late
    FROM submissions s
    JOIN assignments a ON a.id = s.assignment_id
    WHERE s.id = NEW.submission_id;
    
    -- Apply late penalty if applicable
    IF submission_is_late AND assignment_late_penalty > 0 THEN
        adjusted_points := public.apply_late_penalty(
            NEW.points_earned, 
            assignment_late_penalty, 
            true
        );
        
        -- Update points if penalty was applied
        IF adjusted_points != NEW.points_earned THEN
            NEW.points_earned := adjusted_points;
            
            -- Add note about late penalty in feedback
            IF NEW.feedback IS NULL THEN
                NEW.feedback := 'Late penalty applied: -' || assignment_late_penalty || '%';
            ELSE
                NEW.feedback := NEW.feedback || E'\n\nLate penalty applied: -' || assignment_late_penalty || '%';
            END IF;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.auto_assign_fees_to_student(p_student_id uuid)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  student_record RECORD;
  fee_record RECORD;
  assigned_count INTEGER := 0;
BEGIN
  -- Get student details
  SELECT id, preschool_id, age_group, grade_level
  INTO student_record
  FROM public.profiles
  WHERE id = p_student_id;
  
  IF NOT FOUND THEN
    RETURN 0;
  END IF;
  
  -- Find matching fees for this student's age group
  FOR fee_record IN
    SELECT *
    FROM public.school_fee_structures
    WHERE preschool_id = student_record.preschool_id
      AND is_active = true
      AND (
        age_group = student_record.age_group
        OR grade_level = student_record.grade_level
        OR (age_group IS NULL AND grade_level IS NULL) -- School-wide fees
      )
  LOOP
    -- Assign fee to student (if not already assigned)
    INSERT INTO public.student_fee_assignments (
      student_id,
      fee_structure_id,
      preschool_id,
      total_amount_cents,
      due_date,
      status
    )
    SELECT
      p_student_id,
      fee_record.id,
      student_record.preschool_id,
      fee_record.amount_cents,
      CASE 
        WHEN fee_record.due_date IS NOT NULL THEN fee_record.due_date
        WHEN fee_record.due_day_of_month IS NOT NULL THEN 
          DATE_TRUNC('month', CURRENT_DATE) + (fee_record.due_day_of_month || ' days')::INTERVAL
        ELSE CURRENT_DATE + INTERVAL '30 days'
      END,
      'pending'
    WHERE NOT EXISTS (
      SELECT 1 FROM public.student_fee_assignments
      WHERE student_id = p_student_id
        AND fee_structure_id = fee_record.id
        AND EXTRACT(YEAR FROM assigned_date) = EXTRACT(YEAR FROM CURRENT_DATE)
    );
    
    IF FOUND THEN
      assigned_count := assigned_count + 1;
    END IF;
  END LOOP;
  
  RETURN assigned_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.auto_calculate_letter_grade()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Auto-calculate letter grade if not provided
    IF NEW.letter_grade IS NULL OR NEW.letter_grade = '' THEN
        NEW.letter_grade := public.percentage_to_letter_grade(NEW.percentage);
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.auto_create_message_recipient()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Only create recipient record if receiver_id is set and no recipient record exists
  IF NEW.receiver_id IS NOT NULL THEN
    INSERT INTO public.message_recipients (message_id, recipient_id)
    VALUES (NEW.id, NEW.receiver_id)
    ON CONFLICT DO NOTHING;
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.auto_fill_requester_id()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- If requester_id is not provided, use the authenticated user's ID
  IF NEW.requester_id IS NULL THEN
    NEW.requester_id := auth.uid();
  END IF;
  
  -- If invited_by is provided but requester_id is still null, use invited_by
  -- (for admin-created invites where the admin is both inviter and requester)
  IF NEW.requester_id IS NULL AND NEW.invited_by IS NOT NULL THEN
    NEW.requester_id := NEW.invited_by;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.auto_publish_announcements()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  UPDATE announcements
  SET is_published = TRUE,
      published_at = NOW()
  WHERE is_published = FALSE
    AND scheduled_for IS NOT NULL
    AND scheduled_for <= NOW();
END;
$function$
;

CREATE OR REPLACE FUNCTION public.auto_update_user_tier_on_payment()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  IF NEW.status = 'completed'
     AND NEW.user_id IS NOT NULL
     AND NEW.tier IS NOT NULL
     AND (
       OLD.status IS DISTINCT FROM NEW.status
       OR OLD.user_id IS DISTINCT FROM NEW.user_id
       OR OLD.tier IS DISTINCT FROM NEW.tier
     ) THEN

    -- Update user_ai_tiers (cast tier to tier_name_aligned enum)
    INSERT INTO public.user_ai_tiers (user_id, tier, created_at, updated_at)
    VALUES (NEW.user_id, NEW.tier::public.tier_name_aligned, NOW(), NOW())
    ON CONFLICT (user_id)
    DO UPDATE SET tier = EXCLUDED.tier, updated_at = EXCLUDED.updated_at;

    -- Update user_ai_usage.current_tier (also tier_name_aligned enum)
    UPDATE public.user_ai_usage
    SET current_tier = NEW.tier::public.tier_name_aligned, updated_at = NOW()
    WHERE user_id = NEW.user_id;

    IF NOT FOUND THEN
      INSERT INTO public.user_ai_usage (
        user_id,
        current_tier,
        exams_generated_this_month,
        explanations_requested_this_month,
        chat_messages_today,
        created_at,
        updated_at
      ) VALUES (
        NEW.user_id,
        NEW.tier::public.tier_name_aligned,
        0,
        0,
        0,
        NOW(),
        NOW()
      );
    END IF;
  END IF;

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.award_student_achievement(p_student_id uuid, p_achievement_type text, p_achievement_name text, p_category text DEFAULT NULL::text, p_points integer DEFAULT 1, p_description text DEFAULT NULL::text, p_icon text DEFAULT NULL::text, p_color text DEFAULT NULL::text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_preschool_id UUID;
  v_achievement_id UUID;
BEGIN
  -- Get student's preschool
  SELECT preschool_id INTO v_preschool_id FROM students WHERE id = p_student_id;
  
  IF v_preschool_id IS NULL THEN
    RAISE EXCEPTION 'Student not found';
  END IF;
  
  -- Insert achievement
  INSERT INTO student_achievements (
    student_id, preschool_id, achievement_type, achievement_name,
    category, points, description, achievement_icon, achievement_color,
    awarded_by
  ) VALUES (
    p_student_id, v_preschool_id, p_achievement_type, p_achievement_name,
    p_category, p_points, p_description, p_icon, p_color,
    auth.uid()
  ) RETURNING id INTO v_achievement_id;
  
  RETURN v_achievement_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.backfill_profile_age_groups()
 RETURNS TABLE(updated_count bigint, skipped_count bigint, error_message text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  v_updated bigint := 0;
  v_skipped bigint := 0;
begin
  -- Update profiles where date_of_birth exists but age_group is null
  update public.profiles
  set age_group = public.compute_age_group(date_of_birth)
  where date_of_birth is not null
  and age_group is null;
  
  get diagnostics v_updated = row_count;
  
  -- Count profiles with null date_of_birth
  select count(*) into v_skipped
  from public.profiles
  where date_of_birth is null;
  
  return query select v_updated, v_skipped, null::text;
exception when others then
  return query select 0::bigint, 0::bigint, sqlerrm;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.block_content(p_content_type character varying, p_content_id uuid, p_author_id uuid DEFAULT NULL::uuid, p_reason character varying DEFAULT NULL::character varying)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_current_user_id UUID := auth.uid();
  v_school_id UUID;
  v_result JSONB;
BEGIN
  -- Validate input
  IF v_current_user_id IS NULL THEN
    RETURN json_build_object('error', 'Authentication required');
  END IF;
  
  -- Get school context
  SELECT preschool_id INTO v_school_id
  FROM public.users WHERE id = v_current_user_id;
  
  -- Insert blocked content record
  INSERT INTO public.blocked_content (
    blocker_id,
    content_type,
    content_id,
    author_id,
    reason,
    school_id
  ) VALUES (
    v_current_user_id,
    p_content_type,
    p_content_id,
    p_author_id,
    p_reason,
    v_school_id
  )
  ON CONFLICT (blocker_id, content_type, content_id)
  DO UPDATE SET
    reason = EXCLUDED.reason,
    is_active = TRUE;
  
  v_result := json_build_object(
    'success', TRUE,
    'message', 'Content blocked successfully'
  );
  
  RETURN v_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.block_user(p_blocked_user_id uuid, p_block_type character varying DEFAULT 'user'::character varying, p_reason character varying DEFAULT NULL::character varying, p_details text DEFAULT NULL::text, p_expires_at timestamp with time zone DEFAULT NULL::timestamp with time zone)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_current_user_id UUID := auth.uid();
  v_blocker_school_id UUID;
  v_blocked_school_id UUID;
  v_result JSONB;
BEGIN
  -- Validate input
  IF v_current_user_id IS NULL THEN
    RETURN json_build_object('error', 'Authentication required');
  END IF;
  
  IF p_blocked_user_id IS NULL THEN
    RETURN json_build_object('error', 'Blocked user ID is required');
  END IF;
  
  IF v_current_user_id = p_blocked_user_id THEN
    RETURN json_build_object('error', 'Cannot block yourself');
  END IF;
  
  -- Get school context for both users
  SELECT preschool_id INTO v_blocker_school_id
  FROM public.users WHERE id = v_current_user_id;
  
  SELECT preschool_id INTO v_blocked_school_id
  FROM public.users WHERE id = p_blocked_user_id;
  
  -- For COPPA compliance, ensure users can only block within their school context
  IF v_blocker_school_id IS NOT NULL AND v_blocked_school_id IS NOT NULL 
     AND v_blocker_school_id != v_blocked_school_id THEN
    RETURN json_build_object('error', 'Can only block users within your school');
  END IF;
  
  -- Insert or update block record
  INSERT INTO public.user_blocks (
    blocker_id,
    blocked_id,
    block_type,
    reason,
    details,
    school_id,
    expires_at,
    is_active
  ) VALUES (
    v_current_user_id,
    p_blocked_user_id,
    p_block_type,
    p_reason,
    p_details,
    COALESCE(v_blocker_school_id, v_blocked_school_id),
    p_expires_at,
    TRUE
  )
  ON CONFLICT (blocker_id, blocked_id, block_type)
  DO UPDATE SET
    reason = EXCLUDED.reason,
    details = EXCLUDED.details,
    updated_at = NOW(),
    expires_at = EXCLUDED.expires_at,
    is_active = TRUE;
  
  -- Log the action
  PERFORM create_system_notification(
    p_blocked_user_id,
    'User Interaction Update',
    'A user has limited communication with you. This does not affect your account status.',
    'user_blocking',
    json_build_object(
      'blocker_id', v_current_user_id,
      'block_type', p_block_type,
      'reason', p_reason
    )
  );
  
  v_result := json_build_object(
    'success', TRUE,
    'message', 'User blocked successfully',
    'block_type', p_block_type,
    'blocked_user_id', p_blocked_user_id
  );
  
  RETURN v_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.bulk_activate_organization_members(organization_uuid uuid)
 RETURNS TABLE(activated_count integer, member_ids uuid[])
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'extensions', 'auth'
AS $function$
DECLARE
  activated UUID[];
BEGIN
  -- Activate all pending members in the organization
  WITH updated AS (
    UPDATE organization_members
    SET 
      membership_status = 'active',
      seat_status = 'active',
      updated_at = NOW()
    WHERE organization_id = organization_uuid
      AND membership_status = 'pending'
      AND join_date IS NOT NULL
    RETURNING id
  )
  SELECT ARRAY_AGG(id) INTO activated FROM updated;
  
  RETURN QUERY SELECT 
    COALESCE(array_length(activated, 1), 0) as activated_count,
    COALESCE(activated, ARRAY[]::UUID[]) as member_ids;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.bump_seats_used()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  update public.subscriptions s
    set seats_used = (
      select count(*) from public.subscription_seats ss where ss.subscription_id = s.id
    )
  where s.id = coalesce(new.subscription_id, old.subscription_id);
  return coalesce(new, old);
end;
$function$
;

CREATE OR REPLACE FUNCTION public.calculate_distance_km(lat1 numeric, lng1 numeric, lat2 numeric, lng2 numeric)
 RETURNS numeric
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
BEGIN
  RETURN ROUND(
    earth_distance(
      ll_to_earth(lat1, lng1),
      ll_to_earth(lat2, lng2)
    ) / 1000, 1
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.calculate_exam_score(attempt_id uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  exam_data JSONB;
  user_answers JSONB;
  total_score INTEGER := 0;
  total_possible INTEGER;
  result JSONB;
BEGIN
  -- Get exam paper and user answers
  SELECT 
    ep.questions,
    ea.answers,
    ep.total_marks
  INTO exam_data, user_answers, total_possible
  FROM exam_attempts ea
  JOIN exam_papers ep ON ea.exam_paper_id = ep.id
  WHERE ea.id = attempt_id;
  
  -- Update the attempt with score
  UPDATE exam_attempts
  SET 
    score = total_score,
    total_marks = total_possible,
    percentage = ROUND((total_score::NUMERIC / total_possible::NUMERIC) * 100, 2),
    updated_at = NOW()
  WHERE id = attempt_id;
  
  RETURN jsonb_build_object(
    'score', total_score,
    'total_marks', total_possible,
    'percentage', ROUND((total_score::NUMERIC / total_possible::NUMERIC) * 100, 2)
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.calculate_grade_percentage()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF NEW.points_earned IS NOT NULL AND NEW.max_points IS NOT NULL AND NEW.max_points > 0 THEN
    NEW.percentage = ROUND((NEW.points_earned / NEW.max_points) * 100, 2);
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.calculate_grade_percentage(points_earned numeric, points_possible numeric)
 RETURNS numeric
 LANGUAGE sql
 IMMUTABLE
AS $function$
    SELECT CASE 
        WHEN points_possible <= 0 THEN 0.00
        ELSE ROUND((points_earned / points_possible * 100.0)::DECIMAL(5,2), 2)
    END;
$function$
;

CREATE OR REPLACE FUNCTION public.can_access_assignment(assignment_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
DECLARE
    user_id UUID := auth.uid();
    assignment_course_id UUID;
    has_access BOOLEAN := false;
    is_available BOOLEAN := false;
BEGIN
    -- Get assignment's course ID
    SELECT course_id INTO assignment_course_id
    FROM assignments
    WHERE id = assignment_id
    AND deleted_at IS NULL;
    
    IF assignment_course_id IS NULL THEN
        RETURN false;
    END IF;
    
    -- Check if user can access the course
    SELECT can_access_course(assignment_course_id) INTO has_access;
    
    IF NOT has_access THEN
        RETURN false;
    END IF;
    
    -- For students, check if assignment is available
    IF get_user_role() = 'student' THEN
        SELECT (
            (available_from IS NULL OR available_from <= now()) AND
            (available_until IS NULL OR available_until > now())
        ) INTO is_available
        FROM assignments
        WHERE id = assignment_id;
        
        -- Also check assignment access table for group-based distribution
        IF NOT is_available THEN
            SELECT EXISTS (
                SELECT 1 FROM assignment_access
                WHERE assignment_id = assignment_id
                AND student_id = user_id
                AND is_active = true
                AND (release_date IS NULL OR release_date <= now())
            ) INTO is_available;
        END IF;
        
        RETURN is_available;
    END IF;
    
    -- Instructors and admins have full access
    RETURN true;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.can_access_course(course_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
DECLARE
    user_id UUID := auth.uid();
    user_role TEXT;
    user_org_id UUID;
    course_org_id UUID;
    course_instructor_id UUID;
    is_enrolled BOOLEAN := false;
BEGIN
    -- Get user information
    SELECT role, COALESCE(organization_id, preschool_id)
    INTO user_role, user_org_id
    FROM profiles
    WHERE id = user_id;
    
    IF user_role IS NULL THEN
        RETURN false;
    END IF;
    
    -- Get course information
    SELECT instructor_id, organization_id
    INTO course_instructor_id, course_org_id
    FROM courses
    WHERE id = course_id
    AND deleted_at IS NULL;
    
    IF course_org_id IS NULL THEN
        RETURN false;
    END IF;
    
    -- Super admins can access all courses
    IF user_role = 'super_admin' THEN
        RETURN true;
    END IF;
    
    -- Must be in same organization
    IF user_org_id != course_org_id THEN
        RETURN false;
    END IF;
    
    -- Admins can access all courses in their organization
    IF user_role = 'admin' THEN
        RETURN true;
    END IF;
    
    -- Instructors can access their own courses
    IF user_role = 'instructor' AND course_instructor_id = user_id THEN
        RETURN true;
    END IF;
    
    -- Students can access courses they are enrolled in
    IF user_role = 'student' THEN
        SELECT EXISTS (
            SELECT 1 FROM enrollments
            WHERE student_id = user_id
            AND course_id = course_id
            AND is_active = true
        ) INTO is_enrolled;
        
        RETURN is_enrolled;
    END IF;
    
    -- Default deny
    RETURN false;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.can_access_grade(grade_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
DECLARE
    user_id UUID := auth.uid();
    user_role TEXT := get_user_role();
    grade_submission_id UUID;
    grade_is_published BOOLEAN;
    submission_student_id UUID;
BEGIN
    -- Get grade details
    SELECT g.submission_id, g.is_published, s.student_id
    INTO grade_submission_id, grade_is_published, submission_student_id
    FROM grades g
    JOIN submissions s ON s.id = g.submission_id
    WHERE g.id = grade_id;
    
    IF grade_submission_id IS NULL THEN
        RETURN false;
    END IF;
    
    -- Students can only see their own published grades
    IF user_role = 'student' THEN
        RETURN submission_student_id = user_id AND grade_is_published;
    END IF;
    
    -- Others need submission access
    RETURN can_access_submission(grade_submission_id);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.can_access_organization(org_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
    SELECT 
        -- Super admins can access all organizations
        public.is_super_admin() OR 
        -- Users can access their own organization
        (public.get_user_organization_id() = org_id);
$function$
;

CREATE OR REPLACE FUNCTION public.can_access_preschool(target_preschool_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT 
    -- Super admin can access all (role = 'superadmin' in your data)
    (EXISTS (SELECT 1 FROM public.users WHERE auth_user_id = auth.uid() AND role = 'superadmin'))
    OR
    -- Regular users: must be member of the preschool
    (EXISTS (SELECT 1 FROM public.users WHERE auth_user_id = auth.uid() AND preschool_id = target_preschool_id));
$function$
;

CREATE OR REPLACE FUNCTION public.can_access_student_data(student_org_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT public.is_super_admin()
  OR public.is_org_admin(student_org_id)
  OR (
    public.get_user_role() = 'teacher'
    AND public.has_active_seat(student_org_id)
  );
$function$
;

CREATE OR REPLACE FUNCTION public.can_access_submission(submission_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
DECLARE
    user_id UUID := auth.uid();
    user_role TEXT := get_user_role();
    submission_student_id UUID;
    submission_assignment_id UUID;
BEGIN
    -- Get submission details
    SELECT student_id, assignment_id
    INTO submission_student_id, submission_assignment_id
    FROM submissions
    WHERE id = submission_id;
    
    IF submission_assignment_id IS NULL THEN
        RETURN false;
    END IF;
    
    -- Students can only access their own submissions
    IF user_role = 'student' THEN
        RETURN submission_student_id = user_id;
    END IF;
    
    -- Others need assignment access
    RETURN can_access_assignment(submission_assignment_id);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.can_approve_transaction(approver_member_id uuid, transaction_amount numeric, transaction_wing_id uuid DEFAULT NULL::uuid)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
  approver_role TEXT;
  approver_wing TEXT;
  spending_limit DECIMAL;
BEGIN
  -- Get approver details
  SELECT member_type, wing INTO approver_role, approver_wing
  FROM organization_members
  WHERE id = approver_member_id;
  
  IF approver_role IS NULL THEN
    RETURN false;
  END IF;
  
  -- Get spending limit
  spending_limit := get_spending_limit(approver_role);
  
  -- Check if amount is within limit
  IF transaction_amount > spending_limit THEN
    RETURN false;
  END IF;
  
  -- For wing transactions, check if approver belongs to that wing or is national_admin
  IF transaction_wing_id IS NOT NULL AND approver_role != 'national_admin' THEN
    -- Wing presidents/treasurers can approve their wing's transactions
    IF approver_wing != (SELECT wing_code FROM organization_wings WHERE id = transaction_wing_id) THEN
      RETURN false;
    END IF;
  END IF;
  
  RETURN true;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.can_manage_user(target_auth_user_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT EXISTS (
    SELECT 1 FROM public.users cu, public.users tu
    WHERE (
      cu.id = auth.uid() OR 
      cu.auth_user_id = auth.uid()
    )
    AND (
      tu.id = target_auth_user_id OR
      tu.auth_user_id = target_auth_user_id
    )
    AND coalesce(cu.is_active, true) = true
    AND (
      -- Super admin can manage anyone
      lower(cu.role) IN ('super_admin', 'superadmin')
      OR
      -- Self management
      (cu.id = tu.id OR cu.auth_user_id = tu.auth_user_id)
      OR
      -- Principal can manage users in their organization
      (
        lower(cu.role) IN ('principal', 'principal_admin')
        AND (
          (cu.organization_id IS NOT NULL 
           AND tu.organization_id = cu.organization_id)
          OR
          (cu.preschool_id IS NOT NULL 
           AND tu.preschool_id = cu.preschool_id)
          OR
          (coalesce(cu.organization_id, cu.preschool_id) IS NOT NULL 
           AND coalesce(tu.organization_id, tu.preschool_id) = coalesce(cu.organization_id, cu.preschool_id))
        )
      )
    )
  );
$function$
;

CREATE OR REPLACE FUNCTION public.can_self_enroll_in_course(p_course_id uuid, p_enrollment_method text DEFAULT NULL::text)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_course RECORD;
  v_user_org_id UUID;
  v_profile_exists BOOLEAN;
BEGIN
  -- Get course info
  SELECT id, organization_id, is_active, deleted_at
  INTO v_course
  FROM courses
  WHERE id = p_course_id
  LIMIT 1;

  -- Course must exist, be active, and not deleted
  IF NOT FOUND OR NOT v_course.is_active OR v_course.deleted_at IS NOT NULL THEN
    RETURN FALSE;
  END IF;

  -- PRIORITY 1: If enrollment_method is 'join_code', always allow (program code authorization)
  IF p_enrollment_method = 'join_code' THEN
    RETURN TRUE;
  END IF;

  -- Get user's organization_id
  SELECT organization_id INTO v_user_org_id
  FROM profiles
  WHERE id = auth.uid()
  LIMIT 1;

  -- PRIORITY 2: Allow if user can access organization (existing member)
  IF can_access_organization(v_course.organization_id) THEN
    RETURN TRUE;
  END IF;

  -- PRIORITY 3: Allow if user's profile doesn't exist (new registration)
  SELECT EXISTS(SELECT 1 FROM profiles WHERE id = auth.uid()) INTO v_profile_exists;
  IF NOT v_profile_exists THEN
    RETURN TRUE;
  END IF;

  -- PRIORITY 4: Allow if user has NULL organization_id (standalone learner)
  IF v_user_org_id IS NULL THEN
    RETURN TRUE;
  END IF;

  -- Otherwise, deny
  RETURN FALSE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.can_send_in_conversation(p_conversation_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_settings jsonb;
  v_role text;
  v_admins_only boolean := false;
  v_locked boolean := false;
  v_allow_member boolean := true;
  v_user_id uuid;
begin
  select id into v_user_id from public.users where auth_user_id = auth.uid();
  if v_user_id is null then
    return false;
  end if;

  select settings into v_settings from public.conversations where id = p_conversation_id;
  if not found then
    return false;
  end if;

  v_admins_only := coalesce((v_settings->>'admins_only')::boolean, false);
  v_locked := coalesce((v_settings->>'locked')::boolean, false);
  v_allow_member := coalesce((v_settings->>'allow_member_posting')::boolean, true);

  select role into v_role
  from public.conversation_members
  where conversation_id = p_conversation_id
    and user_id = v_user_id;

  if v_role is null then
    return false; -- not a member
  end if;

  if v_locked then
    return v_role in ('owner','admin');
  end if;

  if v_admins_only then
    return v_role in ('owner','admin');
  end if;

  if v_allow_member then
    return true; -- members may post
  end if;

  return v_role in ('owner','admin');
end;$function$
;

CREATE OR REPLACE FUNCTION public.can_student_enroll_in_course(student_id uuid, course_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
DECLARE
    course_max_students INTEGER;
    current_enrollment_count INTEGER;
    is_already_enrolled BOOLEAN;
    course_is_active BOOLEAN;
BEGIN
    -- Check if course exists and is active
    SELECT is_active, max_students
    INTO course_is_active, course_max_students
    FROM courses
    WHERE id = course_id
    AND deleted_at IS NULL;
    
    IF NOT FOUND OR NOT course_is_active THEN
        RETURN false;
    END IF;
    
    -- Check if student is already enrolled
    SELECT EXISTS (
        SELECT 1 FROM enrollments
        WHERE student_id = can_student_enroll_in_course.student_id
        AND course_id = can_student_enroll_in_course.course_id
        AND is_active = true
    ) INTO is_already_enrolled;
    
    IF is_already_enrolled THEN
        RETURN false;
    END IF;
    
    -- Check enrollment capacity
    IF course_max_students IS NOT NULL THEN
        SELECT get_course_enrollment_count(course_id) INTO current_enrollment_count;
        
        IF current_enrollment_count >= course_max_students THEN
            RETURN false;
        END IF;
    END IF;
    
    RETURN true;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.can_student_submit(assignment_id uuid, student_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
    SELECT CASE
        WHEN NOT public.assignment_accepts_submissions(can_student_submit.assignment_id) THEN false
        WHEN a.max_attempts <= 0 THEN true
        ELSE public.get_submission_attempt_count(can_student_submit.assignment_id, can_student_submit.student_id) < a.max_attempts
    END
    FROM assignments a
    WHERE a.id = can_student_submit.assignment_id;
$function$
;

CREATE OR REPLACE FUNCTION public.can_submit_exam(assignment_uuid uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  assignment_record RECORD;
  submission_count INTEGER;
BEGIN
  SELECT * INTO assignment_record FROM public.exam_assignments WHERE id = assignment_uuid AND auth.uid() = ANY(student_ids);
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('can_submit', false, 'reason', 'Assignment not found or not assigned to you');
  END IF;
  
  IF assignment_record.status != 'active' THEN
    RETURN jsonb_build_object('can_submit', false, 'reason', 'Assignment is no longer active');
  END IF;
  
  IF assignment_record.due_date IS NOT NULL AND assignment_record.due_date < NOW() AND NOT assignment_record.allow_late_submission THEN
    RETURN jsonb_build_object('can_submit', false, 'reason', 'Assignment deadline has passed');
  END IF;
  
  SELECT COUNT(*) INTO submission_count FROM public.exam_submissions WHERE assignment_id = assignment_uuid AND student_id = auth.uid() AND status = 'submitted';
  
  IF submission_count >= assignment_record.max_attempts THEN
    RETURN jsonb_build_object('can_submit', false, 'reason', 'Maximum attempts reached');
  END IF;
  
  RETURN jsonb_build_object('can_submit', true, 'attempts_remaining', assignment_record.max_attempts - submission_count);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.can_user_access_event(p_user_id uuid, p_event_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_user_role text;
  v_preschool_id uuid;
  v_can_access boolean := false;
BEGIN
  -- Get user's role and preschool
  SELECT role, preschool_id INTO v_user_role, v_preschool_id
  FROM public.users
  WHERE id = p_user_id;

  -- Check if event is in user's preschool
  IF NOT EXISTS (
    SELECT 1 FROM public.events
    WHERE id = p_event_id
    AND preschool_id = v_preschool_id
  ) THEN
    RETURN false;
  END IF;

  -- Check event audiences
  SELECT true INTO v_can_access
  FROM public.event_audiences
  WHERE event_id = p_event_id
  AND (
    -- Check role-based access
    (audience_type = 'role' AND target_value = v_user_role)
    -- Check user-specific access
    OR (audience_type = 'user' AND target_id = p_user_id)
    -- Check group-based access
    OR (audience_type = 'group' AND target_id IN (
      SELECT group_id FROM public.group_members
      WHERE user_id = p_user_id
      AND status = 'active'
    ))
    -- Check preschool-wide access
    OR (audience_type = 'preschool' AND target_id = v_preschool_id)
  )
  LIMIT 1;

  -- If no specific audiences defined, check if it's a public event
  IF v_can_access IS NULL THEN
    SELECT true INTO v_can_access
    FROM public.events
    WHERE id = p_event_id
    AND (
      metadata->>'visibility' = 'public'
      OR NOT EXISTS (
        SELECT 1 FROM public.event_audiences
        WHERE event_id = p_event_id
      )
    );
  END IF;

  RETURN COALESCE(v_can_access, false);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.can_user_see_event(p_event_id uuid, p_user_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_event RECORD;
    v_user RECORD;
    v_can_see BOOLEAN := false;
BEGIN
    -- Get event details
    SELECT * INTO v_event FROM public.events WHERE id = p_event_id;
    IF NOT FOUND THEN
        RETURN false;
    END IF;
    
    -- Get user details
    SELECT * INTO v_user FROM public.users WHERE id = p_user_id;
    IF NOT FOUND THEN
        RETURN false;
    END IF;
    
    -- Check if user is in the same preschool
    IF v_user.preschool_id != v_event.preschool_id THEN
        RETURN false;
    END IF;
    
    -- Check visibility
    IF v_event.visibility = 'public' THEN
        RETURN true;
    END IF;
    
    -- Check audience type
    CASE v_event.audience_type
        WHEN 'everyone' THEN
            v_can_see := true;
        WHEN 'principals' THEN
            v_can_see := v_user.role = 'preschool_admin';
        WHEN 'teachers' THEN
            v_can_see := v_user.role = 'teacher';
        WHEN 'parents' THEN
            v_can_see := v_user.role = 'parent';
        WHEN 'specific_groups' THEN
            -- Check if user is in any of the specified groups
            v_can_see := EXISTS (
                SELECT 1 FROM public.event_audiences ea
                JOIN public.group_members gm ON ea.target_id = gm.group_id
                WHERE ea.event_id = p_event_id 
                AND ea.audience_type = 'group'
                AND gm.user_id = p_user_id
                AND gm.status = 'active'
            );
        WHEN 'specific_users' THEN
            -- Check if user is specifically invited
            v_can_see := EXISTS (
                SELECT 1 FROM public.event_audiences ea
                WHERE ea.event_id = p_event_id 
                AND ea.audience_type = 'user'
                AND ea.target_id = p_user_id
            );
        ELSE
            v_can_see := false;
    END CASE;
    
    RETURN v_can_see;
END;
$function$
;

create or replace view "public"."caps_curriculum_latest" as  SELECT id,
    grade,
    subject,
    title,
    file_url,
    published_date,
    "left"(content_text, 500) AS preview
   FROM public.caps_documents d
  WHERE ((document_type)::text = 'curriculum'::text)
  ORDER BY grade, subject;


create or replace view "public"."caps_priority_topics" as  SELECT grade,
    subject,
    topic,
    frequency_score,
    likelihood_next_year,
    recommended_study_priority,
    years_appeared
   FROM public.caps_exam_patterns
  WHERE (((recommended_study_priority)::text = ANY ((ARRAY['high'::character varying, 'medium'::character varying])::text[])) AND (likelihood_next_year > (0.5)::double precision))
  ORDER BY grade, subject, likelihood_next_year DESC;


create or replace view "public"."caps_recent_exams" as  SELECT d.id,
    d.grade,
    d.subject,
    d.year,
    d.title,
    d.file_url,
    count(q.id) AS question_count
   FROM (public.caps_documents d
     LEFT JOIN public.caps_exam_questions q ON ((d.id = q.document_id)))
  WHERE (((d.document_type)::text = 'exam'::text) AND ((d.year)::numeric >= (EXTRACT(year FROM now()) - (5)::numeric)))
  GROUP BY d.id, d.grade, d.subject, d.year, d.title, d.file_url
  ORDER BY d.year DESC, d.grade, d.subject;


CREATE OR REPLACE FUNCTION public.check_ai_quota(p_user_id uuid DEFAULT auth.uid(), p_service_type text DEFAULT 'lesson_generation'::text, p_period_days integer DEFAULT 30)
 RETURNS TABLE(requests_used bigint, quota_limit integer, quota_remaining integer, is_over_quota boolean)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_requests_used BIGINT;
    v_quota_limit INTEGER := 50; -- Default limit
    v_user_tier TEXT;
BEGIN
    -- Get user's tier from profiles or preschool
    SELECT COALESCE(p.subscription_tier, ps.subscription_tier, 'free') 
    INTO v_user_tier
    FROM public.profiles p
    LEFT JOIN public.preschools ps ON p.organization_id = ps.id
    WHERE p.id = p_user_id;
    
    -- Set quota based on tier and service type
    IF v_user_tier IN ('premium', 'enterprise') THEN
        v_quota_limit := CASE p_service_type 
            WHEN 'lesson_generation' THEN 500
            WHEN 'homework_help' THEN 1000  
            WHEN 'grading_assistance' THEN 300
            ELSE 100
        END;
    ELSIF v_user_tier = 'starter' THEN
        v_quota_limit := CASE p_service_type
            WHEN 'lesson_generation' THEN 100
            WHEN 'homework_help' THEN 200
            WHEN 'grading_assistance' THEN 50
            ELSE 25
        END;
    ELSE -- free tier
        v_quota_limit := CASE p_service_type
            WHEN 'lesson_generation' THEN 10
            WHEN 'homework_help' THEN 25
            WHEN 'grading_assistance' THEN 5
            ELSE 5
        END;
    END IF;
    
    -- Count recent usage
    SELECT COUNT(*)
    INTO v_requests_used
    FROM public.ai_usage_logs
    WHERE user_id = p_user_id
        AND service_type = p_service_type
        AND created_at >= (now() - (p_period_days || ' days')::interval)
        AND status = 'success';
    
    -- Return results
    RETURN QUERY
    SELECT 
        v_requests_used,
        v_quota_limit,
        GREATEST(0, v_quota_limit - v_requests_used::INTEGER) as quota_remaining,
        v_requests_used >= v_quota_limit as is_over_quota;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_ai_usage_limit(p_user_id uuid, p_request_type character varying)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_usage RECORD;
  v_limits RECORD;
  v_can_proceed BOOLEAN := false;
  v_remaining INTEGER := 0;
  v_limit INTEGER := 0;
  v_preschool_id UUID;
BEGIN
  -- Check if user belongs to a platform school (unlimited access)
  SELECT preschool_id INTO v_preschool_id
  FROM profiles
  WHERE id = p_user_id;
  
  -- BYPASS 1: Community School (platform demo)
  IF v_preschool_id = '00000000-0000-0000-0000-000000000001'::uuid THEN
    RETURN jsonb_build_object(
      'allowed', true,
      'remaining', -1,
      'limit', -1,
      'current_tier', 'community_unlimited',
      'upgrade_available', false
    );
  END IF;
  
  -- BYPASS 2: EduDash Pro Main School (platform admin)
  IF v_preschool_id = '00000000-0000-0000-0000-000000000003'::uuid THEN
    RETURN jsonb_build_object(
      'allowed', true,
      'remaining', -1,
      'limit', -1,
      'current_tier', 'platform_admin_unlimited',
      'upgrade_available', false
    );
  END IF;
  
  -- Get or create user usage record
  INSERT INTO user_ai_usage (user_id)
  VALUES (p_user_id)
  ON CONFLICT (user_id) DO NOTHING;
  
  -- Reset counters if needed
  UPDATE user_ai_usage
  SET 
    exams_generated_this_month = 0,
    explanations_requested_this_month = 0,
    last_monthly_reset_at = NOW()
  WHERE user_id = p_user_id
    AND last_monthly_reset_at < (NOW() - INTERVAL '30 days');
  
  UPDATE user_ai_usage
  SET 
    chat_messages_today = 0,
    last_daily_reset_at = NOW()
  WHERE user_id = p_user_id
    AND last_daily_reset_at < (NOW() - INTERVAL '1 day');
  
  -- Get current usage
  SELECT * INTO v_usage
  FROM user_ai_usage
  WHERE user_id = p_user_id;
  
  -- Get tier limits
  SELECT * INTO v_limits
  FROM ai_usage_tiers
  WHERE tier_name = v_usage.current_tier
    AND is_active = true;
  
  -- Check limits based on request type
  IF p_request_type = 'exam_generation' THEN
    v_limit := v_limits.exams_per_month;
    v_remaining := v_limit - v_usage.exams_generated_this_month;
    v_can_proceed := v_usage.exams_generated_this_month < v_limit;
  ELSIF p_request_type = 'explanation' THEN
    v_limit := v_limits.explanations_per_month;
    v_remaining := v_limit - v_usage.explanations_requested_this_month;
    v_can_proceed := v_usage.explanations_requested_this_month < v_limit;
  ELSIF p_request_type = 'chat_message' THEN
    v_limit := v_limits.chat_messages_per_day;
    v_remaining := v_limit - v_usage.chat_messages_today;
    v_can_proceed := v_usage.chat_messages_today < v_limit;
  END IF;
  
  RETURN jsonb_build_object(
    'allowed', v_can_proceed,
    'remaining', v_remaining,
    'limit', v_limit,
    'current_tier', v_usage.current_tier,
    'upgrade_available', v_usage.current_tier IN ('free', 'trial')
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_document_access(p_document_id uuid, p_required_permission text DEFAULT 'view'::text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_has_access BOOLEAN := FALSE;
  v_doc RECORD;
BEGIN
  -- Get document info
  SELECT * INTO v_doc FROM organization_documents WHERE id = p_document_id;
  IF NOT FOUND THEN RETURN FALSE; END IF;
  
  -- Check if deleted
  IF v_doc.is_deleted THEN RETURN FALSE; END IF;
  
  -- Check member role-based access
  SELECT EXISTS (
    SELECT 1 FROM organization_members om
    WHERE om.user_id = auth.uid()
    AND om.organization_id = v_doc.organization_id
    AND om.membership_status = 'active'
    AND (
      v_doc.access_level = 'public'
      OR v_doc.access_level = 'members'
      OR (v_doc.access_level = 'managers' AND om.role IN ('admin', 'national_admin', 'regional_manager', 'branch_manager'))
      OR (v_doc.access_level = 'executives' AND om.role IN ('admin', 'national_admin'))
      OR (v_doc.access_level = 'admin_only' AND om.role IN ('admin', 'national_admin'))
    )
  ) INTO v_has_access;
  
  IF v_has_access THEN RETURN TRUE; END IF;
  
  -- Check explicit access grants
  SELECT EXISTS (
    SELECT 1 FROM organization_document_access oda
    WHERE oda.document_id = p_document_id
    AND oda.grantee_user_id = auth.uid()
    AND oda.revoked_at IS NULL
    AND (oda.valid_until IS NULL OR oda.valid_until > now())
    AND (
      (p_required_permission = 'view')
      OR (p_required_permission = 'download' AND oda.permission IN ('download', 'edit', 'admin'))
      OR (p_required_permission = 'edit' AND oda.permission IN ('edit', 'admin'))
      OR (p_required_permission = 'admin' AND oda.permission = 'admin')
    )
  ) INTO v_has_access;
  
  RETURN v_has_access;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_email_exists(p_email text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_exists BOOLEAN := false;
BEGIN
  -- Normalize email (lowercase, trim)
  p_email := LOWER(TRIM(p_email));
  
  -- Check in profiles table (source of truth - users table is deprecated)
  SELECT EXISTS(
    SELECT 1 
    FROM public.profiles 
    WHERE LOWER(email) = p_email
  ) INTO v_exists;
  
  RETURN v_exists;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_enrollment_capacity()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    IF TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND OLD.is_active = false AND NEW.is_active = true) THEN
        IF public.is_course_enrollment_full(NEW.course_id) THEN
            RAISE EXCEPTION 'Course enrollment capacity reached. Cannot enroll additional students.';
        END IF;
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_existing_users()
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    users_info JSON;
BEGIN
    SELECT json_build_object(
        'success', true,
        'total_users', (SELECT COUNT(*) FROM auth.users),
        'users', json_agg(
            json_build_object(
                'email', u.email,
                'created_at', u.created_at,
                'email_confirmed_at', u.email_confirmed_at,
                'last_sign_in_at', u.last_sign_in_at,
                'confirmed', (u.email_confirmed_at IS NOT NULL)
            )
        )
    ) INTO users_info
    FROM auth.users u
    ORDER BY u.created_at DESC
    LIMIT 10;
    
    RETURN users_info;
EXCEPTION
    WHEN OTHERS THEN
        RETURN json_build_object(
            'success', false,
            'error', SQLERRM
        );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_guest_limit(p_ip_address text, p_resource_type text DEFAULT 'exam_prep'::text, p_daily_limit integer DEFAULT 1)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_usage_count INT;
  v_allowed BOOLEAN;
BEGIN
  -- Count usage in last 24 hours
  SELECT COUNT(*) INTO v_usage_count
  FROM public.guest_usage_log
  WHERE ip_address = p_ip_address
    AND resource_type = p_resource_type
    AND created_at > NOW() - INTERVAL '24 hours';
  
  v_allowed := v_usage_count < p_daily_limit;
  
  RETURN jsonb_build_object(
    'allowed', v_allowed,
    'usage_count', v_usage_count,
    'limit', p_daily_limit,
    'resets_at', (NOW() + INTERVAL '24 hours')::text,
    'message', CASE 
      WHEN v_allowed THEN 'Access granted'
      ELSE format('Daily limit reached (%s/%s). Resets in %s hours.', 
                   v_usage_count, p_daily_limit, 
                   EXTRACT(HOUR FROM (NOW() + INTERVAL '24 hours' - 
                     (SELECT MIN(created_at) FROM guest_usage_log 
                      WHERE ip_address = p_ip_address 
                        AND created_at > NOW() - INTERVAL '24 hours'))))
    END
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_subscription_quota(p_subscription_id uuid, p_usage_type text, p_requested_amount integer DEFAULT 1)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_current_usage integer;
    v_quota_limit integer;
    v_plan_quota integer;
BEGIN
    -- Get current usage for this period
    SELECT current_usage, quota_limit INTO v_current_usage, v_quota_limit
    FROM public.subscription_usage
    WHERE subscription_id = p_subscription_id
    AND usage_type = p_usage_type
    AND period_start <= now()
    AND period_end > now();
    
    -- If no usage record exists, create one based on the plan
    IF v_current_usage IS NULL THEN
        -- Get quota from subscription plan
        SELECT 
            CASE p_usage_type
                WHEN 'ai_generations' THEN sp.ai_quota_monthly
                WHEN 'students' THEN sp.max_students
                WHEN 'teachers' THEN sp.max_teachers
                ELSE NULL
            END
        INTO v_plan_quota
        FROM public.subscriptions s
        JOIN public.subscription_plans sp ON sp.id = s.plan_id
        WHERE s.id = p_subscription_id;
        
        -- Create usage record
        INSERT INTO public.subscription_usage (
            subscription_id, usage_type, current_usage, quota_limit
        ) VALUES (
            p_subscription_id, p_usage_type, 0, v_plan_quota
        );
        
        v_current_usage := 0;
        v_quota_limit := v_plan_quota;
    END IF;
    
    -- Check if there's enough quota (NULL quota_limit means unlimited)
    IF v_quota_limit IS NULL THEN
        RETURN true;
    END IF;
    
    RETURN (v_current_usage + p_requested_amount) <= v_quota_limit;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_subscription_status(school_uuid uuid)
 RETURNS TABLE(is_active boolean, plan_id text, status text, days_remaining integer, needs_payment boolean)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        s.status = 'active' as is_active,
        s.plan_id,
        s.status,
        CASE 
            WHEN s.end_date IS NOT NULL 
            THEN EXTRACT(days FROM s.end_date - NOW())::INTEGER
            ELSE NULL
        END as days_remaining,
        s.status IN ('payment_failed', 'expired') as needs_payment
    FROM subscriptions s
    WHERE s.school_id = school_uuid
    ORDER BY s.created_at DESC
    LIMIT 1;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_tts_quota(p_user_id uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  user_tier TEXT;
  daily_limit INTEGER;
  current_usage INTEGER;
  remaining INTEGER;
BEGIN
  -- Get user's tier
  SELECT tier INTO user_tier
  FROM user_ai_tiers
  WHERE user_id = p_user_id
  LIMIT 1;
  
  IF user_tier IS NULL THEN
    user_tier := 'free';
  END IF;
  
  -- Get tier limits
  CASE user_tier
    WHEN 'school' THEN daily_limit := 1000;
    WHEN 'premium' THEN daily_limit := 200;
    WHEN 'basic' THEN daily_limit := 50;
    WHEN 'trial' THEN daily_limit := 20;
    ELSE daily_limit := 3;
  END CASE;
  
  -- Get current usage
  current_usage := get_daily_tts_usage(p_user_id);
  remaining := GREATEST(0, daily_limit - current_usage);
  
  RETURN jsonb_build_object(
    'allowed', remaining > 0,
    'remaining', remaining,
    'limit', daily_limit,
    'tier', user_tier,
    'current_usage', current_usage
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_voice_usage_limit(p_user_id uuid, p_preschool_id uuid, p_service text, p_estimated_units numeric)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_tier TEXT;
  v_quota RECORD;
  v_daily_usage RECORD;
  v_monthly_usage RECORD;
  v_can_proceed BOOLEAN := false;
  v_reason TEXT := '';
  v_quota_remaining JSONB;
BEGIN
  -- Get preschool subscription tier
  SELECT subscription_tier INTO v_tier
  FROM public.preschools
  WHERE id = p_preschool_id;
  
  IF v_tier IS NULL THEN
    v_tier := 'free'; -- Default to free tier
  END IF;
  
  -- Get quota limits
  SELECT * INTO v_quota
  FROM public.voice_usage_quotas
  WHERE subscription_tier = v_tier;
  
  -- Get current daily usage
  SELECT * INTO v_daily_usage
  FROM public.user_voice_usage
  WHERE user_id = p_user_id
    AND period_type = 'daily'
    AND period_start::date = CURRENT_DATE
  ORDER BY period_start DESC
  LIMIT 1;
  
  -- Get current monthly usage
  SELECT * INTO v_monthly_usage
  FROM public.user_voice_usage
  WHERE user_id = p_user_id
    AND period_type = 'monthly'
    AND period_start >= date_trunc('month', CURRENT_DATE)
  ORDER BY period_start DESC
  LIMIT 1;
  
  -- Initialize if no records exist
  IF v_daily_usage IS NULL THEN
    v_daily_usage := ROW(
      gen_random_uuid(), p_user_id, p_preschool_id, 'daily',
      CURRENT_DATE, CURRENT_DATE + INTERVAL '1 day',
      0, 0, 0, 0, 0, 0, 0, now(), 0, now(), now()
    )::public.user_voice_usage;
  END IF;
  
  IF v_monthly_usage IS NULL THEN
    v_monthly_usage := ROW(
      gen_random_uuid(), p_user_id, p_preschool_id, 'monthly',
      date_trunc('month', CURRENT_DATE), 
      date_trunc('month', CURRENT_DATE) + INTERVAL '1 month',
      0, 0, 0, 0, 0, 0, 0, now(), 0, now(), now()
    )::public.user_voice_usage;
  END IF;
  
  -- Check limits based on service type
  IF p_service = 'stt' THEN
    -- Check daily STT limit
    IF (COALESCE(v_daily_usage.stt_total_minutes, 0) + p_estimated_units) > v_quota.stt_daily_minutes THEN
      v_reason := format('Daily STT limit exceeded: %s/%s minutes used', 
                        COALESCE(v_daily_usage.stt_total_minutes, 0), 
                        v_quota.stt_daily_minutes);
    -- Check monthly STT limit
    ELSIF (COALESCE(v_monthly_usage.stt_total_minutes, 0) + p_estimated_units) > v_quota.stt_monthly_minutes THEN
      v_reason := format('Monthly STT limit exceeded: %s/%s minutes used', 
                        COALESCE(v_monthly_usage.stt_total_minutes, 0), 
                        v_quota.stt_monthly_minutes);
    -- Check daily cost cap
    ELSIF (COALESCE(v_daily_usage.total_cost_usd, 0) + (p_estimated_units * 0.006 / 60)) > v_quota.daily_cost_cap_usd THEN
      v_reason := format('Daily cost cap exceeded: $%s/$%s', 
                        COALESCE(v_daily_usage.total_cost_usd, 0), 
                        v_quota.daily_cost_cap_usd);
    ELSE
      v_can_proceed := true;
    END IF;
    
  ELSIF p_service = 'tts' THEN
    -- Check daily TTS limit
    IF (COALESCE(v_daily_usage.tts_total_characters, 0) + p_estimated_units) > v_quota.tts_daily_characters THEN
      v_reason := format('Daily TTS limit exceeded: %s/%s characters used', 
                        COALESCE(v_daily_usage.tts_total_characters, 0), 
                        v_quota.tts_daily_characters);
    -- Check monthly TTS limit
    ELSIF (COALESCE(v_monthly_usage.tts_total_characters, 0) + p_estimated_units) > v_quota.tts_monthly_characters THEN
      v_reason := format('Monthly TTS limit exceeded: %s/%s characters used', 
                        COALESCE(v_monthly_usage.tts_total_characters, 0), 
                        v_quota.tts_monthly_characters);
    -- Check daily cost cap
    ELSIF (COALESCE(v_daily_usage.total_cost_usd, 0) + (p_estimated_units * 0.000016)) > v_quota.daily_cost_cap_usd THEN
      v_reason := format('Daily cost cap exceeded: $%s/$%s', 
                        COALESCE(v_daily_usage.total_cost_usd, 0), 
                        v_quota.daily_cost_cap_usd);
    ELSE
      v_can_proceed := true;
    END IF;
  END IF;
  
  -- Build quota remaining response
  v_quota_remaining := jsonb_build_object(
    'tier', v_tier,
    'daily', jsonb_build_object(
      'stt_minutes_remaining', v_quota.stt_daily_minutes - COALESCE(v_daily_usage.stt_total_minutes, 0),
      'tts_characters_remaining', v_quota.tts_daily_characters - COALESCE(v_daily_usage.tts_total_characters, 0),
      'cost_remaining_usd', v_quota.daily_cost_cap_usd - COALESCE(v_daily_usage.total_cost_usd, 0)
    ),
    'monthly', jsonb_build_object(
      'stt_minutes_remaining', v_quota.stt_monthly_minutes - COALESCE(v_monthly_usage.stt_total_minutes, 0),
      'tts_characters_remaining', v_quota.tts_monthly_characters - COALESCE(v_monthly_usage.tts_total_characters, 0),
      'cost_remaining_usd', v_quota.monthly_cost_cap_usd - COALESCE(v_monthly_usage.total_cost_usd, 0)
    )
  );
  
  RETURN jsonb_build_object(
    'allowed', v_can_proceed,
    'reason', v_reason,
    'tier', v_tier,
    'quota_remaining', v_quota_remaining
  );
END;
$function$
;

create or replace view "public"."classes_with_teachers" as  SELECT c.id,
    c.name,
    c.age_group,
    c.preschool_id,
    c.teacher_id,
    c.max_students AS capacity,
    c.active AS is_active,
    c.created_at,
    c.updated_at,
    c.room_number,
    c.current_students AS current_enrollment,
    c.max_capacity,
    c.age_min,
    c.age_max,
    c.age_group_id,
    c.grade_level,
    u.id AS teacher_user_id,
    u.name AS teacher_full_name,
    u.email AS teacher_email,
    u.phone AS teacher_phone,
    u.role AS teacher_role
   FROM (public.classes c
     LEFT JOIN public.users u ON (((c.teacher_id = u.id) AND (u.role = 'teacher'::text))));


CREATE OR REPLACE FUNCTION public.cleanup_expired_blocks()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Update expired blocks to inactive
  UPDATE public.user_blocks
  SET is_active = FALSE, updated_at = NOW()
  WHERE expires_at IS NOT NULL 
    AND expires_at <= NOW() 
    AND is_active = TRUE;
  
  RETURN NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.cleanup_expired_dash_storage()
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM public.dash_storage
    WHERE expires_at IS NOT NULL
    AND expires_at < NOW();
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.cleanup_old_call_signals()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    DELETE FROM public.call_signals
    WHERE created_at < NOW() - INTERVAL '24 hours';
    
    -- Also clean up stale active calls
    UPDATE public.active_calls
    SET status = 'missed', ended_at = NOW()
    WHERE status = 'ringing'
    AND started_at < NOW() - INTERVAL '1 minute';
END;
$function$
;

CREATE OR REPLACE FUNCTION public.cleanup_old_guest_logs()
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_deleted_count INT;
BEGIN
  -- Delete logs older than 30 days
  DELETE FROM public.guest_usage_log
  WHERE created_at < NOW() - INTERVAL '30 days';
  
  GET DIAGNOSTICS v_deleted_count = ROW_COUNT;
  
  RAISE NOTICE 'Deleted % old guest usage logs', v_deleted_count;
  RETURN v_deleted_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.cleanup_old_sessions()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  DELETE FROM user_sessions
  WHERE last_active_at < NOW() - INTERVAL '30 days';
END;
$function$
;

CREATE OR REPLACE FUNCTION public.cleanup_old_voice_notes()
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  deleted_count INTEGER := 0;
  old_file RECORD;
BEGIN
  -- Find and delete voice note files older than 30 days
  FOR old_file IN
    SELECT name
    FROM storage.objects 
    WHERE bucket_id = 'voice-notes' 
    AND created_at < NOW() - INTERVAL '30 days'
  LOOP
    -- Delete the file
    DELETE FROM storage.objects 
    WHERE bucket_id = 'voice-notes' AND name = old_file.name;
    
    deleted_count := deleted_count + 1;
  END LOOP;
  
  RETURN deleted_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.cleanup_stale_typing_indicators()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- Delete typing indicators older than 10 seconds
  DELETE FROM public.typing_indicators
  WHERE last_updated_at < now() - interval '10 seconds';
END;
$function$
;

CREATE OR REPLACE FUNCTION public.cleanup_unused_images(p_days_old integer DEFAULT 90)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
  deleted_count INT;
BEGIN
  DELETE FROM chat_images
  WHERE 
    reference_count = 0
    AND created_at < NOW() - (p_days_old || ' days')::INTERVAL
  RETURNING id INTO deleted_count;
  
  RETURN COALESCE(deleted_count, 0);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.compute_age_group(dob date)
 RETURNS public.age_group_type
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
declare
  years int;
begin
  -- Return null if no date of birth provided
  if dob is null then
    return null;
  end if;
  
  -- Calculate age in years
  years := date_part('year', age(current_date, dob));
  
  -- Classify into age groups
  if years <= 12 then
    return 'child'::public.age_group_type;
  elsif years <= 17 then
    return 'teen'::public.age_group_type;
  else
    return 'adult'::public.age_group_type;
  end if;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.configure_delivery_provider(p_provider_name public.delivery_provider_enum, p_config jsonb DEFAULT '{}'::jsonb, p_endpoints jsonb DEFAULT '{}'::jsonb, p_is_enabled boolean DEFAULT true, p_daily_quota integer DEFAULT NULL::integer, p_monthly_quota integer DEFAULT NULL::integer)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'auth'
AS $function$
DECLARE
  v_user_id UUID;
  v_is_superadmin BOOLEAN;
  v_provider_id UUID;
BEGIN
  -- Get current user ID
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Authentication required',
      'error_code', 'AUTH_REQUIRED'
    );
  END IF;
  
  -- Check if user is superadmin
  SELECT EXISTS (
    SELECT 1 FROM user_profiles 
    WHERE user_id = v_user_id 
    AND role = 'super_admin' 
    AND is_active = true
  ) INTO v_is_superadmin;
  
  IF NOT v_is_superadmin THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Superadmin privileges required',
      'error_code', 'INSUFFICIENT_PRIVILEGES'
    );
  END IF;
  
  -- Update provider configuration
  UPDATE delivery_providers SET
    config = p_config,
    endpoints = p_endpoints,
    is_enabled = p_is_enabled,
    daily_quota = p_daily_quota,
    monthly_quota = p_monthly_quota,
    updated_by = v_user_id,
    updated_at = now()
  WHERE provider_name = p_provider_name
  RETURNING id INTO v_provider_id;
  
  IF NOT FOUND THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Provider not found: ' || p_provider_name,
      'error_code', 'PROVIDER_NOT_FOUND'
    );
  END IF;
  
  RETURN json_build_object(
    'success', true,
    'provider_id', v_provider_id,
    'provider_name', p_provider_name,
    'is_enabled', p_is_enabled,
    'message', 'Provider configured successfully'
  );
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object(
      'success', false,
      'error', SQLERRM,
      'error_code', 'INTERNAL_ERROR'
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_announcement_channel(p_preschool_id uuid, p_created_by uuid, p_channel_name text, p_description text DEFAULT NULL::text, p_audience text DEFAULT 'all_parents'::text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_thread_id UUID;
  v_creator_role TEXT;
  v_user_ids UUID[];
BEGIN
  -- Get creator role
  SELECT role INTO v_creator_role FROM profiles WHERE id = p_created_by;

  -- Only principals and admins can create announcement channels
  IF v_creator_role NOT IN ('principal', 'admin', 'principal_admin') THEN
    RAISE EXCEPTION 'Only principals and admins can create announcement channels';
  END IF;

  -- Create the thread
  INSERT INTO message_threads (
    preschool_id,
    created_by,
    subject,
    type,
    is_group,
    group_name,
    group_description,
    group_type,
    allow_replies,
    created_by_role
  )
  VALUES (
    p_preschool_id,
    p_created_by,
    p_channel_name,
    'announcement',
    TRUE,
    p_channel_name,
    p_description,
    'announcement',
    FALSE, -- No replies allowed
    v_creator_role
  )
  RETURNING id INTO v_thread_id;

  -- Add creator as admin (can send)
  INSERT INTO message_participants (thread_id, user_id, role, is_admin, can_send_messages)
  VALUES (v_thread_id, p_created_by, v_creator_role, TRUE, TRUE);

  -- Add all principals/admins as admins (can also send)
  INSERT INTO message_participants (thread_id, user_id, role, is_admin, can_send_messages)
  SELECT v_thread_id, id, role, TRUE, TRUE
  FROM profiles
  WHERE preschool_id = p_preschool_id
    AND role IN ('principal', 'admin', 'principal_admin')
    AND id != p_created_by
  ON CONFLICT (thread_id, user_id) DO NOTHING;

  -- Get audience user IDs
  CASE p_audience
    WHEN 'all_parents' THEN
      SELECT ARRAY_AGG(DISTINCT guardian_id) INTO v_user_ids
      FROM students
      WHERE preschool_id = p_preschool_id AND guardian_id IS NOT NULL;
    WHEN 'all_teachers' THEN
      SELECT ARRAY_AGG(id) INTO v_user_ids
      FROM profiles
      WHERE preschool_id = p_preschool_id AND role = 'teacher';
    WHEN 'all_staff' THEN
      SELECT ARRAY_AGG(id) INTO v_user_ids
      FROM profiles
      WHERE preschool_id = p_preschool_id AND role IN ('teacher', 'admin', 'principal');
    WHEN 'everyone' THEN
      -- Get all staff
      SELECT ARRAY_AGG(id) INTO v_user_ids
      FROM profiles
      WHERE preschool_id = p_preschool_id;
      -- Add parents
      SELECT array_cat(v_user_ids, ARRAY_AGG(DISTINCT guardian_id)) INTO v_user_ids
      FROM students
      WHERE preschool_id = p_preschool_id AND guardian_id IS NOT NULL;
  END CASE;

  -- Add audience as members (read-only)
  IF v_user_ids IS NOT NULL AND array_length(v_user_ids, 1) > 0 THEN
    INSERT INTO message_participants (thread_id, user_id, role, is_admin, can_send_messages)
    SELECT v_thread_id, uid, 
           COALESCE((SELECT role FROM profiles WHERE id = uid), 'parent'),
           FALSE, 
           FALSE -- Cannot send messages
    FROM unnest(v_user_ids) AS uid
    WHERE uid NOT IN (
      SELECT user_id FROM message_participants WHERE thread_id = v_thread_id
    )
    ON CONFLICT (thread_id, user_id) DO NOTHING;
  END IF;

  RETURN v_thread_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_audit_log(p_event_type public.audit_event_type, p_event_name text, p_actor_id uuid DEFAULT NULL::uuid, p_target_id uuid DEFAULT NULL::uuid, p_target_type text DEFAULT NULL::text, p_ip_address inet DEFAULT NULL::inet, p_metadata jsonb DEFAULT '{}'::jsonb, p_success boolean DEFAULT true, p_error_message text DEFAULT NULL::text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    log_id UUID;
    actor_role TEXT;
    actor_org_id UUID;
BEGIN
    -- Get actor details if provided
    IF p_actor_id IS NOT NULL THEN
        SELECT role, preschool_id INTO actor_role, actor_org_id 
        FROM profiles WHERE id = p_actor_id;
    END IF;
    
    -- Insert audit log
    INSERT INTO audit_logs (
        event_type, event_name, actor_id, actor_role, actor_organization_id,
        target_id, target_type, ip_address, metadata, success, error_message
    ) VALUES (
        p_event_type, p_event_name, p_actor_id, actor_role, actor_org_id,
        p_target_id, p_target_type, p_ip_address, 
        COALESCE(p_metadata, '{}'::jsonb), p_success, p_error_message
    ) RETURNING id INTO log_id;
    
    RETURN log_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_class_group(p_class_id uuid, p_preschool_id uuid, p_created_by uuid, p_group_name text DEFAULT NULL::text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_thread_id UUID;
  v_class_name TEXT;
  v_teacher_id UUID;
  v_parent_ids UUID[];
BEGIN
  -- Get class info
  SELECT name, teacher_id INTO v_class_name, v_teacher_id
  FROM classes
  WHERE id = p_class_id AND preschool_id = p_preschool_id;

  IF v_class_name IS NULL THEN
    RAISE EXCEPTION 'Class not found';
  END IF;

  -- Check if group already exists for this class
  SELECT id INTO v_thread_id
  FROM message_threads
  WHERE class_id = p_class_id AND group_type = 'class_group' AND is_group = TRUE;

  IF v_thread_id IS NOT NULL THEN
    RETURN v_thread_id;
  END IF;

  -- Create the thread
  INSERT INTO message_threads (
    preschool_id,
    created_by,
    subject,
    type,
    is_group,
    group_name,
    group_type,
    class_id,
    created_by_role
  )
  VALUES (
    p_preschool_id,
    p_created_by,
    COALESCE(p_group_name, v_class_name || ' Parents'),
    'class_group',
    TRUE,
    COALESCE(p_group_name, v_class_name || ' Parents'),
    'class_group',
    p_class_id,
    (SELECT role FROM profiles WHERE id = p_created_by)
  )
  RETURNING id INTO v_thread_id;

  -- Add teacher as admin
  IF v_teacher_id IS NOT NULL THEN
    INSERT INTO message_participants (thread_id, user_id, role, is_admin, can_send_messages)
    VALUES (v_thread_id, v_teacher_id, 'teacher', TRUE, TRUE)
    ON CONFLICT (thread_id, user_id) DO NOTHING;
  END IF;

  -- Add creator as admin if different from teacher
  IF p_created_by != v_teacher_id OR v_teacher_id IS NULL THEN
    INSERT INTO message_participants (thread_id, user_id, role, is_admin, can_send_messages)
    VALUES (v_thread_id, p_created_by, (SELECT role FROM profiles WHERE id = p_created_by), TRUE, TRUE)
    ON CONFLICT (thread_id, user_id) DO NOTHING;
  END IF;

  -- Get all parent IDs for students in this class
  SELECT ARRAY_AGG(DISTINCT guardian_id) INTO v_parent_ids
  FROM students
  WHERE class_id = p_class_id
    AND guardian_id IS NOT NULL;

  -- Add all parents
  IF v_parent_ids IS NOT NULL THEN
    INSERT INTO message_participants (thread_id, user_id, role, is_admin, can_send_messages)
    SELECT v_thread_id, unnest(v_parent_ids), 'parent', FALSE, TRUE
    ON CONFLICT (thread_id, user_id) DO NOTHING;
  END IF;

  RETURN v_thread_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_default_fee_structures(p_preschool_id uuid)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  inserted_count INTEGER := 0;
BEGIN
  -- Toddlers (0-2 years)
  INSERT INTO public.school_fee_structures (
    preschool_id, name, description, age_group, amount_cents, 
    billing_frequency, fee_category, is_active
  ) VALUES (
    p_preschool_id, 
    'Toddlers Monthly Fee', 
    'Monthly tuition for children aged 0-2 years',
    '0-2',
    150000, -- R1,500.00
    'monthly',
    'tuition',
    true
  );
  inserted_count := inserted_count + 1;

  -- Preschool (3-4 years)
  INSERT INTO public.school_fee_structures (
    preschool_id, name, description, age_group, amount_cents,
    billing_frequency, fee_category, is_active
  ) VALUES (
    p_preschool_id,
    'Preschool Monthly Fee',
    'Monthly tuition for children aged 3-4 years',
    '3-4',
    120000, -- R1,200.00
    'monthly',
    'tuition',
    true
  );
  inserted_count := inserted_count + 1;

  -- Grade R (5-6 years)
  INSERT INTO public.school_fee_structures (
    preschool_id, name, description, age_group, amount_cents,
    billing_frequency, fee_category, is_active
  ) VALUES (
    p_preschool_id,
    'Grade R Monthly Fee',
    'Monthly tuition for Grade R learners',
    '5-6',
    100000, -- R1,000.00
    'monthly',
    'tuition',
    true
  );
  inserted_count := inserted_count + 1;

  -- Registration fee (once-off)
  INSERT INTO public.school_fee_structures (
    preschool_id, name, description, amount_cents,
    billing_frequency, fee_category, is_optional, is_active
  ) VALUES (
    p_preschool_id,
    'Registration Fee',
    'One-time registration fee for new students',
    50000, -- R500.00
    'once_off',
    'registration',
    false,
    true
  );
  inserted_count := inserted_count + 1;

  RETURN inserted_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_default_school_branding()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
    INSERT INTO public.school_branding (
        preschool_id,
        primary_color,
        secondary_color,
        accent_color,
        footer_text,
        payment_terms
    )
    SELECT 
        p.id,
        '#4F46E5',
        '#7C3AED', 
        '#00f5ff',
        'Thank you for choosing ' || p.name || '!',
        'Payment due within 30 days of invoice date'
    FROM public.preschools p
    WHERE NOT EXISTS (
        SELECT 1 FROM public.school_branding sb 
        WHERE sb.preschool_id = p.id
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_notification_delivery(p_notification_id uuid, p_channel public.delivery_method_enum, p_template_key text DEFAULT NULL::text, p_recipient_id uuid DEFAULT NULL::uuid, p_recipient_email text DEFAULT NULL::text, p_recipient_phone text DEFAULT NULL::text, p_recipient_device_token text DEFAULT NULL::text, p_template_variables jsonb DEFAULT '{}'::jsonb, p_priority integer DEFAULT 0, p_send_at timestamp with time zone DEFAULT now())
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'auth'
AS $function$
DECLARE
  v_user_id UUID;
  v_is_superadmin BOOLEAN;
  v_template notification_templates%ROWTYPE;
  v_provider_id UUID;
  v_delivery_id UUID;
  v_rendered_content JSON;
  v_result JSON;
BEGIN
  -- Get current user ID
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Authentication required',
      'error_code', 'AUTH_REQUIRED'
    );
  END IF;
  
  -- Check if user is superadmin
  SELECT EXISTS (
    SELECT 1 FROM user_profiles 
    WHERE user_id = v_user_id 
    AND role = 'super_admin' 
    AND is_active = true
  ) INTO v_is_superadmin;
  
  IF NOT v_is_superadmin THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Superadmin privileges required',
      'error_code', 'INSUFFICIENT_PRIVILEGES'
    );
  END IF;
  
  -- Validate required parameters
  IF p_notification_id IS NULL OR p_channel IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Missing required parameters: notification_id and channel',
      'error_code', 'MISSING_PARAMETERS'
    );
  END IF;
  
  -- Validate channel-specific recipients
  IF (p_channel = 'email' AND p_recipient_email IS NULL) OR
     (p_channel = 'sms' AND p_recipient_phone IS NULL) OR
     (p_channel = 'push_notification' AND p_recipient_device_token IS NULL) THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Missing recipient information for channel: ' || p_channel,
      'error_code', 'MISSING_RECIPIENT'
    );
  END IF;
  
  -- Get template if specified
  IF p_template_key IS NOT NULL THEN
    SELECT * FROM notification_templates 
    WHERE template_key = p_template_key AND status = 'active'
    INTO v_template;
    
    IF NOT FOUND THEN
      RETURN json_build_object(
        'success', false,
        'error', 'Active template not found: ' || p_template_key,
        'error_code', 'TEMPLATE_NOT_FOUND'
      );
    END IF;
    
    -- Render template content
    SELECT render_notification_template(p_template_key, p_template_variables) INTO v_rendered_content;
    
    IF (v_rendered_content->>'success')::boolean = false THEN
      RETURN json_build_object(
        'success', false,
        'error', 'Template rendering failed: ' || (v_rendered_content->>'error'),
        'error_code', 'TEMPLATE_RENDER_ERROR'
      );
    END IF;
  END IF;
  
  -- Select best available provider for channel
  SELECT id FROM delivery_providers
  WHERE is_enabled = true 
  AND p_channel = ANY(supported_channels)
  AND (daily_quota IS NULL OR current_daily_usage < daily_quota)
  AND (monthly_quota IS NULL OR current_monthly_usage < monthly_quota)
  ORDER BY priority DESC, id
  LIMIT 1
  INTO v_provider_id;
  
  IF v_provider_id IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'No available provider for channel: ' || p_channel,
      'error_code', 'NO_PROVIDER'
    );
  END IF;
  
  -- Create delivery record
  INSERT INTO notification_deliveries (
    notification_id,
    template_id,
    recipient_id,
    recipient_email,
    recipient_phone,
    recipient_device_token,
    channel,
    provider_id,
    subject,
    body,
    html_body,
    template_variables,
    render_time_ms,
    priority,
    send_at
  ) VALUES (
    p_notification_id,
    v_template.id,
    p_recipient_id,
    p_recipient_email,
    p_recipient_phone,
    p_recipient_device_token,
    p_channel,
    v_provider_id,
    CASE WHEN v_rendered_content IS NOT NULL THEN v_rendered_content->>'subject' ELSE NULL END,
    CASE WHEN v_rendered_content IS NOT NULL THEN v_rendered_content->>'body' ELSE 'Default notification content' END,
    CASE WHEN v_rendered_content IS NOT NULL THEN v_rendered_content->>'html' ELSE NULL END,
    p_template_variables,
    CASE WHEN v_rendered_content IS NOT NULL THEN (v_rendered_content->>'render_time_ms')::integer ELSE NULL END,
    p_priority,
    p_send_at
  ) RETURNING id INTO v_delivery_id;
  
  -- Return success
  RETURN json_build_object(
    'success', true,
    'delivery_id', v_delivery_id,
    'provider_id', v_provider_id,
    'channel', p_channel,
    'status', 'pending',
    'message', 'Delivery created successfully'
  );
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object(
      'success', false,
      'error', SQLERRM,
      'error_code', 'INTERNAL_ERROR'
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_notification_template(p_template_key text, p_name text, p_category public.template_category_enum, p_body_template text, p_description text DEFAULT NULL::text, p_subject_template text DEFAULT NULL::text, p_html_template text DEFAULT NULL::text, p_variables jsonb DEFAULT '[]'::jsonb, p_default_variables jsonb DEFAULT '{}'::jsonb, p_required_variables text[] DEFAULT '{}'::text[], p_language text DEFAULT 'en'::text, p_localization_key text DEFAULT NULL::text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'auth'
AS $function$
DECLARE
  v_template_id UUID;
  v_user_id UUID;
  v_is_superadmin BOOLEAN;
  v_result JSON;
BEGIN
  -- Get current user ID
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Authentication required',
      'error_code', 'AUTH_REQUIRED'
    );
  END IF;
  
  -- Check if user is superadmin
  SELECT EXISTS (
    SELECT 1 FROM user_profiles 
    WHERE user_id = v_user_id 
    AND role = 'super_admin' 
    AND is_active = true
  ) INTO v_is_superadmin;
  
  IF NOT v_is_superadmin THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Superadmin privileges required',
      'error_code', 'INSUFFICIENT_PRIVILEGES'
    );
  END IF;
  
  -- Validate required parameters
  IF p_template_key IS NULL OR p_name IS NULL OR p_body_template IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Missing required parameters',
      'error_code', 'MISSING_PARAMETERS'
    );
  END IF;
  
  -- Validate template key format
  IF NOT (p_template_key ~ '^[a-z][a-z0-9_]*$') THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Template key must start with lowercase letter and contain only lowercase letters, numbers, and underscores',
      'error_code', 'INVALID_TEMPLATE_KEY'
    );
  END IF;
  
  -- Validate email templates have subjects
  IF p_category = 'email' AND p_subject_template IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Email templates must have a subject',
      'error_code', 'EMAIL_SUBJECT_REQUIRED'
    );
  END IF;
  
  -- Insert the template
  INSERT INTO notification_templates (
    template_key,
    name,
    description,
    category,
    subject_template,
    body_template,
    html_template,
    variables,
    default_variables,
    required_variables,
    language,
    localization_key,
    status,
    created_by,
    updated_by
  ) VALUES (
    p_template_key,
    p_name,
    p_description,
    p_category,
    p_subject_template,
    p_body_template,
    p_html_template,
    p_variables,
    p_default_variables,
    p_required_variables,
    p_language,
    p_localization_key,
    'draft',
    v_user_id,
    v_user_id
  ) RETURNING id INTO v_template_id;
  
  -- Return success with template details
  SELECT json_build_object(
    'success', true,
    'template_id', v_template_id,
    'template_key', p_template_key,
    'status', 'draft',
    'message', 'Template created successfully'
  ) INTO v_result;
  
  RETURN v_result;
  
EXCEPTION
  WHEN unique_violation THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Template key already exists',
      'error_code', 'DUPLICATE_KEY'
    );
  WHEN OTHERS THEN
    RETURN json_build_object(
      'success', false,
      'error', SQLERRM,
      'error_code', 'INTERNAL_ERROR'
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_organization(p_name text, p_type text DEFAULT 'preschool'::text, p_phone text DEFAULT NULL::text, p_status text DEFAULT 'active'::text)
 RETURNS TABLE(id uuid, name text, type text, phone text, status text, created_by uuid, created_at timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_id UUID;
  v_user_role TEXT;
  v_new_org RECORD;
  v_has_org_id_column BOOLEAN;
BEGIN
  -- Get the authenticated user ID
  v_user_id := auth.uid();

  -- Ensure user is authenticated
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated' USING ERRCODE = '42501';
  END IF;

  -- Get user's role from profiles table
  SELECT profiles.role INTO v_user_role
  FROM public.profiles
  WHERE profiles.id = v_user_id;

  -- Allow principals, superadmins, and admins to create organizations
  -- 'admin' role is for Skills Development Centres, Tertiary Institutions, and Other Organizations
  IF v_user_role NOT IN ('principal', 'superadmin', 'admin') THEN
    RAISE EXCEPTION 'Only principals, superadmins, and admins can create organizations'
      USING ERRCODE = '42501';
  END IF;

  -- Validate organization name
  IF p_name IS NULL OR TRIM(p_name) = '' THEN
    RAISE EXCEPTION 'Organization name is required' USING ERRCODE = '22023';
  END IF;

  -- Validate organization type
  IF p_type NOT IN (
    'preschool',
    'daycare',
    'primary_school',
    'skills',
    'tertiary',
    'org',
    'other'
  ) THEN
    RAISE EXCEPTION 'Invalid organization type' USING ERRCODE = '22023';
  END IF;

  -- Validate status
  IF p_status NOT IN ('active', 'inactive', 'pending') THEN
    RAISE EXCEPTION 'Invalid organization status' USING ERRCODE = '22023';
  END IF;

  -- Insert the new organization
  INSERT INTO public.organizations (
    name,
    type,
    phone,
    status,
    created_by
  )
  VALUES (
    TRIM(p_name),
    p_type,
    p_phone,
    p_status,
    v_user_id
  )
  RETURNING
    organizations.id,
    organizations.name,
    organizations.type,
    organizations.phone,
    organizations.status,
    organizations.created_by,
    organizations.created_at
  INTO v_new_org;

  -- Check if profiles has organization_id column
  SELECT EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema = 'public'
      AND table_name = 'profiles'
      AND column_name = 'organization_id'
  ) INTO v_has_org_id_column;

  -- Update the creator's profile to link to this organization
  IF v_has_org_id_column THEN
    -- Use organization_id if it exists
    UPDATE public.profiles
    SET organization_id = v_new_org.id
    WHERE profiles.id = v_user_id;
  ELSE
    -- For backwards compatibility, try updating preschool_id
    -- but only if preschools table exists and we can create a matching record
    -- For now, skip this to avoid foreign key errors
    -- The profile linking can be handled separately
    NULL;
  END IF;

  -- Return the created organization
  id := v_new_org.id;
  name := v_new_org.name;
  type := v_new_org.type;
  phone := v_new_org.phone;
  status := v_new_org.status;
  created_by := v_new_org.created_by;
  created_at := v_new_org.created_at;

  RETURN NEXT;

END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_parent_group(p_preschool_id uuid, p_created_by uuid, p_group_name text, p_parent_ids uuid[], p_description text DEFAULT NULL::text, p_allow_replies boolean DEFAULT true)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_thread_id UUID;
  v_creator_role TEXT;
BEGIN
  -- Get creator role
  SELECT role INTO v_creator_role FROM profiles WHERE id = p_created_by;

  -- Only principals, teachers, and admins can create parent groups
  IF v_creator_role NOT IN ('principal', 'teacher', 'admin', 'principal_admin') THEN
    RAISE EXCEPTION 'Only school staff can create parent groups';
  END IF;

  -- Create the thread
  INSERT INTO message_threads (
    preschool_id,
    created_by,
    subject,
    type,
    is_group,
    group_name,
    group_description,
    group_type,
    allow_replies,
    created_by_role
  )
  VALUES (
    p_preschool_id,
    p_created_by,
    p_group_name,
    'parent_group',
    TRUE,
    p_group_name,
    p_description,
    'parent_group',
    p_allow_replies,
    v_creator_role
  )
  RETURNING id INTO v_thread_id;

  -- Add creator as admin
  INSERT INTO message_participants (thread_id, user_id, role, is_admin, can_send_messages)
  VALUES (v_thread_id, p_created_by, v_creator_role, TRUE, TRUE);

  -- Add parents as members
  IF p_parent_ids IS NOT NULL AND array_length(p_parent_ids, 1) > 0 THEN
    INSERT INTO message_participants (thread_id, user_id, role, is_admin, can_send_messages)
    SELECT v_thread_id, unnest(p_parent_ids), 'parent', FALSE, p_allow_replies
    ON CONFLICT (thread_id, user_id) DO NOTHING;
  END IF;

  RETURN v_thread_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_school_with_admin(p_school_name text, p_admin_email text, p_admin_name text, p_subscription_plan text DEFAULT 'trial'::text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_school_id UUID;
  v_tenant_slug TEXT;
  v_result jsonb;
BEGIN
  -- Generate unique tenant slug
  v_tenant_slug := LOWER(REGEXP_REPLACE(p_school_name, '[^a-zA-Z0-9]', '-', 'g')) || '-' || EXTRACT(EPOCH FROM NOW())::TEXT;
  
  -- Insert school record (bypasses RLS due to SECURITY DEFINER)
  INSERT INTO preschools (
    name,
    email,
    subscription_plan,
    subscription_status,
    tenant_slug,
    onboarding_status,
    setup_completed,
    phone,
    address,
    timezone,
    max_students,
    max_teachers,
    created_at,
    updated_at
  ) VALUES (
    p_school_name,
    p_admin_email,
    p_subscription_plan,
    'active',
    v_tenant_slug,
    'completed',
    true,
    '',
    '',
    'Africa/Johannesburg',
    50,
    10,
    NOW(),
    NOW()
  )
  RETURNING id INTO v_school_id;

  -- Return success result
  v_result := jsonb_build_object(
    'success', true,
    'school_id', v_school_id,
    'tenant_slug', v_tenant_slug,
    'message', 'School created successfully'
  );

  RETURN v_result;

EXCEPTION WHEN OTHERS THEN
  -- Return error result
  v_result := jsonb_build_object(
    'success', false,
    'error', SQLERRM,
    'sqlstate', SQLSTATE
  );
  
  RETURN v_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_specific_superadmin(p_email text, p_name text DEFAULT 'EduDash Super Administrator'::text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  auth_user_id uuid;
  user_id uuid;
  result_message text;
BEGIN
  -- Check if user already exists in auth.users
  SELECT id INTO auth_user_id 
  FROM auth.users 
  WHERE email = p_email;
  
  IF auth_user_id IS NOT NULL THEN
    -- User exists in auth, now check/create profile
    SELECT id INTO user_id
    FROM users 
    WHERE auth_user_id = auth_user_id;
    
    IF user_id IS NOT NULL THEN
      -- Update existing user to superadmin
      UPDATE users 
      SET 
        role = 'superadmin',
        is_active = true,
        updated_at = now()
      WHERE id = user_id;
      
      result_message := 'Existing user updated to superadmin';
    ELSE
      -- Create new profile for existing auth user
      INSERT INTO users (
        id,
        email,
        name,
        role,
        auth_user_id,
        is_active,
        profile_completion_status,
        created_at,
        updated_at
      ) VALUES (
        gen_random_uuid(),
        p_email,
        p_name,
        'superadmin',
        auth_user_id,
        true,
        'complete',
        now(),
        now()
      )
      RETURNING id INTO user_id;
      
      result_message := 'Profile created for existing auth user';
    END IF;
  ELSE
    -- Auth user doesn't exist, we need to insert manually into auth.users
    -- Generate a new UUID for the auth user
    auth_user_id := gen_random_uuid();
    
    -- Insert into auth.users (this is unusual but needed for setup)
    INSERT INTO auth.users (
      id,
      instance_id,
      email,
      encrypted_password,
      email_confirmed_at,
      created_at,
      updated_at,
      role,
      aud
    ) VALUES (
      auth_user_id,
      '00000000-0000-0000-0000-000000000000',
      p_email,
      crypt('#Olivia@17', gen_salt('bf')), -- Hash the password
      now(),
      now(),
      now(),
      'authenticated',
      'authenticated'
    );
    
    -- Create the corresponding profile
    INSERT INTO users (
      id,
      email,
      name,
      role,
      auth_user_id,
      is_active,
      profile_completion_status,
      created_at,
      updated_at
    ) VALUES (
      gen_random_uuid(),
      p_email,
      p_name,
      'superadmin',
      auth_user_id,
      true,
      'complete',
      now(),
      now()
    )
    RETURNING id INTO user_id;
    
    result_message := 'Complete superadmin user created (auth + profile)';
  END IF;
  
  RETURN json_build_object(
    'success', true,
    'message', result_message,
    'auth_user_id', auth_user_id,
    'profile_user_id', user_id,
    'email', p_email
  );
  
EXCEPTION WHEN OTHERS THEN
  RETURN json_build_object(
    'success', false,
    'message', 'Error: ' || SQLERRM,
    'error_detail', SQLSTATE
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_superadmin_for_current_user()
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  user_id uuid;
  user_email text;
BEGIN
  -- Get current auth user email
  SELECT email INTO user_email
  FROM auth.users 
  WHERE id = auth.uid();
  
  -- Insert or update user as superadmin
  INSERT INTO users (
    id,
    email,
    name,
    role,
    auth_user_id,
    is_active,
    profile_completion_status,
    created_at,
    updated_at
  ) VALUES (
    gen_random_uuid(),
    COALESCE(user_email, 'superadmin@edudash.pro'),
    'EduDash Super Administrator',
    'superadmin',
    auth.uid(),
    true,
    'complete',
    now(),
    now()
  )
  ON CONFLICT (auth_user_id) 
  DO UPDATE SET
    role = 'superadmin',
    is_active = true,
    updated_at = now()
  RETURNING id INTO user_id;
  
  RETURN json_build_object(
    'success', true,
    'message', 'Superadmin user created/updated successfully',
    'user_id', user_id
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_superadmin_notification(admin_id_param uuid, type_param public.notification_type_enum, source_param public.notification_source_enum, severity_param public.severity_enum, title_param text, message_param text, metadata_param jsonb DEFAULT '{}'::jsonb, related_resource_type_param text DEFAULT NULL::text, related_resource_id_param text DEFAULT NULL::text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  notification_id UUID;
BEGIN
  INSERT INTO superadmin_notifications (
    admin_id,
    type,
    source,
    severity,
    title,
    message,
    metadata,
    related_resource_type,
    related_resource_id
  ) VALUES (
    admin_id_param,
    type_param,
    source_param,
    severity_param,
    title_param,
    message_param,
    metadata_param,
    related_resource_type_param,
    related_resource_id_param
  ) RETURNING id INTO notification_id;

  RETURN notification_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_superadmin_test_data()
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  superadmin_id UUID;
  test_user_id UUID;
  notification_id UUID;
  risk_assessment_id UUID;
  result JSONB;
BEGIN
  -- Get or create superladmin user
  SELECT user_id INTO superadmin_id
  FROM user_profiles 
  WHERE role = 'super_admin' AND is_active = true 
  LIMIT 1;

  IF superadmin_id IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'No superladmin user found. Cannot create test data.'
    );
  END IF;

  -- Create a test user if none exists (for testing purposes)
  INSERT INTO user_profiles (user_id, email, full_name, role, is_active)
  VALUES (
    gen_random_uuid(),
    'test.user@example.com',
    'Test User for Superladmin',
    'user',
    true
  ) 
  ON CONFLICT (user_id) DO NOTHING
  RETURNING user_id INTO test_user_id;

  -- If we didn't create a new user, get an existing non-superladmin user
  IF test_user_id IS NULL THEN
    SELECT user_id INTO test_user_id
    FROM user_profiles 
    WHERE role != 'super_admin'
    LIMIT 1;
  END IF;

  -- Create sample risk assessment
  IF test_user_id IS NOT NULL THEN
    INSERT INTO superladmin_user_risk_assessments (
      user_id, 
      risk_score, 
      assessment_reason,
      assessed_by,
      assessment_type
    ) VALUES (
      test_user_id,
      65,
      'Sample risk assessment for testing',
      superadmin_id,
      'manual'
    ) 
    ON CONFLICT (user_id) DO UPDATE SET
      risk_score = EXCLUDED.risk_score,
      assessment_reason = EXCLUDED.assessment_reason,
      updated_at = now()
    RETURNING id INTO risk_assessment_id;
  END IF;

  -- Create sample notification
  SELECT create_superadmin_notification(
    superadmin_id,
    'system_error'::notification_type_enum,
    'error_monitoring'::notification_source_enum,
    'high'::severity_enum,
    'Test System Alert',
    'This is a test notification for the superladmin dashboard.',
    jsonb_build_object('test', true, 'created_by', 'test_function'),
    'system',
    'test'
  ) INTO notification_id;

  -- Create sample audit log entry
  PERFORM log_superadmin_action(
    superadmin_id,
    test_user_id,
    NULL,
    'user_updated'::superladmin_action_enum,
    'test',
    'test_data_creation',
    'Created sample test data for superladmin system',
    jsonb_build_object('action', 'test_data_creation'),
    jsonb_build_object('test_user_id', test_user_id, 'notification_id', notification_id)
  );

  RETURN jsonb_build_object(
    'success', true,
    'message', 'Test data created successfully',
    'data', jsonb_build_object(
      'superadmin_id', superadmin_id,
      'test_user_id', test_user_id,
      'notification_id', notification_id,
      'risk_assessment_id', risk_assessment_id
    )
  );

EXCEPTION
  WHEN OTHERS THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Failed to create test data: ' || SQLERRM
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_system_notification(p_recipient_user_id uuid, p_title text, p_message text, p_notification_type text DEFAULT 'system'::text, p_metadata jsonb DEFAULT '{}'::jsonb)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_notification_id UUID;
  v_preschool_id UUID;
BEGIN
  -- Get the user's preschool_id for context
  SELECT preschool_id INTO v_preschool_id 
  FROM public.users 
  WHERE id = p_recipient_user_id;
  
  -- Insert notification
  INSERT INTO public.push_notifications (
    recipient_user_id,
    title,
    message,
    notification_type,
    preschool_id,
    metadata,
    created_at,
    read_at
  )
  VALUES (
    p_recipient_user_id,
    p_title,
    p_message,
    p_notification_type,
    v_preschool_id,
    p_metadata,
    NOW(),
    NULL
  )
  RETURNING id INTO v_notification_id;
  
  RETURN v_notification_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_teacher_for_preschool(teacher_email text, teacher_name text, target_preschool_id uuid, teacher_phone text DEFAULT NULL::text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  new_teacher_id uuid;
begin
  -- Verify caller is principal/admin of the preschool
  if not exists (
    select 1 from public.users 
    where auth_user_id = auth.uid() 
    and preschool_id = target_preschool_id 
    and role in ('principal', 'superadmin')
  ) then
    raise exception 'Only principals can create teachers for their preschool';
  end if;

  -- Check if teacher already exists
  if exists (select 1 from public.users where email = teacher_email) then
    raise exception 'User with this email already exists';
  end if;

  -- Create the teacher user record (will need manual auth.users creation)
  insert into public.users (
    email,
    name,
    role,
    preschool_id,
    phone,
    is_active,
    profile_completion_status
  ) values (
    teacher_email,
    teacher_name,
    'teacher',
    target_preschool_id,
    teacher_phone,
    true,
    'incomplete'
  ) returning id into new_teacher_id;

  return new_teacher_id;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.create_test_superadmin(p_email text, p_name text, p_auth_user_id uuid)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  user_id uuid;
BEGIN
  -- Insert or update superadmin user
  INSERT INTO users (
    id,
    email,
    name,
    role,
    auth_user_id,
    is_active,
    profile_completion_status,
    created_at,
    updated_at
  ) VALUES (
    gen_random_uuid(),
    p_email,
    p_name,
    'superadmin',
    p_auth_user_id,
    true,
    'complete',
    now(),
    now()
  )
  ON CONFLICT (auth_user_id) 
  DO UPDATE SET
    role = 'superadmin',
    is_active = true,
    updated_at = now()
  RETURNING id INTO user_id;
  
  RETURN user_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_trial_subscription(p_school_id uuid)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  starter_plan_id UUID;
  trial_days INTEGER;
  grace_days INTEGER;
  subscription_id UUID;
BEGIN
  -- Get trial configuration
  SELECT 
    (value->>'duration_days')::INTEGER,
    (value->>'grace_period_days')::INTEGER
  INTO trial_days, grace_days
  FROM public.system_config
  WHERE key = 'trial_settings';
  
  -- Default to 7 days if config not found
  trial_days := COALESCE(trial_days, 7);
  grace_days := COALESCE(grace_days, 1);

  -- Get starter plan
  SELECT id INTO starter_plan_id
  FROM public.subscription_plans
  WHERE tier = 'starter'
  LIMIT 1;

  IF starter_plan_id IS NULL THEN
    RAISE EXCEPTION 'Starter plan not found';
  END IF;

  -- Create trial subscription
  INSERT INTO public.subscriptions (
    school_id,
    plan_id,
    status,
    start_date,
    trial_end_date,
    next_billing_date,
    created_at
  ) VALUES (
    p_school_id,
    starter_plan_id,
    'trialing',
    NOW(),
    NOW() + (trial_days || ' days')::INTERVAL,
    NOW() + ((trial_days + grace_days) || ' days')::INTERVAL,
    NOW()
  )
  RETURNING id INTO subscription_id;

  RETURN subscription_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_trial_subscription_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- Create trial subscription for new preschool
  PERFORM create_trial_subscription(NEW.id);
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_user_trial_subscription(p_user_id uuid)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  starter_plan_id UUID;
  trial_days INTEGER;
  grace_days INTEGER;
  subscription_id UUID;
BEGIN
  -- Get trial configuration
  SELECT 
    (value->>'duration_days')::INTEGER,
    (value->>'grace_period_days')::INTEGER
  INTO trial_days, grace_days
  FROM public.system_config
  WHERE key = 'trial_settings';
  
  trial_days := COALESCE(trial_days, 7);
  grace_days := COALESCE(grace_days, 1);

  -- Get parent starter plan
  SELECT id INTO starter_plan_id
  FROM public.subscription_plans
  WHERE name = 'Parent Starter'
  LIMIT 1;

  IF starter_plan_id IS NULL THEN
    -- Fallback to any starter plan
    SELECT id INTO starter_plan_id
    FROM public.subscription_plans
    WHERE tier = 'starter'
    LIMIT 1;
  END IF;

  IF starter_plan_id IS NULL THEN
    RAISE EXCEPTION 'No starter plan found';
  END IF;

  -- Create trial subscription (if user_subscriptions table exists)
  BEGIN
    INSERT INTO public.user_subscriptions (
      user_id,
      subscription_plan_id,
      status,
      trial_start_date,
      trial_end_date,
      next_billing_date,
      auto_renew,
      created_at
    ) VALUES (
      p_user_id,
      starter_plan_id,
      'trial',
      NOW(),
      NOW() + (trial_days || ' days')::INTERVAL,
      NOW() + ((trial_days + grace_days) || ' days')::INTERVAL,
      false,
      NOW()
    )
    RETURNING id INTO subscription_id;
  EXCEPTION WHEN undefined_table THEN
    -- Table doesn't exist yet, return null
    RETURN NULL;
  END;

  RETURN subscription_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.current_organization_id()
 RETURNS uuid
 LANGUAGE sql
 STABLE
AS $function$
  SELECT COALESCE(
    NULLIF(current_setting('request.jwt.claims', true), '')::jsonb ->> 'organization_id',
    NULLIF(current_setting('request.jwt.claims', true), '')::jsonb ->> 'preschool_id'
  )::uuid;
$function$
;

CREATE OR REPLACE FUNCTION public.current_user_role()
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN COALESCE(
    auth.jwt() ->> 'user_role',
    auth.jwt() ->> 'role',
    'parent'  -- Default fallback
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  claims JSONB;
  user_id UUID;
  user_preschool_id UUID;
  user_role TEXT;
  user_organization_id UUID;
BEGIN
  -- Extract the user ID from the event
  user_id := (event->>'user_id')::UUID;

  -- Get the current claims
  claims := event->'claims';

  -- Try to get user's preschool_id and role from the users table
  BEGIN
    SELECT
      preschool_id,
      role,
      preschool_id -- Also use as organization_id for compatibility
    INTO
      user_preschool_id,
      user_role,
      user_organization_id
    FROM users
    WHERE auth_user_id = user_id OR id = user_id
    LIMIT 1;
  EXCEPTION
    WHEN OTHERS THEN
      -- Log but don't fail
      RAISE WARNING 'custom_access_token_hook: Error querying users table: %', SQLERRM;
  END;

  -- If no user found in users table, try profiles table as fallback
  IF user_preschool_id IS NULL AND user_role IS NULL THEN
    BEGIN
      SELECT
        COALESCE(preschool_id, organization_id),
        role,
        COALESCE(organization_id, preschool_id)
      INTO
        user_preschool_id,
        user_role,
        user_organization_id
      FROM profiles
      WHERE id = user_id
      LIMIT 1;
    EXCEPTION
      WHEN OTHERS THEN
        -- Log but don't fail
        RAISE WARNING 'custom_access_token_hook: Error querying profiles table: %', SQLERRM;
    END;
  END IF;

  -- Add custom claims to the JWT token
  IF user_preschool_id IS NOT NULL THEN
    claims := jsonb_set(claims, '{preschool_id}', to_jsonb(user_preschool_id::TEXT));
    claims := jsonb_set(claims, '{organization_id}', to_jsonb(user_organization_id::TEXT));
  END IF;

  IF user_role IS NOT NULL THEN
    claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    claims := jsonb_set(claims, '{role}', to_jsonb(user_role));
  END IF;

  -- Return the event with updated claims
  RETURN jsonb_set(event, '{claims}', claims);
  
EXCEPTION
  WHEN OTHERS THEN
    -- If anything fails, just return the original event unchanged
    RAISE WARNING 'custom_access_token_hook: Unexpected error: %', SQLERRM;
    RETURN event;
END;
$function$
;

create or replace view "public"."daily_ai_usage_rollup" as  SELECT preschool_id,
    user_id,
    date_trunc('day'::text, created_at) AS usage_date,
    quota_consumed_from,
    count(*) AS request_count,
    sum((COALESCE(input_tokens, 0) + COALESCE(output_tokens, 0))) AS total_tokens,
    avg((COALESCE(input_tokens, 0) + COALESCE(output_tokens, 0))) AS avg_tokens_per_request,
    sum(COALESCE(response_time_ms, 0)) AS total_processing_time,
    avg(COALESCE(response_time_ms, 0)) AS avg_processing_time,
    sum(COALESCE(total_cost, (0)::numeric)) AS total_cost
   FROM public.ai_usage_logs
  WHERE (quota_consumed_from IS NOT NULL)
  GROUP BY preschool_id, user_id, (date_trunc('day'::text, created_at)), quota_consumed_from;


CREATE OR REPLACE FUNCTION public.dash_delete(p_storage_key text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    DELETE FROM public.dash_storage
    WHERE user_id = auth.uid()
    AND storage_key = p_storage_key;
    
    RETURN FOUND;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.dash_list_keys(p_data_type text DEFAULT NULL::text, p_category text DEFAULT NULL::text)
 RETURNS TABLE(storage_key text, data_type text, category text, tags text[], created_at timestamp with time zone, updated_at timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        ds.storage_key,
        ds.data_type,
        ds.category,
        ds.tags,
        ds.created_at,
        ds.updated_at
    FROM public.dash_storage ds
    WHERE ds.user_id = auth.uid()
    AND (ds.expires_at IS NULL OR ds.expires_at > NOW())
    AND (p_data_type IS NULL OR ds.data_type = p_data_type)
    AND (p_category IS NULL OR ds.category = p_category)
    ORDER BY ds.updated_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.dash_retrieve(p_storage_key text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_storage_value JSONB;
BEGIN
    SELECT storage_value INTO v_storage_value
    FROM public.dash_storage
    WHERE user_id = auth.uid()
    AND storage_key = p_storage_key
    AND (expires_at IS NULL OR expires_at > NOW())
    LIMIT 1;
    
    RETURN v_storage_value;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.dash_store(p_storage_key text, p_storage_value jsonb, p_data_type text DEFAULT 'general'::text, p_category text DEFAULT NULL::text, p_tags text[] DEFAULT NULL::text[], p_expires_at timestamp with time zone DEFAULT NULL::timestamp with time zone)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_preschool_id UUID;
    v_storage_id UUID;
BEGIN
    -- Get user's preschool_id
    SELECT preschool_id INTO v_preschool_id
    FROM public.profiles
    WHERE user_id = auth.uid()
    LIMIT 1;
    
    IF v_preschool_id IS NULL THEN
        RAISE EXCEPTION 'User profile not found';
    END IF;
    
    -- Upsert storage entry
    INSERT INTO public.dash_storage (
        preschool_id,
        user_id,
        storage_key,
        storage_value,
        data_type,
        category,
        tags,
        expires_at
    ) VALUES (
        v_preschool_id,
        auth.uid(),
        p_storage_key,
        p_storage_value,
        p_data_type,
        p_category,
        p_tags,
        p_expires_at
    )
    ON CONFLICT (preschool_id, user_id, storage_key)
    DO UPDATE SET
        storage_value = EXCLUDED.storage_value,
        data_type = EXCLUDED.data_type,
        category = EXCLUDED.category,
        tags = EXCLUDED.tags,
        expires_at = EXCLUDED.expires_at,
        updated_at = NOW()
    RETURNING id INTO v_storage_id;
    
    RETURN v_storage_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.deactivate_notification_template(p_template_id uuid)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'auth'
AS $function$
DECLARE
  v_user_id UUID;
  v_is_superadmin BOOLEAN;
BEGIN
  -- Get current user ID
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Authentication required',
      'error_code', 'AUTH_REQUIRED'
    );
  END IF;
  
  -- Check if user is superadmin
  SELECT EXISTS (
    SELECT 1 FROM user_profiles 
    WHERE user_id = v_user_id 
    AND role = 'super_admin' 
    AND is_active = true
  ) INTO v_is_superadmin;
  
  IF NOT v_is_superadmin THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Superadmin privileges required',
      'error_code', 'INSUFFICIENT_PRIVILEGES'
    );
  END IF;
  
  -- Update template status
  UPDATE notification_templates SET
    status = 'inactive',
    updated_by = v_user_id,
    updated_at = now()
  WHERE id = p_template_id;
  
  IF NOT FOUND THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Template not found',
      'error_code', 'TEMPLATE_NOT_FOUND'
    );
  END IF;
  
  RETURN json_build_object(
    'success', true,
    'template_id', p_template_id,
    'status', 'inactive',
    'message', 'Template deactivated successfully'
  );
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object(
      'success', false,
      'error', SQLERRM,
      'error_code', 'INTERNAL_ERROR'
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.debug_auth_detailed()
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    jwt_claims json;
BEGIN
    jwt_claims := auth.jwt();
    RETURN json_build_object(
      'auth_uid', auth.uid(),
      'auth_role', auth.role(),
      'current_user', current_user,
      'session_user', session_user,
      'jwt_sub', jwt_claims->>'sub',
      'jwt_email', jwt_claims->>'email',
      'jwt_role', jwt_claims->>'role',
      'jwt_exp', jwt_claims->>'exp',
      'now', NOW()
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.debug_auth_uid()
 RETURNS json
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT json_build_object(
    'auth_uid', auth.uid(),
    'auth_role', auth.role(),
    'current_user', current_user,
    'session_user', session_user
  );
$function$
;

CREATE OR REPLACE FUNCTION public.debug_find_profile(search_auth_id uuid DEFAULT NULL::uuid)
 RETURNS json
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT json_build_object(
    'search_auth_id', COALESCE(search_auth_id, auth.uid()),
    'profiles_by_auth_user_id', (
      SELECT json_agg(
        json_build_object(
          'id', p.id,
          'email', p.email,
          'role', p.role,
          'auth_user_id', p.auth_user_id
        )
      )
      FROM public.profiles p 
      WHERE p.auth_user_id = COALESCE(search_auth_id, auth.uid())
    ),
    'profiles_by_id', (
      SELECT json_agg(
        json_build_object(
          'id', p.id,
          'email', p.email, 
          'role', p.role,
          'auth_user_id', p.auth_user_id
        )
      )
      FROM public.profiles p
      WHERE p.id = COALESCE(search_auth_id, auth.uid())
    ),
    'all_profiles_sample', (
      SELECT json_agg(
        json_build_object(
          'id', p.id,
          'email', p.email,
          'role', p.role,
          'auth_user_id', p.auth_user_id
        )
      )
      FROM public.profiles p
      LIMIT 3
    )
  );
$function$
;

CREATE OR REPLACE FUNCTION public.debug_get_profile_direct(target_auth_id uuid)
 RETURNS public.profiles
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
    user_profile profiles;
BEGIN
    -- Get the profile directly (bypasses RLS)
    -- First try profile.id
    SELECT * INTO user_profile
    FROM profiles
    WHERE id = target_auth_id;
    
    -- If not found, try auth_user_id
    IF user_profile IS NULL THEN
        SELECT * INTO user_profile
        FROM profiles
        WHERE auth_user_id = target_auth_id;
    END IF;
    
    -- Return the profile
    RETURN user_profile;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.debug_list_all_profiles()
 RETURNS TABLE(email text, role text, auth_user_id uuid, id uuid)
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
    SELECT p.email, p.role, p.auth_user_id, p.id FROM public.profiles p ORDER BY p.email;
$function$
;

CREATE OR REPLACE FUNCTION public.debug_messaging_contacts()
 RETURNS TABLE(current_user_auth_id uuid, current_user_internal_id uuid, current_user_preschool_id uuid, total_users_in_preschool bigint, active_teachers_count bigint, active_parents_count bigint, all_roles_in_preschool text[])
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_auth_id uuid;
  v_user_id uuid;
  v_preschool_id uuid;
BEGIN
  -- Get current user info
  v_auth_id := auth.uid();
  
  SELECT u.id, u.preschool_id INTO v_user_id, v_preschool_id
  FROM public.users u
  WHERE u.auth_user_id = v_auth_id
  LIMIT 1;
  
  RETURN QUERY
  SELECT 
    v_auth_id,
    v_user_id,
    v_preschool_id,
    (SELECT COUNT(*) FROM public.users WHERE preschool_id = v_preschool_id),
    (SELECT COUNT(*) FROM public.users WHERE preschool_id = v_preschool_id AND role IN ('teacher', 'admin', 'principal', 'preschool_admin') AND COALESCE(is_active, true) = true),
    (SELECT COUNT(*) FROM public.users WHERE preschool_id = v_preschool_id AND role = 'parent' AND COALESCE(is_active, true) = true),
    (SELECT ARRAY_AGG(DISTINCT role) FROM public.users WHERE preschool_id = v_preschool_id AND role IS NOT NULL);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.debug_messaging_context()
 RETURNS TABLE(auth_uid uuid, internal_user_id uuid, user_name text, user_role text, preschool_id uuid, preschool_name text, contacts_in_school bigint)
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
DECLARE
  v_user_id uuid;
  v_preschool_id uuid;
BEGIN
  -- Get current user
  BEGIN
    v_user_id := app.current_user_id();
  EXCEPTION WHEN OTHERS THEN
    SELECT u.id INTO v_user_id
    FROM public.users u
    WHERE u.auth_user_id = auth.uid()
    LIMIT 1;
  END;
  
  -- Get preschool
  SELECT u.preschool_id INTO v_preschool_id
  FROM public.users u
  WHERE u.id = v_user_id;
  
  RETURN QUERY
  SELECT 
    auth.uid() as auth_uid,
    v_user_id as internal_user_id,
    u.name as user_name,
    u.role::text as user_role,
    u.preschool_id,
    p.name as preschool_name,
    (SELECT COUNT(*) FROM public.users u2 
     WHERE u2.preschool_id = u.preschool_id 
     AND u2.id != u.id 
     AND COALESCE(u2.is_active, true) = true) as contacts_in_school
  FROM public.users u
  LEFT JOIN public.preschools p ON p.id = u.preschool_id
  WHERE u.id = v_user_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.debug_organization_creation()
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_id UUID;
  v_profile RECORD;
  v_org_columns TEXT[];
  v_result JSONB;
BEGIN
  -- Get authenticated user
  v_user_id := auth.uid();

  -- Gather profile information
  SELECT * INTO v_profile
  FROM public.profiles
  WHERE id = v_user_id;

  -- Get organizations table columns
  SELECT array_agg(column_name) INTO v_org_columns
  FROM information_schema.columns
  WHERE table_schema = 'public'
    AND table_name = 'organizations';

  -- Build result
  v_result := jsonb_build_object(
    'user_id', v_user_id,
    'authenticated', v_user_id IS NOT NULL,
    'profile', jsonb_build_object(
      'exists', v_profile.id IS NOT NULL,
      'email', v_profile.email,
      'role', v_profile.role,
      'first_name', v_profile.first_name,
      'last_name', v_profile.last_name,
      'preschool_id', v_profile.preschool_id,
      'organization_id', (row_to_json(v_profile)::jsonb)->>'organization_id'
    ),
    'permissions', jsonb_build_object(
      'can_create_org', v_profile.role IN ('principal', 'superadmin'),
      'role_check', v_profile.role || ' (expected: principal or superadmin)'
    ),
    'organizations_table', jsonb_build_object(
      'columns', v_org_columns,
      'has_created_by', 'created_by' = ANY(v_org_columns),
      'has_type', 'type' = ANY(v_org_columns),
      'has_status', 'status' = ANY(v_org_columns)
    ),
    'rpc_function', jsonb_build_object(
      'exists', EXISTS(
        SELECT 1
        FROM pg_proc p
        JOIN pg_namespace n ON p.pronamespace = n.oid
        WHERE n.nspname = 'public'
          AND p.proname = 'create_organization'
      )
    )
  );

  RETURN v_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.debug_user_profile(target_user_id uuid)
 RETURNS TABLE(id uuid, email text, role text, first_name text, last_name text, preschool_id uuid, created_at timestamp with time zone, org_member_exists boolean, org_member_seat_status text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    p.id,
    p.email,
    p.role,
    p.first_name,
    p.last_name,
    p.preschool_id,
    p.created_at,
    EXISTS(
      SELECT 1 FROM public.organization_members om 
      WHERE om.user_id = target_user_id
    ) as org_member_exists,
    COALESCE(
      (SELECT om.seat_status FROM public.organization_members om WHERE om.user_id = target_user_id LIMIT 1),
      'none'
    ) as org_member_seat_status
  FROM public.profiles p
  WHERE p.id = target_user_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.decrement_ai_credits(user_id uuid, amount integer)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    current_credits INTEGER;
    new_credits INTEGER;
BEGIN
    -- Get current credits
    SELECT ai_credits_remaining INTO current_credits
    FROM public.users
    WHERE auth_user_id = user_id;
    
    -- If user not found or no credits, return 0
    IF current_credits IS NULL THEN
        RETURN 0;
    END IF;
    
    -- Calculate new credits (don't go below 0)
    new_credits := GREATEST(0, current_credits - amount);
    
    -- Update and return new credit amount
    UPDATE public.users 
    SET ai_credits_remaining = new_credits,
        updated_at = NOW()
    WHERE auth_user_id = user_id;
    
    RETURN new_credits;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.decrement_class_enrollment(class_uuid uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  UPDATE classes
  SET 
    current_students = GREATEST(COALESCE(current_students, 0) - 1, 0),
    updated_at = NOW()
  WHERE id = class_uuid;
END;
$function$
;

create or replace view "public"."delivery_analytics" as  SELECT date_trunc('hour'::text, nd.created_at) AS hour,
    date_trunc('day'::text, nd.created_at) AS day,
    date_trunc('week'::text, nd.created_at) AS week,
    date_trunc('month'::text, nd.created_at) AS month,
    nd.channel,
    nd.status,
    nd.provider_id,
    dp.provider_name,
    dp.display_name AS provider_display_name,
    count(*) AS delivery_count,
    count(
        CASE
            WHEN (nd.status = 'delivered'::public.delivery_status_enum) THEN 1
            ELSE NULL::integer
        END) AS delivered_count,
    count(
        CASE
            WHEN (nd.status = 'failed'::public.delivery_status_enum) THEN 1
            ELSE NULL::integer
        END) AS failed_count,
    count(
        CASE
            WHEN (nd.status = 'bounced'::public.delivery_status_enum) THEN 1
            ELSE NULL::integer
        END) AS bounced_count,
    round(((100.0 * (count(
        CASE
            WHEN (nd.status = 'delivered'::public.delivery_status_enum) THEN 1
            ELSE NULL::integer
        END))::numeric) / (NULLIF(count(*), 0))::numeric), 2) AS delivery_rate_percent,
    round(((100.0 * (count(
        CASE
            WHEN (nd.status = 'failed'::public.delivery_status_enum) THEN 1
            ELSE NULL::integer
        END))::numeric) / (NULLIF(count(*), 0))::numeric), 2) AS failure_rate_percent,
    avg(nd.render_time_ms) AS avg_render_time_ms,
    (avg((EXTRACT(epoch FROM (nd.sent_at - nd.created_at)) * (1000)::numeric)))::integer AS avg_send_delay_ms,
    (avg((EXTRACT(epoch FROM (nd.delivered_at - nd.sent_at)) * (1000)::numeric)))::integer AS avg_delivery_time_ms,
    sum(nd.actual_cost) AS total_actual_cost,
    sum(nd.estimated_cost) AS total_estimated_cost,
    avg(nd.actual_cost) AS avg_cost_per_delivery
   FROM (public.notification_deliveries nd
     LEFT JOIN public.delivery_providers dp ON ((nd.provider_id = dp.id)))
  GROUP BY (date_trunc('hour'::text, nd.created_at)), (date_trunc('day'::text, nd.created_at)), (date_trunc('week'::text, nd.created_at)), (date_trunc('month'::text, nd.created_at)), nd.channel, nd.status, nd.provider_id, dp.provider_name, dp.display_name;


CREATE OR REPLACE FUNCTION public.ensure_petty_cash_account(school_uuid uuid)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  account_uuid UUID;
BEGIN
  -- Check if account already exists
  SELECT id INTO account_uuid 
  FROM petty_cash_accounts 
  WHERE school_id = school_uuid
  AND is_active = true;
  
  -- Create if doesn't exist
  IF account_uuid IS NULL THEN
    INSERT INTO petty_cash_accounts (
      school_id, 
      name, 
      description, 
      opening_balance, 
      low_balance_threshold
    )
    VALUES (
      school_uuid, 
      'Main Petty Cash Account', 
      'Default petty cash account for the school', 
      0, 
      1000.00
    )
    RETURNING id INTO account_uuid;
  END IF;
  
  RETURN account_uuid;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.ensure_petty_cash_account_v2(preschool_uuid uuid)
 RETURNS uuid
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
  SELECT public.ensure_petty_cash_account(preschool_uuid);
$function$
;

CREATE OR REPLACE FUNCTION public.ensure_school_free_subscription(p_school_id uuid, p_seats integer DEFAULT 1)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare v_id uuid; begin
  select id into v_id from public.subscriptions 
    where owner_type = 'school' and school_id = p_school_id limit 1;
  if v_id is null then
    insert into public.subscriptions(id, school_id, plan_id, status, owner_type, billing_frequency, start_date, end_date, next_billing_date, seats_total, seats_used, metadata)
    values (gen_random_uuid(), p_school_id, 'free', 'active', 'school', 'monthly', now(), now() + interval '1 month', now() + interval '1 month', greatest(1, coalesce(p_seats,1)), 0, jsonb_build_object('created_by','ensure_free'))
    returning id into v_id;
  else
    -- If exists already, ensure it's at least free with 1 seat
    update public.subscriptions
      set plan_id = 'free', status = 'active', billing_frequency = 'monthly',
          start_date = now(), end_date = now() + interval '1 month', next_billing_date = now() + interval '1 month',
          seats_total = greatest(1, coalesce(p_seats,1))
    where id = v_id;
  end if;
  return v_id;
end; $function$
;

CREATE OR REPLACE FUNCTION public.execute_safe_query(query_params jsonb, query_sql text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'pg_temp'
AS $function$
DECLARE
  result_data jsonb;
  row_count integer;
  auth_uid uuid;
BEGIN
  -- Get authenticated user ID
  auth_uid := auth.uid();
  
  -- Block unauthenticated users
  IF auth_uid IS NULL THEN
    RAISE EXCEPTION 'Authentication required'
      USING HINT = 'User must be authenticated to execute queries';
  END IF;

  -- Validate query_sql is not empty
  IF query_sql IS NULL OR trim(query_sql) = '' THEN
    RAISE EXCEPTION 'Invalid query: query_sql cannot be empty';
  END IF;

  -- Validate query is SELECT only (basic SQL injection prevention)
  IF NOT (query_sql ~* '^\\s*SELECT\\s') THEN
    RAISE EXCEPTION 'Only SELECT queries are allowed'
      USING HINT = 'Query must start with SELECT';
  END IF;

  -- Block dangerous SQL keywords (additional protection)
  IF query_sql ~* '(DROP|DELETE|UPDATE|INSERT|TRUNCATE|ALTER|CREATE|GRANT|REVOKE)' THEN
    RAISE EXCEPTION 'Query contains forbidden SQL keywords'
      USING HINT = 'Only SELECT operations are permitted';
  END IF;

  -- Execute query with parameters
  -- RLS policies will automatically apply based on authenticated user context
  BEGIN
    EXECUTE format('
      WITH query_result AS (
        %s
      )
      SELECT jsonb_agg(row_to_json(query_result.*)) 
      FROM query_result
    ', query_sql)
    INTO result_data
    USING query_params;

    -- Handle empty result set
    IF result_data IS NULL THEN
      result_data := '[]'::jsonb;
    END IF;

    -- Get row count
    row_count := jsonb_array_length(result_data);

    -- Return result with metadata
    RETURN jsonb_build_object(
      'success', true,
      'data', result_data,
      'row_count', row_count,
      'executed_by', auth_uid,
      'executed_at', now()
    );

  EXCEPTION
    WHEN OTHERS THEN
      -- Log error and return structured error response
      RAISE WARNING 'Query execution error: % (SQLSTATE: %)', SQLERRM, SQLSTATE;
      
      RETURN jsonb_build_object(
        'success', false,
        'error', SQLERRM,
        'error_code', SQLSTATE,
        'executed_by', auth_uid,
        'executed_at', now()
      );
  END;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.execute_superadmin_agent(agent_id_param text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    execution_id uuid;
    agent_record record;
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM public.profiles 
        WHERE id = auth.uid() 
        AND role IN ('super_admin', 'superadmin')
    ) THEN
        RAISE EXCEPTION 'Unauthorized: Super admin access required';
    END IF;
    
    -- Get agent and verify it exists
    SELECT * INTO agent_record FROM public.superadmin_ai_agents WHERE id = agent_id_param;
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Agent not found: %', agent_id_param;
    END IF;
    
    -- Update agent status to running
    UPDATE public.superadmin_ai_agents 
    SET status = 'running', last_run_at = now() 
    WHERE id = agent_id_param;
    
    -- Create execution record
    INSERT INTO public.superadmin_agent_executions (
        agent_id, 
        triggered_by, 
        trigger_type, 
        status
    ) VALUES (
        agent_id_param,
        auth.uid(),
        'manual',
        'pending'
    ) RETURNING id INTO execution_id;
    
    RETURN execution_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.expire_old_allocation_requests()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  UPDATE ai_allocation_requests 
  SET status = 'expired', updated_at = now()
  WHERE status = 'pending' AND expires_at < now();
END;
$function$
;

CREATE OR REPLACE FUNCTION public.expire_old_join_requests()
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_count INTEGER;
BEGIN
  UPDATE join_requests
  SET status = 'expired'
  WHERE status = 'pending'
    AND expires_at IS NOT NULL
    AND expires_at < NOW();
  
  GET DIAGNOSTICS v_count = ROW_COUNT;
  RETURN v_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.expire_user_trials()
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  expired_count INTEGER;
BEGIN
  UPDATE profiles
  SET is_trial = FALSE, updated_at = NOW()
  WHERE is_trial = TRUE AND trial_end_date <= NOW();
  
  GET DIAGNOSTICS expired_count = ROW_COUNT;
  RETURN expired_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.find_caps_topics_by_page(p_textbook_id uuid, p_page_number integer)
 RETURNS TABLE(topic_id uuid, topic_code character varying, topic_title character varying, content_outline text, page_start integer, page_end integer, alignment_score integer)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    ct.id,
    ct.topic_code,
    ct.topic_title,
    ct.content_outline,
    tc.page_start,
    tc.page_end,
    ctm.alignment_score
  FROM caps_topics ct
  JOIN caps_textbook_mapping ctm ON ct.id = ctm.caps_topic_id
  JOIN textbook_content tc ON ctm.textbook_content_id = tc.id
  WHERE tc.textbook_id = p_textbook_id
    AND p_page_number BETWEEN tc.page_start AND tc.page_end
    AND ctm.status IN ('verified', 'approved')
  ORDER BY ctm.alignment_score DESC, tc.page_start;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.generate_card_number(org_id uuid)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  org_prefix TEXT;
  next_num INTEGER;
  new_card_number TEXT;
BEGIN
  -- Get org prefix from first 3 chars of org name or use ORG
  SELECT UPPER(LEFT(REGEXP_REPLACE(name, '[^a-zA-Z]', '', 'g'), 3))
  INTO org_prefix
  FROM public.organizations
  WHERE id = org_id;
  
  IF org_prefix IS NULL OR LENGTH(org_prefix) < 2 THEN
    org_prefix := 'ORG';
  END IF;
  
  -- Get next card number
  SELECT COALESCE(MAX(
    CASE 
      WHEN card_number ~ ('^' || org_prefix || '-[0-9]+$')
      THEN CAST(SUBSTRING(card_number FROM '[0-9]+$') AS INTEGER)
      ELSE 0
    END
  ), 0) + 1
  INTO next_num
  FROM public.member_id_cards
  WHERE organization_id = org_id;
  
  new_card_number := org_prefix || '-' || LPAD(next_num::TEXT, 8, '0');
  RETURN new_card_number;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.generate_course_join_code()
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    join_code TEXT;
    code_exists BOOLEAN;
BEGIN
    LOOP
        -- Generate 6-character alphanumeric code (excluding ambiguous chars)
        join_code := upper(
            substring(
                replace(
                    replace(
                        replace(encode(gen_random_bytes(8), 'base64'), '/', ''),
                        '+', ''
                    ), 
                    '=', ''
                ), 1, 6
            )
        );
        
        -- Replace ambiguous characters
        join_code := replace(replace(replace(replace(join_code, '0', '2'), '1', '3'), 'O', 'P'), 'I', 'J');
        
        -- Check if this code already exists
        SELECT EXISTS(
            SELECT 1 FROM courses 
            WHERE join_code = join_code 
            AND deleted_at IS NULL 
            AND (join_code_expires_at IS NULL OR join_code_expires_at > now())
        ) INTO code_exists;
        
        EXIT WHEN NOT code_exists;
    END LOOP;
    
    RETURN join_code;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.generate_invitation_code()
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
  chars TEXT := 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  result TEXT := '';
  i INTEGER;
BEGIN
  FOR i IN 1..9 LOOP
    result := result || substr(chars, floor(random() * length(chars) + 1)::int, 1);
  END LOOP;
  RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.generate_invitation_code(p_email text, p_role text, p_preschool_id uuid)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_code text;
BEGIN
  v_code := upper(substr(encode(gen_random_bytes(6), 'base64'), 1, 8));
  INSERT INTO public.invitation_codes(code, email, role, preschool_id)
  VALUES (v_code, p_email, p_role, p_preschool_id);
  RETURN v_code;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.generate_invite_code()
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
  code TEXT;
  chars TEXT := 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; -- Exclude confusing chars (0,O,1,I)
  i INTEGER;
BEGIN
  code := '';
  FOR i IN 1..6 LOOP
    code := code || substr(chars, floor(random() * length(chars) + 1)::integer, 1);
  END LOOP;
  RETURN code;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.generate_invite_token()
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
  token TEXT;
BEGIN
  -- Generate a 48-character secure token
  SELECT encode(gen_random_bytes(36), 'base64') INTO token;
  -- Replace URL-unsafe characters
  token := replace(replace(token, '+', '-'), '/', '_');
  RETURN token;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.generate_invoice_number()
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
    year_suffix TEXT;
    sequence_num INT;
    invoice_num TEXT;
BEGIN
    -- Get last two digits of current year
    year_suffix := to_char(NOW(), 'YY');
    
    -- Get next sequence number for this year
    SELECT COALESCE(MAX(
        CAST(SUBSTRING(invoice_number FROM 'EDU' || year_suffix || '-(\d+)') AS INTEGER)
    ), 0) + 1
    INTO sequence_num
    FROM billing_invoices
    WHERE invoice_number LIKE 'EDU' || year_suffix || '-%';
    
    -- Format as EDU25-000001
    invoice_num := 'EDU' || year_suffix || '-' || LPAD(sequence_num::TEXT, 6, '0');
    
    RETURN invoice_num;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.generate_invoice_number(org_id uuid)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  year_prefix TEXT;
  next_num INTEGER;
  new_invoice_number TEXT;
BEGIN
  year_prefix := 'INV-' || TO_CHAR(NOW(), 'YYYY') || '-';
  
  SELECT COALESCE(MAX(
    CASE 
      WHEN invoice_number ~ ('^' || year_prefix || '[0-9]+$')
      THEN CAST(SUBSTRING(invoice_number FROM '[0-9]+$') AS INTEGER)
      ELSE 0
    END
  ), 0) + 1
  INTO next_num
  FROM public.member_invoices
  WHERE organization_id = org_id;
  
  new_invoice_number := year_prefix || LPAD(next_num::TEXT, 6, '0');
  RETURN new_invoice_number;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.generate_learner_document_path(p_learner_id uuid, p_document_type character varying, p_file_name character varying)
 RETURNS text
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
DECLARE
  v_timestamp TEXT;
  v_sanitized_name TEXT;
BEGIN
  -- Get timestamp for uniqueness
  v_timestamp := to_char(NOW(), 'YYYYMMDD_HH24MISS');
  
  -- Sanitize filename (remove spaces, special chars)
  v_sanitized_name := regexp_replace(p_file_name, '[^a-zA-Z0-9._-]', '_', 'g');
  
  -- Return path: learner_id/document_type/timestamp_filename
  RETURN p_learner_id::text || '/' || p_document_type || '/' || v_timestamp || '_' || v_sanitized_name;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.generate_member_number(org_id uuid, prefix text DEFAULT 'MEM'::text)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  next_num INTEGER;
  new_member_number TEXT;
BEGIN
  -- Get the next number for this organization
  SELECT COALESCE(MAX(
    CASE 
      WHEN member_number ~ ('^' || prefix || '-[0-9]+$') 
      THEN CAST(SUBSTRING(member_number FROM '[0-9]+$') AS INTEGER)
      ELSE 0
    END
  ), 0) + 1
  INTO next_num
  FROM public.organization_members
  WHERE organization_id = org_id;
  
  new_member_number := prefix || '-' || LPAD(next_num::TEXT, 6, '0');
  RETURN new_member_number;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.generate_membership_fees_for_period(p_organization_id uuid, p_period_start date, p_period_end date, p_due_date date)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_count INTEGER := 0;
  v_member RECORD;
  v_fee_structure RECORD;
BEGIN
  -- Get active fee structures for this org
  FOR v_fee_structure IN 
    SELECT * FROM membership_fee_structures 
    WHERE organization_id = p_organization_id 
    AND is_active = true
    AND fee_type = 'membership'
  LOOP
    -- Create fee for each active member
    FOR v_member IN 
      SELECT * FROM organization_members 
      WHERE organization_id = p_organization_id 
      AND status = 'active'
      AND membership_tier = ANY(v_fee_structure.applicable_tiers)
    LOOP
      -- Check if fee already exists for this period
      IF NOT EXISTS (
        SELECT 1 FROM membership_fees 
        WHERE member_id = v_member.id 
        AND period_start = p_period_start
      ) THEN
        INSERT INTO membership_fees (
          organization_id, member_id, fee_structure_id,
          fee_type, description, amount, discount_amount, final_amount,
          period_start, period_end, due_date, status
        ) VALUES (
          p_organization_id, v_member.id, v_fee_structure.id,
          'annual_membership',
          v_fee_structure.name || ' - ' || to_char(p_period_start, 'YYYY'),
          v_fee_structure.amount,
          0,
          v_fee_structure.amount,
          p_period_start, p_period_end, p_due_date,
          'pending'
        );
        v_count := v_count + 1;
      END IF;
    END LOOP;
  END LOOP;
  
  RETURN v_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.generate_otp()
 RETURNS character varying
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN LPAD(FLOOR(RANDOM() * 1000000)::TEXT, 6, '0');
END;
$function$
;

CREATE OR REPLACE FUNCTION public.generate_region_invite_code(p_org_code character varying, p_region_code character varying)
 RETURNS character varying
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_code VARCHAR;
  v_year VARCHAR;
  v_random VARCHAR;
BEGIN
  v_year := TO_CHAR(NOW(), 'YY');
  v_random := UPPER(SUBSTRING(MD5(RANDOM()::TEXT) FROM 1 FOR 4));
  v_code := p_org_code || '-' || p_region_code || '-' || v_year || v_random;
  RETURN v_code;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.generate_resume_filename(candidate_email text, original_filename text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
    file_extension TEXT;
    timestamp_str TEXT;
    safe_email TEXT;
BEGIN
    -- Extract file extension
    file_extension := LOWER(SUBSTRING(original_filename FROM '\.([^.]+)$'));
    
    -- Create safe email (replace @ and . with _)
    safe_email := REPLACE(REPLACE(LOWER(candidate_email), '@', '_'), '.', '_');
    
    -- Generate timestamp
    timestamp_str := TO_CHAR(NOW(), 'YYYYMMDD_HH24MISS');
    
    -- Return formatted filename: email_timestamp.extension
    RETURN safe_email || '_' || timestamp_str || '.' || file_extension;
END;
$function$
;

create type "public"."geometry_dump" as ("path" integer[], "geom" public.geometry);

CREATE OR REPLACE FUNCTION public.get_active_connections()
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  user_preschool_id uuid;
  connections_data json;
BEGIN
  -- Get the current user's preschool
  SELECT preschool_id INTO user_preschool_id
  FROM users 
  WHERE auth_user_id = auth.uid();
  
  -- Return active video calls for the user's preschool
  SELECT json_agg(
    json_build_object(
      'id', vc.id,
      'title', vc.title,
      'status', vc.status,
      'scheduled_start', vc.scheduled_start,
      'meeting_url', vc.meeting_url,
      'participants_count', (
        SELECT COUNT(*) 
        FROM video_call_participants vcp 
        WHERE vcp.call_id = vc.id
      )
    )
  ) INTO connections_data
  FROM video_calls vc
  WHERE vc.preschool_id = user_preschool_id
  AND vc.status IN ('scheduled', 'in_progress');
  
  RETURN COALESCE(connections_data, '[]'::json);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_age_groups_for_school_type(p_school_type text)
 RETURNS TABLE(id uuid, name text, min_age_months integer, max_age_months integer, age_min integer, age_max integer, description text)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    ag.id,
    ag.name,
    ag.min_age_months,
    ag.max_age_months,
    ag.age_min,
    ag.age_max,
    ag.description
  FROM public.age_groups ag
  WHERE ag.school_type = p_school_type
    AND ag.is_active = true
  ORDER BY ag.min_age_months;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_ai_config(p_service_type text, p_tier text DEFAULT 'free'::text)
 RETURNS TABLE(provider text, model text, max_tokens integer, temperature numeric, fallback_enabled boolean)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_config RECORD;
  v_global RECORD;
  v_model TEXT;
BEGIN
  -- Get global settings
  SELECT * INTO v_global FROM ai_global_settings WHERE id = '00000000-0000-0000-0000-000000000001'::uuid;
  
  -- Get service-specific config
  SELECT * INTO v_config FROM ai_provider_config WHERE service_type = p_service_type AND is_active = true;
  
  -- If no config found, return defaults
  IF v_config IS NULL THEN
    RETURN QUERY SELECT 
      v_global.default_provider,
      CASE p_tier
        WHEN 'free' THEN 'claude-3-haiku-20240307'
        WHEN 'basic' THEN 'claude-3-sonnet-20240229'
        WHEN 'premium' THEN 'claude-3-5-sonnet-20241022'
        WHEN 'pro' THEN 'claude-3-5-sonnet-20241022'
        WHEN 'enterprise' THEN 'claude-3-5-sonnet-20241022'
        ELSE 'claude-3-haiku-20240307'
      END,
      4096,
      0.7::DECIMAL,
      v_global.enable_automatic_fallback;
    RETURN;
  END IF;
  
  -- Determine provider (service override > global default)
  DECLARE
    v_provider TEXT := COALESCE(v_config.provider_override, v_global.default_provider);
  BEGIN
    -- Select model based on tier
    v_model := CASE p_tier
      WHEN 'free' THEN v_config.model_free
      WHEN 'basic' THEN v_config.model_basic
      WHEN 'premium' THEN v_config.model_premium
      WHEN 'pro' THEN v_config.model_pro
      WHEN 'enterprise' THEN v_config.model_enterprise
      ELSE v_config.model_free
    END;
    
    -- Return configuration
    RETURN QUERY SELECT 
      v_provider,
      v_model,
      v_config.max_tokens,
      v_config.temperature,
      v_global.enable_automatic_fallback;
  END;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_all_schools_for_superadmin()
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  RETURN (
    SELECT jsonb_agg(
      jsonb_build_object(
        'id', p.id,
        'name', p.name,
        'email', p.email,
        'subscription_plan', p.subscription_plan,
        'subscription_status', p.subscription_status,
        'created_at', p.created_at,
        'updated_at', p.updated_at,
        'tenant_slug', p.tenant_slug,
        'onboarding_status', p.onboarding_status,
        'setup_completed', COALESCE(p.setup_completed, true)
      )
    )
    FROM (
      SELECT *
      FROM preschools p
      ORDER BY p.created_at DESC
      LIMIT 100
    ) p
  );
END;$function$
;

CREATE OR REPLACE FUNCTION public.get_all_users_for_superadmin()
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_current_user_id UUID := auth.uid();
  v_users JSONB;
BEGIN
  -- Check if current user is superadmin
  IF NOT EXISTS (
    SELECT 1 FROM public.users 
    WHERE id = v_current_user_id 
    AND role = 'superadmin'
  ) THEN
    RETURN json_build_array(json_build_object('error', 'Unauthorized: Superadmin access required'));
  END IF;
  
  -- Get all users with their school information
  SELECT jsonb_agg(
    jsonb_build_object(
      'id', u.id,
      'email', au.email,
      'name', COALESCE(u.first_name || ' ' || u.last_name, u.first_name, u.last_name, 'Unnamed User'),
      'full_name', COALESCE(u.first_name || ' ' || u.last_name, u.first_name, u.last_name),
      'role', u.role,
      'school_id', u.preschool_id,
      'school_name', COALESCE(p.name, 'No School'),
      'created_at', u.created_at,
      'last_sign_in_at', au.last_sign_in_at,
      'is_active', u.is_active,
      'avatar_url', u.avatar_url
    )
  ) INTO v_users
  FROM public.users u
  LEFT JOIN auth.users au ON u.id = au.id
  LEFT JOIN public.preschools p ON u.preschool_id = p.id
  ORDER BY u.created_at DESC;
  
  RETURN COALESCE(v_users, '[]'::jsonb);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_api_key_expiration_alerts()
 RETURNS TABLE(service_name text, key_alias text, expires_at timestamp with time zone, days_until_expiry integer, status text, owner_email text)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    sak.service_name,
    sak.key_alias,
    sak.expires_at,
    EXTRACT(DAY FROM (sak.expires_at - NOW()))::INT,
    sak.status,
    sak.owner_email
  FROM public.service_api_keys sak
  WHERE sak.expires_at IS NOT NULL
    AND sak.expires_at > NOW()
    AND sak.expires_at < NOW() + INTERVAL '30 days'
  ORDER BY sak.expires_at ASC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_appointable_roles(appointer_role text, appointer_wing text DEFAULT 'main'::text)
 RETURNS text[]
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
BEGIN
  -- National Admin can appoint ALL roles across all wings
  IF appointer_role = 'national_admin' THEN
    RETURN ARRAY[
      -- Main structure
      'regional_manager', 'admin', 'staff', 'facilitator', 'mentor', 'learner',
      -- Youth Wing leadership
      'youth_president', 'youth_deputy', 'youth_secretary', 'youth_treasurer',
      'youth_coordinator', 'youth_facilitator', 'youth_mentor', 'youth_member',
      -- Women's League leadership
      'women_president', 'women_deputy', 'women_secretary', 'women_treasurer',
      'women_coordinator', 'women_facilitator', 'women_mentor', 'women_member',
      -- Veterans
      'veterans_president', 'veterans_coordinator', 'veterans_member'
    ];
  END IF;
  
  -- Regional Manager (main structure only)
  IF appointer_role = 'regional_manager' AND appointer_wing = 'main' THEN
    RETURN ARRAY['facilitator', 'mentor', 'learner'];
  END IF;
  
  -- Youth President can appoint youth wing roles
  IF appointer_role = 'youth_president' THEN
    RETURN ARRAY[
      'youth_deputy', 'youth_secretary', 'youth_treasurer',
      'youth_coordinator', 'youth_facilitator', 'youth_mentor', 'youth_member'
    ];
  END IF;
  
  -- Youth Deputy can appoint operational youth roles
  IF appointer_role = 'youth_deputy' THEN
    RETURN ARRAY['youth_coordinator', 'youth_facilitator', 'youth_mentor', 'youth_member'];
  END IF;
  
  -- Youth Coordinator (regional level)
  IF appointer_role = 'youth_coordinator' THEN
    RETURN ARRAY['youth_facilitator', 'youth_mentor', 'youth_member'];
  END IF;
  
  -- Women's President can appoint women's league roles
  IF appointer_role = 'women_president' THEN
    RETURN ARRAY[
      'women_deputy', 'women_secretary', 'women_treasurer',
      'women_coordinator', 'women_facilitator', 'women_mentor', 'women_member'
    ];
  END IF;
  
  -- Women's Deputy
  IF appointer_role = 'women_deputy' THEN
    RETURN ARRAY['women_coordinator', 'women_facilitator', 'women_mentor', 'women_member'];
  END IF;
  
  -- Women's Coordinator (regional level)
  IF appointer_role = 'women_coordinator' THEN
    RETURN ARRAY['women_facilitator', 'women_mentor', 'women_member'];
  END IF;
  
  -- Veterans President
  IF appointer_role = 'veterans_president' THEN
    RETURN ARRAY['veterans_coordinator', 'veterans_member'];
  END IF;
  
  -- Veterans Coordinator
  IF appointer_role = 'veterans_coordinator' THEN
    RETURN ARRAY['veterans_member'];
  END IF;
  
  -- Default: no appointment rights
  RETURN ARRAY[]::TEXT[];
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_approved_organizations()
 RETURNS TABLE(id uuid, name text, type text, city text, province text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    p.id,
    p.name,
    p.type,
    p.city,
    p.province
  FROM preschools p
  WHERE p.approved = TRUE 
    AND p.verified = TRUE
    AND p.is_active = TRUE
  ORDER BY p.name ASC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_assignment_grade_count(assignment_id uuid)
 RETURNS integer
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
    SELECT COUNT(*)::INTEGER
    FROM grades g
    JOIN submissions s ON s.id = g.submission_id
    WHERE s.assignment_id = get_assignment_grade_count.assignment_id;
$function$
;

CREATE OR REPLACE FUNCTION public.get_assignment_stats(assignment_uuid uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  result JSONB;
BEGIN
  SELECT jsonb_build_object(
    'total_students', array_length(student_ids, 1),
    'submitted_count', (SELECT COUNT(*) FROM public.exam_submissions WHERE assignment_id = assignment_uuid AND status = 'submitted'),
    'average_score', (SELECT COALESCE(AVG(percentage), 0) FROM public.exam_submissions WHERE assignment_id = assignment_uuid AND status = 'submitted'),
    'highest_score', (SELECT COALESCE(MAX(percentage), 0) FROM public.exam_submissions WHERE assignment_id = assignment_uuid AND status = 'submitted'),
    'lowest_score', (SELECT COALESCE(MIN(percentage), 0) FROM public.exam_submissions WHERE assignment_id = assignment_uuid AND status = 'submitted')
  ) INTO result
  FROM public.exam_assignments
  WHERE id = assignment_uuid;
  RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_assignment_submission_count(assignment_id uuid)
 RETURNS integer
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
    SELECT COUNT(*)::INTEGER
    FROM submissions s
    WHERE s.assignment_id = get_assignment_submission_count.assignment_id
    AND s.is_draft = false;
$function$
;

CREATE OR REPLACE FUNCTION public.get_available_enrollment_slots(course_id uuid)
 RETURNS integer
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
    SELECT CASE
        WHEN c.max_students IS NULL THEN 999999
        WHEN c.max_students <= 0 THEN 999999
        ELSE GREATEST(0, c.max_students - (
            SELECT COUNT(*) 
            FROM enrollments e 
            WHERE e.course_id = get_available_enrollment_slots.course_id 
            AND e.is_active = true
        )::INTEGER)
    END
    FROM courses c 
    WHERE c.id = get_available_enrollment_slots.course_id;
$function$
;

CREATE OR REPLACE FUNCTION public.get_blocked_users()
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_current_user_id UUID := auth.uid();
  v_blocks JSONB;
BEGIN
  -- Validate authentication
  IF v_current_user_id IS NULL THEN
    RETURN json_build_object('error', 'Authentication required');
  END IF;
  
  -- Get blocked users with details
  SELECT jsonb_agg(
    jsonb_build_object(
      'id', ub.id,
      'blocked_user_id', ub.blocked_id,
      'blocked_user_name', COALESCE(u.first_name || ' ' || u.last_name, u.first_name, 'Unknown User'),
      'blocked_user_role', u.role,
      'block_type', ub.block_type,
      'reason', ub.reason,
      'created_at', ub.created_at,
      'expires_at', ub.expires_at,
      'school_name', COALESCE(p.name, 'Unknown School')
    )
  ) INTO v_blocks
  FROM public.user_blocks ub
  LEFT JOIN public.users u ON ub.blocked_id = u.id
  LEFT JOIN public.preschools p ON ub.school_id = p.id
  WHERE 
    ub.blocker_id = v_current_user_id 
    AND ub.is_active = TRUE
    AND (ub.expires_at IS NULL OR ub.expires_at > NOW())
  ORDER BY ub.created_at DESC;
  
  RETURN COALESCE(v_blocks, '[]'::jsonb);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_conversation_messages(p_conversation_id text, p_limit integer DEFAULT 50, p_before_date timestamp with time zone DEFAULT NULL::timestamp with time zone)
 RETURNS TABLE(id uuid, role text, content text, image_urls text[], metadata jsonb, created_at timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    m.id,
    m.role,
    m.content,
    m.image_urls,
    m.metadata,
    m.created_at
  FROM ai_messages m
  WHERE 
    m.conversation_id = p_conversation_id
    AND (p_before_date IS NULL OR m.created_at < p_before_date)
  ORDER BY m.created_at DESC
  LIMIT p_limit;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_course_assignment_count(course_id uuid)
 RETURNS integer
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
    SELECT COUNT(*)::INTEGER
    FROM assignments a
    WHERE a.course_id = get_course_assignment_count.course_id
    AND a.deleted_at IS NULL;
$function$
;

CREATE OR REPLACE FUNCTION public.get_course_enrollment_count(course_id uuid)
 RETURNS integer
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
    SELECT COUNT(*)::INTEGER
    FROM enrollments e
    WHERE e.course_id = get_course_enrollment_count.course_id
    AND e.is_active = true;
$function$
;

CREATE OR REPLACE FUNCTION public.get_course_enrollment_stats(course_id uuid)
 RETURNS TABLE(total_enrolled integer, active_enrolled integer, inactive_enrolled integer, enrollment_rate numeric, max_students integer)
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
    SELECT 
        COUNT(*)::INTEGER as total_enrolled,
        COUNT(*) FILTER (WHERE e.is_active = true)::INTEGER as active_enrolled,
        COUNT(*) FILTER (WHERE e.is_active = false)::INTEGER as inactive_enrolled,
        CASE 
            WHEN c.max_students IS NULL OR c.max_students = 0 THEN 0.00
            ELSE ROUND((COUNT(*) FILTER (WHERE e.is_active = true)::DECIMAL / c.max_students * 100), 2)
        END as enrollment_rate,
        COALESCE(c.max_students, 0) as max_students
    FROM enrollments e
    RIGHT JOIN courses c ON c.id = course_id
    WHERE e.course_id = course_id OR e.course_id IS NULL
    GROUP BY c.max_students;
$function$
;

CREATE OR REPLACE FUNCTION public.get_course_grade_stats(course_id uuid)
 RETURNS TABLE(total_assignments integer, total_submissions integer, total_grades integer, average_grade numeric, median_grade numeric, grade_distribution jsonb)
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
DECLARE
    percentiles DECIMAL[];
    grade_dist JSONB;
BEGIN
    -- Get basic counts and average
    SELECT 
        COUNT(DISTINCT a.id)::INTEGER,
        COUNT(DISTINCT s.id)::INTEGER,
        COUNT(g.id)::INTEGER,
        ROUND(AVG(g.percentage), 2)
    INTO total_assignments, total_submissions, total_grades, average_grade
    FROM assignments a
    LEFT JOIN submissions s ON s.assignment_id = a.id AND NOT s.is_draft
    LEFT JOIN grades g ON g.submission_id = s.id
    WHERE a.course_id = get_course_grade_stats.course_id
    AND a.deleted_at IS NULL;
    
    -- Get median grade
    SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY g.percentage)
    INTO median_grade
    FROM assignments a
    JOIN submissions s ON s.assignment_id = a.id AND NOT s.is_draft
    JOIN grades g ON g.submission_id = s.id
    WHERE a.course_id = get_course_grade_stats.course_id
    AND a.deleted_at IS NULL;
    
    -- Get grade distribution
    SELECT jsonb_object_agg(
        CASE 
            WHEN g.percentage >= 90 THEN 'A'
            WHEN g.percentage >= 80 THEN 'B'
            WHEN g.percentage >= 70 THEN 'C'
            WHEN g.percentage >= 60 THEN 'D'
            ELSE 'F'
        END,
        count
    )
    INTO grade_dist
    FROM (
        SELECT 
            CASE 
                WHEN g.percentage >= 90 THEN 'A'
                WHEN g.percentage >= 80 THEN 'B'
                WHEN g.percentage >= 70 THEN 'C'
                WHEN g.percentage >= 60 THEN 'D'
                ELSE 'F'
            END,
            COUNT(*)::INTEGER as count
        FROM assignments a
        JOIN submissions s ON s.assignment_id = a.id AND NOT s.is_draft
        JOIN grades g ON g.submission_id = s.id
        WHERE a.course_id = get_course_grade_stats.course_id
        AND a.deleted_at IS NULL
        GROUP BY 1
    ) grade_counts;
    
    grade_distribution := COALESCE(grade_dist, '{}'::jsonb);
    
    RETURN QUERY SELECT 
        COALESCE(get_course_grade_stats.total_assignments, 0),
        COALESCE(get_course_grade_stats.total_submissions, 0),
        COALESCE(get_course_grade_stats.total_grades, 0),
        COALESCE(get_course_grade_stats.average_grade, 0.00),
        COALESCE(get_course_grade_stats.median_grade, 0.00),
        get_course_grade_stats.grade_distribution;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_current_timestamp()
 RETURNS timestamp with time zone
 LANGUAGE sql
 STABLE
AS $function$
  SELECT NOW();
$function$
;

CREATE OR REPLACE FUNCTION public.get_current_user_org_id()
 RETURNS uuid
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT coalesce(
    organization_id,
    preschool_id
  )
  FROM public.users 
  WHERE (
    id = auth.uid() 
    OR auth_user_id = auth.uid()
  )
  AND coalesce(is_active, true) = true
  ORDER BY 
    CASE WHEN id = auth.uid() THEN 1 ELSE 2 END
  LIMIT 1;
$function$
;

CREATE OR REPLACE FUNCTION public.get_daily_tts_usage(p_user_id uuid)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  usage_count INTEGER;
  today_start TIMESTAMPTZ;
BEGIN
  today_start := DATE_TRUNC('day', NOW() AT TIME ZONE 'UTC');
  
  SELECT COUNT(*)
  INTO usage_count
  FROM voice_usage_logs
  WHERE user_id = p_user_id
    AND service = 'tts'
    AND created_at >= today_start
    AND success = true;
  
  RETURN COALESCE(usage_count, 0);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_dashboard_debug_info()
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_current_user_id UUID := auth.uid();
  v_debug_info JSONB;
  v_user_count INTEGER;
  v_school_count INTEGER;
  v_subscription_count INTEGER;
  v_auth_user_count INTEGER;
BEGIN
  -- Check basic counts
  SELECT COUNT(*) INTO v_user_count FROM public.users;
  SELECT COUNT(*) INTO v_school_count FROM public.preschools;
  SELECT COUNT(*) INTO v_subscription_count FROM public.subscriptions;
  SELECT COUNT(*) INTO v_auth_user_count FROM auth.users;
  
  -- Build debug response
  v_debug_info := json_build_object(
    'current_user_id', v_current_user_id,
    'user_count_public', v_user_count,
    'auth_user_count', v_auth_user_count,
    'school_count', v_school_count,
    'subscription_count', v_subscription_count,
    'tables_exist', json_build_object(
      'users', (SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'users')),
      'preschools', (SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'preschools')),
      'subscriptions', (SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'subscriptions')),
      'auth_users', (SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_schema = 'auth' AND table_name = 'users'))
    ),
    'functions_exist', json_build_object(
      'get_all_users_for_superadmin', (SELECT EXISTS (SELECT FROM information_schema.routines WHERE routine_name = 'get_all_users_for_superadmin')),
      'get_platform_stats_for_superadmin', (SELECT EXISTS (SELECT FROM information_schema.routines WHERE routine_name = 'get_platform_stats_for_superadmin')),
      'get_superadmin_ai_quotas', (SELECT EXISTS (SELECT FROM information_schema.routines WHERE routine_name = 'get_superadmin_ai_quotas'))
    )
  );
  
  RETURN v_debug_info;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_delivery_analytics(p_start_date timestamp with time zone DEFAULT (now() - '7 days'::interval), p_end_date timestamp with time zone DEFAULT now(), p_channel public.delivery_method_enum DEFAULT NULL::public.delivery_method_enum, p_provider_name public.delivery_provider_enum DEFAULT NULL::public.delivery_provider_enum)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_id UUID;
  v_is_superadmin BOOLEAN;
  v_analytics JSON;
BEGIN
  -- Get current user ID
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Authentication required',
      'error_code', 'AUTH_REQUIRED'
    );
  END IF;
  
  -- Check if user is superadmin
  SELECT EXISTS (
    SELECT 1 FROM user_profiles 
    WHERE user_id = v_user_id 
    AND role = 'super_admin' 
    AND is_active = true
  ) INTO v_is_superadmin;
  
  IF NOT v_is_superadmin THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Superadmin privileges required',
      'error_code', 'INSUFFICIENT_PRIVILEGES'
    );
  END IF;
  
  -- Generate analytics
  WITH filtered_deliveries AS (
    SELECT 
      nd.*,
      dp.provider_name,
      dp.display_name as provider_display_name
    FROM notification_deliveries nd
    LEFT JOIN delivery_providers dp ON nd.provider_id = dp.id
    WHERE nd.created_at >= p_start_date 
    AND nd.created_at <= p_end_date
    AND (p_channel IS NULL OR nd.channel = p_channel)
    AND (p_provider_name IS NULL OR dp.provider_name = p_provider_name)
  ),
  summary_stats AS (
    SELECT 
      count(*) as total_deliveries,
      count(CASE WHEN status = 'delivered' THEN 1 END) as delivered_count,
      count(CASE WHEN status = 'failed' THEN 1 END) as failed_count,
      count(CASE WHEN status = 'bounced' THEN 1 END) as bounced_count,
      count(CASE WHEN status = 'pending' THEN 1 END) as pending_count,
      
      round(
        100.0 * count(CASE WHEN status = 'delivered' THEN 1 END) / nullif(count(*), 0), 
        2
      ) as success_rate,
      
      avg(render_time_ms) as avg_render_time_ms,
      avg(extract(epoch from (sent_at - created_at)) * 1000)::integer as avg_send_delay_ms,
      avg(extract(epoch from (delivered_at - sent_at)) * 1000)::integer as avg_delivery_time_ms,
      
      sum(actual_cost) as total_cost,
      avg(actual_cost) as avg_cost_per_delivery
    FROM filtered_deliveries
  ),
  channel_breakdown AS (
    SELECT 
      channel,
      count(*) as count,
      count(CASE WHEN status = 'delivered' THEN 1 END) as delivered_count,
      round(
        100.0 * count(CASE WHEN status = 'delivered' THEN 1 END) / nullif(count(*), 0), 
        2
      ) as success_rate
    FROM filtered_deliveries
    GROUP BY channel
  ),
  provider_breakdown AS (
    SELECT 
      provider_name,
      provider_display_name,
      count(*) as count,
      count(CASE WHEN status = 'delivered' THEN 1 END) as delivered_count,
      round(
        100.0 * count(CASE WHEN status = 'delivered' THEN 1 END) / nullif(count(*), 0), 
        2
      ) as success_rate
    FROM filtered_deliveries
    WHERE provider_name IS NOT NULL
    GROUP BY provider_name, provider_display_name
  ),
  daily_trend AS (
    SELECT 
      date_trunc('day', created_at) as day,
      count(*) as total,
      count(CASE WHEN status = 'delivered' THEN 1 END) as delivered
    FROM filtered_deliveries
    GROUP BY date_trunc('day', created_at)
    ORDER BY day
  )
  SELECT json_build_object(
    'success', true,
    'period', json_build_object(
      'start_date', p_start_date,
      'end_date', p_end_date
    ),
    'summary', row_to_json(s),
    'channel_breakdown', json_agg(DISTINCT cb.* ORDER BY cb.count DESC),
    'provider_breakdown', (
      SELECT json_agg(pb.* ORDER BY pb.count DESC) 
      FROM provider_breakdown pb
    ),
    'daily_trend', (
      SELECT json_agg(dt.* ORDER BY dt.day) 
      FROM daily_trend dt
    )
  )
  FROM summary_stats s, channel_breakdown cb
  GROUP BY s.*
  INTO v_analytics;
  
  RETURN COALESCE(v_analytics, json_build_object(
    'success', true,
    'message', 'No data found for the specified period'
  ));
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object(
      'success', false,
      'error', SQLERRM,
      'error_code', 'INTERNAL_ERROR'
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_exam_questions_by_topic(topic_name character varying, question_grade character varying, question_subject character varying, difficulty_level character varying DEFAULT NULL::character varying, years_back integer DEFAULT 5, result_limit integer DEFAULT 20)
 RETURNS TABLE(id uuid, question_number character varying, question_text text, marks integer, difficulty character varying, year integer, topic character varying, marking_guideline text)
 LANGUAGE plpgsql
AS $function$
DECLARE
  min_year INTEGER;
BEGIN
  min_year := EXTRACT(YEAR FROM NOW()) - years_back;
  
  RETURN QUERY
  SELECT
    q.id,
    q.question_number,
    q.question_text,
    q.marks,
    q.difficulty,
    q.year,
    q.topic,
    q.marking_guideline
  FROM caps_exam_questions q
  WHERE 
    q.grade = question_grade
    AND q.subject = question_subject
    AND q.topic ILIKE '%' || topic_name || '%'
    AND q.year >= min_year
    AND (difficulty_level IS NULL OR q.difficulty = difficulty_level)
  ORDER BY q.year DESC, q.question_number
  LIMIT result_limit;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_member_fee_summary(p_member_id uuid)
 RETURNS TABLE(total_due numeric, total_paid numeric, total_pending numeric, overdue_count integer, next_due_date date)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    COALESCE(SUM(CASE WHEN mf.status IN ('pending', 'overdue', 'partially_paid') THEN mf.final_amount ELSE 0 END), 0) as total_due,
    COALESCE(SUM(CASE WHEN mf.status = 'paid' THEN mf.final_amount ELSE 0 END), 0) as total_paid,
    COALESCE(SUM(CASE WHEN mf.status = 'pending_verification' THEN mf.final_amount ELSE 0 END), 0) as total_pending,
    COUNT(CASE WHEN mf.status = 'overdue' THEN 1 END)::INTEGER as overdue_count,
    MIN(CASE WHEN mf.status IN ('pending', 'overdue') THEN mf.due_date END) as next_due_date
  FROM membership_fees mf
  WHERE mf.member_id = p_member_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_message_display_text(content text)
 RETURNS text
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
DECLARE
  media_type TEXT;
  media_name TEXT;
BEGIN
  -- Check if this is a media message
  IF content LIKE '__media__%' THEN
    BEGIN
      -- Extract media type from JSON (after removing __media__ prefix)
      media_type := (SUBSTRING(content FROM 10))::json->>'mediaType';
      media_name := (SUBSTRING(content FROM 10))::json->>'name';
    EXCEPTION WHEN OTHERS THEN
      media_type := 'file';
      media_name := NULL;
    END;
    
    -- Return friendly display text based on media type
    RETURN CASE media_type
      WHEN 'audio' THEN ' Voice message'
      WHEN 'image' THEN ' Image'
      WHEN 'file' THEN COALESCE(' ' || media_name, ' File attachment')
      ELSE ' Attachment'
    END;
  ELSE
    -- Regular text - return as-is (caller handles truncation)
    RETURN content;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_message_with_attachments(p_message_id uuid)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_result json;
BEGIN
  SELECT json_build_object(
    'id', m.id,
    'content', m.content,
    'message_type', m.message_type,
    'sender_id', m.sender_id,
    'receiver_id', m.receiver_id,
    'created_at', m.created_at,
    'attachments', (
      SELECT json_agg(
        json_build_object(
          'id', a.id,
          'file_name', a.file_name,
          'file_url', a.file_url,
          'file_type', a.file_type,
          'file_size', a.file_size,
          'mime_type', a.mime_type
        )
      )
      FROM public.message_attachments a
      WHERE a.message_id = m.id
    )
  ) INTO v_result
  FROM public.messages m
  WHERE m.id = p_message_id
  AND (
    m.sender_id = app.current_user_id()
    OR m.receiver_id = app.current_user_id()
    OR EXISTS (
      SELECT 1 FROM public.message_recipients mr
      WHERE mr.message_id = m.id
      AND mr.recipient_id = app.current_user_id()
    )
  );
  
  RETURN v_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_messaging_contacts(p_include_staff boolean DEFAULT true, p_include_parents boolean DEFAULT true, p_limit integer DEFAULT 500)
 RETURNS TABLE(id uuid, name text, role text, avatar_url text, email text, class_name text)
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
DECLARE
  v_current_user_id uuid;
  v_preschool_id uuid;
BEGIN
  -- Get current user id
  SELECT u.id, u.preschool_id INTO v_current_user_id, v_preschool_id
  FROM public.users u
  WHERE u.auth_user_id = auth.uid()
  AND COALESCE(u.is_active, true) = true
  LIMIT 1;
  
  -- If we don't have a user ID or preschool, return empty result
  IF v_current_user_id IS NULL OR v_preschool_id IS NULL THEN
    RETURN;
  END IF;
  
  -- Return contacts in the same preschool (fixed to not reference non-existent class_name column)
  RETURN QUERY
  SELECT 
    u.id, 
    COALESCE(u.name, u.email, 'Unknown User') as name,
    COALESCE(u.role, 'unknown')::text as role, 
    u.avatar_url, 
    u.email, 
    ''::text as class_name  -- Return empty string since users table doesn't have class_name
  FROM public.users u
  WHERE u.preschool_id = v_preschool_id
    AND u.id != v_current_user_id  -- Exclude self
    AND COALESCE(u.is_active, true) = true  -- Include active users (default to true if null)
    AND (
      (p_include_staff = true AND COALESCE(u.role, '') IN ('teacher', 'admin', 'principal', 'preschool_admin'))
      OR
      (p_include_parents = true AND COALESCE(u.role, '') = 'parent')
    )
  ORDER BY 
    CASE COALESCE(u.role, '')
      WHEN 'principal' THEN 1
      WHEN 'preschool_admin' THEN 2
      WHEN 'admin' THEN 3
      WHEN 'teacher' THEN 4
      WHEN 'parent' THEN 5
      ELSE 6
    END,
    COALESCE(u.name, u.email, 'Unknown')
  LIMIT p_limit;
  
EXCEPTION WHEN OTHERS THEN
  -- Log the error and return empty result instead of failing
  RAISE WARNING 'Error in get_messaging_contacts: %', SQLERRM;
  RETURN;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_migration_status()
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  result JSON;
  latest_migration TEXT;
  migration_count INTEGER;
BEGIN
  -- Check if current user is superadmin
  IF NOT is_superadmin() THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Access denied: Superladmin privileges required'
    );
  END IF;

  -- Get migration info from supabase_migrations table
  SELECT 
    version,
    COUNT(*)
  INTO latest_migration, migration_count
  FROM supabase_migrations
  ORDER BY inserted_at DESC
  LIMIT 1;

  result := json_build_object(
    'success', true,
    'data', json_build_object(
      'migration_status', 'up_to_date',
      'latest_migration', COALESCE(latest_migration, 'No migrations found'),
      'total_migrations', COALESCE(migration_count, 0),
      'failed_migrations', json_build_array(), -- No easy way to detect failed migrations
      'last_migration_at', (
        SELECT inserted_at 
        FROM supabase_migrations 
        ORDER BY inserted_at DESC 
        LIMIT 1
      )
    ),
    'generated_at', NOW()
  );

  RETURN result;
EXCEPTION
  WHEN OTHERS THEN
    -- Fallback if supabase_migrations table doesn't exist
    RETURN json_build_object(
      'success', true,
      'data', json_build_object(
        'migration_status', 'unknown',
        'latest_migration', 'Unable to determine',
        'total_migrations', 0,
        'failed_migrations', json_build_array(),
        'last_migration_at', null
      ),
      'generated_at', NOW()
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_moderation_items(p_status character varying DEFAULT NULL::character varying, p_severity character varying DEFAULT NULL::character varying, p_content_type character varying DEFAULT NULL::character varying, p_limit integer DEFAULT 50)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_current_user_id UUID := auth.uid();
  v_items JSONB;
BEGIN
  -- Check if current user is superadmin
  IF NOT EXISTS (
    SELECT 1 FROM public.users 
    WHERE id = v_current_user_id 
    AND role = 'superadmin'
  ) THEN
    RETURN json_build_object('error', 'Unauthorized: Superadmin access required');
  END IF;
  
  -- Get moderation queue items with author and school info
  SELECT jsonb_agg(
    jsonb_build_object(
      'id', mq.id,
      'content_type', mq.content_type,
      'content_id', mq.content_id,
      'title', mq.content_title,
      'content', COALESCE(SUBSTRING(mq.content_body FROM 1 FOR 500), ''),
      'author_id', mq.author_id,
      'author_name', COALESCE(u.first_name || ' ' || u.last_name, u.first_name, 'Unknown Author'),
      'author_email', au.email,
      'school_id', mq.school_id,
      'school_name', COALESCE(p.name, 'Unknown School'),
      'status', mq.status,
      'flags', mq.flags,
      'report_count', mq.report_count,
      'severity', mq.severity,
      'priority', mq.priority,
      'auto_flagged', mq.auto_flagged,
      'created_at', mq.created_at,
      'flagged_at', mq.flagged_at,
      'reviewed_by', mq.reviewed_by,
      'reviewed_at', mq.reviewed_at,
      'review_notes', mq.review_notes
    )
  ) INTO v_items
  FROM public.moderation_queue mq
  LEFT JOIN public.users u ON mq.author_id = u.id
  LEFT JOIN auth.users au ON mq.author_id = au.id
  LEFT JOIN public.preschools p ON mq.school_id = p.id
  WHERE 
    (p_status IS NULL OR mq.status = p_status) AND
    (p_severity IS NULL OR mq.severity = p_severity) AND
    (p_content_type IS NULL OR mq.content_type = p_content_type)
  ORDER BY 
    mq.priority ASC,
    CASE mq.severity
      WHEN 'critical' THEN 4
      WHEN 'high' THEN 3
      WHEN 'medium' THEN 2
      WHEN 'low' THEN 1
    END DESC,
    mq.flagged_at DESC
  LIMIT p_limit;
  
  RETURN COALESCE(v_items, '[]'::jsonb);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_moderation_stats()
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_current_user_id UUID := auth.uid();
  v_stats JSONB;
  v_pending_count INTEGER;
  v_flagged_count INTEGER;
  v_critical_count INTEGER;
  v_total_reports INTEGER;
  v_resolved_today INTEGER;
BEGIN
  -- Check if current user is superadmin
  IF NOT EXISTS (
    SELECT 1 FROM public.users 
    WHERE id = v_current_user_id 
    AND role = 'superadmin'
  ) THEN
    RETURN json_build_object('error', 'Unauthorized: Superadmin access required');
  END IF;
  
  -- Get counts
  SELECT COUNT(*) INTO v_pending_count
  FROM public.moderation_queue
  WHERE status = 'pending';
  
  SELECT COUNT(*) INTO v_flagged_count
  FROM public.moderation_queue
  WHERE status IN ('pending', 'reviewing') AND auto_flagged = TRUE;
  
  SELECT COUNT(*) INTO v_critical_count
  FROM public.moderation_queue
  WHERE severity = 'critical' AND status IN ('pending', 'reviewing');
  
  SELECT COUNT(*) INTO v_total_reports
  FROM public.content_reports
  WHERE status = 'pending';
  
  SELECT COUNT(*) INTO v_resolved_today
  FROM public.moderation_queue
  WHERE DATE(reviewed_at) = CURRENT_DATE
  AND status IN ('approved', 'rejected');
  
  v_stats := json_build_object(
    'pending_items', v_pending_count,
    'auto_flagged_items', v_flagged_count,
    'critical_items', v_critical_count,
    'total_reports', v_total_reports,
    'resolved_today', v_resolved_today
  );
  
  RETURN v_stats;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_monthly_service_costs(p_year integer, p_month integer)
 RETURNS TABLE(service_name text, total_cost_usd numeric, total_cost_zar numeric, total_usage_units jsonb, preschool_count bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    sct.service_name,
    ROUND(SUM(sct.cost_usd)::NUMERIC, 2),
    ROUND(SUM(sct.cost_zar)::NUMERIC, 2),
    jsonb_object_agg(sct.preschool_id, sct.usage_units) FILTER (WHERE sct.preschool_id IS NOT NULL),
    COUNT(DISTINCT sct.preschool_id)::BIGINT
  FROM public.service_cost_tracking sct
  WHERE EXTRACT(YEAR FROM sct.period_month) = p_year
    AND EXTRACT(MONTH FROM sct.period_month) = p_month
  GROUP BY sct.service_name
  ORDER BY SUM(sct.cost_usd) DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_my_exam_assignments()
 RETURNS TABLE(assignment_id uuid, exam_title text, teacher_name text, subject text, grade text, due_date timestamp with time zone, status text, my_submission_id uuid, my_score numeric, submitted_at timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    a.id AS assignment_id,
    a.title AS exam_title,
    p.first_name || ' ' || COALESCE(p.last_name, '') AS teacher_name,
    eg.subject,
    eg.grade,
    a.due_date,
    a.status,
    s.id AS my_submission_id,
    s.percentage AS my_score,
    s.submitted_at
  FROM public.exam_assignments a
  JOIN public.exam_generations eg ON a.exam_generation_id = eg.id
  JOIN public.profiles p ON a.teacher_id = p.id
  LEFT JOIN public.exam_submissions s ON s.assignment_id = a.id AND s.student_id = auth.uid()
  WHERE auth.uid() = ANY(a.student_ids) AND a.status = 'active'
  ORDER BY CASE WHEN s.submitted_at IS NULL THEN 0 ELSE 1 END, a.due_date ASC NULLS LAST;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_my_org_member(p_org_id uuid)
 RETURNS TABLE(id uuid, organization_id uuid, region_id uuid, user_id uuid, member_number character varying, member_type character varying, role text, first_name character varying, last_name character varying, email character varying, phone character varying, membership_tier character varying, membership_status character varying, seat_status text, join_date date, created_at timestamp with time zone, invited_by uuid)
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  current_user_id uuid;
BEGIN
  -- Get the current authenticated user ID
  current_user_id := auth.uid();
  
  -- Return empty if no authenticated user
  IF current_user_id IS NULL THEN
    RETURN;
  END IF;
  
  -- Return the user's membership for the specified organization
  RETURN QUERY
  SELECT 
    om.id,
    om.organization_id,
    om.region_id,
    om.user_id,
    om.member_number,
    om.member_type,
    om.role,
    om.first_name,
    om.last_name,
    om.email,
    om.phone,
    om.membership_tier,
    om.membership_status,
    om.seat_status,
    om.join_date,
    om.created_at,
    om.invited_by
  FROM organization_members om
  WHERE om.organization_id = p_org_id
    AND om.user_id = current_user_id
  LIMIT 1;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_my_trial_status()
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  user_profile RECORD;
  org_subscription RECORD;
  result json;
  days_left INTEGER;
  community_school_id UUID := '00000000-0000-0000-0000-000000000001';
BEGIN
  -- Get current user's profile
  SELECT * INTO user_profile
  FROM profiles
  WHERE id = auth.uid();
  
  IF NOT FOUND THEN
    RETURN json_build_object(
      'is_trial', false,
      'message', 'User profile not found'
    );
  END IF;
  
  -- Check if user is in EduDash Pro Community School (virtual school)
  IF user_profile.preschool_id = community_school_id THEN
    RETURN json_build_object(
      'is_trial', false,
      'trial_type', 'virtual_school',
      'message', 'Community school - full access',
      'plan_tier', 'free',
      'plan_name', 'Virtual School'
    );
  END IF;
  
  -- Check if user is linked to an organization
  IF user_profile.preschool_id IS NOT NULL THEN
    -- Organization-level trial (existing logic)
    SELECT * INTO org_subscription
    FROM subscriptions
    WHERE preschool_id = user_profile.preschool_id
    LIMIT 1;
    
    IF FOUND AND org_subscription.is_trial THEN
      -- Calculate days remaining (full days, not just day component)
      days_left := GREATEST(0, CEIL(EXTRACT(EPOCH FROM (org_subscription.trial_end_date - NOW())) / 86400)::INTEGER);
      
      RETURN json_build_object(
        'is_trial', true,
        'trial_type', 'organization',
        'trial_end_date', org_subscription.trial_end_date,
        'days_remaining', days_left,
        'plan_tier', org_subscription.plan_tier,
        'plan_name', 'Premium'
      );
    END IF;
  END IF;
  
  -- Check for user-level trial (independent users)
  IF user_profile.is_trial THEN
    -- Check if trial is still active
    IF user_profile.trial_end_date > NOW() THEN
      -- Calculate days remaining (full days, not just day component)
      days_left := GREATEST(0, CEIL(EXTRACT(EPOCH FROM (user_profile.trial_end_date - NOW())) / 86400)::INTEGER);
      
      RETURN json_build_object(
        'is_trial', true,
        'trial_type', 'personal',
        'trial_end_date', user_profile.trial_end_date,
        'days_remaining', days_left,
        'plan_tier', user_profile.trial_plan_tier,
        'plan_name', 'Premium'
      );
    ELSE
      -- Trial expired - mark as ended
      UPDATE profiles
      SET is_trial = FALSE
      WHERE id = auth.uid();
      
      RETURN json_build_object(
        'is_trial', false,
        'trial_expired', true,
        'message', 'Trial period ended'
      );
    END IF;
  END IF;
  
  -- No active trial
  RETURN json_build_object(
    'is_trial', false,
    'message', 'No active trial'
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_my_user_context()
 RETURNS TABLE(user_id uuid, user_auth_user_id uuid, user_role text, user_preschool_id uuid, is_superadmin boolean)
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT 
    id,
    auth_user_id,
    role,
    preschool_id,
    role = 'superadmin'
  FROM public.users
  WHERE auth_user_id = auth.uid()
  LIMIT 1;
$function$
;

CREATE OR REPLACE FUNCTION public.get_nearby_candidates(job_id uuid, max_distance_km integer DEFAULT 50)
 RETURNS TABLE(candidate_id uuid, candidate_name text, candidate_email text, distance_km numeric, experience_years integer, willing_to_commute_km integer)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  job_lat DECIMAL;
  job_lng DECIMAL;
BEGIN
  -- Get job location
  SELECT latitude, longitude INTO job_lat, job_lng
  FROM public.job_postings
  WHERE id = job_id;
  
  -- Return candidates within radius who are willing to commute
  RETURN QUERY
  SELECT 
    cp.id AS candidate_id,
    CONCAT(cp.first_name, ' ', cp.last_name) AS candidate_name,
    cp.email AS candidate_email,
    ROUND(
      earth_distance(
        ll_to_earth(job_lat, job_lng),
        ll_to_earth(cp.preferred_location_lat, cp.preferred_location_lng)
      ) / 1000, 1
    )::DECIMAL AS distance_km,
    cp.experience_years,
    cp.willing_to_commute_km
  FROM public.candidate_profiles cp
  WHERE 
    cp.preferred_location_lat IS NOT NULL
    AND cp.preferred_location_lng IS NOT NULL
    AND earth_distance(
      ll_to_earth(job_lat, job_lng),
      ll_to_earth(cp.preferred_location_lat, cp.preferred_location_lng)
    ) <= (LEAST(max_distance_km, cp.willing_to_commute_km) * 1000)
  ORDER BY distance_km ASC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_nearby_jobs(candidate_lat numeric, candidate_lng numeric, max_distance_km integer DEFAULT 50)
 RETURNS TABLE(job_id uuid, title text, school_name text, distance_km numeric, employment_type text, salary_range_min numeric, salary_range_max numeric, location text, created_at timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    jp.id AS job_id,
    jp.title,
    p.name AS school_name,
    ROUND(
      earth_distance(
        ll_to_earth(jp.latitude, jp.longitude),
        ll_to_earth(candidate_lat, candidate_lng)
      ) / 1000, 1
    )::DECIMAL AS distance_km,
    jp.employment_type,
    jp.salary_range_min,
    jp.salary_range_max,
    jp.location,
    jp.created_at
  FROM public.job_postings jp
  INNER JOIN public.preschools p ON jp.preschool_id = p.id
  WHERE 
    jp.status = 'active'
    AND (jp.expires_at IS NULL OR jp.expires_at > NOW())
    AND jp.latitude IS NOT NULL
    AND jp.longitude IS NOT NULL
    AND earth_distance(
      ll_to_earth(jp.latitude, jp.longitude),
      ll_to_earth(candidate_lat, candidate_lng)
    ) <= (max_distance_km * 1000)
  ORDER BY distance_km ASC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_notification_template(p_template_key text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_result JSON;
BEGIN
  SELECT json_build_object(
    'success', true,
    'template', json_build_object(
      'id', t.id,
      'template_key', t.template_key,
      'name', t.name,
      'description', t.description,
      'category', t.category,
      'subject_template', t.subject_template,
      'body_template', t.body_template,
      'html_template', t.html_template,
      'variables', t.variables,
      'default_variables', t.default_variables,
      'required_variables', t.required_variables,
      'language', t.language,
      'status', t.status,
      'version', t.version,
      'is_system_template', t.is_system_template,
      'usage_count', t.usage_count,
      'last_used_at', t.last_used_at,
      'created_at', t.created_at,
      'updated_at', t.updated_at
    )
  )
  FROM notification_templates t
  WHERE t.template_key = p_template_key
  AND (t.status = 'active' OR EXISTS (
    SELECT 1 FROM user_profiles 
    WHERE user_id = auth.uid() 
    AND role = 'super_admin' 
    AND is_active = true
  ))
  INTO v_result;
  
  IF v_result IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Template not found or access denied',
      'error_code', 'TEMPLATE_NOT_FOUND'
    );
  END IF;
  
  RETURN v_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_onboarding_status(p_school_id uuid)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_current_user_id UUID := auth.uid();
  v_is_authorized BOOLEAN := FALSE;
  v_school_record RECORD;
  v_progress_record RECORD;
  v_verifications JSONB;
  v_result JSON;
BEGIN
  -- Check authorization
  IF v_current_user_id IS NOT NULL THEN
    SELECT EXISTS(
      SELECT 1 FROM public.users 
      WHERE id = v_current_user_id 
      AND (
        role = 'superadmin' 
        OR (preschool_id = p_school_id AND role IN ('principal', 'preschool_admin'))
      )
    ) INTO v_is_authorized;
  END IF;
  
  IF NOT v_is_authorized THEN
    RETURN json_build_object('error', 'Unauthorized access');
  END IF;
  
  -- Get school information
  SELECT 
    id,
    name,
    school_type,
    verification_status,
    onboarding_flow,
    onboarding_completed_at,
    created_at
  INTO v_school_record
  FROM public.preschools
  WHERE id = p_school_id;
  
  IF NOT FOUND THEN
    RETURN json_build_object('error', 'School not found');
  END IF;
  
  -- Get onboarding progress
  SELECT 
    flow_type,
    current_step,
    completed_steps,
    step_data,
    started_at,
    completed_at
  INTO v_progress_record
  FROM public.onboarding_progress
  WHERE school_id = p_school_id
  ORDER BY started_at DESC
  LIMIT 1;
  
  -- Get verification status
  SELECT json_agg(
    json_build_object(
      'type', verification_type,
      'status', status,
      'verified_at', verified_at,
      'expires_at', expires_at
    )
  )
  INTO v_verifications
  FROM public.school_verifications
  WHERE school_id = p_school_id;
  
  -- Build response
  v_result := json_build_object(
    'success', TRUE,
    'school', json_build_object(
      'id', v_school_record.id,
      'name', v_school_record.name,
      'school_type', v_school_record.school_type,
      'verification_status', v_school_record.verification_status,
      'onboarding_flow', v_school_record.onboarding_flow,
      'onboarding_completed_at', v_school_record.onboarding_completed_at,
      'created_at', v_school_record.created_at
    ),
    'progress', CASE
      WHEN v_progress_record.flow_type IS NOT NULL THEN
        json_build_object(
          'flow_type', v_progress_record.flow_type,
          'current_step', v_progress_record.current_step,
          'completed_steps', v_progress_record.completed_steps,
          'step_data', v_progress_record.step_data,
          'started_at', v_progress_record.started_at,
          'completed_at', v_progress_record.completed_at
        )
      ELSE NULL
    END,
    'verifications', COALESCE(v_verifications, '[]'::JSONB)
  );
  
  RETURN v_result;
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object(
      'error', 'Failed to get onboarding status: ' || SQLERRM
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_or_create_parent_teacher_thread(p_student_id uuid, p_parent_id uuid)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    thread_id UUID;
    student_record RECORD;
    teacher_id UUID;
BEGIN
    -- Get student info
    SELECT s.preschool_id, s.class_id, c.teacher_id
    INTO student_record
    FROM students s
    LEFT JOIN classes c ON s.class_id = c.id
    WHERE s.id = p_student_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Student not found';
    END IF;
    
    teacher_id := student_record.teacher_id;
    
    -- Try to find existing thread
    SELECT mt.id INTO thread_id
    FROM message_threads mt
    JOIN message_participants mp1 ON mt.id = mp1.thread_id AND mp1.user_id = p_parent_id AND mp1.role = 'parent'
    JOIN message_participants mp2 ON mt.id = mp2.thread_id AND mp2.user_id = teacher_id AND mp2.role = 'teacher'
    WHERE mt.student_id = p_student_id
    AND mt.type = 'parent-teacher'
    LIMIT 1;
    
    -- If no existing thread, create one
    IF thread_id IS NULL THEN
        -- Create thread
        INSERT INTO message_threads (preschool_id, type, student_id, subject, created_by)
        VALUES (
            student_record.preschool_id,
            'parent-teacher',
            p_student_id,
            'Student Discussion',
            p_parent_id
        )
        RETURNING id INTO thread_id;
        
        -- Add parent as participant
        INSERT INTO message_participants (thread_id, user_id, role)
        VALUES (thread_id, p_parent_id, 'parent');
        
        -- Add teacher as participant (if teacher exists)
        IF teacher_id IS NOT NULL THEN
            INSERT INTO message_participants (thread_id, user_id, role)
            VALUES (thread_id, teacher_id, 'teacher');
        END IF;
    END IF;
    
    RETURN thread_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_organization_type(org_id uuid)
 RETURNS public.organization_type
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
    select type::text::organization_type
    from organizations
    where id = org_id;
$function$
;

CREATE OR REPLACE FUNCTION public.get_parent_outstanding_fees(p_parent_id uuid)
 RETURNS TABLE(student_id uuid, student_name text, fee_name text, amount_cents integer, paid_cents integer, balance_cents integer, due_date date, status text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    sfa.student_id,
    p.first_name || ' ' || COALESCE(p.last_name, '') AS student_name,
    sfs.name AS fee_name,
    sfa.total_amount_cents AS amount_cents,
    sfa.paid_amount_cents AS paid_cents,
    sfa.balance_cents,
    sfa.due_date,
    sfa.status
  FROM public.student_fee_assignments sfa
  JOIN public.profiles p ON sfa.student_id = p.id
  JOIN public.school_fee_structures sfs ON sfa.fee_structure_id = sfs.id
  WHERE p.parent_id = p_parent_id
    AND sfa.status IN ('pending', 'partial', 'overdue')
  ORDER BY sfa.due_date ASC NULLS LAST;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_pending_deliveries(p_channel public.delivery_method_enum DEFAULT NULL::public.delivery_method_enum, p_limit integer DEFAULT 100)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_id UUID;
  v_is_superadmin BOOLEAN;
  v_deliveries JSON;
BEGIN
  -- Get current user ID
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Authentication required',
      'error_code', 'AUTH_REQUIRED'
    );
  END IF;
  
  -- Check if user is superadmin
  SELECT EXISTS (
    SELECT 1 FROM user_profiles 
    WHERE user_id = v_user_id 
    AND role = 'super_admin' 
    AND is_active = true
  ) INTO v_is_superadmin;
  
  IF NOT v_is_superadmin THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Superadmin privileges required',
      'error_code', 'INSUFFICIENT_PRIVILEGES'
    );
  END IF;
  
  -- Get pending deliveries
  SELECT json_build_object(
    'success', true,
    'deliveries', json_agg(
      json_build_object(
        'id', nd.id,
        'notification_id', nd.notification_id,
        'channel', nd.channel,
        'recipient_email', nd.recipient_email,
        'recipient_phone', nd.recipient_phone,
        'recipient_device_token', nd.recipient_device_token,
        'subject', nd.subject,
        'body', nd.body,
        'html_body', nd.html_body,
        'priority', nd.priority,
        'send_at', nd.send_at,
        'provider', json_build_object(
          'id', dp.id,
          'name', dp.provider_name,
          'display_name', dp.display_name,
          'config', dp.config,
          'endpoints', dp.endpoints
        ),
        'created_at', nd.created_at
      ) ORDER BY nd.priority DESC, nd.send_at ASC
    )
  )
  FROM notification_deliveries nd
  LEFT JOIN delivery_providers dp ON nd.provider_id = dp.id
  WHERE nd.status = 'pending'
  AND nd.send_at <= now()
  AND (p_channel IS NULL OR nd.channel = p_channel)
  ORDER BY nd.priority DESC, nd.send_at ASC
  LIMIT p_limit
  INTO v_deliveries;
  
  RETURN COALESCE(v_deliveries, json_build_object(
    'success', true,
    'deliveries', '[]'::json
  ));
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object(
      'success', false,
      'error', SQLERRM,
      'error_code', 'INTERNAL_ERROR'
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_petty_cash_balance(school_uuid uuid)
 RETURNS numeric
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
  SELECT COALESCE(
    (
      SELECT a.opening_balance + COALESCE(SUM(
        CASE 
          WHEN t.type = 'expense' THEN -t.amount
          WHEN t.type IN ('replenishment', 'adjustment') THEN t.amount
          ELSE 0
        END
      ), 0)
      FROM petty_cash_accounts a
      LEFT JOIN petty_cash_transactions t ON t.account_id = a.id AND t.status = 'approved'
      WHERE a.school_id = school_uuid AND a.is_active = true
      GROUP BY a.id, a.opening_balance
      LIMIT 1
    ), 0
  );
$function$
;

CREATE OR REPLACE FUNCTION public.get_petty_cash_summary(p_preschool_id uuid, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date)
 RETURNS TABLE(total_accounts integer, active_accounts integer, total_balance numeric, total_deposits numeric, total_withdrawals numeric, net_flow numeric, transaction_count integer)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    -- Set default date range if not provided
    v_start_date := COALESCE(p_start_date, DATE_TRUNC('month', CURRENT_DATE)::DATE);
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);

    RETURN QUERY
    SELECT 
        COUNT(*)::INTEGER as total_accounts,
        COUNT(*) FILTER (WHERE is_active = true)::INTEGER as active_accounts,
        COALESCE(SUM(current_balance), 0)::DECIMAL(10,2) as total_balance,
        COALESCE(
            (SELECT SUM(amount) 
             FROM public.petty_cash_transactions t 
             WHERE t.preschool_id = p_preschool_id 
             AND t.transaction_type = 'deposit'
             AND t.transaction_date BETWEEN v_start_date AND v_end_date
            ), 0
        )::DECIMAL(10,2) as total_deposits,
        COALESCE(
            (SELECT SUM(amount) 
             FROM public.petty_cash_transactions t 
             WHERE t.preschool_id = p_preschool_id 
             AND t.transaction_type = 'withdrawal'
             AND t.transaction_date BETWEEN v_start_date AND v_end_date
            ), 0
        )::DECIMAL(10,2) as total_withdrawals,
        COALESCE(
            (SELECT SUM(CASE WHEN transaction_type = 'deposit' THEN amount ELSE -amount END)
             FROM public.petty_cash_transactions t 
             WHERE t.preschool_id = p_preschool_id 
             AND t.transaction_type IN ('deposit', 'withdrawal')
             AND t.transaction_date BETWEEN v_start_date AND v_end_date
            ), 0
        )::DECIMAL(10,2) as net_flow,
        COALESCE(
            (SELECT COUNT(*)
             FROM public.petty_cash_transactions t 
             WHERE t.preschool_id = p_preschool_id 
             AND t.transaction_date BETWEEN v_start_date AND v_end_date
            ), 0
        )::INTEGER as transaction_count
    FROM public.petty_cash_accounts 
    WHERE preschool_id = p_preschool_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_petty_cash_summary(school_uuid uuid, start_date timestamp with time zone DEFAULT NULL::timestamp with time zone, end_date timestamp with time zone DEFAULT NULL::timestamp with time zone)
 RETURNS TABLE(total_expenses numeric, total_replenishments numeric, total_adjustments numeric, transaction_count bigint, pending_count bigint)
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
  SELECT 
    COALESCE(SUM(CASE WHEN type = 'expense' AND status = 'approved' THEN amount ELSE 0 END), 0) as total_expenses,
    COALESCE(SUM(CASE WHEN type = 'replenishment' AND status = 'approved' THEN amount ELSE 0 END), 0) as total_replenishments,
    COALESCE(SUM(CASE WHEN type = 'adjustment' AND status = 'approved' THEN amount ELSE 0 END), 0) as total_adjustments,
    COUNT(CASE WHEN status = 'approved' THEN 1 END) as transaction_count,
    COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_count
  FROM petty_cash_transactions
  WHERE school_id = school_uuid
    AND (start_date IS NULL OR created_at >= start_date)
    AND (end_date IS NULL OR created_at <= end_date);
$function$
;

CREATE OR REPLACE FUNCTION public.get_platform_stats_for_superadmin()
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_current_user_id UUID := auth.uid();
  v_stats JSONB;
  v_total_schools INTEGER := 0;
  v_total_users INTEGER := 0;
  v_total_students INTEGER := 0;
  v_total_teachers INTEGER := 0;
  v_total_parents INTEGER := 0;
  v_active_subscriptions INTEGER := 0;
  v_total_revenue DECIMAL := 0;
  v_monthly_revenue DECIMAL := 0;
  v_ai_usage_month DECIMAL := 0;
  v_avg_school_size DECIMAL := 0;
BEGIN
  -- Check if current user is superadmin
  IF NOT EXISTS (
    SELECT 1 FROM public.users 
    WHERE id = v_current_user_id 
    AND role = 'superadmin'
  ) THEN
    RETURN json_build_object('error', 'Unauthorized: Superadmin access required');
  END IF;
  
  -- Get school count (active preschools) - handle table not existing
  BEGIN
    SELECT COUNT(*) INTO v_total_schools
    FROM public.preschools
    WHERE is_active = TRUE;
  EXCEPTION WHEN OTHERS THEN
    v_total_schools := 0;
  END;
  
  -- Get user counts by role - handle table not existing
  BEGIN
    SELECT COUNT(*) INTO v_total_users FROM public.users WHERE is_active = TRUE;
    SELECT COUNT(*) INTO v_total_teachers FROM public.users WHERE role = 'teacher' AND is_active = TRUE;
    SELECT COUNT(*) INTO v_total_parents FROM public.users WHERE role = 'parent' AND is_active = TRUE;
  EXCEPTION WHEN OTHERS THEN
    v_total_users := 0;
    v_total_teachers := 0;
    v_total_parents := 0;
  END;
  
  -- Get student count from enrollments - handle table not existing
  BEGIN
    SELECT COUNT(DISTINCT student_id) INTO v_total_students 
    FROM public.enrollments 
    WHERE status = 'active';
  EXCEPTION WHEN OTHERS THEN
    v_total_students := 0;
  END;
  
  -- Get subscription stats - handle table not existing
  BEGIN
    SELECT COUNT(*) INTO v_active_subscriptions
    FROM public.subscriptions
    WHERE status = 'active';
  EXCEPTION WHEN OTHERS THEN
    v_active_subscriptions := 0;
  END;
  
  -- Calculate revenue from subscription plans - handle tables not existing
  BEGIN
    SELECT 
      COALESCE(SUM(
        CASE 
          WHEN s.billing_frequency = 'annual' THEN sp.price_annual
          ELSE sp.price_monthly * 12
        END
      ), 0),
      COALESCE(SUM(
        CASE 
          WHEN s.billing_frequency = 'annual' THEN sp.price_annual / 12
          ELSE sp.price_monthly
        END
      ), 0)
    INTO v_total_revenue, v_monthly_revenue
    FROM public.subscriptions s
    JOIN public.subscription_plans sp ON s.plan_id = sp.id
    WHERE s.status = 'active';
  EXCEPTION WHEN OTHERS THEN
    v_total_revenue := 0;
    v_monthly_revenue := 0;
  END;
  
  -- Get AI usage cost for current month - handle table not existing
  BEGIN
    SELECT COALESCE(SUM(total_cost), 0) INTO v_ai_usage_month
    FROM public.ai_usage_logs
    WHERE created_at >= date_trunc('month', CURRENT_DATE)
    AND created_at < date_trunc('month', CURRENT_DATE) + interval '1 month';
  EXCEPTION WHEN OTHERS THEN
    v_ai_usage_month := 0;
  END;
  
  -- Calculate average school size (users per school)
  SELECT 
    CASE 
      WHEN v_total_schools > 0 THEN v_total_users::DECIMAL / v_total_schools
      ELSE 0
    END INTO v_avg_school_size;
  
  -- Build response
  v_stats := jsonb_build_object(
    'total_schools', v_total_schools,
    'total_users', v_total_users,
    'total_students', v_total_students,
    'total_teachers', v_total_teachers,
    'total_parents', v_total_parents,
    'active_subscriptions', v_active_subscriptions,
    'total_revenue', v_total_revenue,
    'monthly_revenue', v_monthly_revenue,
    'ai_usage_month', v_ai_usage_month,
    'avg_school_size', v_avg_school_size,
    'churn_rate', 0,
    'growth_rate', 0
  );
  
  RETURN v_stats;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_pop_upload_stats(target_student_id uuid DEFAULT NULL::uuid, target_preschool_id uuid DEFAULT NULL::uuid)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    result JSON;
    user_role TEXT;
BEGIN
    -- Get user role
    SELECT role INTO user_role FROM public.users WHERE id = auth.uid();
    
    -- Build stats based on role and parameters
    WITH stats AS (
        SELECT 
            upload_type,
            status,
            COUNT(*) as count,
            COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE - INTERVAL '7 days') as recent_count
        FROM public.pop_uploads
        WHERE 
            (target_student_id IS NULL OR student_id = target_student_id) AND
            (target_preschool_id IS NULL OR preschool_id = target_preschool_id) AND
            (
                -- Apply RLS-like filtering
                (user_role = 'parent' AND uploaded_by = auth.uid()) OR
                (user_role IN ('teacher', 'principal', 'superadmin'))
            )
        GROUP BY upload_type, status
    )
    SELECT json_build_object(
        'proof_of_payment', json_build_object(
            'pending', COALESCE((SELECT count FROM stats WHERE upload_type = 'proof_of_payment' AND status = 'pending'), 0),
            'approved', COALESCE((SELECT count FROM stats WHERE upload_type = 'proof_of_payment' AND status = 'approved'), 0),
            'rejected', COALESCE((SELECT count FROM stats WHERE upload_type = 'proof_of_payment' AND status = 'rejected'), 0),
            'recent', COALESCE((SELECT SUM(recent_count) FROM stats WHERE upload_type = 'proof_of_payment'), 0)
        ),
        'picture_of_progress', json_build_object(
            'pending', COALESCE((SELECT count FROM stats WHERE upload_type = 'picture_of_progress' AND status = 'pending'), 0),
            'approved', COALESCE((SELECT count FROM stats WHERE upload_type = 'picture_of_progress' AND status = 'approved'), 0),
            'rejected', COALESCE((SELECT count FROM stats WHERE upload_type = 'picture_of_progress' AND status = 'rejected'), 0),
            'recent', COALESCE((SELECT SUM(recent_count) FROM stats WHERE upload_type = 'picture_of_progress'), 0)
        ),
        'total_pending', COALESCE((SELECT SUM(count) FROM stats WHERE status = 'pending'), 0),
        'total_recent', COALESCE((SELECT SUM(recent_count) FROM stats), 0)
    ) INTO result;
    
    RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_promotional_price(p_user_id uuid, p_tier text, p_user_type text, p_original_price numeric)
 RETURNS numeric
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_campaign RECORD;
  v_promo_price DECIMAL;
  v_existing_promo RECORD;
BEGIN
  -- Check if user already has an active promo for this tier
  SELECT * INTO v_existing_promo
  FROM user_promotional_subscriptions
  WHERE user_id = p_user_id
    AND tier = p_tier
    AND is_active = true
    AND promo_end_date > NOW();
  
  IF FOUND THEN
    RETURN v_existing_promo.promo_price;
  END IF;
  
  -- Find active campaign
  SELECT * INTO v_campaign
  FROM promotional_campaigns
  WHERE is_active = true
    AND NOW() BETWEEN start_date AND end_date
    AND user_type IN (p_user_type, 'all')
    AND (tier_filter IS NULL OR p_tier = ANY(tier_filter))
    AND (max_uses IS NULL OR current_uses < max_uses)
  ORDER BY discount_value DESC -- Best discount first
  LIMIT 1;
  
  IF NOT FOUND THEN
    RETURN p_original_price;
  END IF;
  
  -- Calculate promo price
  CASE v_campaign.discount_type
    WHEN 'percentage' THEN
      v_promo_price := p_original_price * (1 - v_campaign.discount_value / 100);
    WHEN 'fixed_amount' THEN
      v_promo_price := p_original_price - v_campaign.discount_value;
    WHEN 'fixed_price' THEN
      v_promo_price := v_campaign.discount_value;
  END CASE;
  
  -- Ensure price doesn't go below 0
  v_promo_price := GREATEST(v_promo_price, 0);
  
  -- Round to 2 decimal places
  v_promo_price := ROUND(v_promo_price, 2);
  
  RETURN v_promo_price;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_promotional_price(p_user_id uuid, p_tier text, p_user_type text, p_original_price numeric, p_billing_frequency text DEFAULT 'monthly'::text)
 RETURNS numeric
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_campaign RECORD;
  v_promo_price DECIMAL;
  v_existing_promo RECORD;
BEGIN
  -- Annual billing does NOT get promotional discount
  IF p_billing_frequency = 'annual' THEN
    RETURN p_original_price;
  END IF;

  -- Check if user already has an active promo for this tier
  SELECT * INTO v_existing_promo
  FROM user_promotional_subscriptions
  WHERE user_id = p_user_id
    AND tier = p_tier
    AND is_active = true
    AND promo_end_date > NOW();
  
  IF FOUND THEN
    RETURN v_existing_promo.promo_price;
  END IF;
  
  -- Find active campaign
  SELECT * INTO v_campaign
  FROM promotional_campaigns
  WHERE is_active = true
    AND NOW() BETWEEN start_date AND end_date
    AND user_type IN (p_user_type, 'all')
    AND (tier_filter IS NULL OR p_tier = ANY(tier_filter))
    AND (max_uses IS NULL OR current_uses < max_uses)
  ORDER BY discount_value DESC
  LIMIT 1;
  
  IF NOT FOUND THEN
    RETURN p_original_price;
  END IF;
  
  -- Calculate promo price
  CASE v_campaign.discount_type
    WHEN 'percentage' THEN
      v_promo_price := p_original_price * (1 - v_campaign.discount_value / 100);
    WHEN 'fixed_amount' THEN
      v_promo_price := p_original_price - v_campaign.discount_value;
    WHEN 'fixed_price' THEN
      v_promo_price := v_campaign.discount_value;
  END CASE;
  
  v_promo_price := GREATEST(v_promo_price, 0);
  v_promo_price := ROUND(v_promo_price, 2);
  
  RETURN v_promo_price;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_promotional_registration_fee(p_user_id uuid, p_original_fee numeric, p_user_type text DEFAULT 'parent'::text)
 RETURNS numeric
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_campaign RECORD;
  v_promo_price DECIMAL;
BEGIN
  -- Find active registration fee campaign
  SELECT * INTO v_campaign
  FROM promotional_campaigns
  WHERE is_active = true
    AND NOW() BETWEEN start_date AND end_date
    AND applies_to_registration = true
    AND product_type IN ('registration', 'all')
    AND user_type IN (p_user_type, 'all')
    AND (max_uses IS NULL OR current_uses < max_uses)
  ORDER BY discount_value DESC -- Best discount first
  LIMIT 1;
  
  IF NOT FOUND THEN
    RETURN p_original_fee;
  END IF;
  
  -- Calculate promo price
  CASE v_campaign.discount_type
    WHEN 'percentage' THEN
      v_promo_price := p_original_fee * (1 - v_campaign.discount_value / 100);
    WHEN 'fixed_amount' THEN
      v_promo_price := p_original_fee - v_campaign.discount_value;
    WHEN 'fixed_price' THEN
      v_promo_price := v_campaign.discount_value;
  END CASE;
  
  -- Ensure price doesn't go below 0
  v_promo_price := GREATEST(v_promo_price, 0);
  
  -- Round to 2 decimal places
  v_promo_price := ROUND(v_promo_price, 2);
  
  RETURN v_promo_price;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_public_organizations()
 RETURNS TABLE(id uuid, name text, type text, description text, address text, logo_url text, website text, phone text, email text)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    o.id,
    o.name,
    o.type::TEXT,
    o.description,
    COALESCE(o.address_line1 || ', ' || o.city, o.address_line1, '') as address,
    o.logo_url,
    o.website,
    o.phone,
    o.email
  FROM organizations o
  WHERE o.is_public = TRUE
    AND o.accepting_registrations = TRUE
    AND o.is_active = TRUE
  ORDER BY o.name;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_public_preschools()
 RETURNS TABLE(id uuid, name text, description text, address text, logo_url text, website_url text, phone text, email text)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    p.id,
    p.name,
    p.description,
    p.address,
    p.logo_url,
    p.website_url,
    p.phone,
    p.email
  FROM preschools p
  WHERE p.is_public = TRUE
    AND p.accepting_registrations = TRUE
    AND p.is_active = TRUE
  ORDER BY p.name;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_recent_error_logs(hours_back integer DEFAULT 24)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  result JSON;
  log_data JSON;
BEGIN
  -- Check if current user is superadmin
  IF NOT is_superadmin() THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Access denied: Superladmin privileges required'
    );
  END IF;

  -- Get recent logs
  SELECT json_agg(
    json_build_object(
      'id', id,
      'timestamp', timestamp,
      'level', level,
      'message', message,
      'source', source,
      'user_id', user_id,
      'details', details
    ) ORDER BY timestamp DESC
  ) INTO log_data
  FROM error_logs
  WHERE timestamp > NOW() - INTERVAL '1 hour' * hours_back
  LIMIT 100;

  result := json_build_object(
    'success', true,
    'data', json_build_object(
      'logs', COALESCE(log_data, '[]'::json),
      'hours_back', hours_back,
      'total_logs', (
        SELECT COUNT(*) 
        FROM error_logs 
        WHERE timestamp > NOW() - INTERVAL '1 hour' * hours_back
      )
    ),
    'generated_at', NOW()
  );

  RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_risk_color(risk_level public.risk_level_enum)
 RETURNS text
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
BEGIN
  CASE risk_level
    WHEN 'low' THEN
      RETURN '#10b981';      -- Green
    WHEN 'medium' THEN
      RETURN '#f59e0b';      -- Amber  
    WHEN 'high' THEN
      RETURN '#ef4444';      -- Red
    WHEN 'critical' THEN
      RETURN '#dc2626';      -- Dark red
    ELSE
      RETURN '#6b7280';      -- Gray (fallback)
  END CASE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_school_fee_summary(p_preschool_id uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  result JSONB;
BEGIN
  SELECT jsonb_build_object(
    'total_students', (SELECT COUNT(DISTINCT student_id) FROM student_fee_assignments WHERE preschool_id = p_preschool_id),
    'total_fees_assigned_cents', (SELECT COALESCE(SUM(total_amount_cents), 0) FROM student_fee_assignments WHERE preschool_id = p_preschool_id),
    'total_collected_cents', (SELECT COALESCE(SUM(paid_amount_cents), 0) FROM student_fee_assignments WHERE preschool_id = p_preschool_id),
    'outstanding_balance_cents', (SELECT COALESCE(SUM(balance_cents), 0) FROM student_fee_assignments WHERE preschool_id = p_preschool_id AND status IN ('pending', 'partial', 'overdue')),
    'overdue_count', (SELECT COUNT(*) FROM student_fee_assignments WHERE preschool_id = p_preschool_id AND status = 'overdue')
  ) INTO result;
  
  RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_service_health_summary()
 RETURNS TABLE(category text, total_services bigint, healthy_services bigint, degraded_services bigint, down_services bigint, avg_response_time_ms numeric)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    service_category,
    COUNT(*)::BIGINT,
    COUNT(*) FILTER (WHERE status = 'healthy')::BIGINT,
    COUNT(*) FILTER (WHERE status = 'degraded')::BIGINT,
    COUNT(*) FILTER (WHERE status = 'down')::BIGINT,
    ROUND(AVG(response_time_ms)::NUMERIC, 2)
  FROM public.service_health_status
  WHERE last_checked_at > NOW() - INTERVAL '1 hour'
  GROUP BY service_category
  ORDER BY service_category;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_service_role_key()
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  decrypted_secret TEXT;
BEGIN
  -- Attempt to retrieve the service role key from vault
  SELECT decrypted_secret INTO decrypted_secret
  FROM vault.decrypted_secrets
  WHERE name = 'service_role_key'
  LIMIT 1;
  
  RETURN decrypted_secret;
EXCEPTION
  WHEN OTHERS THEN
    -- If vault doesn't have the key, return empty string
    -- The cron job will fail but won't crash
    RETURN '';
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_service_usage_by_preschool(p_service_name text, p_start_date date, p_end_date date)
 RETURNS TABLE(preschool_id uuid, preschool_name text, total_cost_usd numeric, total_usage_units jsonb, months_count bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    sct.preschool_id,
    p.name AS preschool_name,
    ROUND(SUM(sct.cost_usd)::NUMERIC, 2),
    jsonb_object_agg(sct.period_month, sct.usage_units),
    COUNT(DISTINCT sct.period_month)::BIGINT
  FROM public.service_cost_tracking sct
  JOIN public.preschools p ON p.id = sct.preschool_id
  WHERE sct.service_name = p_service_name
    AND sct.period_month BETWEEN p_start_date AND p_end_date
  GROUP BY sct.preschool_id, p.name
  ORDER BY SUM(sct.cost_usd) DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_signature_signed_url(file_path text, expires_in integer DEFAULT 3600)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  signed_url TEXT;
BEGIN
  -- Only allow users to get signed URLs for their own signatures
  IF NOT (storage.foldername(file_path))[1] = auth.uid()::text THEN
    RAISE EXCEPTION 'Access denied: can only access own signatures';
  END IF;
  
  -- Generate signed URL
  SELECT storage.get_signed_url('signatures', file_path, expires_in) INTO signed_url;
  
  RETURN signed_url;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_spending_limit(member_role text)
 RETURNS numeric
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
BEGIN
  RETURN CASE member_role
    -- National Executive
    WHEN 'national_admin' THEN 100000.00
    WHEN 'admin' THEN 10000.00
    WHEN 'staff' THEN 2000.00
    
    -- Regional level
    WHEN 'regional_manager' THEN 5000.00
    
    -- Youth Wing
    WHEN 'youth_president' THEN 5000.00
    WHEN 'youth_deputy' THEN 3000.00
    WHEN 'youth_secretary' THEN 1000.00
    WHEN 'youth_treasurer' THEN 2000.00
    WHEN 'youth_coordinator' THEN 1000.00
    WHEN 'youth_facilitator' THEN 500.00
    
    -- Women's League
    WHEN 'women_president' THEN 5000.00
    WHEN 'women_deputy' THEN 3000.00
    WHEN 'women_secretary' THEN 1000.00
    WHEN 'women_treasurer' THEN 2000.00
    WHEN 'women_coordinator' THEN 1000.00
    WHEN 'women_facilitator' THEN 500.00
    
    -- Veterans
    WHEN 'veterans_president' THEN 3000.00
    WHEN 'veterans_coordinator' THEN 1000.00
    
    -- Others have no spending authority
    ELSE 0.00
  END;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_student_badges(p_student_id uuid)
 RETURNS TABLE(badge_name text, badge_icon text, badge_color text, earned_at timestamp with time zone, category text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    achievement_name,
    achievement_icon,
    achievement_color,
    student_achievements.earned_at,
    student_achievements.category
  FROM student_achievements
  WHERE student_id = p_student_id 
  AND achievement_type = 'badge'
  ORDER BY earned_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_student_course_progress(course_id uuid, student_id uuid)
 RETURNS TABLE(total_assignments integer, submitted_assignments integer, graded_assignments integer, current_grade numeric, completion_rate numeric, on_time_rate numeric)
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
    SELECT 
        COUNT(DISTINCT a.id)::INTEGER as total_assignments,
        COUNT(DISTINCT s.id) FILTER (WHERE NOT s.is_draft)::INTEGER as submitted_assignments,
        COUNT(DISTINCT g.id)::INTEGER as graded_assignments,
        COALESCE(ROUND(AVG(g.percentage), 2), 0.00) as current_grade,
        CASE 
            WHEN COUNT(DISTINCT a.id) = 0 THEN 0.00
            ELSE ROUND((COUNT(DISTINCT s.id) FILTER (WHERE NOT s.is_draft)::DECIMAL / COUNT(DISTINCT a.id) * 100), 2)
        END as completion_rate,
        CASE 
            WHEN COUNT(DISTINCT s.id) FILTER (WHERE NOT s.is_draft) = 0 THEN 100.00
            ELSE ROUND((COUNT(DISTINCT s.id) FILTER (WHERE NOT s.is_draft AND NOT s.is_late)::DECIMAL / 
                       COUNT(DISTINCT s.id) FILTER (WHERE NOT s.is_draft) * 100), 2)
        END as on_time_rate
    FROM assignments a
    LEFT JOIN submissions s ON s.assignment_id = a.id AND s.student_id = get_student_course_progress.student_id
    LEFT JOIN grades g ON g.submission_id = s.id AND g.is_published = true
    WHERE a.course_id = get_student_course_progress.course_id
    AND a.deleted_at IS NULL;
$function$
;

CREATE OR REPLACE FUNCTION public.get_student_pop_uploads(target_student_id uuid, limit_count integer DEFAULT 10)
 RETURNS TABLE(id uuid, upload_type character varying, title character varying, description text, file_path text, file_name character varying, status character varying, payment_amount numeric, payment_method character varying, payment_date date, subject character varying, achievement_level character varying, reviewed_by uuid, reviewed_at timestamp with time zone, review_notes text, created_at timestamp with time zone, reviewer_name text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        pu.id,
        pu.upload_type,
        pu.title,
        pu.description,
        pu.file_path,
        pu.file_name,
        pu.status,
        pu.payment_amount,
        pu.payment_method,
        pu.payment_date,
        pu.subject,
        pu.achievement_level,
        pu.reviewed_by,
        pu.reviewed_at,
        pu.review_notes,
        pu.created_at,
        CASE 
            WHEN pu.reviewed_by IS NOT NULL THEN 
                (up_reviewer.first_name || ' ' || up_reviewer.last_name)
            ELSE NULL
        END as reviewer_name
    FROM public.pop_uploads pu
    LEFT JOIN public.users up_reviewer ON pu.reviewed_by = up_reviewer.id
    WHERE pu.student_id = target_student_id
    AND (
        -- Parent can see their own uploads
        pu.uploaded_by = auth.uid() OR
        -- Teachers/principals can see uploads for their students
        EXISTS (
            SELECT 1 FROM public.users u
            WHERE u.id = auth.uid()
            AND u.role IN ('teacher', 'principal', 'superadmin')
        )
    )
    ORDER BY pu.created_at DESC
    LIMIT limit_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_student_stars(p_student_id uuid)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_total INTEGER;
BEGIN
  SELECT COALESCE(SUM(points), 0) INTO v_total
  FROM student_achievements
  WHERE student_id = p_student_id AND achievement_type = 'star';
  
  RETURN v_total;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_submission_attempt_count(assignment_id uuid, student_id uuid)
 RETURNS integer
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
    SELECT COUNT(*)::INTEGER
    FROM submissions s
    WHERE s.assignment_id = get_submission_attempt_count.assignment_id
    AND s.student_id = get_submission_attempt_count.student_id;
$function$
;

CREATE OR REPLACE FUNCTION public.get_subscription_analytics(p_start_date date, p_end_date date)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_current_user_id UUID := auth.uid();
  v_analytics JSONB;
  v_total_revenue DECIMAL := 0;
  v_monthly_revenue DECIMAL := 0;
  v_active_subs INTEGER := 0;
  v_churned_subs INTEGER := 0;
  v_new_subs INTEGER := 0;
  v_churn_rate DECIMAL := 0;
BEGIN
  -- Check if current user is superadmin
  IF NOT EXISTS (
    SELECT 1 FROM public.users 
    WHERE id = v_current_user_id 
    AND role = 'superadmin'
  ) THEN
    RETURN json_build_object('error', 'Unauthorized: Superadmin access required');
  END IF;
  
  -- Get active subscriptions
  SELECT COUNT(*) INTO v_active_subs
  FROM public.subscriptions
  WHERE status = 'active';
  
  -- Get new subscriptions in date range
  SELECT COUNT(*) INTO v_new_subs
  FROM public.subscriptions
  WHERE created_at::date BETWEEN p_start_date AND p_end_date;
  
  -- Get churned subscriptions in date range
  SELECT COUNT(*) INTO v_churned_subs
  FROM public.subscriptions
  WHERE status = 'cancelled'
  AND updated_at::date BETWEEN p_start_date AND p_end_date;
  
  -- Calculate churn rate
  IF (v_active_subs + v_churned_subs) > 0 THEN
    v_churn_rate := (v_churned_subs::DECIMAL / (v_active_subs + v_churned_subs)) * 100;
  END IF;
  
  -- Calculate revenue
  SELECT 
    COALESCE(SUM(
      CASE 
        WHEN s.billing_frequency = 'annual' THEN sp.price_annual
        ELSE sp.price_monthly * 12
      END
    ), 0),
    COALESCE(SUM(
      CASE 
        WHEN s.billing_frequency = 'annual' THEN sp.price_annual / 12
        ELSE sp.price_monthly
      END
    ), 0)
  INTO v_total_revenue, v_monthly_revenue
  FROM public.subscriptions s
  JOIN public.subscription_plans sp ON s.plan_id = sp.id
  WHERE s.status = 'active';
  
  -- Build response
  v_analytics := jsonb_build_object(
    'total_revenue', v_total_revenue,
    'monthly_revenue', v_monthly_revenue,
    'active_subscriptions', v_active_subs,
    'new_subscriptions', v_new_subs,
    'churned_subscriptions', v_churned_subs,
    'churn_rate', v_churn_rate
  );
  
  RETURN jsonb_build_array(v_analytics);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_subscription_analytics(start_date timestamp with time zone DEFAULT NULL::timestamp with time zone, end_date timestamp with time zone DEFAULT NULL::timestamp with time zone)
 RETURNS TABLE(total_subscriptions bigint, active_subscriptions bigint, trial_subscriptions bigint, cancelled_subscriptions bigint, expired_subscriptions bigint, monthly_revenue numeric, annual_revenue numeric, total_revenue numeric, avg_revenue_per_school numeric, churn_rate numeric)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    date_start TIMESTAMPTZ;
    date_end TIMESTAMPTZ;
BEGIN
    -- Set default date range to current month
    date_start := COALESCE(start_date, date_trunc('month', NOW()));
    date_end := COALESCE(end_date, NOW());
    
    RETURN QUERY
    WITH subscription_stats AS (
        SELECT 
            COUNT(*) as total_subs,
            COUNT(*) FILTER (WHERE status = 'active') as active_subs,
            COUNT(*) FILTER (WHERE status = 'trial') as trial_subs,
            COUNT(*) FILTER (WHERE status = 'cancelled') as cancelled_subs,
            COUNT(*) FILTER (WHERE status = 'expired') as expired_subs
        FROM subscriptions
        WHERE created_at BETWEEN date_start AND date_end
    ),
    revenue_stats AS (
        SELECT 
            SUM(amount) FILTER (WHERE pt.metadata->>'billing_frequency' = 'monthly') as monthly_rev,
            SUM(amount) FILTER (WHERE pt.metadata->>'billing_frequency' = 'annual') as annual_rev,
            SUM(amount) as total_rev,
            AVG(amount) as avg_rev
        FROM payment_transactions pt
        WHERE pt.status = 'completed'
        AND pt.created_at BETWEEN date_start AND date_end
    ),
    churn_calc AS (
        SELECT 
            CASE 
                WHEN COUNT(*) FILTER (WHERE status = 'active') > 0 
                THEN (COUNT(*) FILTER (WHERE status = 'cancelled')::DECIMAL / 
                      COUNT(*) FILTER (WHERE status = 'active')) * 100
                ELSE 0
            END as churn
        FROM subscriptions
        WHERE created_at BETWEEN date_start AND date_end
    )
    SELECT 
        ss.total_subs,
        ss.active_subs,
        ss.trial_subs,
        ss.cancelled_subs,
        ss.expired_subs,
        COALESCE(rs.monthly_rev, 0),
        COALESCE(rs.annual_rev, 0),
        COALESCE(rs.total_rev, 0),
        COALESCE(rs.avg_rev, 0),
        COALESCE(cc.churn, 0)
    FROM subscription_stats ss
    CROSS JOIN revenue_stats rs
    CROSS JOIN churn_calc cc;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_superadmin_ai_agents()
 RETURNS TABLE(id text, name text, description text, agent_type text, status text, configuration jsonb, last_run_at timestamp with time zone, last_run_status text, success_rate numeric, total_runs integer, last_execution_duration_ms integer)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Check if caller is super admin
    IF NOT EXISTS (
        SELECT 1 FROM public.profiles 
        WHERE id = auth.uid() 
        AND role IN ('super_admin', 'superadmin')
    ) THEN
        RAISE EXCEPTION 'Unauthorized: Super admin access required';
    END IF;
    
    RETURN QUERY
    SELECT 
        a.id,
        a.name,
        a.description,
        a.agent_type,
        a.status,
        a.configuration,
        a.last_run_at,
        a.last_run_status,
        a.success_rate,
        a.total_runs,
        (
            SELECT e.duration_ms 
            FROM superadmin_agent_executions e 
            WHERE e.agent_id = a.id 
            ORDER BY e.started_at DESC 
            LIMIT 1
        ) as last_execution_duration_ms
    FROM public.superadmin_ai_agents a
    ORDER BY 
        CASE a.status 
            WHEN 'running' THEN 1 
            WHEN 'active' THEN 2 
            WHEN 'idle' THEN 3 
            WHEN 'error' THEN 4 
            ELSE 5 
        END,
        a.name;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_superadmin_ai_quotas()
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  result JSON;
  quota_settings JSON[];
  global_config JSON;
  usage_stats JSON;
  school_record RECORD;
  monthly_limit INTEGER;
  current_usage INTEGER;
  plan_type TEXT;
  cost_per_overage DECIMAL;
  is_over_limit BOOLEAN;
  is_suspended BOOLEAN;
  overage_cost DECIMAL;
  total_tokens BIGINT := 0;
  total_cost DECIMAL := 0;
  schools_over_limit INTEGER := 0;
  schools_suspended INTEGER := 0;
  top_schools JSON[];
  school_quota JSON;
  usage_percentage DECIMAL;
BEGIN
  -- Only allow superadmin access (use helper function)
  IF NOT public.is_superadmin_user() THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Super admin access required'
    );
  END IF;

  -- Build default global config
  global_config := json_build_object(
    'free_tier_limit', 1000,
    'basic_tier_limit', 5000,
    'pro_tier_limit', 25000,
    'enterprise_tier_limit', 100000,
    'overage_rate', 0.002,
    'warning_thresholds', ARRAY[75, 90, 95],
    'suspension_threshold', 120,
    'auto_reset_enabled', true,
    'cost_alerts_enabled', true
  );

  -- Get real school data from preschools table
  quota_settings := ARRAY[]::JSON[];
  
  FOR school_record IN
    SELECT 
      p.id,
      p.name,
      COALESCE(sp.name, 'basic') as subscription_plan,
      COALESCE(s.status, 'active') as subscription_status
    FROM public.preschools p
    LEFT JOIN public.subscriptions s ON s.preschool_id = p.id AND s.status = 'active'
    LEFT JOIN public.subscription_plans sp ON sp.id = s.plan_id
    WHERE p.is_active = true
    ORDER BY p.name
    LIMIT 50
  LOOP
    current_usage := 0;
    cost_per_overage := 0.002;
    is_over_limit := false;
    is_suspended := false;
    overage_cost := 0;

    CASE LOWER(school_record.subscription_plan)
      WHEN 'free' THEN 
        plan_type := 'free';
        monthly_limit := 1000;
      WHEN 'starter' THEN
        plan_type := 'basic';
        monthly_limit := 5000;
      WHEN 'professional' THEN
        plan_type := 'pro';
        monthly_limit := 25000;
      WHEN 'enterprise' THEN
        plan_type := 'enterprise';
        monthly_limit := 100000;
      ELSE
        plan_type := 'basic';
        monthly_limit := 5000;
    END CASE;

    -- Get actual AI usage if table exists
    IF EXISTS (
      SELECT 1 FROM information_schema.tables 
      WHERE table_name = 'ai_usage_logs' 
      AND table_schema = 'public'
    ) THEN
      SELECT 
        COALESCE(SUM(COALESCE(input_tokens, 0) + COALESCE(output_tokens, 0)), 0)
      INTO current_usage
      FROM public.ai_usage_logs
      WHERE preschool_id = school_record.id::text
        AND created_at >= date_trunc('month', NOW())
        AND status = 'success';
    END IF;

    is_over_limit := current_usage > monthly_limit;
    is_suspended := school_record.subscription_status != 'active' OR 
                   (current_usage > monthly_limit * 1.5);

    IF is_over_limit THEN
      overage_cost := (current_usage - monthly_limit) * cost_per_overage;
      schools_over_limit := schools_over_limit + 1;
    END IF;

    IF is_suspended THEN
      schools_suspended := schools_suspended + 1;
    END IF;

    total_tokens := total_tokens + current_usage;
    total_cost := total_cost + overage_cost;

    quota_settings := quota_settings || json_build_object(
      'id', school_record.id::text,
      'school_id', school_record.id::text,
      'school_name', school_record.name,
      'plan_type', plan_type,
      'monthly_limit', monthly_limit,
      'current_usage', current_usage,
      'reset_date', (date_trunc('month', NOW()) + interval '1 month')::text,
      'overage_allowed', plan_type != 'free',
      'overage_limit', CASE WHEN plan_type != 'free' THEN monthly_limit * 0.5 ELSE 0 END,
      'cost_per_overage', cost_per_overage,
      'warnings_enabled', true,
      'warning_thresholds', ARRAY[75, 90, 95],
      'is_suspended', is_suspended,
      'last_updated', NOW()::text
    );
  END LOOP;

  top_schools := ARRAY[]::JSON[];
  
  FOR school_quota IN
    SELECT value FROM json_array_elements(COALESCE(to_json(quota_settings), '[]'::json)) 
    ORDER BY (value->>'current_usage')::INTEGER DESC
    LIMIT 5
  LOOP
    usage_percentage := CASE 
      WHEN (school_quota->>'monthly_limit')::DECIMAL > 0 THEN
        (school_quota->>'current_usage')::DECIMAL / (school_quota->>'monthly_limit')::DECIMAL * 100
      ELSE 0 
    END;
    
    top_schools := top_schools || json_build_object(
      'school_name', school_quota->>'school_name',
      'usage', (school_quota->>'current_usage')::INTEGER,
      'cost', CASE 
        WHEN (school_quota->>'current_usage')::INTEGER > (school_quota->>'monthly_limit')::INTEGER
        THEN ((school_quota->>'current_usage')::INTEGER - (school_quota->>'monthly_limit')::INTEGER) * (school_quota->>'cost_per_overage')::DECIMAL
        ELSE 0
      END,
      'percentage', usage_percentage
    );
  END LOOP;

  usage_stats := json_build_object(
    'total_tokens_used', total_tokens,
    'total_cost', ROUND(total_cost, 2),
    'average_cost_per_school', CASE 
      WHEN array_length(quota_settings, 1) > 0 
      THEN ROUND(total_cost / array_length(quota_settings, 1), 2)
      ELSE 0 
    END,
    'schools_over_limit', schools_over_limit,
    'schools_suspended', schools_suspended,
    'projected_monthly_cost', ROUND(total_cost * 2, 2),
    'top_consuming_schools', top_schools
  );

  result := json_build_object(
    'success', true,
    'data', json_build_object(
      'school_quotas', quota_settings,
      'global_config', global_config,
      'usage_stats', usage_stats,
      'calculated_at', NOW()
    )
  );

  RETURN result;

EXCEPTION WHEN OTHERS THEN
  RETURN json_build_object(
    'success', false,
    'error', 'Failed to fetch AI quota data',
    'debug_info', CASE 
      WHEN current_setting('app.environment', true) = 'development' 
      THEN SQLERRM 
      ELSE null 
    END
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_superadmin_ai_usage_cost(days_back integer DEFAULT 30)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  result JSON;
  total_cost DECIMAL := 0.00;
  monthly_cost DECIMAL := 0.00;
  daily_average DECIMAL := 0.00;
  total_tokens BIGINT := 0;
  total_requests INTEGER := 0;
  success_rate DECIMAL := 0.00;
  cost_by_service JSON;
  recent_usage JSON;
BEGIN
  -- Only allow superadmin access
  IF NOT EXISTS (
    SELECT 1 FROM public.users u 
    WHERE u.auth_user_id = auth.uid() 
    AND u.role = 'super_admin'
  ) THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Super admin access required'
    );
  END IF;

  -- Check if ai_usage_logs table exists
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.tables 
    WHERE table_name = 'ai_usage_logs' 
    AND table_schema = 'public'
  ) THEN
    -- Return mock data structure if table doesn't exist yet
    RETURN json_build_object(
      'success', true,
      'data', json_build_object(
        'total_cost', 0.00,
        'monthly_cost', 0.00,
        'daily_average', 0.00,
        'total_tokens', 0,
        'total_requests', 0,
        'success_rate', 1.00,
        'cost_by_service', json_build_object(),
        'recent_usage', json_build_array(),
        'note', 'AI usage tracking not yet implemented'
      )
    );
  END IF;

  -- Calculate total cost in the specified period
  SELECT 
    COALESCE(SUM(total_cost), 0.00),
    COUNT(*),
    COALESCE(SUM(input_tokens + output_tokens), 0)
  INTO total_cost, total_requests, total_tokens
  FROM public.ai_usage_logs
  WHERE created_at >= NOW() - (days_back || ' days')::INTERVAL
    AND total_cost IS NOT NULL;

  -- Calculate monthly cost (last 30 days)
  SELECT COALESCE(SUM(total_cost), 0.00)
  INTO monthly_cost
  FROM public.ai_usage_logs
  WHERE created_at >= NOW() - '30 days'::INTERVAL
    AND total_cost IS NOT NULL;

  -- Calculate daily average
  IF days_back > 0 THEN
    daily_average := total_cost / days_back;
  END IF;

  -- Calculate success rate
  SELECT 
    CASE 
      WHEN COUNT(*) > 0 THEN 
        ROUND(COUNT(CASE WHEN status = 'success' THEN 1 END)::DECIMAL / COUNT(*), 4)
      ELSE 1.00 
    END
  INTO success_rate
  FROM public.ai_usage_logs
  WHERE created_at >= NOW() - (days_back || ' days')::INTERVAL;

  -- Get cost breakdown by service
  SELECT json_object_agg(service_type, service_cost)
  INTO cost_by_service
  FROM (
    SELECT 
      service_type,
      COALESCE(SUM(total_cost), 0.00) as service_cost
    FROM public.ai_usage_logs
    WHERE created_at >= NOW() - (days_back || ' days')::INTERVAL
      AND total_cost IS NOT NULL
    GROUP BY service_type
    ORDER BY service_cost DESC
  ) service_costs;

  -- Get recent usage trend (daily costs for last 7 days)
  SELECT json_agg(
    json_build_object(
      'date', usage_date,
      'cost', daily_cost,
      'requests', daily_requests
    )
    ORDER BY usage_date DESC
  )
  INTO recent_usage
  FROM (
    SELECT 
      DATE(created_at) as usage_date,
      COALESCE(SUM(total_cost), 0.00) as daily_cost,
      COUNT(*) as daily_requests
    FROM public.ai_usage_logs
    WHERE created_at >= NOW() - '7 days'::INTERVAL
    GROUP BY DATE(created_at)
    ORDER BY usage_date DESC
    LIMIT 7
  ) daily_usage;

  -- Build result
  result := json_build_object(
    'success', true,
    'data', json_build_object(
      'total_cost', ROUND(total_cost, 2),
      'monthly_cost', ROUND(monthly_cost, 2),
      'daily_average', ROUND(daily_average, 2),
      'total_tokens', total_tokens,
      'total_requests', total_requests,
      'success_rate', success_rate,
      'cost_by_service', COALESCE(cost_by_service, json_build_object()),
      'recent_usage', COALESCE(recent_usage, json_build_array()),
      'period_days', days_back,
      'calculated_at', NOW()
    )
  );

  RETURN result;

EXCEPTION WHEN OTHERS THEN
  -- Return error but don't expose internal details
  RETURN json_build_object(
    'success', false,
    'error', 'Failed to calculate AI usage costs',
    'debug_info', CASE 
      WHEN current_setting('app.environment', true) = 'development' 
      THEN SQLERRM 
      ELSE null 
    END
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_superadmin_autonomous_tasks()
 RETURNS TABLE(id text, name text, description text, task_type text, schedule_cron text, is_enabled boolean, last_execution_at timestamp with time zone, next_execution_at timestamp with time zone, last_execution_status text, configuration jsonb)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM public.profiles 
        WHERE id = auth.uid() 
        AND role IN ('super_admin', 'superadmin')
    ) THEN
        RAISE EXCEPTION 'Unauthorized: Super admin access required';
    END IF;
    
    RETURN QUERY
    SELECT 
        t.id,
        t.name,
        t.description,
        t.task_type,
        t.schedule_cron,
        t.is_enabled,
        t.last_execution_at,
        t.next_execution_at,
        t.last_execution_status,
        t.configuration
    FROM public.superadmin_autonomous_tasks t
    ORDER BY t.is_enabled DESC, t.name;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_superadmin_dashboard_data()
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  result JSON;
  user_stats JSON;
BEGIN
  -- Check if current user is superadmin
  IF NOT is_superadmin() THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Access denied: Superadmin privileges required'
    );
  END IF;

  -- Get user statistics
  SELECT json_build_object(
    'total_users', COUNT(*),
    'active_users', COUNT(*) FILTER (WHERE is_active = true),
    'inactive_users', COUNT(*) FILTER (WHERE is_active = false),
    'superadmins', COUNT(*) FILTER (WHERE role = 'super_admin' AND is_active = true),
    'principals', COUNT(*) FILTER (WHERE role IN ('principal', 'principal_admin') AND is_active = true),
    'teachers', COUNT(*) FILTER (WHERE role = 'teacher' AND is_active = true),
    'parents', COUNT(*) FILTER (WHERE role = 'parent' AND is_active = true)
  ) INTO user_stats
  FROM public.users;

  -- Build result
  result := json_build_object(
    'success', true,
    'data', json_build_object(
      'user_stats', user_stats,
      'generated_at', NOW()
    )
  );

  RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_superadmin_integrations()
 RETURNS TABLE(id text, name text, integration_type text, is_enabled boolean, configuration jsonb, last_sync_at timestamp with time zone, last_sync_status text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM public.profiles 
        WHERE id = auth.uid() 
        AND role IN ('super_admin', 'superadmin')
    ) THEN
        RAISE EXCEPTION 'Unauthorized: Super admin access required';
    END IF;
    
    RETURN QUERY
    SELECT 
        i.id,
        i.name,
        i.integration_type,
        i.is_enabled,
        i.configuration,
        i.last_sync_at,
        i.last_sync_status
    FROM public.superadmin_integrations i
    ORDER BY i.is_enabled DESC, i.name;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_superadmin_platform_insights(limit_count integer DEFAULT 10)
 RETURNS TABLE(id uuid, insight_type text, priority text, title text, description text, data jsonb, action_label text, action_route text, created_at timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM public.profiles 
        WHERE id = auth.uid() 
        AND role IN ('super_admin', 'superadmin')
    ) THEN
        RAISE EXCEPTION 'Unauthorized: Super admin access required';
    END IF;
    
    RETURN QUERY
    SELECT 
        i.id,
        i.insight_type,
        i.priority,
        i.title,
        i.description,
        i.data,
        i.action_label,
        i.action_route,
        i.created_at
    FROM public.superadmin_platform_insights i
    WHERE i.is_dismissed = false
      AND (i.expires_at IS NULL OR i.expires_at > now())
    ORDER BY 
        CASE i.priority 
            WHEN 'critical' THEN 1 
            WHEN 'high' THEN 2 
            WHEN 'medium' THEN 3 
            ELSE 4 
        END,
        i.created_at DESC
    LIMIT limit_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_superadmin_platform_stats()
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  result JSON;
BEGIN
  -- Only allow superadmin access
  IF NOT public.is_superadmin_user() THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Super admin access required'
    );
  END IF;

  -- Get real platform stats
  SELECT json_build_object(
    'success', true,
    'data', json_build_object(
      'total_preschools', (SELECT COUNT(*) FROM public.preschools WHERE is_active = true),
      'total_k12_schools', (SELECT COUNT(*) FROM public.k12_schools WHERE is_active = true),
      'total_users', (SELECT COUNT(*) FROM public.users WHERE is_active = true),
      'active_subscriptions', (SELECT COUNT(*) FROM public.subscriptions WHERE status = 'active'),
      'monthly_revenue', (
        SELECT COALESCE(SUM(sp.price_monthly), 0)
        FROM public.subscriptions s
        JOIN public.subscription_plans sp ON sp.id = s.plan_id
        WHERE s.status = 'active'
      ),
      'total_seats', (SELECT COALESCE(SUM(current_seats), 0) FROM public.subscriptions WHERE status = 'active'),
      'ai_usage_30d', 0,
      'calculated_at', NOW()
    )
  ) INTO result;

  RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_superadmin_users()
 RETURNS TABLE(id uuid, auth_user_id uuid, email text, name text, role text, is_active boolean, updated_at timestamp with time zone, created_at timestamp with time zone)
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
  SELECT 
    u.id,
    u.auth_user_id,
    u.email,
    COALESCE(u.name, u.first_name || ' ' || u.last_name, u.email) as name,
    u.role::text,
    u.is_active,
    u.updated_at,
    u.created_at
  FROM public.users u
  WHERE u.role = 'super_admin'
  ORDER BY u.created_at DESC;
$function$
;

CREATE OR REPLACE FUNCTION public.get_system_health_metrics()
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  result JSON;
  db_connections INTEGER := 0;
  db_max_connections INTEGER := 100;
  storage_size_bytes BIGINT := 0;
  total_users INTEGER := 0;
  active_users INTEGER := 0;
  recent_errors INTEGER := 0;
  rls_errors INTEGER := 0;
  api_errors INTEGER := 0;
  overall_status TEXT := 'healthy';
  issues TEXT[] := ARRAY[]::TEXT[];
BEGIN
  -- Check if current user is superadmin
  IF NOT is_superadmin_safe() THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Access denied: Superadmin privileges required'
    );
  END IF;

  -- Get database connection info
  BEGIN
    SELECT COALESCE(setting::integer, 100) 
    INTO db_max_connections
    FROM pg_settings WHERE name = 'max_connections';
    
    SELECT COUNT(*) INTO db_connections
    FROM pg_stat_activity WHERE state = 'active';
  EXCEPTION WHEN OTHERS THEN
    issues := array_append(issues, 'Unable to query connection stats: ' || SQLERRM);
  END;

  -- Get database size
  BEGIN
    SELECT pg_database_size(current_database()) INTO storage_size_bytes;
  EXCEPTION WHEN OTHERS THEN
    storage_size_bytes := 0;
    issues := array_append(issues, 'Unable to query database size');
  END;

  -- Get user statistics from profiles (not users, to avoid RLS issues)
  BEGIN
    SELECT COUNT(*) INTO total_users FROM public.profiles;
    
    SELECT COUNT(*) INTO active_users
    FROM public.profiles 
    WHERE updated_at > NOW() - INTERVAL '7 days';
  EXCEPTION WHEN OTHERS THEN
    issues := array_append(issues, 'Unable to query user stats: ' || SQLERRM);
  END;

  -- Check for recent errors in error_logs table
  BEGIN
    SELECT COUNT(*) INTO recent_errors
    FROM public.error_logs
    WHERE timestamp > NOW() - INTERVAL '24 hours';
  EXCEPTION WHEN undefined_table THEN
    recent_errors := 0; -- Table doesn't exist, that's OK
  WHEN OTHERS THEN
    issues := array_append(issues, 'Unable to query error logs: ' || SQLERRM);
  END;

  -- Check for RLS policy errors by testing key tables
  BEGIN
    -- Test profiles access
    PERFORM COUNT(*) FROM public.profiles WHERE id = auth.uid();
  EXCEPTION WHEN OTHERS THEN
    rls_errors := rls_errors + 1;
    issues := array_append(issues, 'RLS error on profiles: ' || SQLERRM);
  END;

  BEGIN
    -- Test preschools access
    PERFORM COUNT(*) FROM public.preschools LIMIT 1;
  EXCEPTION WHEN OTHERS THEN
    rls_errors := rls_errors + 1;
    issues := array_append(issues, 'RLS error on preschools: ' || SQLERRM);
  END;

  BEGIN
    -- Test subscriptions access
    PERFORM COUNT(*) FROM public.subscriptions LIMIT 1;
  EXCEPTION WHEN OTHERS THEN
    rls_errors := rls_errors + 1;
    issues := array_append(issues, 'RLS error on subscriptions: ' || SQLERRM);
  END;

  BEGIN
    -- Test announcements access
    PERFORM COUNT(*) FROM public.announcements LIMIT 1;
  EXCEPTION WHEN undefined_table THEN
    NULL; -- Table doesn't exist, that's OK
  WHEN OTHERS THEN
    rls_errors := rls_errors + 1;
    issues := array_append(issues, 'RLS error on announcements: ' || SQLERRM);
  END;

  -- Determine overall status based on findings
  IF rls_errors > 0 THEN
    overall_status := 'critical';
    issues := array_append(issues, format('%s RLS policy errors detected', rls_errors));
  ELSIF db_connections >= db_max_connections * 0.95 THEN
    overall_status := 'critical';
    issues := array_append(issues, 'Database connections at critical level');
  ELSIF recent_errors > 100 THEN
    overall_status := 'critical';
    issues := array_append(issues, format('%s errors in last 24 hours', recent_errors));
  ELSIF db_connections >= db_max_connections * 0.8 THEN
    overall_status := 'degraded';
    issues := array_append(issues, 'Database connections elevated');
  ELSIF recent_errors > 20 THEN
    overall_status := 'degraded';
    issues := array_append(issues, format('%s errors in last 24 hours', recent_errors));
  ELSIF array_length(issues, 1) > 0 THEN
    overall_status := 'warning';
  END IF;

  -- Build comprehensive result
  result := json_build_object(
    'success', true,
    'data', json_build_object(
      'overall_status', overall_status,
      'database_status', CASE 
        WHEN db_connections < db_max_connections * 0.8 THEN 'healthy'
        WHEN db_connections < db_max_connections * 0.95 THEN 'degraded'
        ELSE 'critical'
      END,
      'database_connections', db_connections,
      'database_max_connections', db_max_connections,
      'connection_usage_percent', ROUND((db_connections::numeric / GREATEST(db_max_connections, 1) * 100)::numeric, 1),
      'storage_used_bytes', storage_size_bytes,
      'storage_used_gb', ROUND((COALESCE(storage_size_bytes, 0)::numeric / (1024*1024*1024))::numeric, 2),
      'total_users', total_users,
      'active_users_7d', active_users,
      'recent_errors_24h', recent_errors,
      'rls_errors', rls_errors,
      'rls_status', CASE WHEN rls_errors = 0 THEN 'healthy' ELSE 'error' END,
      'issues', issues,
      'issues_count', COALESCE(array_length(issues, 1), 0),
      'uptime_seconds', EXTRACT(EPOCH FROM (NOW() - pg_postmaster_start_time())),
      'last_check', NOW()
    ),
    'generated_at', NOW()
  );

  RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_system_performance_metrics()
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  result JSON;
  total_queries BIGINT;
  slow_queries BIGINT;
  cache_hit_ratio NUMERIC;
  database_size_mb NUMERIC;
BEGIN
  -- Check if current user is superadmin
  IF NOT is_superadmin() THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Access denied: Superadmin privileges required'
    );
  END IF;

  -- Get database size first
  SELECT (pg_database_size(current_database())::numeric / (1024^2)) INTO database_size_mb;

  -- Get query statistics from pg_stat_database
  SELECT 
    COALESCE(SUM(numbackends), 0),
    COALESCE(SUM(xact_commit + xact_rollback), 0)
  INTO total_queries, total_queries
  FROM pg_stat_database 
  WHERE datname = current_database();

  -- Calculate cache hit ratio with safe type casting
  SELECT 
    CASE 
      WHEN SUM(blks_hit) + SUM(blks_read) > 0 THEN
        (100.0 * SUM(blks_hit) / (SUM(blks_hit) + SUM(blks_read)))::numeric
      ELSE 95.0::numeric
    END
  INTO cache_hit_ratio
  FROM pg_stat_database 
  WHERE datname = current_database();

  -- Set slow queries to 0 for now (pg_stat_statements might not be available)
  slow_queries := 0;

  result := json_build_object(
    'success', true,
    'data', json_build_object(
      'total_connections', total_queries,
      'cache_hit_ratio', ROUND(COALESCE(cache_hit_ratio, 95.0), 2),
      'slow_queries_24h', COALESCE(slow_queries, 0),
      'database_size_mb', ROUND(database_size_mb, 2),
      'active_connections', (SELECT COUNT(*) FROM pg_stat_activity WHERE state = 'active'),
      'idle_connections', (SELECT COUNT(*) FROM pg_stat_activity WHERE state = 'idle')
    ),
    'generated_at', NOW()
  );

  RETURN result;
EXCEPTION
  WHEN OTHERS THEN
    -- Return safe defaults if statistics tables don't exist
    RETURN json_build_object(
      'success', true,
      'data', json_build_object(
        'total_connections', 0,
        'cache_hit_ratio', 95.0,
        'slow_queries_24h', 0,
        'database_size_mb', ROUND((pg_database_size(current_database())::numeric / (1024^2))::numeric, 2),
        'active_connections', (SELECT COUNT(*) FROM pg_stat_activity WHERE state = 'active'),
        'idle_connections', (SELECT COUNT(*) FROM pg_stat_activity WHERE state = 'idle')
      ),
      'generated_at', NOW()
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_textbook_content(p_textbook_id uuid, p_page_start integer, p_page_end integer)
 RETURNS TABLE(page_number integer, content_text text, has_exercises boolean, chapter_title text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT
    p.page_number,
    p.content_text,
    p.has_exercises,
    c.title AS chapter_title
  FROM public.textbook_pages p
  LEFT JOIN public.textbook_chapters c ON p.chapter_id = c.id
  WHERE
    p.textbook_id = p_textbook_id
    AND p.page_number BETWEEN p_page_start AND p_page_end
  ORDER BY p.page_number;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_textbook_metadata(p_textbook_id uuid)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_id UUID;
  v_textbook JSON;
BEGIN
  -- Verify authentication
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Unauthorized: Authentication required';
  END IF;

  -- Get textbook (no RLS check needed as textbooks are public educational resources)
  SELECT row_to_json(t.*)
  INTO v_textbook
  FROM textbooks t
  WHERE t.id = p_textbook_id;

  IF v_textbook IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Textbook not found'
    );
  END IF;

  RETURN json_build_object(
    'success', true,
    'data', v_textbook
  );

EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object(
      'success', false,
      'error', SQLERRM
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_textbook_pages_for_topic(p_caps_topic_id uuid, p_grade character varying DEFAULT NULL::character varying, p_subject character varying DEFAULT NULL::character varying)
 RETURNS TABLE(textbook_title character varying, textbook_publisher character varying, chapter_title character varying, page_start integer, page_end integer, key_pages integer[], alignment_score integer)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    t.title,
    t.publisher,
    tc.title,
    tc.page_start,
    tc.page_end,
    ctm.key_pages,
    ctm.alignment_score
  FROM caps_textbook_mapping ctm
  JOIN textbook_content tc ON ctm.textbook_content_id = tc.id
  JOIN textbooks t ON tc.textbook_id = t.id
  WHERE ctm.caps_topic_id = p_caps_topic_id
    AND (p_grade IS NULL OR t.grade = p_grade)
    AND (p_subject IS NULL OR t.subject = p_subject)
    AND ctm.status IN ('verified', 'approved')
    AND t.is_active = true
  ORDER BY ctm.alignment_score DESC, t.publication_year DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_total_unread_counts()
 RETURNS TABLE(dm_unread integer, room_unread integer, total integer)
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_user_id uuid;
begin
  select id into v_user_id from public.users where auth_user_id = auth.uid();
  if v_user_id is null then
    return query select 0, 0, 0;
    return;
  end if;

  -- Direct/unicast messages unread via message_recipients
  select count(*) into dm_unread
  from public.message_recipients mr
  join public.messages m on m.id = mr.message_id
  where mr.recipient_id = v_user_id
    and coalesce(mr.is_read, false) = false
    and coalesce(mr.is_archived, false) = false;

  -- Room unread: messages after max(last_read_at, cleared_at), excluding own messages
  select coalesce(sum(cnt), 0) into room_unread
  from (
    select cm.conversation_id, count(*)::int as cnt
    from public.conversation_members cm
    join public.messages m on m.conversation_id = cm.conversation_id
    where cm.user_id = v_user_id
      and (greatest(coalesce(cm.last_read_at, timestamp 'epoch'), coalesce(cm.cleared_at, timestamp 'epoch')) is null
           or m.created_at > greatest(coalesce(cm.last_read_at, timestamp 'epoch'), coalesce(cm.cleared_at, timestamp 'epoch')))
      and m.sender_id <> v_user_id
    group by cm.conversation_id
  ) s;

  return query select coalesce(dm_unread,0), coalesce(room_unread,0), coalesce(dm_unread,0) + coalesce(room_unread,0);
end;
$function$
;

CREATE OR REPLACE FUNCTION public.get_trial_days_remaining(p_school_id uuid)
 RETURNS integer
 LANGUAGE sql
 STABLE
AS $function$
  SELECT 
    GREATEST(0, EXTRACT(DAY FROM (trial_end_date - NOW()))::INTEGER)
  FROM public.subscriptions
  WHERE school_id = p_school_id
  AND status = 'trialing'
  AND trial_end_date > NOW()
  LIMIT 1;
$function$
;

CREATE OR REPLACE FUNCTION public.get_trial_duration_days()
 RETURNS integer
 LANGUAGE sql
 STABLE
AS $function$
  SELECT (value->>'duration_days')::INTEGER 
  FROM public.system_config 
  WHERE key = 'trial_settings';
$function$
;

CREATE OR REPLACE FUNCTION public.get_unread_announcements_count(p_user_id uuid)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_count INTEGER;
BEGIN
  -- Count unread announcements for the user
  SELECT COUNT(DISTINCT m.id)
  INTO v_count
  FROM messages m
  INNER JOIN message_recipients mr ON m.id = mr.message_id
  WHERE mr.recipient_id = p_user_id
    AND mr.is_read = false
    AND m.message_type = 'announcement'
    AND m.deleted_at IS NULL;
  
  RETURN COALESCE(v_count, 0);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_unread_counts(p_user_id uuid)
 RETURNS TABLE(unread_messages integer, unread_announcements integer, total_unread integer)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    (SELECT COUNT(DISTINCT m.id)
     FROM messages m
     INNER JOIN message_recipients mr ON m.id = mr.message_id
     WHERE mr.recipient_id = p_user_id
       AND mr.is_read = false
       AND m.message_type != 'announcement'
       AND m.deleted_at IS NULL) AS unread_messages,
    (SELECT COUNT(DISTINCT m.id)
     FROM messages m
     INNER JOIN message_recipients mr ON m.id = mr.message_id
     WHERE mr.recipient_id = p_user_id
       AND mr.is_read = false
       AND m.message_type = 'announcement'
       AND m.deleted_at IS NULL) AS unread_announcements,
    (SELECT COUNT(DISTINCT m.id)
     FROM messages m
     INNER JOIN message_recipients mr ON m.id = mr.message_id
     WHERE mr.recipient_id = p_user_id
       AND mr.is_read = false
       AND m.deleted_at IS NULL) AS total_unread;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_unread_org_announcements_count(p_user_id uuid)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_count INTEGER;
BEGIN
  SELECT COUNT(*)::INTEGER INTO v_count
  FROM organization_announcements oa
  WHERE oa.is_published = TRUE
    AND (oa.expires_at IS NULL OR oa.expires_at > now())
    AND NOT (p_user_id = ANY(oa.read_by))
    AND EXISTS (
      SELECT 1 FROM organization_members om
      WHERE om.user_id = p_user_id
      AND om.organization_id = oa.organization_id
      AND om.status = 'active'
    );
  
  RETURN COALESCE(v_count, 0);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_ai_tier(p_user_id uuid)
 RETURNS public.ai_model_tier
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
DECLARE
    user_tier ai_model_tier;
BEGIN
    SELECT tier INTO user_tier
    FROM user_ai_tiers 
    WHERE user_id = p_user_id 
    AND is_active = true 
    AND (expires_at IS NULL OR expires_at > now())
    LIMIT 1;
    
    -- Default to free tier if no assignment found
    RETURN COALESCE(user_tier, 'free'::ai_model_tier);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_ai_usage_stats(p_user_id uuid DEFAULT auth.uid(), p_period_days integer DEFAULT 30)
 RETURNS TABLE(service_type text, total_requests bigint, total_tokens bigint, total_cost numeric, avg_tokens_per_request numeric)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        logs.service_type,
        COUNT(*) as total_requests,
        COALESCE(SUM(logs.input_tokens + logs.output_tokens), 0) as total_tokens,
        COALESCE(SUM(logs.total_cost), 0) as total_cost,
        CASE 
            WHEN COUNT(*) > 0 THEN COALESCE(SUM(logs.input_tokens + logs.output_tokens), 0)::DECIMAL / COUNT(*)
            ELSE 0
        END as avg_tokens_per_request
    FROM public.ai_usage_logs logs
    WHERE logs.user_id = p_user_id
        AND logs.created_at >= (now() - (p_period_days || ' days')::interval)
        AND logs.status = 'success'
    GROUP BY logs.service_type
    ORDER BY total_requests DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_group_role(p_user_id uuid, p_group_id uuid)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN (
    SELECT role_in_group
    FROM public.group_members
    WHERE user_id = p_user_id
    AND group_id = p_group_id
    AND status = 'active'
    LIMIT 1
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_groups(p_user_id uuid)
 RETURNS TABLE(group_id uuid, group_name character varying, role_in_group character varying, group_type character varying, member_count bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        pg.id,
        pg.name,
        gm.role_in_group,
        pg.group_type,
        (
            SELECT COUNT(*) 
            FROM public.group_members gm2 
            WHERE gm2.group_id = pg.id AND gm2.status = 'active'
        )
    FROM public.principal_groups pg
    JOIN public.group_members gm ON pg.id = gm.group_id
    WHERE gm.user_id = p_user_id 
    AND gm.status = 'active'
    AND pg.is_active = true
    ORDER BY pg.name;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_messages(p_limit integer DEFAULT 50, p_offset integer DEFAULT 0)
 RETURNS TABLE(message_id uuid, subject text, content text, sender_name text, sender_email text, recipient_name text, recipient_email text, sent_at timestamp with time zone, read_at timestamp with time zone, is_sent boolean)
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
DECLARE
  v_user_id uuid;
BEGIN
  -- Get current user ID
  SELECT id INTO v_user_id
  FROM public.users
  WHERE auth_user_id = auth.uid();
  
  IF v_user_id IS NULL THEN
    RETURN;
  END IF;
  
  RETURN QUERY
  (
    -- Messages sent by user
    SELECT 
      m.id as message_id,
      m.subject,
      m.content,
      sender_u.name as sender_name,
      sender_u.email as sender_email,
      recipient_u.name as recipient_name,
      recipient_u.email as recipient_email,
      m.sent_at,
      mr.read_at,
      true as is_sent
    FROM public.messages m
    JOIN public.users sender_u ON sender_u.id = m.sender_id
    JOIN public.message_recipients mr ON mr.message_id = m.id
    JOIN public.users recipient_u ON recipient_u.id = mr.recipient_id
    WHERE m.sender_id = v_user_id
    
    UNION ALL
    
    -- Messages received by user
    SELECT 
      m.id as message_id,
      m.subject,
      m.content,
      sender_u.name as sender_name,
      sender_u.email as sender_email,
      recipient_u.name as recipient_name,
      recipient_u.email as recipient_email,
      m.sent_at,
      mr.read_at,
      false as is_sent
    FROM public.messages m
    JOIN public.users sender_u ON sender_u.id = m.sender_id
    JOIN public.message_recipients mr ON mr.message_id = m.id
    JOIN public.users recipient_u ON recipient_u.id = mr.recipient_id
    WHERE mr.recipient_id = v_user_id
  )
  ORDER BY sent_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_profile_by_auth_id(p_auth_user_id uuid)
 RETURNS TABLE(id uuid, email text, name text, role text, preschool_id uuid, auth_user_id uuid, is_active boolean, avatar_url text, phone text, home_address text, home_city text, home_postal_code text, work_company text, work_position text, work_address text, work_phone text, emergency_contact_1_name text, emergency_contact_1_phone text, emergency_contact_1_relationship text, emergency_contact_2_name text, emergency_contact_2_phone text, emergency_contact_2_relationship text, relationship_to_child text, pickup_authorized text, profile_completed_at timestamp with time zone, profile_completion_status text, created_at timestamp with time zone, updated_at timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    u.id,
    u.email,
    u.name,
    u.role,
    u.preschool_id,
    u.auth_user_id,
    u.is_active,
    u.avatar_url,
    u.phone,
    u.home_address,
    u.home_city,
    u.home_postal_code,
    u.work_company,
    u.work_position,
    u.work_address,
    u.work_phone,
    u.emergency_contact_1_name,
    u.emergency_contact_1_phone,
    u.emergency_contact_1_relationship,
    u.emergency_contact_2_name,
    u.emergency_contact_2_phone,
    u.emergency_contact_2_relationship,
    u.relationship_to_child,
    u.pickup_authorized,
    u.profile_completed_at,
    u.profile_completion_status,
    u.created_at,
    u.updated_at
  FROM users u
  WHERE u.auth_user_id = p_auth_user_id
  AND u.is_active = true;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_storage_stats(p_user_id uuid)
 RETURNS TABLE(image_count bigint, total_size_bytes bigint, total_size_mb numeric)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    COUNT(*)::BIGINT as image_count,
    COALESCE(SUM(size_bytes), 0)::BIGINT as total_size_bytes,
    ROUND(COALESCE(SUM(size_bytes), 0) / 1024.0 / 1024.0, 2) as total_size_mb
  FROM chat_images
  WHERE uploaded_by = p_user_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_subscription_info(user_id uuid)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    result json;
    standalone_record standalone_users%ROWTYPE;
BEGIN
    SELECT * INTO standalone_record
    FROM standalone_users
    WHERE standalone_users.user_id = $1;
    
    IF FOUND THEN
        SELECT json_build_object(
            'is_standalone', true,
            'subscription_tier', standalone_record.subscription_tier,
            'is_trial', standalone_record.is_trial,
            'trial_end_date', standalone_record.trial_end_date,
            'subscription_status', standalone_record.subscription_status,
            'user_type', standalone_record.user_type,
            'usage_type', standalone_record.usage_type
        ) INTO result;
    ELSE
        SELECT json_build_object(
            'is_standalone', false,
            'message', 'User is part of an organization'
        ) INTO result;
    END IF;
    
    RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_subscription_tier(user_id uuid)
 RETURNS text
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
DECLARE
  tier_value TEXT;
  org_id UUID;
BEGIN
  -- Priority order for tier lookup:
  -- 1. user_ai_usage.current_tier (user-level override)
  -- 2. user_ai_tiers.tier (user-specific tier)
  -- 3. organization.subscription_tier (organization tier)
  -- 4. Default to 'free'
  
  -- Check user_ai_usage first (highest priority - user override)
  SELECT current_tier INTO tier_value
  FROM user_ai_usage
  WHERE user_id = get_user_subscription_tier.user_id
  AND current_tier IS NOT NULL
  LIMIT 1;
  
  IF tier_value IS NOT NULL THEN
    RETURN tier_value;
  END IF;
  
  -- Check user_ai_tiers (user-specific tier)
  SELECT tier INTO tier_value
  FROM user_ai_tiers
  WHERE user_id = get_user_subscription_tier.user_id
  AND tier IS NOT NULL
  LIMIT 1;
  
  IF tier_value IS NOT NULL THEN
    RETURN tier_value;
  END IF;
  
  -- Get user's organization
  SELECT get_user_organization_id(get_user_subscription_tier.user_id) INTO org_id;
  
  IF org_id IS NOT NULL THEN
    -- Check organization subscription_tier
    SELECT subscription_tier INTO tier_value
    FROM organizations
    WHERE id = org_id
    AND subscription_tier IS NOT NULL;
    
    IF tier_value IS NOT NULL THEN
      RETURN tier_value;
    END IF;
    
    -- Fallback to plan_tier if it exists
    SELECT plan_tier INTO tier_value
    FROM organizations
    WHERE id = org_id
    AND plan_tier IS NOT NULL;
    
    IF tier_value IS NOT NULL THEN
      RETURN tier_value;
    END IF;
    
    -- Check preschools table for backward compatibility
    SELECT subscription_tier INTO tier_value
    FROM preschools
    WHERE id = org_id::TEXT
    AND subscription_tier IS NOT NULL;
    
    IF tier_value IS NOT NULL THEN
      RETURN tier_value;
    END IF;
  END IF;
  
  -- Default to free tier
  RETURN 'free';
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_tier(p_user_id uuid)
 RETURNS text
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
DECLARE
  v_tier text;
  v_org_id uuid;
BEGIN
  -- Get user's organization
  SELECT preschool_id INTO v_org_id
  FROM users
  WHERE id = p_user_id OR auth_user_id = p_user_id
  LIMIT 1;
  
  IF v_org_id IS NULL THEN
    RETURN 'free';
  END IF;
  
  -- Try organizations table first (new RBAC system)
  SELECT plan_tier INTO v_tier
  FROM organizations
  WHERE id = v_org_id;
  
  -- Fallback to preschools table (legacy)
  IF v_tier IS NULL THEN
    SELECT subscription_tier INTO v_tier
    FROM preschools
    WHERE id = v_org_id;
  END IF;
  
  -- Fallback to active subscription
  IF v_tier IS NULL THEN
    SELECT sp.tier INTO v_tier
    FROM subscriptions s
    JOIN subscription_plans sp ON s.plan_id = sp.id
    WHERE s.school_id = v_org_id
      AND s.status = 'active'
    ORDER BY s.end_date DESC
    LIMIT 1;
  END IF;
  
  -- Default to free
  RETURN COALESCE(v_tier, 'free');
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_valid_oauth_token(p_user_id uuid, p_provider text)
 RETURNS TABLE(access_token text, expires_at timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT ot.access_token, ot.expires_at
  FROM oauth_tokens ot
  WHERE ot.user_id = p_user_id
    AND ot.provider = p_provider
    AND ot.expires_at > NOW() + INTERVAL '5 minutes'
  LIMIT 1;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_viewable_parent_ids_for_principal()
 RETURNS SETOF uuid
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  -- Get parent IDs using the users table (via our safe function) instead of profiles
  SELECT DISTINCT parent_id
  FROM public.students
  WHERE preschool_id = (SELECT user_preschool_id FROM get_my_user_context())
    AND (SELECT user_role FROM get_my_user_context()) IN ('principal', 'principal_admin', 'admin')
    AND parent_id IS NOT NULL
  
  UNION
  
  SELECT DISTINCT guardian_id
  FROM public.students
  WHERE preschool_id = (SELECT user_preschool_id FROM get_my_user_context())
    AND (SELECT user_role FROM get_my_user_context()) IN ('principal', 'principal_admin', 'admin')
    AND guardian_id IS NOT NULL;
$function$
;

CREATE OR REPLACE FUNCTION public.get_voice_note_signed_url(file_path text, expires_in integer DEFAULT 3600)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  signed_url TEXT;
  user_id_in_path TEXT;
BEGIN
  -- Extract user ID from path (supports platform/user_id/file and user_id/file)
  user_id_in_path := COALESCE((storage.foldername(file_path))[2], (storage.foldername(file_path))[1]);

  IF NOT user_id_in_path = auth.uid()::text THEN
    RAISE EXCEPTION 'Access denied: can only access own voice notes';
  END IF;

  SELECT storage.get_signed_url('voice-notes', file_path, expires_in) INTO signed_url;
  RETURN signed_url;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_auth_signup_bulletproof()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
    profile_exists boolean := false;
BEGIN
    -- Always return NEW first to ensure auth user creation succeeds
    -- Profile creation is secondary and should never block auth
    
    BEGIN
        -- Check if profile already exists
        SELECT EXISTS(
            SELECT 1 FROM public.user_profiles 
            WHERE auth_user_id = NEW.id
        ) INTO profile_exists;
        
        -- Only create if profile doesn't exist
        IF NOT profile_exists THEN
            INSERT INTO public.user_profiles (
                auth_user_id,
                email,
                full_name,
                created_at,
                updated_at
            ) VALUES (
                NEW.id,
                NEW.email,
                COALESCE(
                    NEW.raw_user_meta_data->>'full_name',
                    NEW.raw_user_meta_data->>'name',
                    split_part(NEW.email, '@', 1)
                ),
                now(),
                now()
            );
        END IF;
        
    EXCEPTION 
        WHEN OTHERS THEN
            -- Log error but don't raise it - never block auth creation
            -- In production, this would go to logs
            -- For now, we'll just continue silently
            NULL;
    END;
    
    -- Always return NEW to complete the auth user creation
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_auth_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  -- Only create if role is set in metadata (prevents auto-creation)
  if new.raw_user_meta_data->>'role' is not null then
    insert into public.users (
      auth_user_id,
      email,
      name,
      role,
      profile_completion_status
    ) values (
      new.id,
      new.email,
      coalesce(new.raw_user_meta_data->>'name', split_part(new.email, '@', 1)),
      new.raw_user_meta_data->>'role',
      'incomplete'
    );
  end if;
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_parent_join_request_approval()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- If request was just approved, link parent to organization
  IF NEW.status = 'approved' AND OLD.status = 'pending' THEN
    -- Update parent's profile with organization_id
    UPDATE profiles
    SET 
      organization_id = NEW.organization_id,
      preschool_id = COALESCE(NEW.preschool_id, NEW.organization_id), -- Legacy support
      updated_at = NOW()
    WHERE id = NEW.parent_id;
    
    -- Set reviewed timestamp if not set
    NEW.reviewed_at := COALESCE(NEW.reviewed_at, NOW());
    NEW.reviewed_by := COALESCE(NEW.reviewed_by, auth.uid());
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.has_active_seat(org_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT EXISTS (
    SELECT 1
    FROM public.organization_members om
    WHERE om.user_id = auth.uid()
    AND om.organization_id = org_id
    AND om.seat_status = 'active'
  );
$function$
;

CREATE OR REPLACE FUNCTION public.has_premium_access(user_id uuid DEFAULT NULL::uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  target_user_id UUID;
  user_profile RECORD;
  org_subscription RECORD;
BEGIN
  target_user_id := COALESCE(user_id, auth.uid());
  
  SELECT * INTO user_profile FROM profiles WHERE id = target_user_id;
  
  IF NOT FOUND THEN
    RETURN FALSE;
  END IF;
  
  -- Check user-level trial
  IF user_profile.is_trial AND user_profile.trial_end_date > NOW() THEN
    RETURN TRUE;
  END IF;
  
  -- Check organization subscription
  IF user_profile.preschool_id IS NOT NULL THEN
    SELECT * INTO org_subscription
    FROM subscriptions
    WHERE preschool_id = user_profile.preschool_id
    LIMIT 1;
    
    IF FOUND THEN
      IF org_subscription.is_trial AND org_subscription.trial_end_date > NOW() THEN
        RETURN TRUE;
      END IF;
      
      IF org_subscription.plan_tier IN ('premium', 'professional', 'enterprise') THEN
        RETURN TRUE;
      END IF;
    END IF;
  END IF;
  
  RETURN FALSE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.has_role_in_preschool(target_preschool_id uuid, required_roles text[])
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT EXISTS (
    SELECT 1 
    FROM public.users 
    WHERE auth_user_id = auth.uid() 
    AND preschool_id = target_preschool_id 
    AND role = ANY(required_roles)
  );
$function$
;

CREATE OR REPLACE FUNCTION public.has_school_features(user_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM profiles 
    WHERE id = user_id 
    AND preschool_id IS NOT NULL
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.has_tier_access(user_id uuid, required_tier text)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
DECLARE
  user_tier TEXT;
  tier_levels JSONB := '{"free": 0, "starter": 1, "premium": 2, "enterprise": 3}'::JSONB;
  user_level INT;
  required_level INT;
BEGIN
  user_tier := get_user_subscription_tier(user_id);
  
  -- Get numeric levels for comparison
  user_level := COALESCE((tier_levels->>user_tier)::INT, 0);
  required_level := COALESCE((tier_levels->>required_tier)::INT, 0);
  
  RETURN user_level >= required_level;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.has_used_trial(p_email text DEFAULT NULL::text, p_phone text DEFAULT NULL::text, p_device_fingerprint text DEFAULT NULL::text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM trial_usage_log
    WHERE 
      (p_email IS NOT NULL AND email = p_email) OR
      (p_phone IS NOT NULL AND phone = p_phone) OR
      (p_device_fingerprint IS NOT NULL AND device_fingerprint = p_device_fingerprint)
    LIMIT 1
  );
END;
$function$
;

create type "public"."http_header" as ("field" character varying, "value" character varying);

create type "public"."http_request" as ("method" public.http_method, "uri" character varying, "headers" public.http_header[], "content_type" character varying, "content" character varying);

create type "public"."http_response" as ("status" integer, "content_type" character varying, "headers" public.http_header[], "content" character varying);

CREATE OR REPLACE FUNCTION public.increment_activity_play_count(activity_uuid uuid)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  UPDATE interactive_activities
  SET play_count = play_count + 1,
      updated_at = NOW()
  WHERE id = activity_uuid;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.increment_ai_usage(p_user_id uuid, p_request_type character varying, p_status character varying DEFAULT 'success'::character varying, p_metadata jsonb DEFAULT '{}'::jsonb)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- Increment appropriate counter
  IF p_request_type = 'exam_generation' AND p_status = 'success' THEN
    UPDATE user_ai_usage
    SET 
      exams_generated_this_month = exams_generated_this_month + 1,
      total_exams_generated = total_exams_generated + 1,
      updated_at = NOW()
    WHERE user_id = p_user_id;
  ELSIF p_request_type = 'explanation' AND p_status = 'success' THEN
    UPDATE user_ai_usage
    SET 
      explanations_requested_this_month = explanations_requested_this_month + 1,
      total_explanations_requested = total_explanations_requested + 1,
      updated_at = NOW()
    WHERE user_id = p_user_id;
  ELSIF p_request_type = 'chat_message' AND p_status = 'success' THEN
    UPDATE user_ai_usage
    SET 
      chat_messages_today = chat_messages_today + 1,
      total_chat_messages = total_chat_messages + 1,
      updated_at = NOW()
    WHERE user_id = p_user_id;
  END IF;
  
  -- Log the request
  INSERT INTO ai_request_log (user_id, request_type, status, metadata)
  VALUES (p_user_id, p_request_type, p_status, p_metadata);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.increment_announcement_views()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  UPDATE announcements 
  SET view_count = view_count + 1 
  WHERE id = NEW.announcement_id;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.increment_campaign_redemptions(campaign_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  UPDATE marketing_campaigns
  SET current_redemptions = current_redemptions + 1
  WHERE id = campaign_id
  AND current_redemptions < max_redemptions; -- Safety check: don't exceed max
END;
$function$
;

CREATE OR REPLACE FUNCTION public.increment_class_enrollment(class_uuid uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  UPDATE classes
  SET 
    current_students = COALESCE(current_students, 0) + 1,
    updated_at = NOW()
  WHERE id = class_uuid;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.increment_image_references(p_hashes text[])
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  UPDATE chat_images
  SET 
    reference_count = reference_count + 1,
    last_used_at = NOW()
  WHERE hash = ANY(p_hashes);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.increment_invite_code_usage(code_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  UPDATE region_invite_codes
  SET current_uses = COALESCE(current_uses, 0) + 1
  WHERE id = code_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.increment_resource_view(p_resource_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  UPDATE public.resources
  SET view_count = view_count + 1
  WHERE id = p_resource_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.increment_subscription_usage(p_subscription_id uuid, p_usage_type text, p_amount integer DEFAULT 1)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_has_quota boolean;
BEGIN
    -- Check if quota is available
    SELECT public.check_subscription_quota(p_subscription_id, p_usage_type, p_amount)
    INTO v_has_quota;
    
    IF NOT v_has_quota THEN
        RETURN false;
    END IF;
    
    -- Increment usage
    UPDATE public.subscription_usage
    SET 
        current_usage = current_usage + p_amount,
        updated_at = now()
    WHERE subscription_id = p_subscription_id
    AND usage_type = p_usage_type
    AND period_start <= now()
    AND period_end > now();
    
    RETURN true;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.initialize_organization_board_positions(p_organization_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- Insert default positions if they don't exist
  INSERT INTO organization_board_positions (organization_id, position_code, position_title, position_order)
  VALUES
    (p_organization_id, 'president', 'President & Chairperson', 1),
    (p_organization_id, 'vice_chairperson', 'Vice Chairperson', 2),
    (p_organization_id, 'secretary', 'Secretary', 3),
    (p_organization_id, 'treasurer', 'Treasurer', 4),
    (p_organization_id, 'board_member', 'Board Member', 5)
  ON CONFLICT DO NOTHING;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_conversation_admin(p_auth_user_id uuid, p_conversation_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_is_admin boolean := false;
BEGIN
  -- If either param is null, fail closed
  IF p_auth_user_id IS NULL OR p_conversation_id IS NULL THEN
    RETURN false;
  END IF;

  -- Check membership role using users -> conversation_members without triggering recursion
  SELECT EXISTS (
    SELECT 1
    FROM public.conversation_members cm
    JOIN public.users u ON u.id = cm.user_id
    WHERE u.auth_user_id = p_auth_user_id
      AND cm.conversation_id = p_conversation_id
      AND cm.role IN ('owner','admin')
  ) INTO v_is_admin;

  RETURN COALESCE(v_is_admin, false);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_course_enrollment_full(course_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
    SELECT CASE
        WHEN c.max_students IS NULL THEN false
        WHEN c.max_students <= 0 THEN false
        ELSE (
            SELECT COUNT(*) 
            FROM enrollments e 
            WHERE e.course_id = is_course_enrollment_full.course_id 
            AND e.is_active = true
        ) >= c.max_students
    END
    FROM courses c 
    WHERE c.id = is_course_enrollment_full.course_id;
$function$
;

CREATE OR REPLACE FUNCTION public.is_edudashpro_principal(user_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT EXISTS (
    SELECT 1 FROM profiles p
    WHERE p.id = user_id
    AND p.role IN ('principal', 'admin', 'superadmin')
    AND p.organization_id IN ('00000000-0000-0000-0000-000000000001', '00000000-0000-0000-0000-000000000003')
  );
$function$
;

CREATE OR REPLACE FUNCTION public.is_feature_enabled(org_id uuid, feature_name text)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
    select coalesce(
        (features -> feature_name)::boolean,
        false
    )
    from organizations
    where id = org_id;
$function$
;

CREATE OR REPLACE FUNCTION public.is_org_member(org_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT EXISTS (
    SELECT 1
    FROM public.organization_members om
    WHERE om.user_id = auth.uid()
    AND om.organization_id = org_id
  );
$function$
;

CREATE OR REPLACE FUNCTION public.is_organization_admin(target_org uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT public.has_role_in_preschool(target_org, ARRAY['principal', 'principal_admin', 'super_admin']);
$function$
;

CREATE OR REPLACE FUNCTION public.is_phone_opted_out(p_preschool_id uuid, p_phone_number text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM sms_opt_outs
    WHERE preschool_id = p_preschool_id
      AND phone_number = p_phone_number
      AND opted_in_at IS NULL
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_preschool_admin(check_preschool_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT EXISTS (
    SELECT 1 FROM public.profiles
    WHERE id = auth.uid()
    AND (preschool_id = check_preschool_id OR organization_id = check_preschool_id)
    AND role IN ('principal', 'admin', 'principal_admin')
  );
$function$
;

CREATE OR REPLACE FUNCTION public.is_submission_late(assignment_id uuid, submission_time timestamp with time zone DEFAULT now())
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
    SELECT CASE
        WHEN a.due_at IS NULL THEN false
        ELSE submission_time > a.due_at
    END
    FROM assignments a
    WHERE a.id = is_submission_late.assignment_id;
$function$
;

CREATE OR REPLACE FUNCTION public.is_superadmin_by_id(user_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT EXISTS (
    SELECT 1 FROM public.users
    WHERE auth_user_id = user_id
    AND role = 'super_admin'
    AND is_active = true
  );
$function$
;

CREATE OR REPLACE FUNCTION public.is_superadmin_user()
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.users u 
    WHERE u.auth_user_id = auth.uid() 
    AND LOWER(u.role) IN ('super_admin', 'superadmin', 'super-admin', 'admin', 'platform_admin')
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_trial_active(p_school_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE
AS $function$
  SELECT EXISTS (
    SELECT 1
    FROM public.subscriptions
    WHERE school_id = p_school_id
    AND status = 'trialing'
    AND trial_end_date > NOW()
  );
$function$
;

CREATE OR REPLACE FUNCTION public.is_user_blocked(p_user_id uuid, p_block_type character varying DEFAULT 'user'::character varying)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_current_user_id UUID := auth.uid();
  v_is_blocked BOOLEAN := FALSE;
BEGIN
  -- Check if user is blocked
  SELECT EXISTS(
    SELECT 1 FROM public.user_blocks
    WHERE 
      blocker_id = v_current_user_id
      AND blocked_id = p_user_id
      AND block_type = p_block_type
      AND is_active = TRUE
      AND (expires_at IS NULL OR expires_at > NOW())
  ) INTO v_is_blocked;
  
  RETURN v_is_blocked;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_user_standalone(user_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM standalone_users WHERE standalone_users.user_id = $1
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_valid_join_code(code text, course_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
    SELECT EXISTS (
        SELECT 1 FROM courses c
        WHERE c.id = course_id
        AND c.join_code = code
        AND c.is_active = true
        AND c.deleted_at IS NULL
        AND (c.join_code_expires_at IS NULL OR c.join_code_expires_at > now())
    );
$function$
;

CREATE OR REPLACE FUNCTION public.jsonb_deep_merge(left_json jsonb, right_json jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
DECLARE
  result JSONB := left_json;
  key TEXT;
  value JSONB;
BEGIN
  -- Iterate through each key-value pair in right_json
  FOR key, value IN SELECT * FROM jsonb_each(right_json)
  LOOP
    -- If the key exists in left_json and both values are objects, merge recursively
    IF result ? key AND jsonb_typeof(result->key) = 'object' AND jsonb_typeof(value) = 'object' THEN
      result := jsonb_set(result, ARRAY[key], jsonb_deep_merge(result->key, value));
    ELSE
      -- Otherwise, simply set the value from right_json
      result := jsonb_set(result, ARRAY[key], value);
    END IF;
  END LOOP;
  
  RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.letter_grade_to_gpa(letter_grade text)
 RETURNS numeric
 LANGUAGE sql
 IMMUTABLE
AS $function$
    SELECT CASE UPPER(letter_grade)
        WHEN 'A+' THEN 4.00
        WHEN 'A' THEN 4.00
        WHEN 'A-' THEN 3.70
        WHEN 'B+' THEN 3.30
        WHEN 'B' THEN 3.00
        WHEN 'B-' THEN 2.70
        WHEN 'C+' THEN 2.30
        WHEN 'C' THEN 2.00
        WHEN 'C-' THEN 1.70
        WHEN 'D+' THEN 1.30
        WHEN 'D' THEN 1.00
        WHEN 'D-' THEN 0.70
        WHEN 'F' THEN 0.00
        WHEN 'PASS' THEN 4.00
        WHEN 'FAIL' THEN 0.00
        ELSE 0.00
    END;
$function$
;

CREATE OR REPLACE FUNCTION public.link_student_on_guardian_approval()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_parent_internal_id uuid;
BEGIN
  IF NEW.status = 'approved' AND (OLD.status IS NULL OR OLD.status != 'approved') THEN
    -- Get parent's internal ID from users table
    -- guardian_requests.parent_auth_id is the auth.users.id
    -- We need users.id which is the internal ID that students.parent_id references
    SELECT id INTO v_parent_internal_id
    FROM public.users
    WHERE auth_user_id = NEW.parent_auth_id;
    
    IF v_parent_internal_id IS NOT NULL THEN
      -- Update student's parent_id with the internal users.id
      UPDATE public.students
      SET parent_id = v_parent_internal_id,
          updated_at = now()
      WHERE id = NEW.student_id
        AND (parent_id IS NULL OR parent_id != v_parent_internal_id);
    END IF;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.link_user_to_school(user_id uuid, school_id uuid)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Update profile
    UPDATE profiles
    SET 
        preschool_id = school_id,
        usage_type = 'school_linked',
        updated_at = NOW()
    WHERE id = user_id;
    
    -- Remove from standalone_users
    DELETE FROM standalone_users WHERE standalone_users.user_id = $1;
    
    RETURN json_build_object(
        'success', true,
        'user_id', user_id,
        'school_id', school_id,
        'message', 'User linked to school'
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.list_notification_templates(p_category public.template_category_enum DEFAULT NULL::public.template_category_enum, p_status public.template_status_enum DEFAULT NULL::public.template_status_enum, p_language text DEFAULT NULL::text, p_system_only boolean DEFAULT NULL::boolean, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_is_superadmin BOOLEAN;
  v_where_conditions TEXT[];
  v_sql TEXT;
  v_result JSON;
BEGIN
  -- Check if user is superadmin
  SELECT EXISTS (
    SELECT 1 FROM user_profiles 
    WHERE user_id = auth.uid() 
    AND role = 'super_admin' 
    AND is_active = true
  ) INTO v_is_superadmin;
  
  -- Build dynamic WHERE clause
  v_where_conditions := ARRAY[]::TEXT[];
  
  IF NOT v_is_superadmin THEN
    v_where_conditions := array_append(v_where_conditions, 'status = ''active''');
  END IF;
  
  IF p_category IS NOT NULL THEN
    v_where_conditions := array_append(v_where_conditions, 'category = ''' || p_category || '''');
  END IF;
  
  IF p_status IS NOT NULL THEN
    v_where_conditions := array_append(v_where_conditions, 'status = ''' || p_status || '''');
  END IF;
  
  IF p_language IS NOT NULL THEN
    v_where_conditions := array_append(v_where_conditions, 'language = ''' || p_language || '''');
  END IF;
  
  IF p_system_only IS NOT NULL THEN
    v_where_conditions := array_append(v_where_conditions, 'is_system_template = ' || p_system_only);
  END IF;
  
  -- Execute query
  WITH filtered_templates AS (
    SELECT 
      id, template_key, name, description, category, status, 
      version, is_system_template, usage_count, last_used_at,
      created_at, updated_at
    FROM notification_templates
    WHERE CASE 
      WHEN array_length(v_where_conditions, 1) > 0 THEN
        (array_to_string(v_where_conditions, ' AND '))::BOOLEAN
      ELSE true
    END
    ORDER BY 
      CASE WHEN is_system_template THEN 0 ELSE 1 END,
      name
    LIMIT p_limit 
    OFFSET p_offset
  ),
  total_count AS (
    SELECT count(*) as total
    FROM notification_templates
    WHERE CASE 
      WHEN array_length(v_where_conditions, 1) > 0 THEN
        (array_to_string(v_where_conditions, ' AND '))::BOOLEAN
      ELSE true
    END
  )
  SELECT json_build_object(
    'success', true,
    'templates', json_agg(
      json_build_object(
        'id', ft.id,
        'template_key', ft.template_key,
        'name', ft.name,
        'description', ft.description,
        'category', ft.category,
        'status', ft.status,
        'version', ft.version,
        'is_system_template', ft.is_system_template,
        'usage_count', ft.usage_count,
        'last_used_at', ft.last_used_at,
        'created_at', ft.created_at,
        'updated_at', ft.updated_at
      )
    ),
    'pagination', json_build_object(
      'limit', p_limit,
      'offset', p_offset,
      'total', tc.total,
      'has_more', (p_offset + p_limit) < tc.total
    )
  )
  FROM filtered_templates ft, total_count tc
  INTO v_result;
  
  RETURN COALESCE(v_result, json_build_object(
    'success', true,
    'templates', '[]'::json,
    'pagination', json_build_object(
      'limit', p_limit,
      'offset', p_offset,
      'total', 0,
      'has_more', false
    )
  ));
END;
$function$
;

CREATE OR REPLACE FUNCTION public.log_activity(p_activity_type text, p_description text, p_organization_id uuid DEFAULT NULL::uuid)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_log_id UUID;
  v_user_name TEXT;
  v_org_id UUID;
BEGIN
  -- Get user name from profiles
  SELECT COALESCE(first_name || ' ' || last_name, email, id::text)
  INTO v_user_name
  FROM public.profiles
  WHERE id = auth.uid();

  -- Get organization_id if not provided
  IF p_organization_id IS NULL THEN
    SELECT preschool_id
    INTO v_org_id
    FROM public.profiles
    WHERE id = auth.uid();
  ELSE
    v_org_id := p_organization_id;
  END IF;

  -- Insert the activity log
  INSERT INTO public.activity_logs (
    activity_type,
    description,
    user_name,
    user_id,
    organization_id,
    created_at
  ) VALUES (
    p_activity_type,
    p_description,
    v_user_name,
    auth.uid(),
    v_org_id,
    NOW()
  ) RETURNING id INTO v_log_id;

  RETURN v_log_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.log_activity(p_actor_id uuid, p_action text, p_target_type text, p_target_id uuid, p_preschool_id uuid, p_metadata jsonb DEFAULT '{}'::jsonb, p_visibility text DEFAULT 'public'::text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  INSERT INTO public.activity_feed (
    actor_id,
    action,
    target_type,
    target_id,
    preschool_id,
    metadata,
    visibility
  ) VALUES (
    p_actor_id,
    p_action,
    p_target_type,
    p_target_id,
    p_preschool_id,
    p_metadata,
    p_visibility
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.log_ai_tool_event(p_tool_name text, p_metadata jsonb DEFAULT '{}'::jsonb)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_id UUID;
  v_event_id UUID;
BEGIN
  -- Verify authentication
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Unauthorized: Authentication required';
  END IF;

  -- Insert AI event
  INSERT INTO ai_events (
    user_id,
    event_type,
    tool_name,
    metadata,
    created_at
  ) VALUES (
    v_user_id,
    'tool_use',
    p_tool_name,
    p_metadata,
    NOW()
  )
  RETURNING id INTO v_event_id;

  RETURN json_build_object(
    'success', true,
    'event_id', v_event_id
  );

EXCEPTION
  WHEN OTHERS THEN
    -- Don't fail the main operation if logging fails
    RETURN json_build_object(
      'success', false,
      'error', SQLERRM
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.log_allocation_change()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO ai_allocation_history (
      preschool_id, teacher_id, action, quotas_changed, 
      previous_quotas, new_quotas, performed_by, reason
    ) VALUES (
      NEW.preschool_id, NEW.user_id, 'allocate', NEW.allocated_quotas,
      '{}'::jsonb, NEW.allocated_quotas, NEW.allocated_by, 
      COALESCE(NEW.allocation_reason, 'Initial allocation')
    );
  ELSIF TG_OP = 'UPDATE' THEN
    -- Determine the action based on changes
    DECLARE
      action_type TEXT := 'increase';
      changed_quotas JSONB;
    BEGIN
      -- Calculate quota changes
      SELECT jsonb_object_agg(
        key, 
        (NEW.allocated_quotas->>key)::int - (OLD.allocated_quotas->>key)::int
      ) INTO changed_quotas
      FROM jsonb_object_keys(NEW.allocated_quotas) AS key;
      
      -- Determine action type
      IF NEW.is_suspended = true AND OLD.is_suspended = false THEN
        action_type := 'suspend';
      ELSIF NEW.is_suspended = false AND OLD.is_suspended = true THEN
        action_type := 'reactivate';
      ELSIF EXISTS (
        SELECT 1 FROM jsonb_each_text(changed_quotas) 
        WHERE value::int < 0
      ) THEN
        action_type := 'decrease';
      END IF;
      
      INSERT INTO ai_allocation_history (
        preschool_id, teacher_id, action, quotas_changed,
        previous_quotas, new_quotas, performed_by, reason
      ) VALUES (
        NEW.preschool_id, NEW.user_id, action_type, changed_quotas,
        OLD.allocated_quotas, NEW.allocated_quotas, 
        -- Get current user from session or use allocated_by
        COALESCE(
          (SELECT id FROM users WHERE auth_user_id = auth.uid()),
          NEW.allocated_by
        ), 
        COALESCE(NEW.allocation_reason, 'Allocation updated')
      );
    END;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO ai_allocation_history (
      preschool_id, teacher_id, action, quotas_changed,
      previous_quotas, new_quotas, performed_by, reason
    ) VALUES (
      OLD.preschool_id, OLD.user_id, 'revoke', OLD.allocated_quotas,
      OLD.allocated_quotas, '{}'::jsonb, 
      -- Get current user from session or use allocated_by
      COALESCE(
        (SELECT id FROM users WHERE auth_user_id = auth.uid()),
        OLD.allocated_by
      ), 
      'Allocation revoked'
    );
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.log_audit_event(action text, table_name text DEFAULT NULL::text, record_id uuid DEFAULT NULL::uuid, old_values json DEFAULT NULL::json, new_values json DEFAULT NULL::json)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  INSERT INTO public.audit_logs (
    user_id,
    action,
    table_name,
    record_id,
    old_values,
    new_values,
    ip_address
  ) VALUES (
    auth.uid(),
    action,
    table_name,
    record_id,
    old_values,
    new_values,
    inet_client_addr()
  );
EXCEPTION
  WHEN OTHERS THEN
    -- Silently ignore audit log failures to not break main operations
    NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.log_document_access(p_document_id uuid, p_action text, p_details jsonb DEFAULT '{}'::jsonb)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_log_id UUID;
BEGIN
  INSERT INTO organization_document_audit_log (document_id, user_id, action, details)
  VALUES (p_document_id, auth.uid(), p_action, p_details)
  RETURNING id INTO v_log_id;
  
  RETURN v_log_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.log_educational_operations()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    operation_type text;
    table_name text;
    record_data jsonb;
BEGIN
    table_name := TG_TABLE_NAME;
    operation_type := TG_OP;
    
    -- Prepare record data
    CASE TG_OP
        WHEN 'INSERT' THEN record_data := to_jsonb(NEW);
        WHEN 'UPDATE' THEN record_data := jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW));
        WHEN 'DELETE' THEN record_data := to_jsonb(OLD);
    END CASE;
    
    -- Log to audit_logs table if it exists
    BEGIN
        INSERT INTO audit_logs (
            actor_id,
            actor_organization_id,
            action,
            resource_type,
            resource_id,
            metadata,
            ip_address,
            user_agent,
            created_at
        ) VALUES (
            auth.uid(),
            public.get_user_organization_id(),
            operation_type || '_' || table_name,
            table_name,
            COALESCE(NEW.id, OLD.id),
            record_data,
            current_setting('request.headers', true)::json->>'x-forwarded-for',
            current_setting('request.headers', true)::json->>'user-agent',
            now()
        );
    EXCEPTION WHEN OTHERS THEN
        -- Fail silently if audit_logs table doesn't exist or has issues
        NULL;
    END;
    
    RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.log_guest_usage(p_ip_address text, p_user_agent text DEFAULT NULL::text, p_resource_type text DEFAULT 'exam_prep'::text, p_metadata jsonb DEFAULT '{}'::jsonb)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_log_id UUID;
BEGIN
  INSERT INTO public.guest_usage_log (
    ip_address,
    user_agent,
    resource_type,
    metadata
  ) VALUES (
    p_ip_address,
    p_user_agent,
    p_resource_type,
    p_metadata
  )
  RETURNING id INTO v_log_id;
  
  RETURN v_log_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.log_superadmin_action(admin_id uuid, target_user_id uuid, tenant_id uuid, action public.superadmin_action_enum, resource_type text, resource_id text, description text, previous_values jsonb DEFAULT NULL::jsonb, new_values jsonb DEFAULT NULL::jsonb, bulk_operation_id uuid DEFAULT NULL::uuid, affected_count integer DEFAULT 1)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  action_id UUID;
BEGIN
  INSERT INTO superadmin_user_actions (
    admin_id,
    target_user_id,
    tenant_id,
    action,
    resource_type,
    resource_id,
    description,
    previous_values,
    new_values,
    ip_address,
    user_agent,
    bulk_operation_id,
    affected_count
  ) VALUES (
    admin_id,
    target_user_id,
    tenant_id,
    action,
    resource_type,
    resource_id,
    description,
    previous_values,
    new_values,
    inet_client_addr(),
    current_setting('request.headers', true)::json->>'user-agent',
    bulk_operation_id,
    affected_count
  ) RETURNING id INTO action_id;

  RETURN action_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.log_superadmin_command(command_type_param text, command_input_param text, target_entity_param text DEFAULT NULL::text, target_id_param text DEFAULT NULL::text, metadata_param jsonb DEFAULT '{}'::jsonb)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    log_id uuid;
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM public.profiles 
        WHERE id = auth.uid() 
        AND role IN ('super_admin', 'superadmin')
    ) THEN
        RAISE EXCEPTION 'Unauthorized: Super admin access required';
    END IF;
    
    INSERT INTO public.superadmin_command_log (
        admin_id,
        command_type,
        command_input,
        target_entity,
        target_id,
        metadata,
        status
    ) VALUES (
        auth.uid(),
        command_type_param,
        command_input_param,
        target_entity_param,
        target_id_param,
        metadata_param,
        'pending'
    ) RETURNING id INTO log_id;
    
    RETURN log_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.log_system_error(error_level text, error_message text, error_source text DEFAULT 'system'::text, error_details jsonb DEFAULT NULL::jsonb)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- Validate error level
  IF error_level NOT IN ('error', 'warning', 'info') THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Invalid error level. Must be: error, warning, or info'
    );
  END IF;

  -- Insert error log
  INSERT INTO error_logs (level, message, source, user_id, details)
  VALUES (error_level, error_message, error_source, auth.uid(), error_details);

  RETURN json_build_object(
    'success', true,
    'message', 'Error logged successfully'
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.log_trial_activation(p_user_id uuid, p_email text DEFAULT NULL::text, p_phone text DEFAULT NULL::text, p_device_fingerprint text DEFAULT NULL::text, p_metadata jsonb DEFAULT '{}'::jsonb)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_log_id UUID;
BEGIN
  -- Check if at least one identifier is provided
  IF p_email IS NULL AND p_phone IS NULL AND p_device_fingerprint IS NULL THEN
    RAISE EXCEPTION 'At least one identifier (email, phone, or device_fingerprint) must be provided';
  END IF;

  -- Insert trial log
  INSERT INTO trial_usage_log (
    user_id,
    email,
    phone,
    device_fingerprint,
    metadata
  ) VALUES (
    p_user_id,
    p_email,
    p_phone,
    p_device_fingerprint,
    p_metadata
  )
  RETURNING id INTO v_log_id;

  RETURN v_log_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.manually_sync_registration(registration_id uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  reg_record RECORD;
  webhook_url TEXT := 'https://bppuzibjlxgfwrujzfsz.supabase.co/functions/v1/sync-registration-to-edudash';
  result JSONB;
BEGIN
  -- Get registration record
  SELECT * INTO reg_record FROM registration_requests WHERE id = registration_id;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Registration not found');
  END IF;
  
  -- Call webhook
  SELECT content::JSONB INTO result
  FROM net.http_post(
    url := webhook_url,
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer ' || current_setting('app.settings.service_role_key', true)
    ),
    body := jsonb_build_object(
      'record', row_to_json(reg_record),
      'type', 'manual_sync'
    )
  );
  
  RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.mark_message_as_read(message_id uuid, reader_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  UPDATE messages
  SET read_by = array_append(read_by, reader_id)
  WHERE id = message_id
    AND NOT (reader_id = ANY(read_by))
    AND sender_id != reader_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.mark_messages_delivered(p_thread_id uuid, p_user_id uuid)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    updated_count INTEGER;
BEGIN
    -- Mark all undelivered messages in thread as delivered
    -- Only messages NOT sent by this user
    UPDATE public.messages
    SET delivered_at = NOW()
    WHERE thread_id = p_thread_id
      AND sender_id != p_user_id
      AND delivered_at IS NULL;
    
    GET DIAGNOSTICS updated_count = ROW_COUNT;
    RETURN updated_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.mark_org_announcement_read(p_announcement_id uuid, p_user_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- Update the read_by array
  UPDATE organization_announcements
  SET read_by = array_append(read_by, p_user_id)
  WHERE id = p_announcement_id
    AND NOT (p_user_id = ANY(read_by));
  
  -- Update or insert recipient record
  INSERT INTO organization_announcement_recipients (announcement_id, recipient_id, read_at)
  VALUES (p_announcement_id, p_user_id, now())
  ON CONFLICT (announcement_id, recipient_id)
  DO UPDATE SET read_at = now();
  
  RETURN TRUE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.mark_thread_messages_as_read(thread_id uuid, reader_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  UPDATE messages
  SET read_by = array_append(read_by, reader_id)
  WHERE messages.thread_id = mark_thread_messages_as_read.thread_id
    AND NOT (reader_id = ANY(read_by))
    AND sender_id != reader_id;
    
  -- Also update last_read_at in message_participants
  UPDATE message_participants
  SET last_read_at = now()
  WHERE message_participants.thread_id = mark_thread_messages_as_read.thread_id
    AND user_id = reader_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.match_caps_chunks(query_embedding public.vector, match_count integer, filter_phase text DEFAULT NULL::text, filter_subject text DEFAULT NULL::text, filter_grades text DEFAULT NULL::text, filter_language text DEFAULT NULL::text, min_content_length integer DEFAULT 50)
 RETURNS TABLE(chunk_id uuid, document_id uuid, title text, document_type text, subject text, grade text, language text, page_start integer, page_end integer, heading text, content text, similarity double precision)
 LANGUAGE sql
 STABLE
AS $function$
  select c.id as chunk_id,
         d.id as document_id,
         d.title,
         d.document_type,
         d.subject,
         d.grade,
         d.language,
         c.page_start,
         c.page_end,
         c.heading,
         c.content,
         1 - (c.embedding <=> query_embedding) as similarity
  from public.caps_chunks c
  join public.caps_documents d on d.id = c.document_id
  where length(c.content) >= min_content_length
    and (filter_subject is null or d.subject ilike filter_subject)
    and (filter_grades is null or d.grade ilike filter_grades)
    and (filter_language is null or d.language ilike filter_language)
  order by c.embedding <=> query_embedding
  limit greatest(match_count, 1);
$function$
;

CREATE OR REPLACE FUNCTION public.match_rag_chunks(query_embedding public.vector, match_count integer, filter_conversation_id text DEFAULT NULL::text, filter_attachment_ids uuid[] DEFAULT NULL::uuid[], min_content_length integer DEFAULT 20)
 RETURNS TABLE(chunk_id uuid, document_id uuid, attachment_id uuid, content text, page integer, chunk_index integer, similarity double precision)
 LANGUAGE sql
 STABLE
AS $function$
  select
    c.id as chunk_id,
    c.document_id,
    c.attachment_id,
    c.content,
    c.page,
    c.chunk_index,
    1 - (c.embedding <#> query_embedding) as similarity
  from rag_chunks c
  where
    c.user_id = auth.uid()
    and (filter_conversation_id is null or c.conversation_id = filter_conversation_id)
    and (filter_attachment_ids is null or c.attachment_id = any(filter_attachment_ids))
    and length(c.content) >= min_content_length
  order by c.embedding <#> query_embedding
  limit match_count;
$function$
;

CREATE OR REPLACE FUNCTION public.merge_invoice_notification_prefs(p_user_id uuid, p_updates jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  current_prefs JSONB;
  merged_prefs JSONB;
  default_prefs JSONB := '{
    "channels": {
      "email": true,
      "push": false,
      "sms": false
    },
    "events": {
      "new_invoice": {
        "email": true,
        "push": false
      },
      "invoice_sent": {
        "email": true,
        "push": false
      },
      "overdue_reminder": {
        "email": true,
        "push": false,
        "cadence_days": [1, 3, 7]
      },
      "payment_confirmed": {
        "email": true,
        "push": false
      },
      "invoice_viewed": {
        "email": false,
        "push": false
      }
    },
    "email_include_signature": true,
    "pdf_include_signature": true,
    "digest": {
      "overdue_daily": false,
      "weekly_summary": false
    }
  }';
BEGIN
  -- Verify the user exists and is the authenticated user
  IF p_user_id != auth.uid() THEN
    RAISE EXCEPTION 'Access denied: can only update own preferences';
  END IF;
  
  -- Get current preferences
  SELECT invoice_notification_preferences 
  INTO current_prefs
  FROM profiles 
  WHERE id = p_user_id;
  
  -- If no current preferences, use defaults
  IF current_prefs IS NULL THEN
    current_prefs := default_prefs;
  END IF;
  
  -- Deep merge the updates with current preferences
  -- This preserves nested structure while updating only provided fields
  merged_prefs := jsonb_deep_merge(current_prefs, COALESCE(p_updates, '{}'::jsonb));
  
  -- Update the profile
  UPDATE profiles
  SET invoice_notification_preferences = merged_prefs,
      updated_at = NOW()
  WHERE id = p_user_id;
  
  -- Verify update was successful
  IF NOT FOUND THEN
    RAISE EXCEPTION 'User not found or update failed';
  END IF;
  
  RETURN merged_prefs;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.moderate_content(p_queue_item_id uuid, p_action character varying, p_notes text DEFAULT NULL::text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_current_user_id UUID := auth.uid();
  v_queue_item RECORD;
  v_new_status VARCHAR(20);
  v_result JSONB;
BEGIN
  -- Check if current user is superadmin
  IF NOT EXISTS (
    SELECT 1 FROM public.users 
    WHERE id = v_current_user_id 
    AND role = 'superadmin'
  ) THEN
    RETURN json_build_object('error', 'Unauthorized: Superadmin access required');
  END IF;
  
  -- Get the queue item
  SELECT * INTO v_queue_item
  FROM public.moderation_queue
  WHERE id = p_queue_item_id;
  
  IF NOT FOUND THEN
    RETURN json_build_object('error', 'Queue item not found');
  END IF;
  
  -- Determine new status based on action
  CASE p_action
    WHEN 'approve' THEN v_new_status := 'approved';
    WHEN 'reject' THEN v_new_status := 'rejected';
    WHEN 'escalate' THEN v_new_status := 'escalated';
    ELSE v_new_status := v_queue_item.status;
  END CASE;
  
  -- Update the queue item
  UPDATE public.moderation_queue
  SET 
    status = v_new_status,
    reviewed_by = v_current_user_id,
    reviewed_at = NOW(),
    review_notes = p_notes,
    updated_at = NOW()
  WHERE id = p_queue_item_id;
  
  -- Log the moderation action
  INSERT INTO public.moderation_actions (
    queue_item_id,
    moderator_id,
    action,
    reason,
    details,
    previous_status,
    new_status
  ) VALUES (
    p_queue_item_id,
    v_current_user_id,
    p_action,
    p_notes,
    json_build_object(
      'content_type', v_queue_item.content_type,
      'content_title', v_queue_item.content_title,
      'author_id', v_queue_item.author_id,
      'school_id', v_queue_item.school_id
    ),
    v_queue_item.status,
    v_new_status
  );
  
  -- Create notification for content author if rejected
  IF p_action = 'reject' AND v_queue_item.author_id IS NOT NULL THEN
    PERFORM create_system_notification(
      v_queue_item.author_id,
      'Content Moderation Update',
      'Your ' || v_queue_item.content_type || ' "' || v_queue_item.content_title || '" has been reviewed and requires attention.',
      'content_moderation',
      json_build_object(
        'action', p_action,
        'content_type', v_queue_item.content_type,
        'content_title', v_queue_item.content_title,
        'review_notes', p_notes
      )
    );
  END IF;
  
  -- Build result
  v_result := json_build_object(
    'success', TRUE,
    'queue_item_id', p_queue_item_id,
    'action', p_action,
    'new_status', v_new_status,
    'message', 'Content moderation action completed successfully'
  );
  
  RETURN v_result;
END;
$function$
;

create or replace view "public"."monthly_ai_usage_rollup" as  SELECT preschool_id,
    user_id,
    date_trunc('month'::text, created_at) AS usage_month,
    quota_consumed_from,
    count(*) AS request_count,
    sum((COALESCE(input_tokens, 0) + COALESCE(output_tokens, 0))) AS total_tokens,
    avg((COALESCE(input_tokens, 0) + COALESCE(output_tokens, 0))) AS avg_tokens_per_request,
    sum(COALESCE(response_time_ms, 0)) AS total_processing_time,
    avg(COALESCE(response_time_ms, 0)) AS avg_processing_time,
    sum(COALESCE(total_cost, (0)::numeric)) AS total_cost
   FROM public.ai_usage_logs
  WHERE (quota_consumed_from IS NOT NULL)
  GROUP BY preschool_id, user_id, (date_trunc('month'::text, created_at)), quota_consumed_from;


CREATE OR REPLACE FUNCTION public.normalize_usage_type(input_usage_type text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN CASE 
        -- Map organization types to NULL (they should use org subscription)
        WHEN input_usage_type IN ('k12_school', 'preschool', 'organization', 'school_linked', 'school') THEN NULL
        
        -- Map to valid standalone types
        WHEN input_usage_type IN ('standalone', 'personal', 'individual') THEN 'standalone'
        WHEN input_usage_type = 'freelance' THEN 'freelance'
        WHEN input_usage_type = 'homeschool' THEN 'homeschool'
        WHEN input_usage_type = 'independent' THEN 'independent'
        
        -- Default to standalone
        ELSE 'standalone'
    END;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_assignment_changes()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    course_title TEXT;
    notification_data JSONB;
    enrolled_students UUID[];
    student_id UUID;
BEGIN
    -- Get course information
    SELECT c.title INTO course_title
    FROM courses c
    WHERE c.id = COALESCE(NEW.course_id, OLD.course_id);
    
    -- Get enrolled students
    SELECT array_agg(e.student_id)
    INTO enrolled_students
    FROM enrollments e
    WHERE e.course_id = COALESCE(NEW.course_id, OLD.course_id)
    AND e.is_active = true;
    
    -- Prepare notification data
    notification_data := jsonb_build_object(
        'assignment_id', COALESCE(NEW.id, OLD.id),
        'assignment_title', COALESCE(NEW.title, OLD.title),
        'course_id', COALESCE(NEW.course_id, OLD.course_id),
        'course_title', course_title,
        'due_at', COALESCE(NEW.due_at, OLD.due_at)
    );
    
    -- Handle new assignment creation
    IF TG_OP = 'INSERT' AND NEW.deleted_at IS NULL THEN
        -- Notify all enrolled students about new assignment
        FOREACH student_id IN ARRAY enrolled_students
        LOOP
            BEGIN
                INSERT INTO push_notifications (
                    recipient_user_id,
                    title,
                    body,
                    data,
                    type,
                    preschool_id
                ) VALUES (
                    student_id,
                    'New Assignment: ' || NEW.title,
                    'New assignment posted in ' || course_title,
                    notification_data,
                    'assignment_new',
                    public.get_user_organization_id()
                );
            EXCEPTION WHEN OTHERS THEN
                -- Continue with other notifications even if one fails
                CONTINUE;
            END;
        END LOOP;
        
    -- Handle due date changes
    ELSIF TG_OP = 'UPDATE' AND OLD.due_at IS DISTINCT FROM NEW.due_at AND NEW.deleted_at IS NULL THEN
        -- Notify students about due date change
        FOREACH student_id IN ARRAY enrolled_students
        LOOP
            BEGIN
                INSERT INTO push_notifications (
                    recipient_user_id,
                    title,
                    body,
                    data,
                    type,
                    preschool_id
                ) VALUES (
                    student_id,
                    'Assignment Due Date Changed',
                    'Due date updated for "' || NEW.title || '" in ' || course_title,
                    notification_data,
                    'assignment_due_changed',
                    public.get_user_organization_id()
                );
            EXCEPTION WHEN OTHERS THEN
                CONTINUE;
            END;
        END LOOP;
    END IF;
    
    RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_enrollment_change()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    course_title TEXT;
    instructor_id UUID;
    student_name TEXT;
    notification_data JSONB;
BEGIN
    -- Get course and student information
    SELECT c.title, c.instructor_id
    INTO course_title, instructor_id
    FROM courses c
    WHERE c.id = COALESCE(NEW.course_id, OLD.course_id);
    
    SELECT p.first_name || ' ' || p.last_name
    INTO student_name
    FROM profiles p
    WHERE p.id = COALESCE(NEW.student_id, OLD.student_id);
    
    -- Prepare notification data
    notification_data := jsonb_build_object(
        'course_id', COALESCE(NEW.course_id, OLD.course_id),
        'course_title', course_title,
        'student_id', COALESCE(NEW.student_id, OLD.student_id),
        'student_name', student_name,
        'enrollment_id', COALESCE(NEW.id, OLD.id)
    );
    
    -- Handle different operations
    IF TG_OP = 'INSERT' THEN
        -- Student enrolled - notify instructor
        BEGIN
            INSERT INTO push_notifications (
                recipient_user_id,
                title,
                body,
                data,
                type,
                preschool_id
            ) VALUES (
                instructor_id,
                'New Student Enrollment',
                student_name || ' enrolled in ' || course_title,
                notification_data,
                'enrollment_new',
                public.get_user_organization_id()
            );
        EXCEPTION WHEN OTHERS THEN
            -- Ignore notification failures
            NULL;
        END;
        
    ELSIF TG_OP = 'UPDATE' AND OLD.is_active = true AND NEW.is_active = false THEN
        -- Student dropped - notify instructor
        BEGIN
            INSERT INTO push_notifications (
                recipient_user_id,
                title,
                body,
                data,
                type,
                preschool_id
            ) VALUES (
                instructor_id,
                'Student Dropped Course',
                student_name || ' dropped from ' || course_title,
                notification_data,
                'enrollment_dropped',
                public.get_user_organization_id()
            );
        EXCEPTION WHEN OTHERS THEN
            -- Ignore notification failures
            NULL;
        END;
    END IF;
    
    RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_grade_published()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    assignment_title TEXT;
    course_title TEXT;
    student_id UUID;
    notification_data JSONB;
BEGIN
    -- Only notify when grade is published for the first time
    IF TG_OP = 'UPDATE' AND OLD.is_published = false AND NEW.is_published = true THEN
        
        -- Get assignment and course information
        SELECT 
            a.title,
            c.title,
            s.student_id
        INTO assignment_title, course_title, student_id
        FROM grades g
        JOIN submissions s ON s.id = g.submission_id
        JOIN assignments a ON a.id = s.assignment_id
        JOIN courses c ON c.id = a.course_id
        WHERE g.id = NEW.id;
        
        -- Prepare notification data
        notification_data := jsonb_build_object(
            'grade_id', NEW.id,
            'submission_id', NEW.submission_id,
            'assignment_title', assignment_title,
            'course_title', course_title,
            'points_earned', NEW.points_earned,
            'points_possible', NEW.points_possible,
            'percentage', NEW.percentage,
            'letter_grade', NEW.letter_grade
        );
        
        -- Send notification to student
        BEGIN
            INSERT INTO push_notifications (
                recipient_user_id,
                title,
                body,
                data,
                type,
                preschool_id
            ) VALUES (
                student_id,
                'Grade Published',
                'Your grade for "' || assignment_title || '" is now available',
                notification_data,
                'grade_published',
                public.get_user_organization_id()
            );
        EXCEPTION WHEN OTHERS THEN
            -- Ignore notification failures
            NULL;
        END;
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_message_recipients()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  participant RECORD;
  sender_name TEXT;
  thread_type TEXT;
  thread_preschool_id UUID;
  student_name TEXT;
  display_message TEXT;
BEGIN
  -- Get sender name
  SELECT 
    COALESCE(first_name || ' ' || last_name, email, 'Someone') INTO sender_name
  FROM profiles
  WHERE id = NEW.sender_id;

  -- Get thread info
  SELECT type, preschool_id, student_id INTO thread_type, thread_preschool_id
  FROM message_threads
  WHERE id = NEW.thread_id;

  -- Get student name if thread is about a student
  SELECT first_name || ' ' || last_name INTO student_name
  FROM students
  WHERE id = (SELECT student_id FROM message_threads WHERE id = NEW.thread_id);

  -- Get display message (handles media content transformation)
  display_message := get_message_display_text(NEW.content);
  
  -- Truncate if needed (only for regular text, media messages are already short)
  IF LENGTH(display_message) > 100 AND NOT display_message LIKE '%' AND NOT display_message LIKE '%' AND NOT display_message LIKE '%' THEN
    display_message := LEFT(display_message, 97) || '...';
  END IF;

  -- Create notification for each participant except sender
  FOR participant IN
    SELECT user_id
    FROM message_participants
    WHERE thread_id = NEW.thread_id
      AND user_id != NEW.sender_id
  LOOP
    INSERT INTO notifications (
      user_id,
      title,
      message,
      type,
      is_read,
      action_url,
      preschool_id,
      metadata
    ) VALUES (
      participant.user_id,
      'New message from ' || COALESCE(sender_name, 'Unknown'),
      display_message,
      'message',
      false,
      CASE
        WHEN (SELECT role FROM profiles WHERE id = participant.user_id) = 'parent' 
          THEN '/dashboard/parent/messages'
        WHEN (SELECT role FROM profiles WHERE id = participant.user_id) IN ('teacher', 'principal') 
          THEN '/dashboard/teacher/messages'
        ELSE '/dashboard'
      END,
      thread_preschool_id,
      jsonb_build_object(
        'thread_id', NEW.thread_id,
        'message_id', NEW.id,
        'sender_id', NEW.sender_id,
        'sender_name', sender_name,
        'student_name', student_name
      )
    );
  END LOOP;

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_principal_on_student_registration()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    principal_user_id UUID;
    school_name TEXT;
    student_name TEXT;
    notification_data JSONB;
BEGIN
    -- Get student's full name
    student_name := COALESCE(NEW.first_name || ' ' || NEW.last_name, 'New Student');
    
    -- Try to get principal from preschool first
    IF NEW.preschool_id IS NOT NULL THEN
        SELECT p.principal_id, p.name INTO principal_user_id, school_name
        FROM preschools p
        WHERE p.id = NEW.preschool_id;
    END IF;
    
    -- Fallback to organization principal if no preschool principal
    IF principal_user_id IS NULL AND NEW.organization_id IS NOT NULL THEN
        SELECT o.principal_id, o.name INTO principal_user_id, school_name
        FROM organizations o
        WHERE o.id = NEW.organization_id;
    END IF;
    
    -- If no principal found, skip notification
    IF principal_user_id IS NULL THEN
        RETURN NEW;
    END IF;
    
    -- Build notification data
    notification_data := jsonb_build_object(
        'type', 'student_registered',
        'student_id', NEW.id,
        'student_name', student_name,
        'student_code', NEW.student_id,
        'preschool_id', NEW.preschool_id,
        'organization_id', NEW.organization_id,
        'class_id', NEW.class_id,
        'academic_year', NEW.academic_year,
        'action_url', '/dashboard/principal/students',
        'channel', 'educational',
        'priority', 'default'
    );
    
    -- Insert push notification for principal
    BEGIN
        INSERT INTO push_notifications (
            recipient_user_id,
            title,
            body,
            notification_type,
            preschool_id,
            status,
            data
        ) VALUES (
            principal_user_id,
            ' New Student Registered',
            student_name || ' has been registered at ' || COALESCE(school_name, 'your school') || '. Student ID: ' || COALESCE(NEW.student_id, 'Pending'),
            'student_registered',
            NEW.preschool_id,
            'pending',
            notification_data
        );
    EXCEPTION WHEN OTHERS THEN
        -- Log error but don't fail the registration
        RAISE WARNING 'Failed to create registration notification: %', SQLERRM;
    END;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_registration_status_change()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  webhook_url TEXT := 'https://bppuzibjlxgfwrujzfsz.supabase.co/functions/v1/sync-approval-to-edusite';
BEGIN
  -- Only trigger if status changed to approved, rejected, or waitlisted
  IF NEW.status IS DISTINCT FROM OLD.status AND 
     NEW.status IN ('approved', 'rejected', 'waitlisted') THEN
    
    PERFORM
      net.http_post(
        url := webhook_url,
        headers := jsonb_build_object(
          'Content-Type', 'application/json',
          'Authorization', 'Bearer ' || current_setting('app.settings.service_role_key', true)
        ),
        body := jsonb_build_object(
          'record', row_to_json(NEW),
          'old_record', row_to_json(OLD),
          'type', 'status_update'
        )
      );
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_registration_submission()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  webhook_url TEXT := 'https://bppuzibjlxgfwrujzfsz.supabase.co/functions/v1/sync-registration-to-edudash';
BEGIN
  PERFORM
    net.http_post(
      url := webhook_url,
      headers := jsonb_build_object(
        'Content-Type', 'application/json',
        'Authorization', 'Bearer ' || current_setting('app.settings.service_role_key', true)
      ),
      body := jsonb_build_object(
        'record', row_to_json(NEW),
        'type', 'new_registration'
      )
    );
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_superadmins(p_title text, p_message text, p_notification_type text DEFAULT 'admin_alert'::text, p_metadata jsonb DEFAULT '{}'::jsonb)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_superadmin_record RECORD;
  v_notification_count INTEGER := 0;
BEGIN
  -- Loop through all superadmin users
  FOR v_superadmin_record IN
    SELECT id FROM public.users WHERE role = 'superadmin' AND is_active = TRUE
  LOOP
    -- Create notification for each superadmin
    PERFORM create_system_notification(
      v_superadmin_record.id,
      p_title,
      p_message,
      p_notification_type,
      p_metadata
    );
    
    v_notification_count := v_notification_count + 1;
  END LOOP;
  
  RETURN v_notification_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_superadmins_on_org_creation()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_superadmin_record RECORD;
  v_creator_name TEXT;
  v_notification_count INTEGER := 0;
BEGIN
  -- Only proceed if this is a new organization creation
  IF TG_OP != 'INSERT' THEN
    RETURN NEW;
  END IF;
  
  -- Get the creator's name for the notification
  SELECT COALESCE(
    NULLIF(TRIM(first_name || ' ' || last_name), ''),
    email,
    'Unknown User'
  )
  INTO v_creator_name
  FROM public.profiles
  WHERE id = NEW.created_by;
  
  -- Insert a notification for each active superadmin
  FOR v_superadmin_record IN (
    SELECT p.id, p.email
    FROM public.profiles p
    WHERE p.role = 'superadmin'
      AND p.is_active = true
      AND p.id != NEW.created_by  -- Don't notify if superadmin created their own org
  )
  LOOP
    BEGIN
      INSERT INTO public.push_notifications (
        recipient_user_id,
        title,
        body,
        data,
        status,
        notification_type,
        preschool_id
      )
      VALUES (
        v_superadmin_record.id,
        'New Organization Created',
        'Organization "' || NEW.name || '" was created by ' || v_creator_name || ' and is now active.',
        jsonb_build_object(
          'organization_id', NEW.id,
          'organization_name', NEW.name,
          'organization_type', NEW.type,
          'creator_id', NEW.created_by,
          'creator_name', v_creator_name,
          'created_at', NEW.created_at,
          'notification_category', 'organization_management'
        ),
        'sent',
        'organization_created',
        NEW.id
      );
      
      v_notification_count := v_notification_count + 1;
      
    EXCEPTION WHEN OTHERS THEN
      -- Log error but don't fail the transaction
      RAISE WARNING 'Failed to create notification for superadmin %: %', 
        v_superadmin_record.email, SQLERRM;
    END;
  END LOOP;
  
  -- Log successful notifications (optional)
  IF v_notification_count > 0 THEN
    RAISE NOTICE 'Created % notification(s) for new organization: %', 
      v_notification_count, NEW.name;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.percentage_to_letter_grade(percentage numeric, use_plus_minus boolean DEFAULT true)
 RETURNS text
 LANGUAGE sql
 IMMUTABLE
AS $function$
    SELECT CASE
        WHEN use_plus_minus THEN
            CASE 
                WHEN percentage >= 97 THEN 'A+'
                WHEN percentage >= 93 THEN 'A'
                WHEN percentage >= 90 THEN 'A-'
                WHEN percentage >= 87 THEN 'B+'
                WHEN percentage >= 83 THEN 'B'
                WHEN percentage >= 80 THEN 'B-'
                WHEN percentage >= 77 THEN 'C+'
                WHEN percentage >= 73 THEN 'C'
                WHEN percentage >= 70 THEN 'C-'
                WHEN percentage >= 67 THEN 'D+'
                WHEN percentage >= 63 THEN 'D'
                WHEN percentage >= 60 THEN 'D-'
                ELSE 'F'
            END
        ELSE
            CASE
                WHEN percentage >= 90 THEN 'A'
                WHEN percentage >= 80 THEN 'B'
                WHEN percentage >= 70 THEN 'C'
                WHEN percentage >= 60 THEN 'D'
                ELSE 'F'
            END
    END;
$function$
;

CREATE OR REPLACE FUNCTION public.prevent_graded_submission_modification()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Check if submission has been graded and user is a student
    IF TG_OP = 'UPDATE' AND OLD.student_id = auth.uid() AND
       NOT public.is_instructor_level() AND
       EXISTS (
           SELECT 1 FROM grades g
           WHERE g.submission_id = OLD.id
       ) THEN
        RAISE EXCEPTION 'Cannot modify graded submission';
    END IF;
    
    RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.principal_create_school(p_school_name text, p_admin_name text DEFAULT NULL::text, p_phone text DEFAULT NULL::text, p_plan_tier text DEFAULT 'free'::text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_user uuid := auth.uid();
  v_school_id uuid;
  v_slug text;
  v_email text;
  v_existing_preschool uuid;
begin
  if v_user is null then
    raise exception 'Not authenticated';
  end if;

  select preschool_id from public.profiles where id = v_user into v_existing_preschool;
  if v_existing_preschool is not null then
    return v_existing_preschool;
  end if;

  select email from public.profiles where id = v_user into v_email;

  v_slug := slugify(p_school_name);

  insert into public.preschools (name, phone, is_active, setup_completed, subscription_tier, tenant_slug, created_at, updated_at)
  values (coalesce(p_school_name,'New Preschool'), p_phone, true, false, coalesce(p_plan_tier,'free'), v_slug, now(), now())
  returning id into v_school_id;

  update public.profiles
    set preschool_id = v_school_id,
        organization_id = coalesce(organization_id, v_school_id),
        role = case when role in ('super_admin','principal_admin','principal') then role else 'principal_admin' end,
        updated_at = now()
  where id = v_user;

  begin
    insert into public.organization_members (id, organization_id, user_id, role, seat_status, created_at, updated_at)
    values (gen_random_uuid(), v_school_id, v_user, 'principal_admin', 'active', now(), now());
  exception when undefined_table then
    null;
  end;

  return v_school_id;
end;
$function$
;

create or replace view "public"."principal_financial_summary" as  SELECT id AS preschool_id,
    name AS preschool_name,
    COALESCE(( SELECT sum(COALESCE(rr.registration_fee_amount, (0)::numeric)) AS sum
           FROM public.registration_requests rr
          WHERE ((rr.organization_id = p.id) AND (rr.payment_verified = true) AND (rr.status = 'approved'::text))), (0)::numeric) AS registration_fees_collected,
    COALESCE(( SELECT count(*) AS count
           FROM public.registration_requests rr
          WHERE ((rr.organization_id = p.id) AND (rr.registration_fee_amount > (0)::numeric) AND ((rr.payment_verified = false) OR (rr.payment_verified IS NULL)) AND (rr.status <> ALL (ARRAY['rejected'::text, 'cancelled'::text])))), (0)::bigint) AS pending_registration_fees,
    COALESCE(( SELECT sum(sf.amount) AS sum
           FROM (public.student_fees sf
             JOIN public.students s ON ((s.id = sf.student_id)))
          WHERE ((s.preschool_id = p.id) AND (sf.status = 'paid'::text) AND (EXTRACT(month FROM sf.paid_date) = EXTRACT(month FROM CURRENT_DATE)) AND (EXTRACT(year FROM sf.paid_date) = EXTRACT(year FROM CURRENT_DATE)))), (0)::numeric) AS monthly_fees_collected,
    COALESCE(( SELECT sum(sf.amount) AS sum
           FROM (public.student_fees sf
             JOIN public.students s ON ((s.id = sf.student_id)))
          WHERE ((s.preschool_id = p.id) AND (sf.status = ANY (ARRAY['pending'::text, 'overdue'::text])))), (0)::numeric) AS outstanding_school_fees,
    COALESCE(( SELECT sum(pay.amount) AS sum
           FROM public.payments pay
          WHERE ((pay.preschool_id = p.id) AND (pay.status = ANY (ARRAY['completed'::text, 'approved'::text])) AND (EXTRACT(month FROM pay.created_at) = EXTRACT(month FROM CURRENT_DATE)) AND (EXTRACT(year FROM pay.created_at) = EXTRACT(year FROM CURRENT_DATE)))), (0)::numeric) AS payments_this_month,
    COALESCE(( SELECT count(*) AS count
           FROM public.pop_uploads pu
          WHERE ((pu.preschool_id = p.id) AND ((pu.status)::text = 'pending'::text))), (0)::bigint) AS pending_pop_reviews,
    COALESCE(( SELECT sum(abs(pct.amount)) AS sum
           FROM public.petty_cash_transactions pct
          WHERE ((pct.school_id = p.id) AND (pct.type = 'expense'::text) AND (pct.status = ANY (ARRAY['approved'::text, 'completed'::text])) AND (EXTRACT(month FROM pct.created_at) = EXTRACT(month FROM CURRENT_DATE)) AND (EXTRACT(year FROM pct.created_at) = EXTRACT(year FROM CURRENT_DATE)))), (0)::numeric) AS expenses_this_month
   FROM public.preschools p
  WHERE (is_active = true);


CREATE OR REPLACE FUNCTION public.process_push_queue_item()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  edge_function_url TEXT := 'https://lvvvjywrmpcqrpvuptdi.supabase.co/functions/v1/push-queue-processor';
  request_body JSONB;
BEGIN
  -- Build the request body with the new record
  request_body := jsonb_build_object(
    'type', 'INSERT',
    'record', jsonb_build_object(
      'id', NEW.id,
      'user_id', NEW.user_id,
      'title', NEW.title,
      'body', NEW.body,
      'icon', NEW.icon,
      'badge', NEW.badge,
      'tag', NEW.tag,
      'data', NEW.data,
      'require_interaction', NEW.require_interaction
    )
  );

  -- Use pg_net to make async HTTP request (non-blocking)
  -- No auth header needed since function is deployed with --no-verify-jwt
  PERFORM net.http_post(
    url := edge_function_url,
    body := request_body::TEXT,
    headers := '{"Content-Type": "application/json"}'::JSONB
  );

  RETURN NEW;
EXCEPTION WHEN OTHERS THEN
  -- Log error but don't fail the insert
  RAISE WARNING 'Failed to trigger push processor: %', SQLERRM;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.process_user_deletion_request(request_id_param uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  request_record RECORD;
  backup_data JSONB;
  result JSONB;
BEGIN
  -- Get the deletion request
  SELECT * INTO request_record
  FROM superadmin_user_deletion_requests
  WHERE id = request_id_param AND status = 'pending';

  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Deletion request not found or already processed',
      'code', 'REQUEST_NOT_FOUND'
    );
  END IF;

  -- Update status to in_progress
  UPDATE superadmin_user_deletion_requests
  SET status = 'in_progress', started_at = now()
  WHERE id = request_id_param;

  -- Create backup of user data before deletion
  SELECT jsonb_build_object(
    'user_profile', to_jsonb(up.*),
    'auth_user', to_jsonb(au.*),
    'last_sign_in', au.last_sign_in_at,
    'created_at', au.created_at
  ) INTO backup_data
  FROM auth.users au
  LEFT JOIN user_profiles up ON au.id = up.user_id
  WHERE au.id = request_record.user_id;

  -- Process based on deletion type
  CASE request_record.deletion_type
    WHEN 'soft' THEN
      -- Soft delete: disable user but keep data
      UPDATE user_profiles
      SET 
        is_active = false,
        deleted_at = now(),
        deleted_reason = request_record.reason
      WHERE user_id = request_record.user_id;

      -- Mark auth user as deleted (if your schema supports it)
      -- UPDATE auth.users SET deleted_at = now() WHERE id = request_record.user_id;

    WHEN 'hard' THEN
      -- Hard delete: remove all user data
      DELETE FROM user_profiles WHERE user_id = request_record.user_id;
      -- Note: auth.users deletion should be handled carefully in production

    WHEN 'gdpr_compliance' THEN
      -- GDPR compliant deletion with anonymization
      UPDATE user_profiles
      SET 
        email = 'deleted-' || request_record.user_id || '@gdpr.local',
        full_name = 'GDPR Deleted User',
        phone = NULL,
        is_active = false,
        deleted_at = now(),
        deleted_reason = 'GDPR/POPIA Compliance Deletion',
        gdpr_deleted = true
      WHERE user_id = request_record.user_id;
  END CASE;

  -- Update deletion request as completed
  UPDATE superadmin_user_deletion_requests
  SET 
    status = 'completed',
    completed_at = now(),
    metadata = metadata || jsonb_build_object(
      'backup_data', backup_data,
      'processed_at', now()
    )
  WHERE id = request_id_param;

  -- Log the completion
  PERFORM log_superadmin_action(
    request_record.requester_id,
    request_record.user_id,
    request_record.tenant_id,
    'user_deleted'::superadmin_action_enum,
    'user',
    request_record.user_id::text,
    format('User deletion completed (%s)', request_record.deletion_type),
    backup_data,
    jsonb_build_object(
      'request_id', request_id_param,
      'deletion_type', request_record.deletion_type
    )
  );

  RETURN jsonb_build_object(
    'success', true,
    'message', 'User deletion completed successfully',
    'deletion_type', request_record.deletion_type,
    'completed_at', now()
  );

EXCEPTION
  WHEN OTHERS THEN
    -- Mark request as failed
    UPDATE superadmin_user_deletion_requests
    SET 
      status = 'failed',
      error_message = SQLERRM,
      completed_at = now()
    WHERE id = request_id_param;

    RETURN jsonb_build_object(
      'success', false,
      'error', 'Deletion processing failed: ' || SQLERRM,
      'code', 'PROCESSING_ERROR'
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.promote_user_to_superladmin(target_email text)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    target_user_id UUID;
    result_message TEXT;
BEGIN
    -- Find user by email in auth.users
    SELECT id INTO target_user_id
    FROM auth.users
    WHERE email = target_email;
    
    IF target_user_id IS NULL THEN
        RETURN 'User not found: ' || target_email;
    END IF;
    
    -- Insert or update in user_profiles
    INSERT INTO user_profiles (
        user_id, 
        email, 
        full_name, 
        role, 
        is_active
    ) VALUES (
        target_user_id,
        target_email,
        'Super Administrator',
        'super_admin',
        true
    ) ON CONFLICT (user_id) DO UPDATE SET
        role = 'super_admin',
        is_active = true,
        updated_at = now();
    
    result_message := 'Successfully promoted ' || target_email || ' to super_admin';
    RETURN result_message;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.public_list_plans()
 RETURNS TABLE(id uuid, name text, tier text, price_monthly numeric, price_annual numeric, max_teachers integer, max_students integer, is_active boolean)
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$ select p.id, p.name, p.tier, p.price_monthly, p.price_annual, p.max_teachers, p.max_students, coalesce(p.is_active, true) from public.subscription_plans p where coalesce(p.is_active, true) = true order by p.price_monthly nulls last; $function$
;

CREATE OR REPLACE FUNCTION public.public_list_schools()
 RETURNS TABLE(id uuid, name text, tenant_slug text, subscription_tier text)
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  select s.id, s.name, s.tenant_slug, s.subscription_tier
  from public.preschools s
  order by s.name asc
$function$
;

CREATE OR REPLACE FUNCTION public.push_devices_set_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.queue_call_push_notification()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  caller_name TEXT;
  callee_role TEXT;
  action_url TEXT;
  supabase_url TEXT;
  service_role_key TEXT;
  request_id BIGINT;
BEGIN
  -- Only queue for new ringing calls
  IF NEW.status != 'ringing' THEN
    RETURN NEW;
  END IF;

  -- Get Supabase URL and service role key from vault (or use hardcoded fallback)
  SELECT decrypted_secret INTO supabase_url 
  FROM vault.decrypted_secrets 
  WHERE name = 'supabase_url';
  
  IF supabase_url IS NULL THEN
    supabase_url := 'https://lvvvjywrmpcqrpvuptdi.supabase.co';
  END IF;

  SELECT decrypted_secret INTO service_role_key 
  FROM vault.decrypted_secrets 
  WHERE name = 'supabase_service_role_key';
  
  IF service_role_key IS NULL THEN
    -- Skip if no service role key (can't call Edge Function securely)
    RAISE WARNING 'No service_role_key found in vault, skipping notifications-dispatcher call';
  ELSE
    -- Get caller name for notification
    SELECT COALESCE(first_name || ' ' || last_name, email, 'Someone')
    INTO caller_name
    FROM profiles
    WHERE id = NEW.caller_id;

    -- Call notifications-dispatcher Edge Function for mobile push
    -- This sends Expo push notifications which work when app is killed
    SELECT INTO request_id net.http_post(
      url := supabase_url || '/functions/v1/notifications-dispatcher',
      headers := jsonb_build_object(
        'Content-Type', 'application/json',
        'Authorization', 'Bearer ' || service_role_key
      ),
      body := jsonb_build_object(
        'event_type', 'incoming_call',
        'user_ids', ARRAY[NEW.callee_id],
        'call_id', NEW.call_id,
        'caller_id', NEW.caller_id,
        'caller_name', caller_name,
        'call_type', COALESCE(NEW.call_type, 'voice'),
        'meeting_url', NEW.meeting_url,
        'send_immediately', true,
        'include_push', true
      )::jsonb
    );
    
    RAISE LOG 'Sent incoming call notification for call % to user %, request_id: %', 
      NEW.call_id, NEW.callee_id, request_id;
  END IF;

  -- Also queue for web push (PWA support)
  SELECT COALESCE(first_name || ' ' || last_name, email, 'Someone')
  INTO caller_name
  FROM profiles
  WHERE id = NEW.caller_id;

  SELECT role INTO callee_role
  FROM profiles
  WHERE id = NEW.callee_id;

  action_url := CASE 
    WHEN callee_role = 'parent' THEN '/dashboard/parent/messages'
    ELSE '/dashboard/teacher/messages'
  END;

  -- Insert into push_notification_queue for web push
  INSERT INTO push_notification_queue (
    user_id,
    title,
    body,
    tag,
    data,
    require_interaction
  ) VALUES (
    NEW.callee_id,
    'Incoming ' || COALESCE(NEW.call_type, 'voice') || ' call',
    caller_name || ' is calling...',
    'call-' || NEW.call_id,
    jsonb_build_object(
      'type', 'incoming_call',
      'url', action_url,
      'call_id', NEW.call_id,
      'caller_id', NEW.caller_id,
      'caller_name', caller_name,
      'call_type', COALESCE(NEW.call_type, 'voice'),
      'meeting_url', NEW.meeting_url,
      'channelId', 'calls',
      'priority', 'high',
      'sound', 'default',
      'categoryId', 'incoming_call'
    ),
    true -- Require interaction for calls
  );

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.queue_message_push_notification()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  recipient_record RECORD;
  sender_name TEXT;
  message_preview TEXT;
  recipient_role TEXT;
  action_url TEXT;
BEGIN
  -- Get sender name
  SELECT COALESCE(first_name || ' ' || last_name, email, 'Someone')
  INTO sender_name
  FROM profiles
  WHERE id = NEW.sender_id;

  -- Get message preview (handles media content transformation)
  message_preview := get_message_display_text(NEW.content);
  
  -- Truncate if needed (only for regular text)
  IF LENGTH(message_preview) > 50 AND NOT message_preview LIKE '%' AND NOT message_preview LIKE '%' AND NOT message_preview LIKE '%' THEN
    message_preview := LEFT(message_preview, 47) || '...';
  END IF;

  -- Queue notification for each recipient (except sender)
  FOR recipient_record IN
    SELECT mp.user_id, p.role
    FROM message_participants mp
    JOIN profiles p ON p.id = mp.user_id
    WHERE mp.thread_id = NEW.thread_id
      AND mp.user_id != NEW.sender_id
  LOOP
    -- Determine action URL based on recipient role
    action_url := CASE 
      WHEN recipient_record.role = 'parent' THEN '/dashboard/parent/messages?thread=' || NEW.thread_id
      ELSE '/dashboard/teacher/messages?thread=' || NEW.thread_id
    END;

    -- Insert into queue
    INSERT INTO push_notification_queue (
      user_id,
      title,
      body,
      tag,
      data,
      require_interaction
    ) VALUES (
      recipient_record.user_id,
      'New message from ' || COALESCE(sender_name, 'Someone'),
      message_preview,
      'message-' || NEW.thread_id,
      jsonb_build_object(
        'type', 'message',
        'url', action_url,
        'thread_id', NEW.thread_id,
        'message_id', NEW.id,
        'sender_id', NEW.sender_id,
        'sender_name', sender_name
      ),
      false
    );
  END LOOP;

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.recalculate_all_class_enrollments(preschool_uuid uuid)
 RETURNS TABLE(class_id uuid, class_name character varying, old_count integer, new_count integer)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  WITH counts AS (
    SELECT 
      c.id,
      c.name,
      c.current_students as old_count,
      COUNT(s.id) as new_count
    FROM classes c
    LEFT JOIN students s ON s.class_id = c.id AND s.status IN ('active', 'enrolled')
    WHERE c.preschool_id = preschool_uuid
    GROUP BY c.id, c.name, c.current_students
  )
  UPDATE classes
  SET 
    current_students = counts.new_count,
    updated_at = NOW()
  FROM counts
  WHERE classes.id = counts.id
  RETURNING classes.id, counts.name, counts.old_count, counts.new_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.recalculate_class_enrollment(class_uuid uuid)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  actual_count INTEGER;
BEGIN
  SELECT COUNT(*)
  INTO actual_count
  FROM students
  WHERE class_id = class_uuid
    AND status IN ('active', 'enrolled');
  
  UPDATE classes
  SET 
    current_students = actual_count,
    updated_at = NOW()
  WHERE id = class_uuid;
  
  RETURN actual_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.record_ai_usage(p_user_id uuid, p_model_used text, p_feature_used text, p_tokens_used integer DEFAULT NULL::integer, p_request_tokens integer DEFAULT NULL::integer, p_response_tokens integer DEFAULT NULL::integer, p_processing_time_ms integer DEFAULT NULL::integer, p_success boolean DEFAULT true, p_error_message text DEFAULT NULL::text, p_metadata jsonb DEFAULT '{}'::jsonb)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    usage_id UUID;
    org_id UUID;
BEGIN
    -- Get user's organization
    SELECT preschool_id INTO org_id FROM profiles WHERE id = p_user_id;
    
    -- Insert usage record
    INSERT INTO ai_usage (
        user_id, organization_id, model_used, feature_used,
        tokens_used, request_tokens, response_tokens, processing_time_ms,
        success, error_message, metadata
    ) VALUES (
        p_user_id, org_id, p_model_used, p_feature_used,
        p_tokens_used, p_request_tokens, p_response_tokens, p_processing_time_ms,
        p_success, p_error_message, COALESCE(p_metadata, '{}'::jsonb)
    ) RETURNING id INTO usage_id;
    
    RETURN usage_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.record_promotional_subscription(p_user_id uuid, p_tier text, p_user_type text, p_original_price numeric)
 RETURNS uuid
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_campaign RECORD;
  v_promo_price DECIMAL;
  v_promo_end_date TIMESTAMPTZ;
  v_record_id UUID;
BEGIN
  -- Find active campaign
  SELECT * INTO v_campaign
  FROM promotional_campaigns
  WHERE is_active = true
    AND NOW() BETWEEN start_date AND end_date
    AND user_type IN (p_user_type, 'all')
    AND (tier_filter IS NULL OR p_tier = ANY(tier_filter))
    AND (max_uses IS NULL OR current_uses < max_uses)
  ORDER BY discount_value DESC
  LIMIT 1;
  
  IF NOT FOUND THEN
    RAISE EXCEPTION 'No active promotional campaign found';
  END IF;
  
  -- Calculate promo price
  v_promo_price := get_promotional_price(p_user_id, p_tier, p_user_type, p_original_price);
  
  -- Calculate promo end date
  v_promo_end_date := NOW() + (v_campaign.promo_duration_months || ' months')::INTERVAL;
  
  -- Record the promotional subscription
  INSERT INTO user_promotional_subscriptions (
    user_id,
    campaign_id,
    tier,
    original_price,
    promo_price,
    promo_start_date,
    promo_end_date
  ) VALUES (
    p_user_id,
    v_campaign.id,
    p_tier,
    p_original_price,
    v_promo_price,
    NOW(),
    v_promo_end_date
  )
  ON CONFLICT (user_id, tier) DO UPDATE SET
    campaign_id = EXCLUDED.campaign_id,
    original_price = EXCLUDED.original_price,
    promo_price = EXCLUDED.promo_price,
    promo_start_date = EXCLUDED.promo_start_date,
    promo_end_date = EXCLUDED.promo_end_date,
    is_active = true,
    updated_at = NOW()
  RETURNING id INTO v_record_id;
  
  -- Increment campaign usage counter
  UPDATE promotional_campaigns
  SET current_uses = current_uses + 1,
      updated_at = NOW()
  WHERE id = v_campaign.id;
  
  RETURN v_record_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.record_service_health_check(p_service_name text, p_status text, p_response_time_ms integer, p_metadata jsonb DEFAULT '{}'::jsonb)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_health_id UUID;
  v_consecutive_failures INT := 0;
  v_circuit_state TEXT := 'closed';
BEGIN
  -- Get current consecutive failures
  SELECT consecutive_failures, circuit_state INTO v_consecutive_failures, v_circuit_state
  FROM public.service_health_status
  WHERE service_name = p_service_name;
  
  -- Update failure counter and circuit state
  IF p_status = 'down' THEN
    v_consecutive_failures := COALESCE(v_consecutive_failures, 0) + 1;
    IF v_consecutive_failures >= 5 THEN
      v_circuit_state := 'open';
    END IF;
  ELSE
    v_consecutive_failures := 0;
    IF v_circuit_state = 'open' THEN
      v_circuit_state := 'half_open';
    ELSIF v_circuit_state = 'half_open' THEN
      v_circuit_state := 'closed';
    END IF;
  END IF;
  
  -- Upsert health status
  INSERT INTO public.service_health_status (
    service_name,
    service_category,
    status,
    response_time_ms,
    circuit_state,
    last_checked_at,
    last_success_at,
    last_failure_at,
    consecutive_failures,
    metadata,
    updated_at
  )
  VALUES (
    p_service_name,
    COALESCE((p_metadata->>'category')::TEXT, 'unknown'),
    p_status,
    p_response_time_ms,
    v_circuit_state,
    NOW(),
    CASE WHEN p_status != 'down' THEN NOW() ELSE NULL END,
    CASE WHEN p_status = 'down' THEN NOW() ELSE NULL END,
    v_consecutive_failures,
    p_metadata,
    NOW()
  )
  ON CONFLICT (service_name) 
  DO UPDATE SET
    status = EXCLUDED.status,
    response_time_ms = EXCLUDED.response_time_ms,
    circuit_state = EXCLUDED.circuit_state,
    last_checked_at = EXCLUDED.last_checked_at,
    last_success_at = COALESCE(EXCLUDED.last_success_at, service_health_status.last_success_at),
    last_failure_at = COALESCE(EXCLUDED.last_failure_at, service_health_status.last_failure_at),
    consecutive_failures = EXCLUDED.consecutive_failures,
    metadata = EXCLUDED.metadata,
    updated_at = EXCLUDED.updated_at
  RETURNING id INTO v_health_id;
  
  RETURN v_health_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.record_voice_usage(p_user_id uuid, p_preschool_id uuid, p_service text, p_units numeric, p_cost_usd numeric, p_provider text, p_language text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_daily_id UUID;
  v_monthly_id UUID;
BEGIN
  -- Update or insert daily usage
  INSERT INTO public.user_voice_usage (
    user_id, preschool_id, period_type, period_start, period_end,
    stt_total_minutes, stt_request_count, stt_total_cost_usd,
    tts_total_characters, tts_request_count, tts_total_cost_usd,
    total_cost_usd
  ) VALUES (
    p_user_id, p_preschool_id, 'daily',
    CURRENT_DATE, CURRENT_DATE + INTERVAL '1 day',
    CASE WHEN p_service = 'stt' THEN p_units ELSE 0 END,
    CASE WHEN p_service = 'stt' THEN 1 ELSE 0 END,
    CASE WHEN p_service = 'stt' THEN p_cost_usd ELSE 0 END,
    CASE WHEN p_service = 'tts' THEN p_units::INTEGER ELSE 0 END,
    CASE WHEN p_service = 'tts' THEN 1 ELSE 0 END,
    CASE WHEN p_service = 'tts' THEN p_cost_usd ELSE 0 END,
    p_cost_usd
  )
  ON CONFLICT (user_id, period_type, period_start) DO UPDATE SET
    stt_total_minutes = public.user_voice_usage.stt_total_minutes + 
      CASE WHEN p_service = 'stt' THEN p_units ELSE 0 END,
    stt_request_count = public.user_voice_usage.stt_request_count + 
      CASE WHEN p_service = 'stt' THEN 1 ELSE 0 END,
    stt_total_cost_usd = public.user_voice_usage.stt_total_cost_usd + 
      CASE WHEN p_service = 'stt' THEN p_cost_usd ELSE 0 END,
    tts_total_characters = public.user_voice_usage.tts_total_characters + 
      CASE WHEN p_service = 'tts' THEN p_units::INTEGER ELSE 0 END,
    tts_request_count = public.user_voice_usage.tts_request_count + 
      CASE WHEN p_service = 'tts' THEN 1 ELSE 0 END,
    tts_total_cost_usd = public.user_voice_usage.tts_total_cost_usd + 
      CASE WHEN p_service = 'tts' THEN p_cost_usd ELSE 0 END,
    total_cost_usd = public.user_voice_usage.total_cost_usd + p_cost_usd,
    updated_at = now();
  
  -- Update or insert monthly usage
  INSERT INTO public.user_voice_usage (
    user_id, preschool_id, period_type, period_start, period_end,
    stt_total_minutes, stt_request_count, stt_total_cost_usd,
    tts_total_characters, tts_request_count, tts_total_cost_usd,
    total_cost_usd
  ) VALUES (
    p_user_id, p_preschool_id, 'monthly',
    date_trunc('month', CURRENT_DATE),
    date_trunc('month', CURRENT_DATE) + INTERVAL '1 month',
    CASE WHEN p_service = 'stt' THEN p_units ELSE 0 END,
    CASE WHEN p_service = 'stt' THEN 1 ELSE 0 END,
    CASE WHEN p_service = 'stt' THEN p_cost_usd ELSE 0 END,
    CASE WHEN p_service = 'tts' THEN p_units::INTEGER ELSE 0 END,
    CASE WHEN p_service = 'tts' THEN 1 ELSE 0 END,
    CASE WHEN p_service = 'tts' THEN p_cost_usd ELSE 0 END,
    p_cost_usd
  )
  ON CONFLICT (user_id, period_type, period_start) DO UPDATE SET
    stt_total_minutes = public.user_voice_usage.stt_total_minutes + 
      CASE WHEN p_service = 'stt' THEN p_units ELSE 0 END,
    stt_request_count = public.user_voice_usage.stt_request_count + 
      CASE WHEN p_service = 'stt' THEN 1 ELSE 0 END,
    stt_total_cost_usd = public.user_voice_usage.stt_total_cost_usd + 
      CASE WHEN p_service = 'stt' THEN p_cost_usd ELSE 0 END,
    tts_total_characters = public.user_voice_usage.tts_total_characters + 
      CASE WHEN p_service = 'tts' THEN p_units::INTEGER ELSE 0 END,
    tts_request_count = public.user_voice_usage.tts_request_count + 
      CASE WHEN p_service = 'tts' THEN 1 ELSE 0 END,
    tts_total_cost_usd = public.user_voice_usage.tts_total_cost_usd + 
      CASE WHEN p_service = 'tts' THEN p_cost_usd ELSE 0 END,
    total_cost_usd = public.user_voice_usage.total_cost_usd + p_cost_usd,
    updated_at = now();
  
  -- Log to voice_usage_logs
  INSERT INTO public.voice_usage_logs (
    preschool_id, user_id, service, provider, language_code,
    units, cost_estimate_usd, success
  ) VALUES (
    p_preschool_id, p_user_id, p_service, p_provider, p_language,
    p_units, p_cost_usd, true
  );
  
  RETURN true;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.refresh_teachers_dimension()
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  upserted integer := 0;
BEGIN
  -- Upsert all current teachers from users
  WITH up AS (
    INSERT INTO public.teachers (user_id, auth_user_id, preschool_id, full_name, email, role, is_active, created_at, updated_at)
    SELECT u.id, u.auth_user_id, COALESCE(u.preschool_id, u.organization_id) AS preschool_id,
           TRIM(BOTH FROM COALESCE(CONCAT(u.first_name, ' ', u.last_name), u.name, u.email)) AS full_name,
           u.email, 'teacher', COALESCE(u.is_active, true), now(), now()
    FROM public.users u
    WHERE u.role = 'teacher'
    ON CONFLICT (user_id) DO UPDATE SET
      auth_user_id = EXCLUDED.auth_user_id,
      preschool_id = EXCLUDED.preschool_id,
      full_name = EXCLUDED.full_name,
      email = EXCLUDED.email,
      is_active = EXCLUDED.is_active,
      updated_at = now()
    RETURNING 1
  )
  SELECT COUNT(*) INTO upserted FROM up;

  -- Remove stale teacher rows where user no longer a teacher
  DELETE FROM public.teachers t
  WHERE NOT EXISTS (
    SELECT 1 FROM public.users u WHERE u.id = t.user_id AND u.role = 'teacher'
  );

  RETURN upserted;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.register_new_school(p_school_name text, p_principal_email text, p_principal_name text, p_school_type character varying DEFAULT 'preschool'::character varying, p_grade_levels text[] DEFAULT ARRAY['pre_k'::text], p_contact_email text DEFAULT NULL::text, p_contact_phone text DEFAULT NULL::text, p_physical_address text DEFAULT NULL::text, p_selected_plan_id uuid DEFAULT NULL::uuid)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_school_id UUID;
  v_principal_id UUID;
  v_verification_id UUID;
  v_onboarding_id UUID;
  v_notification_count INTEGER;
  v_result JSON;
  v_error_msg TEXT;
BEGIN
  -- Input validation
  IF p_school_name IS NULL OR LENGTH(TRIM(p_school_name)) = 0 THEN
    RETURN json_build_object('error', 'School name is required');
  END IF;
  
  IF p_principal_email IS NULL OR p_principal_email !~ '^[^\s@]+@[^\s@]+\.[^\s@]+$' THEN
    RETURN json_build_object('error', 'Valid principal email is required');
  END IF;
  
  IF p_principal_name IS NULL OR LENGTH(TRIM(p_principal_name)) = 0 THEN
    RETURN json_build_object('error', 'Principal name is required');
  END IF;
  
  IF p_school_type NOT IN ('preschool', 'k12_school', 'hybrid') THEN
    RETURN json_build_object('error', 'Invalid school type');
  END IF;
  
  -- Check if school name already exists
  IF EXISTS (SELECT 1 FROM public.preschools WHERE name = TRIM(p_school_name)) THEN
    RETURN json_build_object('error', 'School name already exists');
  END IF;
  
  -- Check if principal email already exists
  IF EXISTS (SELECT 1 FROM auth.users WHERE email = LOWER(TRIM(p_principal_email))) THEN
    RETURN json_build_object('error', 'Principal email already registered');
  END IF;
  
  -- Create school record
  INSERT INTO public.preschools (
    name,
    school_type,
    grade_levels,
    contact_email,
    contact_phone,
    physical_address,
    verification_status,
    onboarding_flow,
    created_at
  )
  VALUES (
    TRIM(p_school_name),
    p_school_type,
    p_grade_levels,
    LOWER(TRIM(p_contact_email)),
    TRIM(p_contact_phone),
    TRIM(p_physical_address),
    'pending',
    'self_service',
    NOW()
  )
  RETURNING id INTO v_school_id;
  
  -- Create verification record for email
  INSERT INTO public.school_verifications (
    school_id,
    verification_type,
    status,
    verification_data,
    verification_token,
    expires_at
  )
  VALUES (
    v_school_id,
    'email',
    'pending',
    json_build_object(
      'email', LOWER(TRIM(p_contact_email)),
      'school_name', TRIM(p_school_name)
    ),
    encode(gen_random_bytes(32), 'hex'),
    NOW() + INTERVAL '24 hours'
  )
  RETURNING id INTO v_verification_id;
  
  -- Create onboarding progress tracker
  INSERT INTO public.onboarding_progress (
    school_id,
    flow_type,
    current_step,
    completed_steps,
    step_data
  )
  VALUES (
    v_school_id,
    'self_service',
    'school_registered',
    ARRAY['school_registered'],
    json_build_object(
      'school_name', TRIM(p_school_name),
      'school_type', p_school_type,
      'principal_email', LOWER(TRIM(p_principal_email)),
      'principal_name', TRIM(p_principal_name),
      'selected_plan_id', p_selected_plan_id
    )
  )
  RETURNING id INTO v_onboarding_id;
  
  -- Notify superadmins about new school registration
  SELECT notify_superadmins(
    'New School Registration',
    TRIM(p_school_name) || ' (' || 
    CASE p_school_type 
      WHEN 'preschool' THEN 'Preschool'
      WHEN 'k12_school' THEN 'K-12 School'
      WHEN 'hybrid' THEN 'Hybrid Institution'
      ELSE 'School'
    END || ') has registered via self-service.',
    'school_registration',
    json_build_object(
      'school_id', v_school_id,
      'school_name', TRIM(p_school_name),
      'school_type', p_school_type,
      'principal_email', LOWER(TRIM(p_principal_email)),
      'onboarding_flow', 'self_service',
      'requires_verification', TRUE
    )
  ) INTO v_notification_count;
  
  -- Build success response
  v_result := json_build_object(
    'success', TRUE,
    'school_id', v_school_id,
    'verification_id', v_verification_id,
    'onboarding_id', v_onboarding_id,
    'next_step', 'email_verification',
    'message', 'School registered successfully. Email verification required.',
    'notifications_sent', v_notification_count
  );
  
  -- Log the registration
  INSERT INTO public.audit_logs (
    user_id,
    action,
    table_name,
    record_id,
    old_values,
    new_values,
    metadata
  )
  VALUES (
    NULL, -- No user yet, this is self-registration
    'school_self_registration',
    'preschools',
    v_school_id,
    '{}',
    json_build_object(
      'name', TRIM(p_school_name),
      'school_type', p_school_type,
      'onboarding_flow', 'self_service'
    ),
    json_build_object(
      'ip_address', inet_client_addr()::TEXT,
      'notifications_sent', v_notification_count
    )
  );
  
  RETURN v_result;
  
EXCEPTION
  WHEN OTHERS THEN
    GET STACKED DIAGNOSTICS v_error_msg = MESSAGE_TEXT;
    RETURN json_build_object(
      'error', 'Registration failed: ' || v_error_msg
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.remove_group_participant(p_thread_id uuid, p_user_id uuid, p_removed_by uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_is_admin BOOLEAN;
BEGIN
  -- Check if remover is admin
  SELECT is_admin INTO v_is_admin
  FROM message_participants
  WHERE thread_id = p_thread_id AND user_id = p_removed_by;

  IF v_is_admin != TRUE AND p_user_id != p_removed_by THEN
    RAISE EXCEPTION 'Only group admins can remove other participants';
  END IF;

  -- Remove participant
  DELETE FROM message_participants
  WHERE thread_id = p_thread_id AND user_id = p_user_id;

  RETURN TRUE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.render_notification_template(p_template_key text, p_variables jsonb DEFAULT '{}'::jsonb)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_template notification_templates%ROWTYPE;
  v_rendered_subject TEXT;
  v_rendered_body TEXT;
  v_rendered_html TEXT;
  v_variable_name TEXT;
  v_variable_value TEXT;
  v_required_var TEXT;
  v_missing_vars TEXT[] := '{}';
  v_render_start TIMESTAMP;
  v_render_time INTEGER;
BEGIN
  v_render_start := clock_timestamp();
  
  -- Get template
  SELECT * FROM notification_templates 
  WHERE template_key = p_template_key 
  AND status = 'active'
  INTO v_template;
  
  IF NOT FOUND THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Active template not found',
      'error_code', 'TEMPLATE_NOT_FOUND'
    );
  END IF;
  
  -- Check for missing required variables
  FOREACH v_required_var IN ARRAY v_template.required_variables
  LOOP
    IF NOT (p_variables ? v_required_var) THEN
      v_missing_vars := array_append(v_missing_vars, v_required_var);
    END IF;
  END LOOP;
  
  IF array_length(v_missing_vars, 1) > 0 THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Missing required variables',
      'missing_variables', array_to_json(v_missing_vars),
      'error_code', 'MISSING_VARIABLES'
    );
  END IF;
  
  -- Start with templates
  v_rendered_subject := v_template.subject_template;
  v_rendered_body := v_template.body_template;
  v_rendered_html := v_template.html_template;
  
  -- Merge default variables with provided variables
  p_variables := v_template.default_variables || p_variables;
  
  -- Replace variables in templates
  FOR v_variable_name, v_variable_value IN SELECT * FROM jsonb_each_text(p_variables)
  LOOP
    v_rendered_subject := replace(v_rendered_subject, '{{' || v_variable_name || '}}', v_variable_value);
    v_rendered_body := replace(v_rendered_body, '{{' || v_variable_name || '}}', v_variable_value);
    IF v_rendered_html IS NOT NULL THEN
      v_rendered_html := replace(v_rendered_html, '{{' || v_variable_name || '}}', v_variable_value);
    END IF;
  END LOOP;
  
  -- Calculate render time
  v_render_time := extract(milliseconds from clock_timestamp() - v_render_start)::INTEGER;
  
  RETURN json_build_object(
    'success', true,
    'template_id', v_template.id,
    'template_key', v_template.template_key,
    'category', v_template.category,
    'subject', v_rendered_subject,
    'body', v_rendered_body,
    'html', v_rendered_html,
    'variables_used', p_variables,
    'render_time_ms', v_render_time
  );
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object(
      'success', false,
      'error', SQLERRM,
      'error_code', 'RENDER_ERROR'
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.request_phone_verification(p_user_id uuid, p_phone_number character varying, p_country_code character varying DEFAULT '+27'::character varying)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_phone_id UUID;
  v_otp VARCHAR(6);
  v_existing_record RECORD;
  v_result JSON;
BEGIN
  -- Check if phone number already exists for another user
  SELECT * INTO v_existing_record
  FROM user_phone_numbers
  WHERE phone_number = p_phone_number AND user_id != p_user_id;
  
  IF FOUND THEN
    RETURN json_build_object(
      'success', FALSE,
      'error', 'Phone number already registered to another user'
    );
  END IF;
  
  -- Check rate limiting (max 3 attempts per hour)
  IF EXISTS (
    SELECT 1 FROM phone_verification_logs pvl
    JOIN user_phone_numbers upn ON pvl.user_phone_id = upn.id
    WHERE upn.user_id = p_user_id
    AND pvl.sent_at > NOW() - INTERVAL '1 hour'
    GROUP BY upn.id
    HAVING COUNT(*) >= 3
  ) THEN
    RETURN json_build_object(
      'success', FALSE,
      'error', 'Too many verification attempts. Please try again later.'
    );
  END IF;
  
  -- Generate OTP
  v_otp := generate_otp();
  
  -- Insert or update phone number record
  INSERT INTO user_phone_numbers (user_id, phone_number, country_code, verification_code, verification_code_expires_at, verification_attempts)
  VALUES (p_user_id, p_phone_number, p_country_code, v_otp, NOW() + INTERVAL '10 minutes', 0)
  ON CONFLICT (phone_number) 
  DO UPDATE SET
    verification_code = v_otp,
    verification_code_expires_at = NOW() + INTERVAL '10 minutes',
    verification_attempts = 0,
    updated_at = NOW()
  RETURNING id INTO v_phone_id;
  
  -- Log verification attempt
  INSERT INTO phone_verification_logs (user_phone_id, verification_code, status)
  VALUES (v_phone_id, v_otp, 'pending');
  
  RETURN json_build_object(
    'success', TRUE,
    'phone_id', v_phone_id,
    'otp', v_otp, -- Remove this in production, send via SMS only
    'expires_at', (NOW() + INTERVAL '10 minutes')
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.resend_school_verification(p_email text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_school_id UUID;
  v_verification_id UUID;
  v_school_name TEXT;
  v_verification_token TEXT;
  v_result JSON;
  v_error_msg TEXT;
  v_notification_count INTEGER;
BEGIN
  -- Input validation
  IF p_email IS NULL OR p_email !~ '^[^\s@]+@[^\s@]+\.[^\s@]+$' THEN
    RETURN json_build_object('error', 'Valid email address is required');
  END IF;
  
  -- Find the school by contact email
  SELECT id, name INTO v_school_id, v_school_name
  FROM public.preschools
  WHERE LOWER(contact_email) = LOWER(TRIM(p_email))
  AND verification_status = 'pending'
  ORDER BY created_at DESC
  LIMIT 1;
  
  -- Check if school exists and needs verification
  IF v_school_id IS NULL THEN
    RETURN json_build_object(
      'error', 
      'No pending verification found for this email address. The school may already be verified or the email address may be incorrect.'
    );
  END IF;
  
  -- Check for existing unexpired verification
  SELECT id, verification_token INTO v_verification_id, v_verification_token
  FROM public.school_verifications
  WHERE school_id = v_school_id
  AND verification_type = 'email'
  AND status = 'pending'
  AND expires_at > NOW()
  ORDER BY created_at DESC
  LIMIT 1;
  
  -- If no valid verification exists, create a new one
  IF v_verification_id IS NULL THEN
    -- Generate new verification token
    v_verification_token := encode(gen_random_bytes(32), 'hex');
    
    -- Create new verification record
    INSERT INTO public.school_verifications (
      school_id,
      verification_type,
      status,
      verification_data,
      verification_token,
      expires_at
    )
    VALUES (
      v_school_id,
      'email',
      'pending',
      json_build_object(
        'email', LOWER(TRIM(p_email)),
        'school_name', v_school_name,
        'resend_requested', NOW()::TEXT
      ),
      v_verification_token,
      NOW() + INTERVAL '24 hours'
    )
    RETURNING id INTO v_verification_id;
  END IF;
  
  -- Update school's last activity
  UPDATE public.preschools 
  SET updated_at = NOW()
  WHERE id = v_school_id;
  
  -- Notify superadmins about resend request (optional)
  SELECT notify_superadmins(
    'Verification Email Resent',
    v_school_name || ' requested a new verification email.',
    'verification_resent',
    json_build_object(
      'school_id', v_school_id,
      'school_name', v_school_name,
      'email', LOWER(TRIM(p_email)),
      'verification_id', v_verification_id
    )
  ) INTO v_notification_count;
  
  -- Build success response
  v_result := json_build_object(
    'success', TRUE,
    'message', 'Verification email has been resent successfully',
    'school_id', v_school_id,
    'verification_id', v_verification_id,
    'expires_in_hours', 24,
    'school_name', v_school_name
  );
  
  -- Log the resend request
  INSERT INTO public.audit_logs (
    user_id,
    action,
    table_name,
    record_id,
    old_values,
    new_values,
    metadata
  )
  VALUES (
    NULL, -- No user, this is self-service
    'school_verification_resent',
    'school_verifications',
    v_verification_id,
    '{}',
    json_build_object(
      'school_id', v_school_id,
      'email', LOWER(TRIM(p_email)),
      'verification_token', LEFT(v_verification_token, 8) || '...'
    ),
    json_build_object(
      'ip_address', inet_client_addr()::TEXT,
      'user_agent', current_setting('request.headers', true)::json->>'user-agent'
    )
  );
  
  RETURN v_result;
  
EXCEPTION
  WHEN OTHERS THEN
    GET STACKED DIAGNOSTICS v_error_msg = MESSAGE_TEXT;
    RETURN json_build_object(
      'error', 'Failed to resend verification email: ' || v_error_msg
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.reset_monthly_quotas()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Reset usage for the new month
    UPDATE public.subscription_usage
    SET current_usage = 0,
        period_start = date_trunc('month', now()),
        period_end = date_trunc('month', now()) + interval '1 month',
        updated_at = now()
    WHERE period_end <= now();
END;
$function$
;

CREATE OR REPLACE FUNCTION public.respond_to_connection_request(p_connection_id uuid, p_response character varying)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_connection RECORD;
BEGIN
  -- Get connection
  SELECT * INTO v_connection
  FROM user_connections
  WHERE id = p_connection_id
  AND addressee_id = auth.uid()
  AND status = 'pending';
  
  IF NOT FOUND THEN
    RETURN json_build_object('success', FALSE, 'error', 'Connection request not found');
  END IF;
  
  -- Update status
  UPDATE user_connections
  SET
    status = p_response,
    responded_at = NOW(),
    updated_at = NOW()
  WHERE id = p_connection_id;
  
  -- If accepted, create reverse connection for easy lookup
  IF p_response = 'accepted' THEN
    -- Create message thread for cross-school chat
    -- TODO: Integrate with messaging system
    NULL;
  END IF;
  
  RETURN json_build_object('success', TRUE, 'status', p_response);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.retry_delivery(p_delivery_id uuid, p_retry_strategy public.retry_strategy_enum DEFAULT 'exponential_backoff'::public.retry_strategy_enum)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_id UUID;
  v_is_superadmin BOOLEAN;
  v_delivery notification_deliveries%ROWTYPE;
  v_retry_delay INTERVAL;
  v_next_retry_at TIMESTAMP WITH TIME ZONE;
BEGIN
  -- Get current user ID
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Authentication required',
      'error_code', 'AUTH_REQUIRED'
    );
  END IF;
  
  -- Check if user is superadmin
  SELECT EXISTS (
    SELECT 1 FROM user_profiles 
    WHERE user_id = v_user_id 
    AND role = 'super_admin' 
    AND is_active = true
  ) INTO v_is_superadmin;
  
  IF NOT v_is_superadmin THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Superadmin privileges required',
      'error_code', 'INSUFFICIENT_PRIVILEGES'
    );
  END IF;
  
  -- Get existing delivery
  SELECT * FROM notification_deliveries WHERE id = p_delivery_id INTO v_delivery;
  
  IF NOT FOUND THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Delivery not found',
      'error_code', 'DELIVERY_NOT_FOUND'
    );
  END IF;
  
  -- Check if delivery can be retried
  IF v_delivery.delivery_attempts >= v_delivery.max_retry_attempts THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Maximum retry attempts exceeded',
      'error_code', 'MAX_RETRIES_EXCEEDED'
    );
  END IF;
  
  IF v_delivery.status NOT IN ('failed', 'bounced', 'pending') THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Delivery cannot be retried from current status: ' || v_delivery.status,
      'error_code', 'INVALID_STATUS'
    );
  END IF;
  
  -- Calculate retry delay based on strategy
  CASE p_retry_strategy
    WHEN 'exponential_backoff' THEN
      v_retry_delay := (interval '30 seconds') * (2 ^ v_delivery.delivery_attempts);
    WHEN 'linear_backoff' THEN
      v_retry_delay := (interval '5 minutes') * (v_delivery.delivery_attempts + 1);
    WHEN 'fixed_delay' THEN
      v_retry_delay := interval '10 minutes';
    WHEN 'immediate' THEN
      v_retry_delay := interval '0';
    ELSE
      v_retry_delay := interval '15 minutes';
  END CASE;
  
  v_next_retry_at := now() + v_retry_delay;
  
  -- Update delivery for retry
  UPDATE notification_deliveries SET
    status = 'pending',
    delivery_attempts = delivery_attempts + 1,
    retry_strategy = p_retry_strategy,
    next_retry_at = v_next_retry_at,
    updated_at = now()
  WHERE id = p_delivery_id;
  
  -- Add to retry queue
  INSERT INTO delivery_retry_queue (
    delivery_id,
    retry_attempt,
    scheduled_at,
    reason,
    previous_error,
    retry_strategy
  ) VALUES (
    p_delivery_id,
    v_delivery.delivery_attempts + 1,
    v_next_retry_at,
    'Manual retry requested',
    v_delivery.provider_error_message,
    p_retry_strategy
  );
  
  RETURN json_build_object(
    'success', true,
    'delivery_id', p_delivery_id,
    'retry_attempt', v_delivery.delivery_attempts + 1,
    'next_retry_at', v_next_retry_at,
    'retry_strategy', p_retry_strategy,
    'message', 'Delivery scheduled for retry'
  );
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object(
      'success', false,
      'error', SQLERRM,
      'error_code', 'INTERNAL_ERROR'
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.revoke_teacher_seat(p_subscription_id uuid, p_user_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- 1. Remove from subscription_seats table
  DELETE FROM public.subscription_seats
  WHERE subscription_id = p_subscription_id AND user_id = p_user_id;
  
  -- 2. Update organization_members to deactivate seat status
  UPDATE public.organization_members
  SET 
    seat_status = 'pending',
    updated_at = NOW()
  WHERE user_id = p_user_id
    AND seat_status = 'active';
  
  -- 3. Update subscription seats_used counter
  UPDATE public.subscriptions
  SET seats_used = (
    SELECT COUNT(*) FROM public.subscription_seats ss 
    WHERE ss.subscription_id = p_subscription_id
  )
  WHERE id = p_subscription_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.rls_auto_enable()
 RETURNS event_trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'pg_catalog'
AS $function$
DECLARE
  cmd record;
BEGIN
  FOR cmd IN
    SELECT *
    FROM pg_event_trigger_ddl_commands()
    WHERE command_tag IN ('CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO')
      AND object_type IN ('table','partitioned table')
  LOOP
     IF cmd.schema_name IS NOT NULL AND cmd.schema_name IN ('public') AND cmd.schema_name NOT IN ('pg_catalog','information_schema') AND cmd.schema_name NOT LIKE 'pg_toast%' AND cmd.schema_name NOT LIKE 'pg_temp%' THEN
      BEGIN
        EXECUTE format('alter table if exists %s enable row level security', cmd.object_identity);
        RAISE LOG 'rls_auto_enable: enabled RLS on %', cmd.object_identity;
      EXCEPTION
        WHEN OTHERS THEN
          RAISE LOG 'rls_auto_enable: failed to enable RLS on %', cmd.object_identity;
      END;
     ELSE
        RAISE LOG 'rls_auto_enable: skip % (either system schema or not in enforced list: %.)', cmd.object_identity, cmd.schema_name;
     END IF;
  END LOOP;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.rpc_assign_teacher_seat(target_user_id uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_is_service boolean := public.util_is_service_role();
  v_school uuid := public.util_caller_principal_school();
  v_subscription_id uuid;
  v_limit int;
  v_used int;
  v_target_user_db_id uuid;
  v_assigned_by_db_id uuid;
BEGIN
  -- Authorization check
  IF NOT v_is_service AND v_school IS NULL THEN
    RAISE EXCEPTION 'Only principals can assign teacher seats';
  END IF;

  -- Service role path: infer school from target user
  IF v_is_service AND v_school IS NULL THEN
    SELECT preschool_id INTO v_school 
    FROM public.profiles 
    WHERE id = target_user_id;
    
    IF v_school IS NULL THEN
      RAISE EXCEPTION 'Cannot infer preschool for target user';
    END IF;
  END IF;

  -- Acquire advisory lock for concurrency control
  IF NOT public.util_acquire_school_lock(v_school) THEN
    RAISE EXCEPTION 'Seat assignment in progress; please retry';
  END IF;

  -- Verify target is teacher in same school (profiles.id is auth user id)
  PERFORM 1 
  FROM public.profiles
  WHERE id = target_user_id 
    AND preschool_id = v_school 
    AND role = 'teacher';
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Target must be a teacher in the same preschool';
  END IF;

  -- Get active subscription for the school
  SELECT id INTO v_subscription_id
  FROM public.subscriptions
  WHERE school_id = v_school
    AND status = 'active'
  ORDER BY created_at DESC
  LIMIT 1;
  IF v_subscription_id IS NULL THEN
    RAISE EXCEPTION 'No active subscription found for school';
  END IF;

  -- Map target auth user id (profiles.id) -> users.id for subscription_seats.user_id
  SELECT id INTO v_target_user_db_id
  FROM public.users
  WHERE auth_user_id = target_user_id;
  IF v_target_user_db_id IS NULL THEN
    RAISE EXCEPTION 'Cannot find user record for target user ID';
  END IF;

  -- Prevent duplicate active seat for this user and subscription
  PERFORM 1
  FROM public.subscription_seats
  WHERE subscription_id = v_subscription_id
    AND user_id = v_target_user_db_id
    AND revoked_at IS NULL;
  IF FOUND THEN
    RETURN jsonb_build_object('status', 'already_assigned');
  END IF;

  -- Capacity check based on plan limit
  SELECT sp.max_teachers INTO v_limit
  FROM public.subscriptions s
  JOIN public.subscription_plans sp ON sp.id = s.plan_id
  WHERE s.id = v_subscription_id;

  IF v_limit IS NOT NULL THEN
    SELECT COUNT(*) INTO v_used
    FROM public.subscription_seats
    WHERE subscription_id = v_subscription_id
      AND revoked_at IS NULL;

    IF v_used >= v_limit THEN
      RAISE EXCEPTION 'No teacher seats available for this plan (used: %, limit: %)', v_used, v_limit;
    END IF;
  END IF;

  -- Map caller auth uid -> users.id for assigned_by (FK references users.id on some schemas)
  SELECT id INTO v_assigned_by_db_id
  FROM public.users
  WHERE auth_user_id = auth.uid();
  -- If not found (edge case), allow NULL to avoid FK violation

  -- Assign the seat - INCLUDING preschool_id to fix constraint violation
  INSERT INTO public.subscription_seats (
    subscription_id,
    user_id,
    assigned_at,
    assigned_by,
    preschool_id  -- THIS WAS MISSING AND CAUSING THE ERROR
  ) VALUES (
    v_subscription_id,
    v_target_user_db_id,
    NOW(),
    v_assigned_by_db_id,
    v_school  -- Use the school ID we already have
  );

  -- Update seats_used counter
  UPDATE public.subscriptions
  SET seats_used = (
    SELECT COUNT(*)
    FROM public.subscription_seats
    WHERE subscription_id = v_subscription_id
      AND revoked_at IS NULL
  ),
  updated_at = NOW()
  WHERE id = v_subscription_id;

  RETURN jsonb_build_object('status', 'assigned');
END;
$function$
;

CREATE OR REPLACE FUNCTION public.rpc_find_available_teachers_near(school_id uuid, radius_km integer DEFAULT 10, subject_filter text DEFAULT NULL::text)
 RETURNS TABLE(user_id uuid, full_name text, email text, phone text, home_city text, home_postal_code text, distance_km numeric)
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  WITH school AS (
    SELECT ST_SetSRID(ST_MakePoint(p.location_longitude, p.location_latitude), 4326)::geography AS g
    FROM public.preschools p
    WHERE p.id = school_id AND p.location_latitude IS NOT NULL AND p.location_longitude IS NOT NULL
  ),
  candidates AS (
    SELECT 
      u.id AS user_id,
      COALESCE(NULLIF(TRIM(u.name), ''), u.email) AS full_name,
      u.email,
      u.phone,
      u.city,
      u.postal_code,
      -- distance in KM
      (ST_Distance(s.g, ST_SetSRID(ST_MakePoint(u.home_longitude, u.home_latitude), 4326)::geography) / 1000.0) AS distance_km
    FROM public.users u
    CROSS JOIN school s
    WHERE 
      u.role = 'teacher'
      AND COALESCE(u.is_active, true) = true
      AND u.preschool_id IS NULL
      AND u.home_latitude IS NOT NULL
      AND u.home_longitude IS NOT NULL
      -- Note: Subject filtering removed as user_subjects table doesn't exist
      -- Can be added later when subject system is implemented
  )
  SELECT 
    c.user_id,
    c.full_name,
    c.email,
    c.phone,
    c.city,
    c.postal_code,
    ROUND(c.distance_km::numeric, 2) AS distance_km
  FROM candidates c
  WHERE c.distance_km <= GREATEST(radius_km, 1)
  ORDER BY c.distance_km ASC
  LIMIT 200;
$function$
;

CREATE OR REPLACE FUNCTION public.rpc_list_teacher_seats()
 RETURNS TABLE(user_id uuid, assigned_at timestamp with time zone, revoked_at timestamp with time zone, assigned_by uuid, revoked_by uuid)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_school uuid := public.util_caller_principal_school();
  v_caller uuid := auth.uid();
  v_subscription_id uuid;
BEGIN
  -- Principals see all seats for their school
  IF v_school IS NOT NULL THEN
    -- Get active subscription
    SELECT id INTO v_subscription_id
    FROM public.subscriptions
    WHERE school_id = v_school
      AND status = 'active'
    ORDER BY created_at DESC
    LIMIT 1;
    
    IF v_subscription_id IS NOT NULL THEN
      RETURN QUERY
      SELECT 
        u.auth_user_id as user_id,  -- Return auth_user_id instead of users.id
        ss.assigned_at, 
        ss.revoked_at,
        ss.assigned_by,
        ss.revoked_by
      FROM public.subscription_seats ss
      JOIN public.users u ON u.id = ss.user_id  -- Join to get auth_user_id
      WHERE ss.subscription_id = v_subscription_id
        AND ss.preschool_id = v_school
      ORDER BY ss.assigned_at DESC;
    END IF;
    
    RETURN;
  END IF;

  -- Teachers see only their own seats
  -- First get the teacher's users.id
  DECLARE
    v_teacher_user_db_id uuid;
  BEGIN
    SELECT id INTO v_teacher_user_db_id
    FROM public.users
    WHERE auth_user_id = v_caller;
    
    RETURN QUERY
    SELECT 
      u.auth_user_id as user_id,  -- Return auth_user_id instead of users.id
      ss.assigned_at, 
      ss.revoked_at,
      ss.assigned_by,
      ss.revoked_by
    FROM public.subscription_seats ss
    JOIN public.users u ON u.id = ss.user_id  -- Join to get auth_user_id
    WHERE ss.user_id = v_teacher_user_db_id
    ORDER BY ss.assigned_at DESC;
  END;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.rpc_revoke_teacher_seat(target_user_id uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE v_school uuid := public.util_caller_principal_school(); v_subscription_id uuid; v_updated_rows int; v_target_user_db_id uuid;
BEGIN
  IF v_school IS NULL THEN RAISE EXCEPTION 'Only principals can revoke teacher seats'; END IF;
  SELECT id INTO v_subscription_id FROM public.subscriptions WHERE school_id = v_school AND status = 'active' ORDER BY created_at DESC LIMIT 1;
  IF v_subscription_id IS NULL THEN RAISE EXCEPTION 'No active subscription found'; END IF;
  SELECT id INTO v_target_user_db_id FROM public.users WHERE auth_user_id = target_user_id;
  IF v_target_user_db_id IS NULL THEN SELECT id INTO v_target_user_db_id FROM public.users WHERE id = target_user_id; END IF;
  IF v_target_user_db_id IS NULL THEN SELECT user_id INTO v_target_user_db_id FROM public.teachers WHERE id = target_user_id OR user_id = target_user_id OR auth_user_id = target_user_id; END IF;
  IF v_target_user_db_id IS NULL THEN RAISE EXCEPTION 'Cannot find user for ID: %', target_user_id; END IF;
  UPDATE public.subscription_seats SET revoked_at = NOW(), revoked_by = COALESCE(auth.uid(), target_user_id) WHERE subscription_id = v_subscription_id AND user_id = v_target_user_db_id AND preschool_id = v_school AND revoked_at IS NULL;
  GET DIAGNOSTICS v_updated_rows = ROW_COUNT;
  IF v_updated_rows = 0 THEN RETURN jsonb_build_object('status', 'no_active_seat'); END IF;
  UPDATE public.subscriptions SET seats_used = (SELECT COUNT(*) FROM public.subscription_seats WHERE subscription_id = v_subscription_id AND revoked_at IS NULL), updated_at = NOW() WHERE id = v_subscription_id;
  RETURN jsonb_build_object('status', 'revoked');
END; $function$
;

CREATE OR REPLACE FUNCTION public.rpc_teacher_seat_limits()
 RETURNS TABLE("limit" integer, used integer, available integer)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_school uuid := public.util_caller_principal_school();
  v_subscription_id uuid;
  v_limit int;
  v_used int;
BEGIN
  -- Allow teachers to query for their school too
  IF v_school IS NULL AND NOT public.util_is_service_role() THEN
    SELECT preschool_id INTO v_school 
    FROM public.profiles 
    WHERE id = auth.uid();
  END IF;

  IF v_school IS NULL THEN
    RAISE EXCEPTION 'Cannot determine preschool for caller';
  END IF;

  -- Get active subscription and its plan limit
  SELECT s.id, sp.max_teachers 
  INTO v_subscription_id, v_limit
  FROM public.subscriptions s
  INNER JOIN public.subscription_plans sp ON sp.id = s.plan_id
  WHERE s.school_id = v_school
    AND s.status = 'active'
  ORDER BY s.created_at DESC
  LIMIT 1;
  
  -- If no subscription, return zeros
  IF v_subscription_id IS NULL THEN
    RETURN QUERY SELECT NULL::int, 0, 0;
    RETURN;
  END IF;

  -- Count active seats
  SELECT COUNT(*) INTO v_used
  FROM public.subscription_seats
  WHERE subscription_id = v_subscription_id 
    AND (revoked_at IS NULL);

  RETURN QUERY
  SELECT 
    v_limit,
    v_used,
    CASE 
      WHEN v_limit IS NULL THEN NULL
      ELSE GREATEST(v_limit - v_used, 0)
    END AS available;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.safe_auth_uid()
 RETURNS uuid
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
BEGIN
  RETURN auth.uid();
EXCEPTION
  WHEN OTHERS THEN
    RETURN NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.safe_update_provider_usage()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Only update if we're in a fully authenticated context
  IF auth.uid() IS NOT NULL AND session_user != 'postgres' 
     AND NEW.status = 'sent' AND OLD.status != 'sent' THEN
    UPDATE delivery_providers 
    SET 
      current_daily_usage = current_daily_usage + 1,
      current_monthly_usage = current_monthly_usage + 1
    WHERE id = NEW.provider_id;
  END IF;
  RETURN NEW;
EXCEPTION
  WHEN OTHERS THEN
    -- Log error but don't fail the operation
    RAISE WARNING 'Failed to update provider usage: %', SQLERRM;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.safe_update_template_usage_count()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Only update if we're in a fully authenticated context
  IF auth.uid() IS NOT NULL AND session_user != 'postgres' THEN
    UPDATE notification_templates 
    SET 
      usage_count = usage_count + 1,
      last_used_at = now()
    WHERE id = NEW.template_id;
  END IF;
  RETURN NEW;
EXCEPTION
  WHEN OTHERS THEN
    -- Log error but don't fail the operation
    RAISE WARNING 'Failed to update template usage count: %', SQLERRM;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.schedule_block_cleanup()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- This would typically be called by a cron job or scheduled function
  PERFORM public.cleanup_expired_blocks();
END;
$function$
;

create or replace view "public"."school_daily_ai_usage" as  SELECT preschool_id,
    date_trunc('day'::text, created_at) AS usage_date,
    quota_consumed_from,
    count(*) AS total_requests,
    count(DISTINCT user_id) AS active_users,
    sum((COALESCE(input_tokens, 0) + COALESCE(output_tokens, 0))) AS total_tokens,
    avg((COALESCE(input_tokens, 0) + COALESCE(output_tokens, 0))) AS avg_tokens_per_request,
    sum(COALESCE(response_time_ms, 0)) AS total_processing_time,
    sum(COALESCE(total_cost, (0)::numeric)) AS total_cost
   FROM public.ai_usage_logs
  WHERE (quota_consumed_from IS NOT NULL)
  GROUP BY preschool_id, (date_trunc('day'::text, created_at)), quota_consumed_from;


CREATE OR REPLACE FUNCTION public.search_caps_curriculum(search_query text, search_grade character varying DEFAULT NULL::character varying, search_subject character varying DEFAULT NULL::character varying, result_limit integer DEFAULT 10)
 RETURNS TABLE(id uuid, title character varying, grade character varying, subject character varying, document_type character varying, content_preview text, file_url text, relevance_rank real)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT
    d.id,
    d.title,
    d.grade,
    d.subject,
    d.document_type,
    LEFT(d.content_text, 300) as content_preview,
    d.file_url,
    ts_rank(
      to_tsvector('english', d.content_text),
      plainto_tsquery('english', search_query)
    ) as relevance_rank
  FROM caps_documents d
  WHERE 
    to_tsvector('english', d.content_text) @@ plainto_tsquery('english', search_query)
    AND (search_grade IS NULL OR d.grade = search_grade)
    AND (search_subject IS NULL OR d.subject = search_subject)
  ORDER BY relevance_rank DESC
  LIMIT result_limit;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.search_exam_papers(search_query text, filter_subject text DEFAULT NULL::text, filter_grade text DEFAULT NULL::text, filter_year integer DEFAULT NULL::integer)
 RETURNS TABLE(id uuid, title text, subject text, grade text, year integer, topics text[], total_marks integer, language text, rank real)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    ep.id,
    ep.title,
    ep.subject,
    ep.grade,
    ep.year,
    ep.topics,
    ep.total_marks,
    ep.language,
    ts_rank(ep.search_vector, websearch_to_tsquery('english', search_query)) AS rank
  FROM exam_papers ep
  WHERE 
    (search_query IS NULL OR ep.search_vector @@ websearch_to_tsquery('english', search_query))
    AND (filter_subject IS NULL OR ep.subject = filter_subject)
    AND (filter_grade IS NULL OR ep.grade = filter_grade)
    AND (filter_year IS NULL OR ep.year = filter_year)
  ORDER BY rank DESC, ep.year DESC, ep.title;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.search_textbooks(search_query text, search_grade text DEFAULT NULL::text, search_subject text DEFAULT NULL::text)
 RETURNS TABLE(id uuid, title text, grade text, subject text, publisher text, cover_url text, total_pages integer, is_free boolean, rank real)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT
    t.id,
    t.title,
    t.grade,
    t.subject,
    t.publisher,
    t.cover_url,
    t.total_pages,
    t.is_free,
    ts_rank(
      to_tsvector('english', t.title || ' ' || COALESCE(t.description, '') || ' ' || t.subject),
      plainto_tsquery('english', search_query)
    ) AS rank
  FROM public.textbooks t
  WHERE
    t.is_active = true
    AND (search_grade IS NULL OR t.grade = search_grade)
    AND (search_subject IS NULL OR t.subject = search_subject)
    AND (
      to_tsvector('english', t.title || ' ' || COALESCE(t.description, '') || ' ' || t.subject)
      @@ plainto_tsquery('english', search_query)
    )
  ORDER BY rank DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.send_connection_request(p_requester_id uuid, p_addressee_id uuid, p_connection_type character varying DEFAULT 'cross_school'::character varying)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_existing_connection RECORD;
BEGIN
  -- Check if already connected
  SELECT * INTO v_existing_connection
  FROM user_connections
  WHERE (requester_id = p_requester_id AND addressee_id = p_addressee_id)
     OR (requester_id = p_addressee_id AND addressee_id = p_requester_id);
  
  IF FOUND THEN
    IF v_existing_connection.status = 'blocked' THEN
      RETURN json_build_object('success', FALSE, 'error', 'Connection blocked');
    ELSIF v_existing_connection.status = 'accepted' THEN
      RETURN json_build_object('success', FALSE, 'error', 'Already connected');
    ELSIF v_existing_connection.status = 'pending' THEN
      RETURN json_build_object('success', FALSE, 'error', 'Request already pending');
    END IF;
  END IF;
  
  -- Check if addressee allows cross-school messages
  IF NOT EXISTS (
    SELECT 1 FROM contact_discovery_settings
    WHERE user_id = p_addressee_id AND allow_cross_school_messages = TRUE
  ) THEN
    RETURN json_build_object('success', FALSE, 'error', 'User does not accept connection requests');
  END IF;
  
  -- Create connection request
  INSERT INTO user_connections (requester_id, addressee_id, connection_type, status)
  VALUES (p_requester_id, p_addressee_id, p_connection_type, 'pending');
  
  -- TODO: Send push notification to addressee
  
  RETURN json_build_object('success', TRUE, 'status', 'pending');
END;
$function$
;

CREATE OR REPLACE FUNCTION public.send_direct_message(p_recipient_user_id uuid, p_content text, p_subject text DEFAULT ''::text, p_message_type text DEFAULT 'direct'::text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_sender_id    uuid;
  v_preschool_id uuid;
  v_recipient_id uuid;
  v_message_id   uuid;
  v_actual_type  text;
BEGIN
  -- Validate inputs
  IF p_recipient_user_id IS NULL THEN
    RAISE EXCEPTION 'Recipient user id is required' USING ERRCODE = '22023';
  END IF;

  IF p_content IS NULL OR btrim(p_content) = '' THEN
    RAISE EXCEPTION 'Message content cannot be empty' USING ERRCODE = '22023';
  END IF;

  -- Resolve current user -> users.id and preschool
  SELECT u.id, u.preschool_id
    INTO v_sender_id, v_preschool_id
  FROM public.users u
  WHERE u.auth_user_id = auth.uid();

  IF v_sender_id IS NULL THEN
    RAISE EXCEPTION 'Sender not found for current auth user' USING ERRCODE = '28000';
  END IF;

  -- Ensure recipient exists
  SELECT u.id
    INTO v_recipient_id
  FROM public.users u
  WHERE u.id = p_recipient_user_id;

  IF v_recipient_id IS NULL THEN
    RAISE EXCEPTION 'Recipient not found' USING ERRCODE = '22023';
  END IF;

  -- Optional safety: enforce same preschool when both sides have one
  IF EXISTS (
    SELECT 1
    FROM public.users r
    WHERE r.id = v_recipient_id
      AND r.preschool_id IS NOT NULL
      AND v_preschool_id IS NOT NULL
      AND r.preschool_id <> v_preschool_id
  ) THEN
    RAISE EXCEPTION 'Recipient not in the same preschool' USING ERRCODE = '42501';
  END IF;

  -- Normalize/validate message type
  v_actual_type := CASE 
    WHEN p_message_type IN ('text','image','file','announcement','system','direct') THEN p_message_type
    ELSE 'text'
  END;

  -- Insert the message
  INSERT INTO public.messages (
    content, message_type, sender_id, preschool_id, subject, sent_at
  ) VALUES (
    btrim(p_content), v_actual_type, v_sender_id, v_preschool_id, COALESCE(p_subject, ''), now()
  )
  RETURNING id INTO v_message_id;

  -- Insert the recipient record (used by queries and realtime)
  INSERT INTO public.message_recipients (message_id, recipient_id)
  VALUES (v_message_id, v_recipient_id);

  RETURN v_message_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.send_school_announcement(p_content text, p_audience text DEFAULT 'parents'::text, p_subject text DEFAULT ''::text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'pg_temp'
AS $function$
DECLARE
  v_sender_id uuid;
  v_preschool_id uuid;
  v_message_id uuid;
  v_audience text;
BEGIN
  IF p_content IS NULL OR btrim(p_content) = '' THEN
    RAISE EXCEPTION 'Announcement content cannot be empty' USING ERRCODE = '22023';
  END IF;

  -- Resolve current user and preschool context
  SELECT u.id, u.preschool_id INTO v_sender_id, v_preschool_id
  FROM public.users u
  WHERE u.auth_user_id = auth.uid();

  IF v_sender_id IS NULL THEN
    RAISE EXCEPTION 'Sender not found' USING ERRCODE = '28000';
  END IF;
  IF v_preschool_id IS NULL THEN
    RAISE EXCEPTION 'Sender is not linked to a preschool' USING ERRCODE = '42501';
  END IF;

  v_audience := lower(coalesce(p_audience, 'parents'));
  IF v_audience NOT IN ('parents','teachers','all') THEN
    v_audience := 'parents';
  END IF;

  -- Create the announcement message
  INSERT INTO public.messages (
    preschool_id,
    sender_id,
    subject,
    content,
    message_type,
    priority
  ) VALUES (
    v_preschool_id,
    v_sender_id,
    coalesce(p_subject, ''),
    btrim(p_content),
    'announcement',
    'normal'
  ) RETURNING id INTO v_message_id;

  -- Deliver to recipients based on audience
  IF v_audience = 'parents' THEN
    INSERT INTO public.message_recipients (message_id, recipient_type, recipient_id)
    SELECT v_message_id, 'user', u.id
    FROM public.users u
    WHERE u.preschool_id = v_preschool_id AND u.role = 'parent' AND coalesce(u.is_active, true) = true;
  ELSIF v_audience = 'teachers' THEN
    INSERT INTO public.message_recipients (message_id, recipient_type, recipient_id)
    SELECT v_message_id, 'user', u.id
    FROM public.users u
    WHERE u.preschool_id = v_preschool_id AND u.role IN ('teacher','preschool_admin','principal') AND coalesce(u.is_active, true) = true;
  ELSE -- all
    INSERT INTO public.message_recipients (message_id, recipient_type, recipient_id)
    SELECT v_message_id, 'user', u.id
    FROM public.users u
    WHERE u.preschool_id = v_preschool_id AND u.role IN ('teacher','preschool_admin','principal','parent') AND coalesce(u.is_active, true) = true;
  END IF;

  -- Create notifications for recipients
  INSERT INTO public.notifications (user_id, title, message, type, action_url)
  SELECT mr.recipient_id,
         CASE WHEN v_audience = 'teachers' THEN 'New Staff Announcement' ELSE 'New School Announcement' END,
         left(btrim(p_content), 140),
         'info',
         '/messages'
  FROM public.message_recipients mr
  WHERE mr.message_id = v_message_id;

  RETURN v_message_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.send_school_announcement(p_content text, p_subject text DEFAULT ''::text, p_include_parents boolean DEFAULT true, p_include_staff boolean DEFAULT false, p_include_sender boolean DEFAULT true)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_sender_id uuid;
  v_preschool_id uuid;
  v_message_id uuid;
  v_roles text[] := ARRAY[]::text[];
begin
  -- Resolve current user and preschool
  select id, preschool_id into v_sender_id, v_preschool_id
  from public.users
  where auth_user_id = auth.uid();

  if v_sender_id is null or v_preschool_id is null then
    raise exception 'User not associated with a preschool or not authenticated';
  end if;

  -- Insert the message
  insert into public.messages (preschool_id, sender_id, subject, content, message_type)
  values (v_preschool_id, v_sender_id, coalesce(p_subject, ''), p_content, 'announcement')
  returning id into v_message_id;

  -- Build role filter
  if p_include_parents then
    v_roles := v_roles || ARRAY['parent'];
  end if;
  if p_include_staff then
    v_roles := v_roles || ARRAY['teacher','preschool_admin','admin','principal'];
  end if;

  -- Insert recipients: audience in same preschool
  -- Note: message_recipients only has (message_id, recipient_id) columns
  if array_length(v_roles, 1) is not null then
    insert into public.message_recipients (message_id, recipient_id)
    select v_message_id, u.id
    from public.users u
    where u.preschool_id = v_preschool_id
      and u.role = any (v_roles)
      and u.id <> v_sender_id;
  end if;

  -- Optionally include sender so they also see it under Announcements
  if p_include_sender then
    insert into public.message_recipients (message_id, recipient_id)
    values (v_message_id, v_sender_id);
  end if;

  return v_message_id;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.set_current_timestamp_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_invite_tokens()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Generate invite token if not provided
  IF NEW.invite_token IS NULL THEN
    NEW.invite_token := generate_invite_token();
  END IF;
  
  -- Generate invite code for invite types
  IF NEW.invite_code IS NULL AND NEW.request_type IN ('teacher_invite', 'staff_invite', 'member_join') THEN
    -- Try up to 10 times to generate unique code
    FOR i IN 1..10 LOOP
      NEW.invite_code := generate_invite_code();
      BEGIN
        -- Check if code exists
        PERFORM 1 FROM join_requests WHERE invite_code = NEW.invite_code;
        IF NOT FOUND THEN
          EXIT; -- Unique code found
        END IF;
      EXCEPTION WHEN OTHERS THEN
        EXIT; -- On error, proceed with current code
      END;
    END LOOP;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_profile_age_group()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  -- Auto-compute age_group from date_of_birth
  new.age_group := public.compute_age_group(new.date_of_birth);
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.set_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  new.updated_at = now();
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.set_user_as_principal(p_user_id uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_current_role TEXT;
  v_result JSONB;
BEGIN
  -- Check if user exists
  SELECT role INTO v_current_role
  FROM public.profiles
  WHERE id = p_user_id;

  IF v_current_role IS NULL THEN
    RAISE EXCEPTION 'User not found' USING ERRCODE = '22023';
  END IF;

  -- Update role to principal if not already
  IF v_current_role != 'principal' AND v_current_role != 'superadmin' THEN
    UPDATE public.profiles
    SET role = 'principal'
    WHERE id = p_user_id;

    v_result := jsonb_build_object(
      'success', TRUE,
      'message', 'Role updated to principal',
      'previous_role', v_current_role,
      'new_role', 'principal'
    );
  ELSE
    v_result := jsonb_build_object(
      'success', TRUE,
      'message', 'User already has elevated role',
      'current_role', v_current_role
    );
  END IF;

  RETURN v_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_user_language(p_user_id uuid, p_language text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- Validate language is one of the supported AI/TTS languages
  IF p_language NOT IN ('en', 'af', 'zu') THEN
    -- Default to English for unsupported languages
    p_language := 'en';
  END IF;
  
  UPDATE public.profiles
  SET preferred_language = p_language,
      updated_at = NOW()
  WHERE id = p_user_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.slugify(input text)
 RETURNS text
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
declare
  s text;
begin
  s := lower(coalesce(input,''));
  s := regexp_replace(s, '[^a-z0-9]+', '-', 'g');
  s := regexp_replace(s, '(^-+|-+$)', '', 'g');
  if s is null or length(s) = 0 then
    s := 'school-' || substr(replace(gen_random_uuid()::text, '-', ''), 1, 8);
  end if;
  return s;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.start_parent_trial()
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_user_id uuid;
  v_user_role text;
  v_existing_subscription subscriptions%ROWTYPE;
  v_starter_plan_id uuid;
  v_free_plan_id uuid;
  v_new_subscription_id uuid;
BEGIN
  -- Get the authenticated user ID
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Not authenticated'
    );
  END IF;
  
  -- Get user's role
  SELECT role INTO v_user_role
  FROM profiles
  WHERE id = v_user_id;
  
  -- Allow both 'parent' role and NULL role (for new signups that haven't set role yet)
  -- This ensures parents can get trials even if they skip school selection
  IF v_user_role IS NOT NULL AND v_user_role != 'parent' THEN
    RETURN json_build_object(
      'success', false,
      'error', 'User trials are only available for parents',
      'role', v_user_role
    );
  END IF;
  
  -- Check if user already has a subscription
  SELECT * INTO v_existing_subscription
  FROM subscriptions
  WHERE owner_type = 'user' 
  AND user_id = v_user_id
  LIMIT 1;
  
  -- If subscription exists, return its status
  IF FOUND THEN
    RETURN json_build_object(
      'success', true,
      'already_exists', true,
      'subscription_id', v_existing_subscription.id,
      'status', v_existing_subscription.status,
      'trial_end_date', v_existing_subscription.trial_end_date,
      'message', 'User subscription already exists'
    );
  END IF;
  
  -- Get starter plan ID (default trial plan)
  SELECT id INTO v_starter_plan_id
  FROM subscription_plans
  WHERE tier = 'starter'
  AND is_active = true
  LIMIT 1;
  
  -- Get free plan ID (fallback)
  SELECT id INTO v_free_plan_id
  FROM subscription_plans
  WHERE tier = 'free'
  AND is_active = true
  LIMIT 1;
  
  IF v_starter_plan_id IS NULL AND v_free_plan_id IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'No subscription plans available'
    );
  END IF;
  
  -- Create new user-level trial subscription
  INSERT INTO subscriptions (
    owner_type,
    user_id,
    school_id,
    plan_id,
    status,
    start_date,
    trial_end_date,
    next_billing_date,
    seats_total,
    seats_used,
    billing_frequency
  ) VALUES (
    'user',
    v_user_id,
    NULL, -- No school_id for user subscriptions
    COALESCE(v_starter_plan_id, v_free_plan_id),
    'trialing',
    NOW(),
    NOW() + INTERVAL '7 days', -- 7-day trial for parents
    NOW() + INTERVAL '8 days', -- Billing would start after trial
    1, -- One seat for the parent
    1, -- Seat is used by the parent
    'monthly'
  )
  RETURNING id INTO v_new_subscription_id;
  
  RAISE NOTICE 'Created 7-day trial subscription for user %', v_user_id;
  
  RETURN json_build_object(
    'success', true,
    'subscription_id', v_new_subscription_id,
    'status', 'trialing',
    'trial_end_date', NOW() + INTERVAL '7 days',
    'days_remaining', 7,
    'message', '7-day trial started successfully'
  );
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object(
      'success', false,
      'error', SQLERRM
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.start_user_trial(target_user_id uuid, trial_days integer DEFAULT 7, plan_tier text DEFAULT 'premium'::text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_user_email TEXT;
  v_user_phone TEXT;
  v_has_used_trial BOOLEAN;
  v_trial_tier TEXT;
BEGIN
  -- Get user email and phone
  SELECT email, phone INTO v_user_email, v_user_phone
  FROM profiles
  WHERE id = target_user_id;

  -- Check if trial already used (by email, phone, or user_id)
  SELECT has_used_trial(v_user_email, v_user_phone, NULL) INTO v_has_used_trial;
  
  IF v_has_used_trial THEN
    RAISE EXCEPTION 'User has already used their trial period';
  END IF;

  -- Map plan_tier to tier_name_aligned enum
  v_trial_tier := CASE plan_tier
    WHEN 'premium' THEN 'parent_plus'
    WHEN 'starter' THEN 'parent_starter'
    ELSE 'parent_starter'
  END;

  -- Set trial in user_ai_tiers
  INSERT INTO user_ai_tiers (
    user_id,
    tier,
    assigned_reason,
    is_active,
    trial_ends_at,
    metadata
  ) VALUES (
    target_user_id,
    v_trial_tier,
    'Trial activation',
    true,
    NOW() + (trial_days || ' days')::INTERVAL,
    jsonb_build_object(
      'trial_started_at', NOW(),
      'trial_days', trial_days,
      'plan_tier', plan_tier
    )
  )
  ON CONFLICT (user_id) DO UPDATE SET
    tier = v_trial_tier,
    assigned_reason = 'Trial activation',
    is_active = true,
    trial_ends_at = NOW() + (trial_days || ' days')::INTERVAL,
    metadata = jsonb_build_object(
      'trial_started_at', NOW(),
      'trial_days', trial_days,
      'plan_tier', plan_tier
    ),
    updated_at = NOW();

  -- Update user_ai_usage
  INSERT INTO user_ai_usage (user_id, current_tier)
  VALUES (target_user_id, v_trial_tier)
  ON CONFLICT (user_id) DO UPDATE SET
    current_tier = v_trial_tier,
    updated_at = NOW();

  -- Set is_trial flag in profiles
  UPDATE profiles
  SET is_trial = true
  WHERE id = target_user_id;

  -- Log trial activation permanently
  PERFORM log_trial_activation(
    target_user_id,
    v_user_email,
    v_user_phone,
    NULL, -- device_fingerprint (can be added from client)
    jsonb_build_object(
      'plan_tier', plan_tier,
      'trial_days', trial_days,
      'activation_source', 'start_user_trial'
    )
  );

  RETURN jsonb_build_object(
    'success', true,
    'trial_tier', v_trial_tier,
    'trial_days', trial_days,
    'expires_at', NOW() + (trial_days || ' days')::INTERVAL
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.superadmin_approve_onboarding(request_id uuid)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  current_user_role text;
  request_exists boolean;
BEGIN
  -- Check if current user is superadmin
  SELECT role INTO current_user_role
  FROM users 
  WHERE auth_user_id = auth.uid();
  
  IF current_user_role != 'superadmin' THEN
    RETURN json_build_object(
      'success', false, 
      'message', 'Access denied: Superadmin role required'
    );
  END IF;
  
  -- Check if request exists
  SELECT EXISTS(
    SELECT 1 FROM preschool_onboarding_requests 
    WHERE id = request_id
  ) INTO request_exists;
  
  IF NOT request_exists THEN
    RETURN json_build_object(
      'success', false, 
      'message', 'Onboarding request not found'
    );
  END IF;
  
  -- Update the request status
  UPDATE preschool_onboarding_requests 
  SET 
    status = 'approved',
    reviewed_at = now(),
    reviewed_by = (SELECT id FROM users WHERE auth_user_id = auth.uid())
  WHERE id = request_id;
  
  RETURN json_build_object(
    'success', true, 
    'message', 'Onboarding request approved successfully'
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.superadmin_onboard_school(p_school_data jsonb, p_principal_data jsonb, p_subscription_data jsonb DEFAULT NULL::jsonb)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_school_id UUID;
  v_principal_id UUID;
  v_subscription_id UUID;
  v_onboarding_id UUID;
  v_current_user_id UUID := auth.uid();
  v_result JSON;
  v_error_msg TEXT;
  v_school_name TEXT;
  v_school_type VARCHAR(20);
  v_principal_email TEXT;
  v_principal_name TEXT;
BEGIN
  -- Check if current user is superadmin
  IF NOT EXISTS (
    SELECT 1 FROM public.users 
    WHERE id = v_current_user_id 
    AND role = 'superadmin'
  ) THEN
    RETURN json_build_object('error', 'Unauthorized: Superadmin access required');
  END IF;
  
  -- Extract and validate school data
  v_school_name := p_school_data->>'name';
  v_school_type := COALESCE(p_school_data->>'school_type', 'preschool');
  
  IF v_school_name IS NULL OR LENGTH(TRIM(v_school_name)) = 0 THEN
    RETURN json_build_object('error', 'School name is required');
  END IF;
  
  -- Extract and validate principal data
  v_principal_email := p_principal_data->>'email';
  v_principal_name := p_principal_data->>'name';
  
  IF v_principal_email IS NULL OR v_principal_email !~ '^[^\s@]+@[^\s@]+\.[^\s@]+$' THEN
    RETURN json_build_object('error', 'Valid principal email is required');
  END IF;
  
  -- Check for existing school
  IF EXISTS (SELECT 1 FROM public.preschools WHERE name = TRIM(v_school_name)) THEN
    RETURN json_build_object('error', 'School name already exists');
  END IF;
  
  -- Create school record
  INSERT INTO public.preschools (
    name,
    school_type,
    grade_levels,
    contact_email,
    contact_phone,
    physical_address,
    verification_status,
    onboarding_flow,
    registration_notes,
    created_at
  )
  VALUES (
    TRIM(v_school_name),
    v_school_type,
    COALESCE(
      (SELECT ARRAY(SELECT jsonb_array_elements_text(p_school_data->'grade_levels'))),
      ARRAY['pre_k']
    ),
    p_school_data->>'contact_email',
    p_school_data->>'contact_phone',
    p_school_data->>'physical_address',
    'manual_override', -- Superadmin bypass verification
    'superadmin_invite',
    p_school_data->>'notes',
    NOW()
  )
  RETURNING id INTO v_school_id;
  
  -- Create onboarding progress tracker
  INSERT INTO public.onboarding_progress (
    school_id,
    flow_type,
    current_step,
    completed_steps,
    step_data,
    created_by
  )
  VALUES (
    v_school_id,
    'superadmin_invite',
    'school_created',
    ARRAY['school_created'],
    json_build_object(
      'school_data', p_school_data,
      'principal_data', p_principal_data,
      'subscription_data', p_subscription_data,
      'created_by_admin', v_current_user_id
    ),
    v_current_user_id
  )
  RETURNING id INTO v_onboarding_id;
  
  -- Create subscription if provided
  IF p_subscription_data IS NOT NULL AND p_subscription_data->>'plan_id' IS NOT NULL THEN
    -- Use existing subscription creation RPC
    SELECT id INTO v_subscription_id
    FROM public.subscriptions
    WHERE school_id = v_school_id
    AND plan_id = (p_subscription_data->>'plan_id')
    LIMIT 1;
    
    -- If no subscription exists, create one
    IF v_subscription_id IS NULL THEN
      INSERT INTO public.subscriptions (
        school_id,
        plan_id,
        status,
        seats_total,
        seats_used,
        created_at
      )
      VALUES (
        v_school_id,
        (p_subscription_data->>'plan_id')::UUID,
        'active',
        COALESCE((p_subscription_data->>'seats')::INTEGER, 5),
        0,
        NOW()
      )
      RETURNING id INTO v_subscription_id;
    END IF;
  END IF;
  
  -- Notify the creating admin (confirmation)
  PERFORM create_system_notification(
    v_current_user_id,
    'School Created Successfully',
    TRIM(v_school_name) || ' has been created and is ready for principal invitation.',
    'school_creation_success',
    json_build_object(
      'school_id', v_school_id,
      'school_name', TRIM(v_school_name),
      'school_type', v_school_type,
      'has_subscription', v_subscription_id IS NOT NULL
    )
  );
  
  -- Build success response
  v_result := json_build_object(
    'success', TRUE,
    'school_id', v_school_id,
    'subscription_id', v_subscription_id,
    'onboarding_id', v_onboarding_id,
    'next_step', 'principal_invitation',
    'message', 'School created successfully. Principal invitation can be sent.'
  );
  
  -- Log the creation
  INSERT INTO public.audit_logs (
    user_id,
    action,
    table_name,
    record_id,
    old_values,
    new_values,
    metadata
  )
  VALUES (
    v_current_user_id,
    'superadmin_school_creation',
    'preschools',
    v_school_id,
    '{}',
    json_build_object(
      'name', v_school_name,
      'school_type', v_school_type,
      'onboarding_flow', 'superadmin_invite'
    ),
    json_build_object(
      'subscription_created', v_subscription_id IS NOT NULL,
      'principal_data', p_principal_data
    )
  );
  
  RETURN v_result;
  
EXCEPTION
  WHEN OTHERS THEN
    GET STACKED DIAGNOSTICS v_error_msg = MESSAGE_TEXT;
    RETURN json_build_object(
      'error', 'School creation failed: ' || v_error_msg
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.superadmin_reactivate_user(target_user_id uuid, reason text DEFAULT NULL::text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- Check if current user is superadmin
  IF NOT is_superadmin() THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Access denied: Superadmin privileges required'
    );
  END IF;

  -- Reactivate user (using basic approach for compatibility)
  UPDATE public.users
  SET
    is_active = true,
    updated_at = NOW()
  WHERE auth_user_id = target_user_id;

  RETURN json_build_object(
    'success', true,
    'message', 'User reactivated successfully',
    'target_user_id', target_user_id,
    'reason', reason
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.superadmin_request_user_deletion(target_user_id uuid, deletion_reason text DEFAULT 'Administrative action'::text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  target_user RECORD;
BEGIN
  -- Check if current user is superladmin
  IF NOT is_superadmin() THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Access denied: Superladmin privileges required'
    );
  END IF;

  -- Get target user info
  SELECT * INTO target_user
  FROM public.users
  WHERE auth_user_id = target_user_id;

  -- Check if user exists
  IF NOT FOUND THEN
    RETURN json_build_object(
      'success', false,
      'error', 'User not found'
    );
  END IF;

  -- Prevent deletion of superladmin users
  IF target_user.role = 'super_admin' THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Cannot delete superladmin users'
    );
  END IF;

  -- Log the deletion request
  INSERT INTO error_logs (level, message, source, details)
  VALUES (
    'info',
    'User deletion requested by superladmin',
    'user_management',
    json_build_object(
      'target_user_id', target_user_id,
      'target_email', target_user.email,
      'target_role', target_user.role,
      'deletion_reason', deletion_reason,
      'admin_user_id', auth.uid()
    )
  );

  -- For now, just deactivate the user instead of hard deletion
  -- Hard deletion should be a separate process due to data integrity
  UPDATE public.users
  SET 
    is_active = false,
    updated_at = NOW()
  WHERE auth_user_id = target_user_id;

  RETURN json_build_object(
    'success', true,
    'message', 'User deactivated successfully (deletion logged for processing)',
    'target_user_id', target_user_id,
    'action_taken', 'deactivation',
    'reason', deletion_reason
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.superadmin_request_user_deletion(target_user_id uuid, deletion_type_param public.deletion_type_enum DEFAULT 'soft'::public.deletion_type_enum, reason_param text DEFAULT 'Administrative action'::text, internal_notes_param text DEFAULT NULL::text, scheduled_for_param timestamp with time zone DEFAULT NULL::timestamp with time zone)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  requester_id UUID;
  tenant_id_param UUID;
  request_id UUID;
  user_exists BOOLEAN;
  user_info RECORD;
  result JSONB;
BEGIN
  -- Get the current user (must be superadmin)
  requester_id := auth.uid();
  
  IF requester_id IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Authentication required',
      'code', 'AUTH_REQUIRED'
    );
  END IF;

  -- Verify superadmin permissions
  IF NOT is_superadmin_by_id(requester_id) THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Insufficient permissions - superadmin required',
      'code', 'INSUFFICIENT_PERMISSIONS'
    );
  END IF;

  -- Check if target user exists and get user info
  SELECT EXISTS(SELECT 1 FROM auth.users WHERE id = target_user_id) INTO user_exists;
  
  IF NOT user_exists THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'User not found',
      'code', 'USER_NOT_FOUND'
    );
  END IF;

  -- Get user information for audit trail
  SELECT 
    u.email,
    u.created_at as user_created_at,
    COALESCE(up.tenant_id, 'system'::UUID) as tenant_id,
    up.role,
    up.full_name
  INTO user_info
  FROM auth.users u
  LEFT JOIN user_profiles up ON u.id = up.user_id
  WHERE u.id = target_user_id;

  tenant_id_param := user_info.tenant_id;

  -- Prevent deletion of other superadmins unless GDPR compliance
  IF is_superadmin_by_id(target_user_id) AND deletion_type_param != 'gdpr_compliance' AND target_user_id != requester_id THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Cannot delete other superadmin accounts (use GDPR compliance deletion if required)',
      'code', 'CANNOT_DELETE_SUPERADMIN'
    );
  END IF;

  -- Check if there's already a pending deletion request
  IF EXISTS(
    SELECT 1 FROM superadmin_user_deletion_requests 
    WHERE user_id = target_user_id AND status IN ('pending', 'in_progress')
  ) THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Deletion request already exists for this user',
      'code', 'DUPLICATE_REQUEST'
    );
  END IF;

  -- Create deletion request
  INSERT INTO superadmin_user_deletion_requests (
    user_id,
    requester_id,
    tenant_id,
    deletion_type,
    reason,
    internal_notes,
    scheduled_for,
    metadata
  ) VALUES (
    target_user_id,
    requester_id,
    tenant_id_param,
    deletion_type_param,
    reason_param,
    internal_notes_param,
    scheduled_for_param,
    jsonb_build_object(
      'user_info', to_jsonb(user_info),
      'ip_address', inet_client_addr()::text,
      'user_agent', current_setting('request.headers', true)::json->>'user-agent'
    )
  ) RETURNING id INTO request_id;

  -- Log the action
  PERFORM log_superadmin_action(
    requester_id,
    target_user_id,
    tenant_id_param,
    'user_deleted'::superadmin_action_enum,
    'user',
    target_user_id::text,
    format('Deletion request created for user %s (%s)', user_info.email, deletion_type_param),
    jsonb_build_object(
      'deletion_type', deletion_type_param,
      'reason', reason_param,
      'scheduled_for', scheduled_for_param
    ),
    jsonb_build_object(
      'request_id', request_id
    )
  );

  -- Return success response
  result := jsonb_build_object(
    'success', true,
    'request_id', request_id,
    'message', format('Deletion request created for user %s', user_info.email),
    'deletion_type', deletion_type_param,
    'status', 'pending'
  );

  -- If immediate soft deletion, process it now
  IF deletion_type_param = 'soft' AND scheduled_for_param IS NULL THEN
    PERFORM process_user_deletion_request(request_id);
    result := result || jsonb_build_object('processed', true);
  END IF;

  RETURN result;

EXCEPTION
  WHEN OTHERS THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Internal server error: ' || SQLERRM,
      'code', 'INTERNAL_ERROR'
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.superadmin_suspend_user(target_user_id uuid, escalation_level_param public.escalation_level_enum DEFAULT 'suspension'::public.escalation_level_enum, reason_param text DEFAULT 'Policy violation'::text, duration_days integer DEFAULT NULL::integer, auto_reactivate boolean DEFAULT false)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  admin_id UUID;
  tenant_id_param UUID;
  user_info RECORD;
  suspension_end TIMESTAMP WITH TIME ZONE;
BEGIN
  admin_id := auth.uid();
  
  -- Verify superadmin permissions
  IF NOT is_superadmin_by_id(admin_id) THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Insufficient permissions',
      'code', 'INSUFFICIENT_PERMISSIONS'
    );
  END IF;

  -- Get user information
  SELECT 
    up.tenant_id,
    up.email,
    up.full_name,
    up.role,
    up.is_active
  INTO user_info
  FROM user_profiles up
  WHERE up.user_id = target_user_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'User not found',
      'code', 'USER_NOT_FOUND'
    );
  END IF;

  tenant_id_param := user_info.tenant_id;

  -- Prevent suspension of other superadmins
  IF is_superadmin_by_id(target_user_id) AND target_user_id != admin_id THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Cannot suspend other superadmin accounts',
      'code', 'CANNOT_SUSPEND_SUPERADMIN'
    );
  END IF;

  -- Calculate suspension end time if duration is specified
  IF duration_days IS NOT NULL THEN
    suspension_end := now() + (duration_days || ' days')::interval;
  END IF;

  -- Update user profile based on escalation level
  UPDATE user_profiles
  SET 
    is_active = CASE 
      WHEN escalation_level_param = 'warning' THEN true 
      ELSE false 
    END,
    suspension_level = escalation_level_param::text,
    suspension_reason = reason_param,
    suspended_at = CASE 
      WHEN escalation_level_param != 'warning' THEN now() 
      ELSE suspended_at 
    END,
    suspension_expires_at = suspension_end,
    auto_reactivate_enabled = auto_reactivate,
    updated_at = now()
  WHERE user_id = target_user_id;

  -- Log the action
  PERFORM log_superadmin_action(
    admin_id,
    target_user_id,
    tenant_id_param,
    'user_suspended'::superadmin_action_enum,
    'user',
    target_user_id::text,
    format('User %s suspended with level %s', user_info.email, escalation_level_param),
    to_jsonb(user_info),
    jsonb_build_object(
      'escalation_level', escalation_level_param,
      'reason', reason_param,
      'duration_days', duration_days,
      'suspension_end', suspension_end,
      'auto_reactivate', auto_reactivate
    )
  );

  -- Create risk assessment if not warning level
  IF escalation_level_param != 'warning' THEN
    INSERT INTO superadmin_user_risk_assessments (
      user_id,
      tenant_id,
      risk_score,
      assessment_reason,
      assessed_by,
      assessment_type,
      automated_flags
    ) VALUES (
      target_user_id,
      tenant_id_param,
      CASE escalation_level_param
        WHEN 'suspension' THEN 60
        WHEN 'termination' THEN 85
        ELSE 30
      END,
      reason_param,
      admin_id,
      'manual',
      jsonb_build_object(
        'suspension_trigger', true,
        'escalation_level', escalation_level_param
      )
    ) ON CONFLICT (user_id) DO UPDATE SET
      risk_score = EXCLUDED.risk_score,
      assessment_reason = EXCLUDED.assessment_reason,
      assessed_by = EXCLUDED.assessed_by,
      updated_at = now();
  END IF;

  RETURN jsonb_build_object(
    'success', true,
    'message', format('User %s %s successfully', 
      user_info.email,
      CASE escalation_level_param
        WHEN 'warning' THEN 'warned'
        WHEN 'suspension' THEN 'suspended'
        WHEN 'termination' THEN 'terminated'
      END
    ),
    'escalation_level', escalation_level_param,
    'suspension_end', suspension_end,
    'auto_reactivate', auto_reactivate
  );

EXCEPTION
  WHEN OTHERS THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Suspension failed: ' || SQLERRM,
      'code', 'SUSPENSION_ERROR'
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.superadmin_suspend_user(target_user_id uuid, reason text DEFAULT 'Administrative action'::text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- Check if current user is superadmin
  IF NOT is_superadmin() THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Access denied: Superadmin privileges required'
    );
  END IF;

  -- Suspend user (using basic approach for compatibility)
  UPDATE public.users 
  SET 
    is_active = false,
    updated_at = NOW()
  WHERE auth_user_id = target_user_id
  AND role != 'super_admin'; -- Prevent suspending other superadmins

  IF FOUND THEN
    RETURN json_build_object(
      'success', true,
      'message', 'User suspended successfully',
      'target_user_id', target_user_id,
      'reason', reason
    );
  ELSE
    RETURN json_build_object(
      'success', false,
      'error', 'User not found or cannot be suspended'
    );
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.superadmin_suspend_user(target_user_id uuid, suspension_type public.suspension_status_enum, reason text, duration_days integer DEFAULT NULL::integer)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  expires_at TIMESTAMPTZ;
BEGIN
  -- Check if current user is superadmin
  IF NOT is_superadmin() THEN
    RAISE EXCEPTION 'Access denied: Superadmin privileges required';
  END IF;

  -- Calculate expiration if duration provided
  IF duration_days IS NOT NULL THEN
    expires_at := NOW() + (duration_days || ' days')::INTERVAL;
  END IF;

  -- Update user suspension status
  UPDATE public.users 
  SET 
    suspension_status = suspension_type,
    suspension_reason = reason,
    suspended_at = NOW(),
    suspension_expires_at = expires_at,
    is_active = CASE WHEN suspension_type = 'suspended' THEN false ELSE is_active END
  WHERE auth_user_id = target_user_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Target user not found: %', target_user_id;
  END IF;

  -- Log the action
  PERFORM log_superadmin_action(
    'user_suspended'::superadmin_action_enum,
    json_build_object(
      'target_user_id', target_user_id,
      'suspension_type', suspension_type,
      'duration_days', duration_days,
      'expires_at', expires_at
    )::jsonb
  );

  RETURN json_build_object(
    'success', true,
    'message', format('User %s successfully', suspension_type::text),
    'expires_at', expires_at
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.superadmin_update_user_role(target_user_id uuid, new_role text, reason text DEFAULT 'Administrative role change'::text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  target_user RECORD;
  old_role TEXT;
BEGIN
  -- Check if current user is superadmin
  IF NOT is_superadmin() THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Access denied: Superadmin privileges required'
    );
  END IF;

  -- Validate new role
  IF new_role NOT IN ('principal', 'teacher', 'parent', 'super_admin') THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Invalid role. Must be: principal, teacher, parent, or super_admin'
    );
  END IF;

  -- Get target user info and current role
  SELECT * INTO target_user
  FROM public.users
  WHERE auth_user_id = target_user_id;

  -- Check if user exists
  IF NOT FOUND THEN
    RETURN json_build_object(
      'success', false,
      'error', 'User not found'
    );
  END IF;

  old_role := target_user.role;

  -- Prevent changing role from/to superadmin unless current user is superadmin
  IF (old_role = 'super_admin' OR new_role = 'super_admin') AND NOT is_superadmin() THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Cannot change superadmin role'
    );
  END IF;

  -- Update the user role
  UPDATE public.users
  SET 
    role = new_role::text,
    updated_at = NOW()
  WHERE auth_user_id = target_user_id;

  -- Log the role change
  INSERT INTO error_logs (level, message, source, details)
  VALUES (
    'info',
    'User role updated by superadmin',
    'user_management',
    json_build_object(
      'target_user_id', target_user_id,
      'target_email', target_user.email,
      'old_role', old_role,
      'new_role', new_role,
      'reason', reason,
      'admin_user_id', auth.uid()
    )
  );

  RETURN json_build_object(
    'success', true,
    'message', 'User role updated successfully',
    'target_user_id', target_user_id,
    'old_role', old_role,
    'new_role', new_role,
    'reason', reason
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.sync_campaign_to_edusite()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  request_id int;
  payload jsonb;
BEGIN
  -- Build payload based on operation
  IF TG_OP = 'DELETE' THEN
    payload := jsonb_build_object(
      'operation', TG_OP,
      'old_record', row_to_json(OLD)
    );
  ELSE
    payload := jsonb_build_object(
      'operation', TG_OP,
      'record', row_to_json(NEW),
      'old_record', CASE WHEN TG_OP = 'UPDATE' THEN row_to_json(OLD) ELSE NULL END
    );
  END IF;

  -- Call Edge Function (it will use its own service_role_key from environment)
  SELECT INTO request_id net.http_post(
    url := 'https://lvvvjywrmpcqrpvuptdi.supabase.co/functions/v1/sync-campaign-to-edusite',
    headers := jsonb_build_object(
      'Content-Type', 'application/json'
    ),
    body := payload
  );

  RAISE NOTICE '[Campaign Sync] % operation synced to EduSitePro. Request ID: %', TG_OP, request_id;

  RETURN COALESCE(NEW, OLD);
EXCEPTION WHEN OTHERS THEN
  RAISE WARNING '[Campaign Sync] Failed to sync: %', SQLERRM;
  RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.sync_organization_membership()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- If user has preschool_id, ensure organization membership exists
  IF NEW.preschool_id IS NOT NULL THEN
    INSERT INTO public.organization_members (
      user_id, 
      organization_id, 
      role,
      seat_status
    )
    VALUES (
      NEW.auth_user_id,
      NEW.preschool_id,
      NEW.role,
      CASE WHEN NEW.role IN ('teacher', 'principal', 'principal_admin') THEN 'active' ELSE 'inactive' END
    )
    ON CONFLICT (user_id, organization_id) 
    DO UPDATE SET 
      role = EXCLUDED.role,
      updated_at = NOW();
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.sync_organization_tier(p_org_id uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_tier text;
  v_result jsonb;
BEGIN
  -- Get tier from active subscription
  SELECT 
    sp.tier INTO v_tier
  FROM subscriptions s
  JOIN subscription_plans sp ON s.plan_id = sp.id
  WHERE s.school_id = p_org_id
    AND s.status = 'active'
  ORDER BY s.end_date DESC
  LIMIT 1;
  
  -- If no active subscription, default to 'free'
  IF v_tier IS NULL THEN
    v_tier := 'free';
  END IF;
  
  -- Map unsupported tier values to valid ones
  -- Allowed: free, starter, professional, enterprise, parent-starter, parent-plus
  v_tier := CASE
    WHEN v_tier IN ('free', 'starter', 'professional', 'enterprise', 'parent-starter', 'parent-plus') THEN v_tier
    WHEN v_tier IN ('premium', 'pro') THEN 'professional'
    WHEN v_tier IN ('basic') THEN 'starter'
    ELSE 'free'
  END;
  
  -- Update both preschools and organizations
  UPDATE preschools
  SET subscription_tier = v_tier
  WHERE id = p_org_id;
  
  UPDATE organizations
  SET plan_tier = v_tier
  WHERE id = p_org_id;
  
  -- Return result
  v_result := jsonb_build_object(
    'organization_id', p_org_id,
    'tier', v_tier,
    'synced', true,
    'timestamp', now()
  );
  
  RETURN v_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.sync_profile_avatar_to_org_members()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- When a profile avatar is updated, sync it to organization_members
  IF TG_OP = 'UPDATE' AND (NEW.avatar_url IS DISTINCT FROM OLD.avatar_url) THEN
    UPDATE organization_members
    SET photo_url = NEW.avatar_url,
        updated_at = NOW()
    WHERE user_id = NEW.id;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.sync_profile_seat_status()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_auth_user_id uuid;
  v_role text;
BEGIN
  -- Get auth_user_id for the affected seat
  SELECT u.auth_user_id, p.role 
  INTO v_auth_user_id, v_role
  FROM public.users u
  LEFT JOIN public.profiles p ON p.id = u.auth_user_id
  WHERE u.id = COALESCE(NEW.user_id, OLD.user_id);
  
  -- Only update if it's a teacher
  IF v_role != 'teacher' OR v_auth_user_id IS NULL THEN
    RETURN COALESCE(NEW, OLD);
  END IF;
  
  -- Update profile seat_status based on operation
  IF TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND NEW.revoked_at IS NULL) THEN
    -- Seat assigned or reactivated
    UPDATE public.profiles
    SET seat_status = 'active'
    WHERE id = v_auth_user_id;
  ELSIF (TG_OP = 'UPDATE' AND NEW.revoked_at IS NOT NULL) OR TG_OP = 'DELETE' THEN
    -- Seat revoked or deleted - check if they have any other active seats
    IF NOT EXISTS (
      SELECT 1 
      FROM public.subscription_seats ss2
      JOIN public.users u2 ON u2.id = ss2.user_id
      WHERE u2.auth_user_id = v_auth_user_id
        AND ss2.revoked_at IS NULL
        AND ss2.id != COALESCE(NEW.id, OLD.id)
    ) THEN
      UPDATE public.profiles
      SET seat_status = 'inactive'
      WHERE id = v_auth_user_id;
    END IF;
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.sync_subscription_tier_to_ai_tables()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- Upsert to user_ai_tiers (uses tier_name_aligned enum)
  INSERT INTO user_ai_tiers (user_id, tier, updated_at)
  VALUES (NEW.id, NEW.subscription_tier, NOW())
  ON CONFLICT (user_id) 
  DO UPDATE SET 
    tier = EXCLUDED.tier,
    updated_at = NOW();
  
  -- Upsert to user_ai_usage (also uses tier_name_aligned enum)
  INSERT INTO user_ai_usage (user_id, current_tier, updated_at)
  VALUES (NEW.id, NEW.subscription_tier, NOW())
  ON CONFLICT (user_id) 
  DO UPDATE SET 
    current_tier = EXCLUDED.current_tier,
    updated_at = NOW();
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.sync_teacher_from_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_preschool_id uuid;
  v_full_name text;
BEGIN
  IF TG_OP = 'DELETE' THEN
    -- Remove teacher row when user is deleted
    DELETE FROM public.teachers WHERE user_id = OLD.id;
    RETURN OLD;
  END IF;

  -- Compute tenant and display name from NEW
  v_preschool_id := COALESCE(NEW.preschool_id, NEW.organization_id);
  v_full_name := TRIM(BOTH FROM COALESCE(CONCAT(NEW.first_name, ' ', NEW.last_name), NEW.name, NEW.email));

  IF TG_OP = 'INSERT' THEN
    IF NEW.role = 'teacher' THEN
      INSERT INTO public.teachers (user_id, auth_user_id, preschool_id, full_name, email, role, is_active, created_at, updated_at)
      VALUES (NEW.id, NEW.auth_user_id, v_preschool_id, v_full_name, NEW.email, 'teacher', COALESCE(NEW.is_active, true), now(), now())
      ON CONFLICT (user_id) DO UPDATE SET
        auth_user_id = EXCLUDED.auth_user_id,
        preschool_id = EXCLUDED.preschool_id,
        full_name = EXCLUDED.full_name,
        email = EXCLUDED.email,
        is_active = EXCLUDED.is_active,
        updated_at = now();
    END IF;
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN
    IF NEW.role = 'teacher' THEN
      INSERT INTO public.teachers (user_id, auth_user_id, preschool_id, full_name, email, role, is_active, created_at, updated_at)
      VALUES (NEW.id, NEW.auth_user_id, v_preschool_id, v_full_name, NEW.email, 'teacher', COALESCE(NEW.is_active, true), now(), now())
      ON CONFLICT (user_id) DO UPDATE SET
        auth_user_id = EXCLUDED.auth_user_id,
        preschool_id = EXCLUDED.preschool_id,
        full_name = EXCLUDED.full_name,
        email = EXCLUDED.email,
        is_active = EXCLUDED.is_active,
        updated_at = now();
    ELSE
      -- Role changed away from teacher 
      DELETE FROM public.teachers WHERE user_id = NEW.id;
    END IF;
    RETURN NEW;
  END IF;

  RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.sync_user_contacts(p_user_id uuid, p_contact_hashes json)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_contact JSON;
  v_matched_user_id UUID;
  v_match_count INT := 0;
  v_new_count INT := 0;
BEGIN
  -- Check if user has enabled contact sync
  IF NOT EXISTS (
    SELECT 1 FROM contact_discovery_settings
    WHERE user_id = p_user_id AND allow_contact_sync = TRUE
  ) THEN
    RETURN json_build_object(
      'success', FALSE,
      'error', 'Contact sync is disabled'
    );
  END IF;
  
  -- Process each contact hash
  FOR v_contact IN SELECT * FROM json_array_elements(p_contact_hashes)
  LOOP
    -- Try to find matching user by phone number hash
    SELECT upn.user_id INTO v_matched_user_id
    FROM user_phone_numbers upn
    JOIN contact_discovery_settings cds ON cds.user_id = upn.user_id
    WHERE encode(sha256((upn.phone_number)::bytea), 'hex') = (v_contact->>'hash')
    AND upn.is_verified = TRUE
    AND cds.allow_phone_discovery = TRUE
    AND upn.user_id != p_user_id
    LIMIT 1;
    
    -- Insert or update contact
    INSERT INTO user_contacts (user_id, phone_number_hash, contact_name, matched_user_id)
    VALUES (
      p_user_id,
      v_contact->>'hash',
      v_contact->>'name',
      v_matched_user_id
    )
    ON CONFLICT (user_id, phone_number_hash)
    DO UPDATE SET
      matched_user_id = EXCLUDED.matched_user_id,
      contact_name = COALESCE(EXCLUDED.contact_name, user_contacts.contact_name);
    
    -- Create suggestion if matched
    IF v_matched_user_id IS NOT NULL THEN
      v_match_count := v_match_count + 1;
      
      INSERT INTO contact_suggestions (user_id, suggested_user_id, reason, confidence_score)
      VALUES (p_user_id, v_matched_user_id, 'phone_contact', 95)
      ON CONFLICT (user_id, suggested_user_id) DO NOTHING;
    ELSE
      v_new_count := v_new_count + 1;
    END IF;
  END LOOP;
  
  RETURN json_build_object(
    'success', TRUE,
    'matches_found', v_match_count,
    'new_contacts', v_new_count
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.teacher_self_subscribe(p_plan_id text, p_billing_frequency text DEFAULT 'monthly'::text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare v_id uuid; v_start timestamptz := now(); v_end timestamptz; begin
  if p_billing_frequency = 'annual' then v_end := v_start + interval '1 year'; else v_end := v_start + interval '1 month'; end if;
  insert into public.subscriptions(id, user_id, plan_id, status, owner_type, billing_frequency, start_date, end_date, next_billing_date, seats_total, seats_used, metadata)
  values (gen_random_uuid(), auth.uid(), p_plan_id, 'active', 'user', p_billing_frequency, v_start, v_end, v_end, 1, 1, jsonb_build_object('created_by','teacher_self'))
  returning id into v_id;
  return v_id;
end; $function$
;

create or replace view "public"."teacher_stats" as  SELECT u.id,
    u.name AS full_name,
    u.email,
    u.phone,
    u.role,
    u.preschool_id,
    u.created_at AS hire_date,
    count(DISTINCT c.id) AS classes_assigned,
    count(DISTINCT s.id) AS students_count,
        CASE
            WHEN (u.role = 'teacher'::text) THEN 'active'::text
            ELSE 'inactive'::text
        END AS status
   FROM ((public.users u
     LEFT JOIN public.classes c ON ((c.teacher_id = u.id)))
     LEFT JOIN public.students s ON ((s.class_id = c.id)))
  WHERE (u.role = 'teacher'::text)
  GROUP BY u.id, u.name, u.email, u.phone, u.role, u.preschool_id, u.created_at;


create or replace view "public"."teachers_resolved" as  WITH has_teachers AS (
         SELECT (EXISTS ( SELECT 1
                   FROM public.teachers)) AS any_rows
        )
 SELECT t.user_id,
    t.auth_user_id,
    t.preschool_id,
    t.full_name,
    t.email,
    t.is_active
   FROM public.teachers t
UNION ALL
 SELECT u.id AS user_id,
    u.auth_user_id,
    COALESCE(u.preschool_id, u.organization_id) AS preschool_id,
    TRIM(BOTH FROM COALESCE(concat(u.first_name, ' ', u.last_name), u.name, u.email)) AS full_name,
    u.email,
    COALESCE(u.is_active, true) AS is_active
   FROM ((public.users u
     LEFT JOIN public.teachers t2 ON ((u.id = t2.user_id)))
     CROSS JOIN has_teachers ht)
  WHERE ((ht.any_rows = false) AND (u.role = 'teacher'::text) AND (t2.user_id IS NULL));


create or replace view "public"."template_performance_metrics" as  SELECT t.id,
    t.template_key,
    t.name,
    t.category,
    t.status,
    t.usage_count,
    t.last_used_at,
    count(tul.id) AS total_uses,
    count(
        CASE
            WHEN (tul.delivery_success = true) THEN 1
            ELSE NULL::integer
        END) AS successful_deliveries,
    count(
        CASE
            WHEN (tul.delivery_success = false) THEN 1
            ELSE NULL::integer
        END) AS failed_deliveries,
    round(avg(
        CASE
            WHEN (tul.delivery_success = true) THEN 100.0
            ELSE 0.0
        END), 2) AS success_rate_percent,
    avg(tul.render_time_ms) AS avg_render_time_ms,
    max(tul.render_time_ms) AS max_render_time_ms,
    min(tul.render_time_ms) AS min_render_time_ms,
    max(tul.created_at) AS last_usage_tracked,
    count(
        CASE
            WHEN (tul.created_at > (now() - '24:00:00'::interval)) THEN 1
            ELSE NULL::integer
        END) AS uses_last_24h,
    count(
        CASE
            WHEN (tul.created_at > (now() - '7 days'::interval)) THEN 1
            ELSE NULL::integer
        END) AS uses_last_7d
   FROM (public.notification_templates t
     LEFT JOIN public.template_usage_logs tul ON ((t.id = tul.template_id)))
  GROUP BY t.id, t.template_key, t.name, t.category, t.status, t.usage_count, t.last_used_at;


CREATE OR REPLACE FUNCTION public.test_auth_uid()
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    current_uid UUID;
BEGIN
    BEGIN
        current_uid := auth.uid();
        IF current_uid IS NULL THEN
            RETURN 'auth.uid() returns NULL - normal during login';
        ELSE
            RETURN 'auth.uid() returns: ' || current_uid::text;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN 'ERROR calling auth.uid(): ' || SQLERRM;
    END;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.test_jwt_claims()
 RETURNS TABLE(user_id uuid, preschool_id_claim text, organization_id_claim text, role_claim text, computed_preschool_id uuid, computed_role text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY SELECT
    auth.uid() as user_id,
    auth.jwt() ->> 'preschool_id' as preschool_id_claim,
    auth.jwt() ->> 'organization_id' as organization_id_claim,
    auth.jwt() ->> 'role' as role_claim,
    current_preschool_id() as computed_preschool_id,
    current_user_role() as computed_role;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.test_messaging_user_context()
 RETURNS TABLE(auth_user_id uuid, internal_user_id uuid, user_exists boolean, user_active boolean, has_preschool boolean, preschool_id uuid, user_role text, error_message text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_auth_uid uuid;
  v_internal_id uuid;
  v_user_record record;
  v_error_msg text := 'No error';
BEGIN
  BEGIN
    v_auth_uid := auth.uid();
    
    IF v_auth_uid IS NULL THEN
      v_error_msg := 'No authenticated user (auth.uid() is null)';
    ELSE
      -- Try to get user record
      SELECT u.id, u.is_active, u.preschool_id, u.role 
      INTO v_user_record
      FROM public.users u
      WHERE u.auth_user_id = v_auth_uid
      LIMIT 1;
      
      IF v_user_record.id IS NULL THEN
        v_error_msg := 'User not found in users table';
      END IF;
      
      v_internal_id := v_user_record.id;
    END IF;
    
    RETURN QUERY
    SELECT 
      v_auth_uid as auth_user_id,
      v_internal_id as internal_user_id,
      (v_user_record.id IS NOT NULL) as user_exists,
      COALESCE(v_user_record.is_active, false) as user_active,
      (v_user_record.preschool_id IS NOT NULL) as has_preschool,
      v_user_record.preschool_id as preschool_id,
      COALESCE(v_user_record.role, 'unknown') as user_role,
      v_error_msg as error_message;
      
  EXCEPTION WHEN OTHERS THEN
    RETURN QUERY
    SELECT 
      v_auth_uid as auth_user_id,
      NULL::uuid as internal_user_id,
      false as user_exists,
      false as user_active,
      false as has_preschool,
      NULL::uuid as preschool_id,
      'error'::text as user_role,
      ('Exception: ' || SQLERRM)::text as error_message;
  END;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.test_onboarding_access()
 RETURNS TABLE(can_select boolean, can_insert boolean, user_role text, jwt_role text, user_id uuid)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    (SELECT COUNT(*) > 0 FROM public.preschool_onboarding_requests LIMIT 1) as can_select,
    true as can_insert, -- We'll assume insert works if select works
    (SELECT role FROM public.users WHERE auth_user_id = auth.uid()) as user_role,
    (auth.jwt() ->> 'role') as jwt_role,
    auth.uid() as user_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.test_rpc()
 RETURNS text
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
  SELECT 'RPC functions are working correctly'::TEXT;
$function$
;

CREATE OR REPLACE FUNCTION public.test_superadmin_system()
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_user_id UUID;
  v_user_role TEXT;
  v_superadmin_count INTEGER;
  v_system_status TEXT;
BEGIN
  -- Get current user
  v_user_id := auth.uid();
  
  -- Get user's role
  SELECT role INTO v_user_role
  FROM profiles
  WHERE id = v_user_id;
  
  -- Count total superadmins
  SELECT COUNT(*) INTO v_superadmin_count
  FROM profiles
  WHERE role = 'superadmin';
  
  -- Determine system status
  IF v_superadmin_count = 0 THEN
    v_system_status := 'no_superadmins';
  ELSIF v_user_role = 'superadmin' THEN
    v_system_status := 'operational';
  ELSE
    v_system_status := 'limited_access';
  END IF;
  
  -- Return comprehensive status
  RETURN json_build_object(
    'test_suite', 'SuperAdmin System Test',
    'run_at', NOW(),
    'superadmin_count', v_superadmin_count,
    'current_user_role', COALESCE(v_user_role, 'unknown'),
    'current_user_id', v_user_id,
    'is_superadmin', (v_user_role = 'superadmin'),
    'system_status', v_system_status
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.tg_sync_school_preschool_id()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF NEW.school_id IS NULL AND NEW.preschool_id IS NOT NULL THEN
    NEW.school_id := NEW.preschool_id;
  ELSIF NEW.preschool_id IS NULL AND NEW.school_id IS NOT NULL THEN
    NEW.preschool_id := NEW.school_id;
  END IF;
  RETURN NEW;
END
$function$
;

CREATE OR REPLACE FUNCTION public.toggle_superadmin_agent(agent_id_param text, new_status text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM public.profiles 
        WHERE id = auth.uid() 
        AND role IN ('super_admin', 'superadmin')
    ) THEN
        RAISE EXCEPTION 'Unauthorized: Super admin access required';
    END IF;
    
    IF new_status NOT IN ('active', 'idle', 'disabled') THEN
        RAISE EXCEPTION 'Invalid status: %', new_status;
    END IF;
    
    UPDATE public.superadmin_ai_agents 
    SET status = new_status, updated_at = now() 
    WHERE id = agent_id_param;
    
    RETURN FOUND;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.toggle_superadmin_task(task_id_param text, is_enabled_param boolean)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM public.profiles 
        WHERE id = auth.uid() 
        AND role IN ('super_admin', 'superadmin')
    ) THEN
        RAISE EXCEPTION 'Unauthorized: Super admin access required';
    END IF;
    
    UPDATE public.superadmin_autonomous_tasks 
    SET is_enabled = is_enabled_param, updated_at = now() 
    WHERE id = task_id_param;
    
    RETURN FOUND;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_assign_student_class()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Only auto-assign if preschool_id and date_of_birth exist, and class_id is null
  IF NEW.preschool_id IS NOT NULL 
     AND NEW.date_of_birth IS NOT NULL 
     AND NEW.class_id IS NULL THEN
    
    NEW.class_id := assign_student_to_class(
      NEW.id,
      NEW.preschool_id,
      NEW.date_of_birth
    );
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_gradebook_update()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    affected_course_id UUID;
    affected_student_id UUID;
BEGIN
    -- Get course and student IDs from the grade change
    SELECT a.course_id, s.student_id
    INTO affected_course_id, affected_student_id
    FROM submissions s
    JOIN assignments a ON a.id = s.assignment_id
    WHERE s.id = COALESCE(NEW.submission_id, OLD.submission_id);
    
    -- Update gradebook entry
    IF affected_course_id IS NOT NULL AND affected_student_id IS NOT NULL THEN
        PERFORM update_gradebook_entry(affected_course_id, affected_student_id);
    END IF;
    
    RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_sync_approval_to_edusite()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  request_id bigint;
BEGIN
  -- Only trigger on status change to approved/rejected/waitlisted
  IF (TG_OP = 'UPDATE' AND 
      OLD.status IS DISTINCT FROM NEW.status AND 
      NEW.status IN ('approved', 'rejected', 'waitlisted')) THEN
    
    -- Call Edge Function (it will use its own credentials from environment)
    SELECT INTO request_id net.http_post(
      url := 'https://lvvvjywrmpcqrpvuptdi.supabase.co/functions/v1/sync-approval-to-edusite',
      headers := jsonb_build_object(
        'Content-Type', 'application/json'
      ),
      body := jsonb_build_object(
        'record', to_jsonb(NEW),
        'old_record', to_jsonb(OLD)
      )
    );
    
    RAISE NOTICE '[Approval Sync] Status changed to % for registration %. Request ID: %', NEW.status, NEW.id, request_id;
  END IF;
  
  RETURN NEW;
EXCEPTION WHEN OTHERS THEN
  RAISE WARNING '[Approval Sync] Failed to sync: %', SQLERRM;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_sync_campaign_to_edusite()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  request_id bigint;
  service_role_key text;
  edudash_function_url text;
BEGIN
  -- Get service role key from vault
  SELECT decrypted_secret INTO service_role_key
  FROM vault.decrypted_secrets
  WHERE name = 'service_role_key'
  LIMIT 1;

  -- EduDashPro Edge Function URL
  edudash_function_url := 'https://lvvvjywrmpcqrpvuptdi.supabase.co/functions/v1/sync-campaign-to-edusite';

  -- Call Edge Function to sync to EduSitePro
  SELECT INTO request_id
    net.http_post(
      url := edudash_function_url,
      headers := jsonb_build_object(
        'Content-Type', 'application/json',
        'Authorization', 'Bearer ' || service_role_key
      ),
      body := jsonb_build_object(
        'type', TG_OP,
        'table', TG_TABLE_NAME,
        'schema', TG_TABLE_SCHEMA,
        'record', CASE WHEN TG_OP = 'DELETE' THEN NULL ELSE row_to_json(NEW) END,
        'old_record', CASE WHEN TG_OP IN ('UPDATE', 'DELETE') THEN row_to_json(OLD) ELSE NULL END
      )
    );

  -- Log the sync attempt
  RAISE NOTICE '[Campaign Sync] % operation synced to EduSitePro. Request ID: %', TG_OP, request_id;

  -- Return appropriate value based on operation
  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  ELSE
    RETURN NEW;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_sync_delete_to_edusite()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  request_id bigint;
BEGIN
  -- Call Edge Function with hardcoded URL
  SELECT INTO request_id net.http_post(
    url := 'https://lvvvjywrmpcqrpvuptdi.supabase.co/functions/v1/sync-delete-to-edusite',
    headers := jsonb_build_object(
      'Content-Type', 'application/json'
    ),
    body := jsonb_build_object(
      'old_record', to_jsonb(OLD)
    )
  );
  
  RAISE NOTICE '[Delete Sync] Registration deleted: %. Request ID: %', OLD.id, request_id;
  
  RETURN OLD;
EXCEPTION WHEN OTHERS THEN
  RAISE WARNING '[Delete Sync] Failed to sync: %', SQLERRM;
  RETURN OLD;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_sync_payment_to_edusite()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  request_id bigint;
BEGIN
  -- Only trigger on payment_verified change
  IF (TG_OP = 'UPDATE' AND 
      OLD.payment_verified IS DISTINCT FROM NEW.payment_verified) THEN
    
    -- Call Edge Function to sync payment status to EduSitePro
    SELECT INTO request_id net.http_post(
      url := 'https://lvvvjywrmpcqrpvuptdi.supabase.co/functions/v1/sync-payment-to-edusite',
      headers := jsonb_build_object(
        'Content-Type', 'application/json'
      ),
      body := jsonb_build_object(
        'record', to_jsonb(NEW),
        'old_record', to_jsonb(OLD)
      )
    );
    
    RAISE NOTICE '[Payment Sync] Payment verification changed to % for registration %. Request ID: %', NEW.payment_verified, NEW.id, request_id;
  END IF;
  
  RETURN NEW;
EXCEPTION WHEN OTHERS THEN
  RAISE WARNING '[Payment Sync] Failed to sync: %', SQLERRM;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_sync_tier_on_subscription_change()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Sync tier when subscription status or plan changes
  IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') AND NEW.status = 'active' THEN
    PERFORM public.sync_organization_tier(NEW.school_id);
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_sync_unverify_to_edusite()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  request_id bigint;
BEGIN
  -- Only sync if payment_verified changed from true to false
  IF OLD.payment_verified = true AND NEW.payment_verified = false THEN
    
    -- Call Edge Function with hardcoded URL
    SELECT INTO request_id net.http_post(
      url := 'https://lvvvjywrmpcqrpvuptdi.supabase.co/functions/v1/sync-unverify-to-edusite',
      headers := jsonb_build_object(
        'Content-Type', 'application/json'
      ),
      body := jsonb_build_object(
        'record', to_jsonb(NEW),
        'old_record', to_jsonb(OLD)
      )
    );
    
    RAISE NOTICE '[Unverify Sync] Payment unverified for registration %. Request ID: %', NEW.id, request_id;
  END IF;
  
  RETURN NEW;
EXCEPTION WHEN OTHERS THEN
  RAISE WARNING '[Unverify Sync] Failed to sync: %', SQLERRM;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.uid()
 RETURNS uuid
 LANGUAGE sql
 STABLE
AS $function$ select auth.uid() $function$
;

CREATE OR REPLACE FUNCTION public.unblock_user(p_blocked_user_id uuid, p_block_type character varying DEFAULT 'user'::character varying)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_current_user_id UUID := auth.uid();
  v_result JSONB;
BEGIN
  -- Validate input
  IF v_current_user_id IS NULL THEN
    RETURN json_build_object('error', 'Authentication required');
  END IF;
  
  -- Update block record to inactive
  UPDATE public.user_blocks
  SET 
    is_active = FALSE,
    updated_at = NOW()
  WHERE 
    blocker_id = v_current_user_id 
    AND blocked_id = p_blocked_user_id
    AND block_type = p_block_type
    AND is_active = TRUE;
  
  IF FOUND THEN
    v_result := json_build_object(
      'success', TRUE,
      'message', 'User unblocked successfully'
    );
  ELSE
    v_result := json_build_object(
      'error', 'Block record not found or already inactive'
    );
  END IF;
  
  RETURN v_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.unlink_user_from_school(user_id uuid)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    user_profile profiles%ROWTYPE;
BEGIN
    SELECT * INTO user_profile FROM profiles WHERE id = user_id;
    
    IF NOT FOUND THEN
        RETURN json_build_object('success', false, 'error', 'User not found');
    END IF;
    
    -- Update profile
    UPDATE profiles
    SET 
        preschool_id = NULL,
        usage_type = 'standalone',
        updated_at = NOW()
    WHERE id = user_id;
    
    -- Add to standalone_users
    INSERT INTO standalone_users (
        user_id,
        profile_id,
        user_type,
        subscription_tier,
        usage_type
    ) VALUES (
        user_id,
        user_id,
        user_profile.role,
        'free',
        'standalone'
    )
    ON CONFLICT (user_id) DO UPDATE SET updated_at = NOW();
    
    RETURN json_build_object(
        'success', true,
        'user_id', user_id,
        'message', 'User unlinked from school'
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_aftercare_registrations_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_ai_messages_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_announcements_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_board_positions_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_budget_spent()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- When a transaction is marked as paid, update the relevant budget
  IF NEW.status = 'paid' AND NEW.transaction_type = 'expense' THEN
    UPDATE organization_budgets
    SET spent_amount = spent_amount + NEW.amount,
        updated_at = now()
    WHERE organization_id = NEW.organization_id
      AND fiscal_year = EXTRACT(YEAR FROM NEW.payment_date)
      AND category = NEW.category
      AND status = 'active'
      AND (region_id = NEW.region_id OR (region_id IS NULL AND NEW.region_id IS NULL))
      AND (wing_id = NEW.wing_id OR (wing_id IS NULL AND NEW.wing_id IS NULL));
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_chat_images_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_class_enrollment_on_student_change()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- When a student is inserted with active/enrolled status
  IF (TG_OP = 'INSERT' AND NEW.status IN ('active', 'enrolled') AND NEW.class_id IS NOT NULL) THEN
    PERFORM increment_class_enrollment(NEW.class_id);
  END IF;

  -- When a student's status changes
  IF (TG_OP = 'UPDATE') THEN
    -- Student moved from active/enrolled to inactive/graduated/withdrawn
    IF (OLD.status IN ('active', 'enrolled') AND NEW.status NOT IN ('active', 'enrolled')) THEN
      IF OLD.class_id IS NOT NULL THEN
        PERFORM decrement_class_enrollment(OLD.class_id);
      END IF;
    END IF;
    
    -- Student moved from inactive/graduated/withdrawn to active/enrolled
    IF (OLD.status NOT IN ('active', 'enrolled') AND NEW.status IN ('active', 'enrolled')) THEN
      IF NEW.class_id IS NOT NULL THEN
        PERFORM increment_class_enrollment(NEW.class_id);
      END IF;
    END IF;
    
    -- Student moved to a different class (while active/enrolled)
    IF (NEW.status IN ('active', 'enrolled') AND OLD.class_id IS DISTINCT FROM NEW.class_id) THEN
      IF OLD.class_id IS NOT NULL THEN
        PERFORM decrement_class_enrollment(OLD.class_id);
      END IF;
      IF NEW.class_id IS NOT NULL THEN
        PERFORM increment_class_enrollment(NEW.class_id);
      END IF;
    END IF;
  END IF;

  -- When a student is deleted
  IF (TG_OP = 'DELETE' AND OLD.status IN ('active', 'enrolled') AND OLD.class_id IS NOT NULL) THEN
    PERFORM decrement_class_enrollment(OLD.class_id);
  END IF;

  RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_dash_storage_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_dashboard_voice_notes_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_deletion_requests_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_delivery_status(p_delivery_id uuid, p_status public.delivery_status_enum, p_provider_message_id text DEFAULT NULL::text, p_provider_response jsonb DEFAULT NULL::jsonb, p_error_message text DEFAULT NULL::text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_id UUID;
  v_is_superadmin BOOLEAN;
  v_delivery notification_deliveries%ROWTYPE;
BEGIN
  -- Get current user ID
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Authentication required',
      'error_code', 'AUTH_REQUIRED'
    );
  END IF;
  
  -- Check if user is superadmin
  SELECT EXISTS (
    SELECT 1 FROM user_profiles 
    WHERE user_id = v_user_id 
    AND role = 'super_admin' 
    AND is_active = true
  ) INTO v_is_superadmin;
  
  IF NOT v_is_superadmin THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Superadmin privileges required',
      'error_code', 'INSUFFICIENT_PRIVILEGES'
    );
  END IF;
  
  -- Get existing delivery
  SELECT * FROM notification_deliveries WHERE id = p_delivery_id INTO v_delivery;
  
  IF NOT FOUND THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Delivery not found',
      'error_code', 'DELIVERY_NOT_FOUND'
    );
  END IF;
  
  -- Update delivery status
  UPDATE notification_deliveries SET
    status = p_status,
    provider_message_id = COALESCE(p_provider_message_id, provider_message_id),
    provider_response = COALESCE(p_provider_response, provider_response),
    provider_error_message = COALESCE(p_error_message, provider_error_message),
    sent_at = CASE WHEN p_status = 'sent' AND sent_at IS NULL THEN now() ELSE sent_at END,
    delivered_at = CASE WHEN p_status = 'delivered' AND delivered_at IS NULL THEN now() ELSE delivered_at END,
    bounced_at = CASE WHEN p_status = 'bounced' AND bounced_at IS NULL THEN now() ELSE bounced_at END,
    complained_at = CASE WHEN p_status = 'complained' AND complained_at IS NULL THEN now() ELSE complained_at END,
    updated_at = now()
  WHERE id = p_delivery_id;
  
  RETURN json_build_object(
    'success', true,
    'delivery_id', p_delivery_id,
    'status', p_status,
    'message', 'Delivery status updated successfully'
  );
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object(
      'success', false,
      'error', SQLERRM,
      'error_code', 'INTERNAL_ERROR'
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_document_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_event_participant_count()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF TG_OP = 'INSERT' AND NEW.status = 'accepted' THEN
    UPDATE public.events 
    SET current_participants = current_participants + 1
    WHERE id = NEW.event_id;
  ELSIF TG_OP = 'UPDATE' AND OLD.status != 'accepted' AND NEW.status = 'accepted' THEN
    UPDATE public.events 
    SET current_participants = current_participants + 1
    WHERE id = NEW.event_id;
  ELSIF TG_OP = 'UPDATE' AND OLD.status = 'accepted' AND NEW.status != 'accepted' THEN
    UPDATE public.events 
    SET current_participants = current_participants - 1
    WHERE id = NEW.event_id;
  ELSIF TG_OP = 'DELETE' AND OLD.status = 'accepted' THEN
    UPDATE public.events 
    SET current_participants = current_participants - 1
    WHERE id = OLD.event_id;
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_event_statuses()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  -- Ongoing: between start and end
  update public.events
    set status = 'ongoing', updated_at = now()
  where status <> 'cancelled'
    and start_date <= now()
    and end_date is not null
    and end_date >= now()
    and status is distinct from 'ongoing';

  -- Ongoing: start passed, no end
  update public.events
    set status = 'ongoing', updated_at = now()
  where status <> 'cancelled'
    and start_date <= now()
    and end_date is null
    and status is distinct from 'ongoing';

  -- Completed: now past end
  update public.events
    set status = 'completed', updated_at = now()
  where status <> 'cancelled'
    and end_date is not null
    and end_date < now()
    and status is distinct from 'completed';

  -- Completed: no end_date, now past start
  update public.events
    set status = 'completed', updated_at = now()
  where status <> 'cancelled'
    and end_date is null
    and start_date < now()
    and status is distinct from 'completed';

  -- Upcoming: before start
  update public.events
    set status = 'upcoming', updated_at = now()
  where status <> 'cancelled'
    and start_date > now()
    and status is distinct from 'upcoming';
end;
$function$
;

CREATE OR REPLACE FUNCTION public.update_exam_papers_search_vector()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.search_vector := to_tsvector('english',
    coalesce(NEW.title, '') || ' ' ||
    coalesce(NEW.subject, '') || ' ' ||
    coalesce(NEW.grade, '') || ' ' ||
    coalesce(array_to_string(NEW.topics, ' '), '')
  );
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_fee_assignment_on_payment()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  assignment_record RECORD;
BEGIN
  IF NEW.status = 'completed' THEN
    -- Update the fee assignment
    UPDATE public.student_fee_assignments
    SET 
      paid_amount_cents = paid_amount_cents + NEW.amount_cents,
      paid_date = CASE WHEN balance_cents <= NEW.amount_cents THEN NEW.payment_date ELSE paid_date END,
      status = CASE 
        WHEN balance_cents <= NEW.amount_cents THEN 'paid'
        WHEN paid_amount_cents > 0 THEN 'partial'
        ELSE status
      END,
      updated_at = NOW()
    WHERE id = NEW.student_fee_assignment_id;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_fee_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_full_name()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.full_name := TRIM(COALESCE(NEW.first_name, '') || ' ' || COALESCE(NEW.last_name, ''));
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_gradebook_entry(course_id uuid, student_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    total_earned DECIMAL(10,2) := 0;
    total_possible DECIMAL(10,2) := 0;
    current_letter_grade TEXT;
BEGIN
    -- Calculate totals from published grades
    SELECT 
        COALESCE(SUM(g.points_earned), 0),
        COALESCE(SUM(g.points_possible), 0)
    INTO total_earned, total_possible
    FROM grades g
    JOIN submissions s ON s.id = g.submission_id
    JOIN assignments a ON a.id = s.assignment_id
    WHERE a.course_id = update_gradebook_entry.course_id
    AND s.student_id = update_gradebook_entry.student_id
    AND g.is_published = true
    AND a.deleted_at IS NULL;
    
    -- Calculate letter grade
    IF total_possible > 0 THEN
        current_letter_grade := public.percentage_to_letter_grade((total_earned / total_possible) * 100);
    ELSE
        current_letter_grade := NULL;
    END IF;
    
    -- Update or insert gradebook entry
    INSERT INTO gradebook_entries (
        course_id, 
        student_id, 
        total_points_earned, 
        total_points_possible, 
        current_letter_grade
    )
    VALUES (
        update_gradebook_entry.course_id, 
        update_gradebook_entry.student_id, 
        total_earned, 
        total_possible, 
        current_letter_grade
    )
    ON CONFLICT (course_id, student_id)
    DO UPDATE SET
        total_points_earned = EXCLUDED.total_points_earned,
        total_points_possible = EXCLUDED.total_points_possible,
        current_letter_grade = EXCLUDED.current_letter_grade,
        updated_at = now();
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_invite_logs_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_job_postings_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_join_requests_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at := NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_lessons_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_memory_recency_score()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Calculate recency score: newer memories and frequently accessed ones get higher scores
  NEW.recency_score := 1.0 / (1.0 + EXTRACT(EPOCH FROM (now() - NEW.created_at)) / 86400.0)
                     + (NEW.accessed_count * 0.1);
  NEW.updated_at := now();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_notification_template(p_template_id uuid, p_name text DEFAULT NULL::text, p_description text DEFAULT NULL::text, p_subject_template text DEFAULT NULL::text, p_body_template text DEFAULT NULL::text, p_html_template text DEFAULT NULL::text, p_variables jsonb DEFAULT NULL::jsonb, p_default_variables jsonb DEFAULT NULL::jsonb, p_required_variables text[] DEFAULT NULL::text[], p_language text DEFAULT NULL::text, p_localization_key text DEFAULT NULL::text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'auth'
AS $function$
DECLARE
  v_user_id UUID;
  v_is_superadmin BOOLEAN;
  v_template_record notification_templates%ROWTYPE;
  v_new_version INTEGER;
BEGIN
  -- Get current user ID
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Authentication required',
      'error_code', 'AUTH_REQUIRED'
    );
  END IF;
  
  -- Check if user is superadmin
  SELECT EXISTS (
    SELECT 1 FROM user_profiles 
    WHERE user_id = v_user_id 
    AND role = 'super_admin' 
    AND is_active = true
  ) INTO v_is_superadmin;
  
  IF NOT v_is_superadmin THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Superadmin privileges required',
      'error_code', 'INSUFFICIENT_PRIVILEGES'
    );
  END IF;
  
  -- Get existing template
  SELECT * FROM notification_templates 
  WHERE id = p_template_id 
  INTO v_template_record;
  
  IF NOT FOUND THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Template not found',
      'error_code', 'TEMPLATE_NOT_FOUND'
    );
  END IF;
  
  -- Cannot edit system templates
  IF v_template_record.is_system_template THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Cannot edit system templates',
      'error_code', 'SYSTEM_TEMPLATE_READONLY'
    );
  END IF;
  
  -- Increment version for active templates
  IF v_template_record.status = 'active' THEN
    v_new_version := v_template_record.version + 1;
  ELSE 
    v_new_version := v_template_record.version;
  END IF;
  
  -- Update template
  UPDATE notification_templates SET
    name = COALESCE(p_name, name),
    description = COALESCE(p_description, description),
    subject_template = COALESCE(p_subject_template, subject_template),
    body_template = COALESCE(p_body_template, body_template),
    html_template = COALESCE(p_html_template, html_template),
    variables = COALESCE(p_variables, variables),
    default_variables = COALESCE(p_default_variables, default_variables),
    required_variables = COALESCE(p_required_variables, required_variables),
    language = COALESCE(p_language, language),
    localization_key = COALESCE(p_localization_key, localization_key),
    version = v_new_version,
    updated_by = v_user_id,
    updated_at = now()
  WHERE id = p_template_id;
  
  RETURN json_build_object(
    'success', true,
    'template_id', p_template_id,
    'version', v_new_version,
    'message', 'Template updated successfully'
  );
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object(
      'success', false,
      'error', SQLERRM,
      'error_code', 'INTERNAL_ERROR'
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_org_announcement_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_organizations_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
    new.updated_at = now();
    return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.update_petty_cash_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_preschool_subscription(p_preschool_id uuid, p_subscription_tier text, p_subscription_status text, p_subscription_plan_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- Check if caller is super admin or service role
  IF NOT (
    -- Super admin check
    EXISTS (
      SELECT 1 FROM public.profiles 
      WHERE id = auth.uid() 
      AND role IN ('superadmin', 'super_admin')
    )
    OR
    -- Service role bypass
    current_setting('role') = 'service_role'
  ) THEN
    RAISE EXCEPTION 'Access denied: Only super admins can update preschool subscriptions';
  END IF;

  -- Update the preschool subscription fields
  UPDATE public.preschools 
  SET 
    subscription_tier = p_subscription_tier,
    subscription_status = p_subscription_status,
    subscription_plan_id = p_subscription_plan_id,
    updated_at = NOW()
  WHERE id = p_preschool_id;

  -- Return true if row was updated, false if not found
  RETURN FOUND;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_push_subscriptions_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_region_invite_codes_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_registration_requests_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_resource_rating()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  UPDATE public.resources
  SET 
    average_rating = (
      SELECT ROUND(AVG(rating)::numeric, 2)
      FROM public.resource_reviews
      WHERE resource_id = COALESCE(NEW.resource_id, OLD.resource_id)
      AND is_public = true
      AND is_flagged = false
    ),
    rating_count = (
      SELECT COUNT(*)
      FROM public.resource_reviews
      WHERE resource_id = COALESCE(NEW.resource_id, OLD.resource_id)
      AND is_public = true
      AND is_flagged = false
    )
  WHERE id = COALESCE(NEW.resource_id, OLD.resource_id);
  
  RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_risk_level_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.risk_level = validate_risk_score(NEW.risk_score);
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_school_allocated_quotas()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Recalculate total allocated quotas for the school
  UPDATE school_ai_subscriptions 
  SET 
    allocated_quotas = (
      SELECT COALESCE((
        SELECT jsonb_object_agg(
          quota_type, 
          COALESCE(SUM((allocated_quotas->>quota_type)::int), 0)
        )
        FROM teacher_ai_allocations ta,
        jsonb_object_keys(ta.allocated_quotas) AS quota_type
        WHERE ta.preschool_id = NEW.preschool_id 
        AND ta.is_active = true
        AND ta.period_start <= now()
        AND ta.period_end > now()
        GROUP BY quota_type
      ), '{"claude_messages": 0, "content_generation": 0, "assessment_ai": 0}'::jsonb)
    ),
    updated_at = now()
  WHERE preschool_id = NEW.preschool_id;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_school_settings(p_preschool_id uuid, p_patch jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_id UUID;
  v_user_role TEXT;
  v_current_settings JSONB;
  v_result JSONB;
BEGIN
  -- Get current user
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;
  
  -- Get user's role and verify they belong to this preschool
  SELECT role INTO v_user_role
  FROM profiles
  WHERE id = v_user_id 
    AND (preschool_id = p_preschool_id OR organization_id = p_preschool_id);
  
  IF v_user_role IS NULL THEN
    RAISE EXCEPTION 'User does not belong to this school';
  END IF;
  
  -- Only principals can update school settings
  IF v_user_role NOT IN ('principal', 'principal_admin', 'super_admin', 'admin') THEN
    RAISE EXCEPTION 'Insufficient permissions to update school settings';
  END IF;
  
  -- Get current settings from preschools table
  SELECT COALESCE(settings, '{}'::jsonb) INTO v_current_settings
  FROM preschools
  WHERE id = p_preschool_id;
  
  IF NOT FOUND THEN
    RAISE EXCEPTION 'School not found';
  END IF;
  
  -- Merge patch into current settings (deep merge at top level)
  v_result := v_current_settings || p_patch;
  
  -- Update preschools.settings
  UPDATE preschools
  SET settings = v_result,
      updated_at = now()
  WHERE id = p_preschool_id;
  
  RETURN v_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_standalone_users_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_stem_progress_on_completion()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Only update if lesson has STEM category
  IF EXISTS (
    SELECT 1 FROM lesson_assignments la
    WHERE la.id = NEW.assignment_id
    AND la.stem_category != 'none'
  ) THEN
    INSERT INTO stem_progress (
      student_id, 
      preschool_id, 
      category, 
      lessons_completed,
      last_activity_date
    )
    SELECT 
      NEW.student_id,
      NEW.preschool_id,
      la.stem_category,
      1,
      CURRENT_DATE
    FROM lesson_assignments la
    WHERE la.id = NEW.assignment_id
    AND la.stem_category != 'none'
    ON CONFLICT (student_id, preschool_id, category)
    DO UPDATE SET
      lessons_completed = stem_progress.lessons_completed + 1,
      last_activity_date = CURRENT_DATE,
      updated_at = NOW();
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_student_streak(p_student_id uuid, p_streak_type text)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_preschool_id UUID;
  v_last_date DATE;
  v_current_streak INTEGER;
  v_longest_streak INTEGER;
BEGIN
  -- Get student's preschool
  SELECT preschool_id INTO v_preschool_id FROM students WHERE id = p_student_id;
  
  -- Get current streak data
  SELECT last_activity_date, current_streak, longest_streak 
  INTO v_last_date, v_current_streak, v_longest_streak
  FROM student_streaks 
  WHERE student_id = p_student_id AND streak_type = p_streak_type;
  
  IF NOT FOUND THEN
    -- Create new streak
    INSERT INTO student_streaks (student_id, preschool_id, streak_type, current_streak, longest_streak, last_activity_date)
    VALUES (p_student_id, v_preschool_id, p_streak_type, 1, 1, CURRENT_DATE);
    RETURN 1;
  END IF;
  
  -- Check if streak continues
  IF v_last_date = CURRENT_DATE - 1 THEN
    -- Continue streak
    v_current_streak := v_current_streak + 1;
    IF v_current_streak > v_longest_streak THEN
      v_longest_streak := v_current_streak;
    END IF;
  ELSIF v_last_date < CURRENT_DATE - 1 THEN
    -- Reset streak
    v_current_streak := 1;
  END IF;
  -- If same day, don't update
  
  UPDATE student_streaks SET
    current_streak = v_current_streak,
    longest_streak = v_longest_streak,
    last_activity_date = CURRENT_DATE,
    updated_at = now()
  WHERE student_id = p_student_id AND streak_type = p_streak_type;
  
  RETURN v_current_streak;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_submission_status_on_grade()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF NEW.status = 'published' THEN
    UPDATE public.assignment_submissions
    SET status = 'graded'
    WHERE id = NEW.submission_id
    AND status != 'graded';
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_subscription_seats_used()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  UPDATE public.subscriptions s
    SET seats_used = (
      SELECT COUNT(*) FROM public.subscription_seats ss WHERE ss.subscription_id = s.id
    )
  WHERE s.id = COALESCE(NEW.subscription_id, OLD.subscription_id);
  RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_superadmin_ai_agents_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_teacher_notes_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_thread_last_message_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    UPDATE message_threads 
    SET 
        last_message_at = NEW.created_at,
        updated_at = NOW()
    WHERE id = NEW.thread_id;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_typing_indicator(p_thread_id uuid, p_is_typing boolean)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  INSERT INTO public.typing_indicators (thread_id, user_id, is_typing, last_updated_at)
  VALUES (p_thread_id, auth.uid(), p_is_typing, NOW())
  ON CONFLICT (thread_id, user_id)
  DO UPDATE SET 
    is_typing = EXCLUDED.is_typing,
    last_updated_at = NOW();
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_typing_indicator_timestamp()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.last_updated_at = now();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_updated_at_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_user_last_login()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  UPDATE public.users
  SET last_login_at = NOW(),
      updated_at = NOW()
  WHERE id = auth.uid();
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_user_profiles_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.upsert_plan_quota(p_plan_tier text, p_quota_type text, p_monthly_limit integer, p_overage_enabled boolean, p_overage_unit_price numeric)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
  begin
    if exists (
      select 1 from public.plan_quotas where plan_tier = p_plan_tier and quota_type = p_quota_type
    ) then
      update public.plan_quotas
        set monthly_limit = p_monthly_limit,
            overage_enabled = p_overage_enabled,
            overage_unit_price = p_overage_unit_price,
            updated_at = now()
        where plan_tier = p_plan_tier and quota_type = p_quota_type;
    else
      insert into public.plan_quotas(
        id, plan_tier, quota_type, monthly_limit, overage_enabled, overage_unit_price, created_at, updated_at
      ) values (
        gen_random_uuid(), p_plan_tier, p_quota_type, p_monthly_limit, p_overage_enabled, p_overage_unit_price, now(), now()
      );
    end if;
  end;
  $function$
;

CREATE OR REPLACE FUNCTION public.upsert_user_presence(p_user_id uuid, p_status text DEFAULT 'online'::text, p_device_type text DEFAULT NULL::text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    INSERT INTO public.user_presence (user_id, status, last_seen_at, device_type, updated_at)
    VALUES (p_user_id, p_status, NOW(), p_device_type, NOW())
    ON CONFLICT (user_id) 
    DO UPDATE SET 
        status = EXCLUDED.status,
        last_seen_at = NOW(),
        device_type = COALESCE(EXCLUDED.device_type, user_presence.device_type),
        updated_at = NOW();
END;
$function$
;

CREATE OR REPLACE FUNCTION public.use_invitation_code(p_code text, p_auth_user_id uuid, p_name text, p_phone text DEFAULT NULL::text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'auth'
 SET row_security TO 'off'
AS $function$
DECLARE
  v_invitation public.school_invitation_codes%rowtype;
  v_profile_id uuid;
  v_profile_email text;
  v_auth_email text;
  v_full_name text := p_name;
  v_first text;
  v_last text;
  v_existing_profile_preschool_id uuid;
  v_actor_role text := auth.role();
  v_actor_id uuid := auth.uid();
BEGIN
  -- Only allow linking the authenticated user, unless called by service role.
  IF v_actor_role <> 'service_role' AND (v_actor_id IS NULL OR v_actor_id <> p_auth_user_id) THEN
    RAISE EXCEPTION 'Cannot redeem invitation for a different user';
  END IF;

  -- Lock and load the invitation row to prevent race conditions
  SELECT * INTO v_invitation
  FROM public.school_invitation_codes
  WHERE code = p_code
  FOR UPDATE;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Invalid or expired invitation code';
  END IF;

  -- Basic validations
  IF COALESCE(v_invitation.is_active, false) = false THEN
    RAISE EXCEPTION 'Invitation code is inactive';
  END IF;

  IF v_invitation.expires_at IS NOT NULL AND v_invitation.expires_at <= now() THEN
    RAISE EXCEPTION 'Invitation code has expired';
  END IF;

  IF v_invitation.max_uses IS NOT NULL AND v_invitation.max_uses > 0
     AND COALESCE(v_invitation.current_uses, 0) >= v_invitation.max_uses THEN
    RAISE EXCEPTION 'Invitation code has reached its maximum number of uses';
  END IF;

  IF v_invitation.invitation_type <> 'parent' THEN
    RAISE EXCEPTION 'Unsupported invitation type: %', v_invitation.invitation_type;
  END IF;

  -- Check if profile already exists and is linked to a DIFFERENT school
  SELECT preschool_id, email INTO v_existing_profile_preschool_id, v_profile_email
  FROM public.profiles
  WHERE id = p_auth_user_id;

  IF FOUND AND v_existing_profile_preschool_id IS NOT NULL
     AND v_existing_profile_preschool_id <> v_invitation.preschool_id THEN
    RAISE EXCEPTION 'You are already linked to a different school. Please contact support to change schools.';
  END IF;

  -- If profile is already linked to THIS school, just return success (idempotent)
  IF FOUND AND v_existing_profile_preschool_id = v_invitation.preschool_id THEN
    RETURN p_auth_user_id;
  END IF;

  -- Get auth email as fallback
  SELECT email INTO v_auth_email FROM auth.users WHERE id = p_auth_user_id;

  -- Derive name parts; fallback to email local part if needed
  IF v_full_name IS NULL OR btrim(v_full_name) = '' THEN
    v_full_name := COALESCE(split_part(COALESCE(v_profile_email, v_auth_email), '@', 1), 'Parent');
  END IF;
  v_first := btrim(split_part(v_full_name, ' ', 1));
  IF position(' ' in v_full_name) > 0 THEN
    v_last := btrim(substr(v_full_name, position(' ' in v_full_name) + 1));
  ELSE
    v_last := NULL;
  END IF;

  -- Update profile (primary table)
  UPDATE public.profiles
  SET preschool_id = v_invitation.preschool_id,
      organization_id = v_invitation.preschool_id,
      role = CASE WHEN role IS NULL OR role = 'parent' THEN 'parent' ELSE role END,
      auth_user_id = COALESCE(auth_user_id, id),
      phone = COALESCE(phone, p_phone),
      first_name = COALESCE(NULLIF(first_name, ''), v_first),
      last_name = COALESCE(NULLIF(last_name, ''), v_last),
      email = COALESCE(email, v_profile_email, v_auth_email),
      updated_at = now()
  WHERE id = p_auth_user_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Profile not found for user. Please ensure you are signed in.';
  END IF;

  -- Sync to legacy users table for backward compatibility
  INSERT INTO public.users (
    auth_user_id, email, name, phone, role, preschool_id, organization_id,
    is_active, first_name, last_name, created_at, updated_at
  ) VALUES (
    p_auth_user_id,
    COALESCE(v_profile_email, v_auth_email),
    v_full_name,
    p_phone,
    'parent',
    v_invitation.preschool_id,
    v_invitation.preschool_id,
    true,
    COALESCE(NULLIF(v_first, ''), v_full_name),
    NULLIF(v_last, ''),
    now(),
    now()
  )
  ON CONFLICT (auth_user_id) DO UPDATE
    SET email = COALESCE(EXCLUDED.email, users.email),
        name = COALESCE(EXCLUDED.name, users.name),
        phone = COALESCE(EXCLUDED.phone, users.phone),
        role = 'parent',
        preschool_id = EXCLUDED.preschool_id,
        organization_id = EXCLUDED.organization_id,
        is_active = true,
        updated_at = now();

  -- Mark the invitation as used and increment counters (only on first use)
  UPDATE public.school_invitation_codes sic
  SET current_uses = COALESCE(sic.current_uses, 0) + 1,
      used_at = now(),
      used_by = p_auth_user_id,
      is_active = CASE
                    WHEN sic.max_uses IS NOT NULL AND sic.max_uses > 0
                         AND COALESCE(sic.current_uses, 0) + 1 >= sic.max_uses
                    THEN false
                    ELSE sic.is_active
                  END,
      updated_at = now()
  WHERE sic.id = v_invitation.id
    AND (sic.used_by IS NULL OR sic.used_by <> p_auth_user_id);

  RETURN p_auth_user_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.user_can_access_assignment(assignment_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
    SELECT EXISTS (
        SELECT 1 FROM assignments a
        JOIN courses c ON c.id = a.course_id
        WHERE a.id = assignment_id
        AND a.deleted_at IS NULL
        AND c.deleted_at IS NULL
        AND (
            -- User is the course instructor
            c.instructor_id = auth.uid() OR
            -- User is enrolled in the course
            EXISTS (
                SELECT 1 FROM enrollments e
                WHERE e.course_id = c.id
                AND e.student_id = auth.uid()
                AND e.is_active = true
            )
        )
    );
$function$
;

CREATE OR REPLACE FUNCTION public.user_can_access_grade(grade_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
    SELECT EXISTS (
        SELECT 1 FROM grades g
        JOIN submissions s ON s.id = g.submission_id
        JOIN assignments a ON a.id = s.assignment_id
        JOIN courses c ON c.id = a.course_id
        WHERE g.id = grade_id
        AND a.deleted_at IS NULL
        AND c.deleted_at IS NULL
        AND (
            -- Student can see their own published grade
            (s.student_id = auth.uid() AND g.is_published = true) OR
            -- Course instructor can see all grades
            c.instructor_id = auth.uid() OR
            -- Admin can see all grades in their organization
            (public.is_admin_level() AND public.can_access_organization(c.organization_id))
        )
    );
$function$
;

CREATE OR REPLACE FUNCTION public.user_can_access_submission(submission_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
    SELECT EXISTS (
        SELECT 1 FROM submissions s
        JOIN assignments a ON a.id = s.assignment_id
        JOIN courses c ON c.id = a.course_id
        WHERE s.id = submission_id
        AND a.deleted_at IS NULL
        AND c.deleted_at IS NULL
        AND (
            -- User is the student who made the submission
            s.student_id = auth.uid() OR
            -- User is the course instructor
            c.instructor_id = auth.uid() OR
            -- User is admin in the organization
            (public.is_admin_level() AND public.can_access_organization(c.organization_id))
        )
    );
$function$
;

CREATE OR REPLACE FUNCTION public.user_can_create_course(p_org_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'extensions', 'auth'
AS $function$
BEGIN
  RETURN EXISTS (
    SELECT 1
    FROM public.organization_members om
    WHERE om.user_id = auth.uid()
      AND om.organization_id = p_org_id
      AND om.membership_status = 'active'
      AND om.member_type IN (
        'youth_president',
        'youth_deputy', 
        'youth_secretary',
        'youth_treasurer',
        'president',
        'deputy_president',
        'secretary_general',
        'treasurer'
      )
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.user_can_view_thread_participants(p_thread_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT EXISTS (
    SELECT 1 FROM public.message_participants
    WHERE thread_id = p_thread_id
    AND user_id = auth.uid()
  );
$function$
;

CREATE OR REPLACE FUNCTION public.user_enrolled_in_course(course_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
    SELECT EXISTS (
        SELECT 1 FROM enrollments e
        JOIN courses c ON c.id = e.course_id
        WHERE e.course_id = course_id
        AND e.student_id = auth.uid()
        AND e.is_active = true
        AND c.deleted_at IS NULL
    );
$function$
;

CREATE OR REPLACE FUNCTION public.user_exists_check(p_user_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM auth.users WHERE id = p_user_id
  );
EXCEPTION
  WHEN OTHERS THEN
    RETURN FALSE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.user_has_active_seat(p_user_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE
AS $function$
  SELECT EXISTS (
    SELECT 1 
    FROM public.subscription_seats ss
    JOIN public.users u ON u.id = ss.user_id
    WHERE u.auth_user_id = p_user_id
      AND ss.revoked_at IS NULL
  );
$function$
;

CREATE OR REPLACE FUNCTION public.user_is_thread_participant(p_thread_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT EXISTS (
    SELECT 1 FROM public.message_participants
    WHERE thread_id = p_thread_id
    AND user_id = auth.uid()
  );
$function$
;

create or replace view "public"."user_organizations" as  SELECT id AS user_id,
    COALESCE(organization_id, preschool_id) AS organization_id,
    role,
    seat_status,
    capabilities
   FROM public.profiles;


CREATE OR REPLACE FUNCTION public.user_owns_course(course_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
    SELECT EXISTS (
        SELECT 1 FROM courses 
        WHERE id = course_id 
        AND instructor_id = auth.uid()
        AND deleted_at IS NULL
    );
$function$
;

CREATE OR REPLACE FUNCTION public.user_owns_submission(submission_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
    SELECT EXISTS (
        SELECT 1 FROM submissions 
        WHERE id = submission_id 
        AND student_id = auth.uid()
    );
$function$
;

create or replace view "public"."user_profiles_with_tier" as  SELECT u.id,
    u.auth_user_id,
    u.preschool_id,
    u.role,
    COALESCE(((u.first_name || ' '::text) || u.last_name), u.email) AS name,
    u.email,
    u.phone,
    u.avatar_url,
    u.is_active,
    u.created_at,
    u.updated_at,
    p.id AS preschool_id_nested,
    p.name AS preschool_name,
    COALESCE(o.plan_tier, p.subscription_tier, 'free'::text) AS subscription_tier
   FROM ((public.users u
     LEFT JOIN public.preschools p ON ((u.preschool_id = p.id)))
     LEFT JOIN public.organizations o ON ((u.preschool_id = o.id)));


create or replace view "public"."user_subscription_info" as  SELECT p.id AS user_id,
    p.role,
    COALESCE(p.organization_id, p.preschool_id) AS organization_id,
    public.get_user_subscription_tier(p.id) AS subscription_tier,
    uau.current_tier AS user_tier_override,
    uat.tier AS user_specific_tier,
    o.subscription_tier AS org_subscription_tier,
    o.plan_tier AS org_plan_tier_legacy,
    p.seat_status,
        CASE
            WHEN (p.seat_status = 'active'::text) THEN true
            ELSE false
        END AS has_active_seat
   FROM (((public.profiles p
     LEFT JOIN public.user_ai_usage uau ON ((p.id = uau.user_id)))
     LEFT JOIN public.user_ai_tiers uat ON ((p.id = uat.user_id)))
     LEFT JOIN public.organizations o ON ((COALESCE(p.organization_id, p.preschool_id) = o.id)));


create or replace view "public"."users_with_subscription" as  SELECT u.id,
    u.auth_user_id,
    u.email,
    u.name,
    u.role,
    u.phone,
    u.is_active,
    u.profile_completion_status,
    u.preschool_id,
    u.created_at,
    u.updated_at,
    u.date_of_birth,
    u.gender,
    u.nationality,
    u.id_number,
    u.emergency_contact_name,
    u.emergency_contact_phone,
    u.emergency_contact_relationship,
    u.street_address,
    u.city,
    u.state_province,
    u.postal_code,
    u.country,
    u.employee_id,
    u.department,
    u.position_title,
    u.employment_start_date,
    u.employment_status,
    u.salary_amount,
    u.salary_currency,
    u.highest_qualification,
    u.institution_name,
    u.qualification_year,
    u.certifications,
    u.teaching_experience_years,
    u.subjects_taught,
    u.age_groups_taught,
    u.biography,
    u.languages_spoken,
    u.profile_picture_url,
    u.notes,
    u.documents,
    u.availability,
    u.password_reset_required,
    u.subscription_tier,
    u.subscription_status,
    u.subscription_start_date,
    u.subscription_plan_id,
    s.status AS latest_subscription_status,
    s.plan_id AS latest_subscription_plan_id,
    s.billing_interval AS latest_subscription_billing_interval,
    s.current_period_end AS latest_subscription_current_period_end
   FROM (public.users u
     LEFT JOIN LATERAL ( SELECT ps.status,
            ps.plan_id,
            ps.billing_interval,
            ps.current_period_end
           FROM public.platform_subscriptions ps
          WHERE ((ps.user_id = u.auth_user_id) AND (ps.status = ANY (ARRAY['trial'::text, 'active'::text, 'past_due'::text])))
          ORDER BY ps.created_at DESC
         LIMIT 1) s ON (true));


CREATE OR REPLACE FUNCTION public.util_acquire_school_lock(p_school uuid)
 RETURNS boolean
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
  SELECT pg_try_advisory_xact_lock(hashtext(p_school::text))
$function$
;

CREATE OR REPLACE FUNCTION public.util_is_service_role()
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT COALESCE(
    (current_setting('request.jwt.claims', TRUE)::jsonb->>'role') = 'service_role',
    FALSE
  )
$function$
;

create or replace view "public"."v_active_teacher_seats" as  SELECT ss.id AS seat_id,
    ss.subscription_id,
    ss.preschool_id,
    ss.user_id AS users_table_id,
    u.auth_user_id,
    u.email,
    p.first_name,
    p.last_name,
    p.role,
    ss.assigned_at,
    ss.assigned_by,
    s.plan_id,
    s.status AS subscription_status
   FROM (((public.subscription_seats ss
     JOIN public.users u ON ((u.id = ss.user_id)))
     LEFT JOIN public.profiles p ON ((p.id = u.auth_user_id)))
     LEFT JOIN public.subscriptions s ON ((s.id = ss.subscription_id)))
  WHERE (ss.revoked_at IS NULL);


create type "public"."valid_detail" as ("valid" boolean, "reason" character varying, "location" public.geometry);

CREATE OR REPLACE FUNCTION public.validate_assignment_course_active()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        IF NOT EXISTS (
            SELECT 1 FROM courses c
            WHERE c.id = NEW.course_id
            AND c.is_active = true
            AND c.deleted_at IS NULL
        ) THEN
            RAISE EXCEPTION 'Cannot create assignment in inactive or deleted course';
        END IF;
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.validate_course_join_code(course_id uuid, provided_join_code text)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
    SELECT EXISTS (
        SELECT 1 FROM courses c
        WHERE c.id = validate_course_join_code.course_id
        AND c.join_code = provided_join_code
        AND c.is_active = true
        AND c.deleted_at IS NULL
        AND (c.join_code_expires_at IS NULL OR c.join_code_expires_at > now())
    );
$function$
;

CREATE OR REPLACE FUNCTION public.validate_enrollment_course_active()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        IF NOT EXISTS (
            SELECT 1 FROM courses c
            WHERE c.id = NEW.course_id
            AND c.is_active = true
            AND c.deleted_at IS NULL
        ) THEN
            RAISE EXCEPTION 'Cannot enroll in inactive or deleted course';
        END IF;
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.validate_invitation_code(p_code text, p_email text DEFAULT NULL::text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_invitation public.school_invitation_codes%rowtype;
  v_school_name text;
  v_school_slug text;
  v_result jsonb;
BEGIN
  IF p_code IS NULL OR btrim(p_code) = '' THEN
    RETURN jsonb_build_object('valid', false, 'error', 'Missing invitation code');
  END IF;

  -- Find invitation code (case-insensitive)
  SELECT * INTO v_invitation
  FROM public.school_invitation_codes
  WHERE upper(code) = upper(btrim(p_code));

  IF NOT FOUND THEN
    RETURN jsonb_build_object('valid', false, 'error', 'Invalid or expired invitation code');
  END IF;

  -- Get school/org name (support both preschools and organizations as "school_id")
  SELECT name, slug INTO v_school_name, v_school_slug
  FROM public.preschools
  WHERE id = v_invitation.preschool_id;

  IF v_school_name IS NULL THEN
    SELECT name, slug INTO v_school_name, v_school_slug
    FROM public.organizations
    WHERE id = v_invitation.preschool_id;
  END IF;

  -- Build response payload
  v_result := jsonb_build_object(
    'valid', true,
    'invitation_type', v_invitation.invitation_type,
    'is_active', COALESCE(v_invitation.is_active, false),
    'current_uses', COALESCE(v_invitation.current_uses, 0),
    'max_uses', v_invitation.max_uses,
    'expires_at', v_invitation.expires_at,
    'school_name', COALESCE(v_school_name, 'Unknown'),
    'school_slug', v_school_slug,
    'school_id', v_invitation.preschool_id
  );

  -- Active checks (return friendly errors)
  IF NOT COALESCE(v_invitation.is_active, false) THEN
    RETURN jsonb_build_object('valid', false, 'error', 'This invitation code is no longer active');
  END IF;

  IF v_invitation.expires_at IS NOT NULL AND v_invitation.expires_at <= now() THEN
    RETURN jsonb_build_object('valid', false, 'error', 'This invitation code has expired');
  END IF;

  IF v_invitation.max_uses IS NOT NULL AND v_invitation.max_uses > 0
     AND COALESCE(v_invitation.current_uses, 0) >= v_invitation.max_uses THEN
    RETURN jsonb_build_object('valid', false, 'error', 'This invitation code has reached its maximum uses');
  END IF;

  RETURN v_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.validate_join_invite_code(p_code text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_request join_requests%ROWTYPE;
  v_org organizations%ROWTYPE;
BEGIN
  -- Find the request
  SELECT * INTO v_request
  FROM join_requests
  WHERE UPPER(invite_code) = UPPER(p_code)
    AND status = 'pending'
    AND (expires_at IS NULL OR expires_at > NOW());
  
  IF NOT FOUND THEN
    RETURN json_build_object('valid', false, 'error', 'Invalid or expired invite code');
  END IF;
  
  -- Get organization details
  SELECT * INTO v_org
  FROM organizations
  WHERE id = v_request.organization_id;
  
  RETURN json_build_object(
    'valid', true,
    'request_type', v_request.request_type,
    'organization_name', v_org.name,
    'organization_id', v_request.organization_id,
    'invite_token', v_request.invite_token
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.validate_program_code(p_code text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_code text := btrim(COALESCE(p_code, ''));
  v_course record;
  v_org record;
BEGIN
  IF v_code = '' THEN
    RETURN jsonb_build_object('valid', false, 'error', 'Missing program code');
  END IF;

  SELECT
    c.id,
    c.title,
    c.description,
    c.course_code,
    c.organization_id
  INTO v_course
  FROM public.courses c
  WHERE c.is_active = true
    AND (
      upper(c.course_code) = upper(v_code)
      OR c.id::text = v_code
    )
  LIMIT 1;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('valid', false, 'error', 'Invalid or inactive program code');
  END IF;

  SELECT o.id, o.name, o.slug
  INTO v_org
  FROM public.organizations o
  WHERE o.id = v_course.organization_id;

  RETURN jsonb_build_object(
    'valid', true,
    'course', jsonb_build_object(
      'id', v_course.id,
      'title', v_course.title,
      'description', v_course.description,
      'course_code', v_course.course_code
    ),
    'organization', jsonb_build_object(
      'id', v_org.id,
      'name', v_org.name,
      'slug', v_org.slug
    )
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.validate_report_status_transition(old_status text, new_status text, user_role text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- Teacher transitions
  IF user_role IN ('teacher', 'teacher_assistant') THEN
    -- draft -> pending_review (submit)
    IF old_status = 'draft' AND new_status = 'pending_review' THEN
      RETURN TRUE;
    END IF;
    -- rejected -> pending_review (resubmit)
    IF old_status = 'rejected' AND new_status = 'pending_review' THEN
      RETURN TRUE;
    END IF;
    -- approved -> sent (send to parent)
    IF old_status = 'approved' AND new_status = 'sent' THEN
      RETURN TRUE;
    END IF;
  END IF;
  
  -- Principal transitions
  IF user_role IN ('principal', 'principal_admin', 'superadmin') THEN
    -- pending_review -> approved
    IF old_status = 'pending_review' AND new_status = 'approved' THEN
      RETURN TRUE;
    END IF;
    -- pending_review -> rejected
    IF old_status = 'pending_review' AND new_status = 'rejected' THEN
      RETURN TRUE;
    END IF;
  END IF;
  
  -- No status change (allowed)
  IF old_status = new_status THEN
    RETURN TRUE;
  END IF;
  
  -- All other transitions denied
  RETURN FALSE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.validate_risk_score(score integer)
 RETURNS public.risk_level_enum
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
BEGIN
  CASE 
    WHEN score >= 0 AND score <= 25 THEN
      RETURN 'low'::risk_level_enum;
    WHEN score > 25 AND score <= 50 THEN  
      RETURN 'medium'::risk_level_enum;
    WHEN score > 50 AND score <= 75 THEN
      RETURN 'high'::risk_level_enum;
    WHEN score > 75 AND score <= 100 THEN
      RETURN 'critical'::risk_level_enum;
    ELSE
      -- Default to medium for invalid scores
      RETURN 'medium'::risk_level_enum;
  END CASE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.validate_student_age_for_school()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  school_type_val TEXT;
  student_age_months INTEGER;
BEGIN
  -- Get the school type
  SELECT p.school_type INTO school_type_val
  FROM public.preschools p
  WHERE p.id = NEW.preschool_id;
  
  -- Calculate student age in months
  IF NEW.date_of_birth IS NOT NULL THEN
    student_age_months := EXTRACT(YEAR FROM AGE(CURRENT_DATE, NEW.date_of_birth)) * 12 + 
                         EXTRACT(MONTH FROM AGE(CURRENT_DATE, NEW.date_of_birth));
    
    -- Validate age range for preschools
    IF school_type_val = 'preschool' AND (student_age_months < 18 OR student_age_months > 71) THEN
      RAISE EXCEPTION 'Student age (% months) is not appropriate for preschool (18-71 months)', student_age_months;
    END IF;
    
    -- Validate age range for primary schools
    IF school_type_val = 'primary' AND (student_age_months < 60 OR student_age_months > 167) THEN
      RAISE EXCEPTION 'Student age (% months) is not appropriate for primary school (60-167 months)', student_age_months;
    END IF;
    
    -- Validate age range for secondary schools
    IF school_type_val = 'secondary' AND (student_age_months < 156 OR student_age_months > 227) THEN
      RAISE EXCEPTION 'Student age (% months) is not appropriate for secondary school (156-227 months)', student_age_months;
    END IF;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.validate_user_access(target_user_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
    current_user_role text;
    current_preschool_id uuid;
    target_preschool_id uuid;
    is_valid boolean := false;
BEGIN
    -- Get current user details
    SELECT role, preschool_id INTO current_user_role, current_preschool_id
    FROM public.users 
    WHERE id = auth.uid();

    -- Get target user preschool
    SELECT preschool_id INTO target_preschool_id
    FROM public.users 
    WHERE id = target_user_id;

    -- Validation logic
    IF current_user_role = 'superadmin' THEN
        is_valid := true;
    ELSIF current_user_role IN ('principal', 'preschool_admin') THEN
        is_valid := (current_preschool_id = target_preschool_id);
    ELSIF auth.uid() = target_user_id THEN
        is_valid := true;
    END IF;

    RETURN is_valid;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.verify_lessons_migration()
 RETURNS TABLE(total_lessons bigint, status_breakdown json, subject_breakdown json, age_group_breakdown json)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    (SELECT COUNT(*) FROM lessons) as total_lessons,
    (SELECT json_object_agg(status, count) 
     FROM (SELECT status, COUNT(*) as count FROM lessons GROUP BY status) s
    ) as status_breakdown,
    (SELECT json_object_agg(subject, count)
     FROM (SELECT subject, COUNT(*) as count FROM lessons GROUP BY subject) s
    ) as subject_breakdown,
    (SELECT json_object_agg(age_group, count)
     FROM (SELECT age_group, COUNT(*) as count FROM lessons GROUP BY age_group) s
    ) as age_group_breakdown;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.verify_phone_otp(p_user_id uuid, p_phone_number character varying, p_otp character varying)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_phone_record RECORD;
  v_is_primary BOOLEAN;
BEGIN
  -- Get phone record
  SELECT * INTO v_phone_record
  FROM user_phone_numbers
  WHERE user_id = p_user_id
  AND phone_number = p_phone_number
  AND is_verified = FALSE;
  
  IF NOT FOUND THEN
    RETURN json_build_object(
      'success', FALSE,
      'error', 'Phone number not found or already verified'
    );
  END IF;
  
  -- Check if OTP is expired
  IF v_phone_record.verification_code_expires_at < NOW() THEN
    UPDATE phone_verification_logs
    SET status = 'expired'
    WHERE user_phone_id = v_phone_record.id AND status = 'pending';
    
    RETURN json_build_object(
      'success', FALSE,
      'error', 'Verification code expired. Please request a new one.'
    );
  END IF;
  
  -- Check if OTP matches
  IF v_phone_record.verification_code != p_otp THEN
    -- Increment failed attempts
    UPDATE user_phone_numbers
    SET verification_attempts = verification_attempts + 1
    WHERE id = v_phone_record.id;
    
    UPDATE phone_verification_logs
    SET status = 'failed'
    WHERE user_phone_id = v_phone_record.id AND verification_code = p_otp;
    
    -- Lock account after 5 failed attempts
    IF v_phone_record.verification_attempts >= 4 THEN
      UPDATE user_phone_numbers
      SET verification_code_expires_at = NOW() - INTERVAL '1 hour'
      WHERE id = v_phone_record.id;
      
      RETURN json_build_object(
        'success', FALSE,
        'error', 'Too many failed attempts. Please request a new code.'
      );
    END IF;
    
    RETURN json_build_object(
      'success', FALSE,
      'error', 'Invalid verification code'
    );
  END IF;
  
  -- Check if this is the user's first verified number
  v_is_primary := NOT EXISTS (
    SELECT 1 FROM user_phone_numbers
    WHERE user_id = p_user_id AND is_verified = TRUE
  );
  
  -- Mark as verified
  UPDATE user_phone_numbers
  SET
    is_verified = TRUE,
    is_primary = v_is_primary,
    verified_at = NOW(),
    verification_code = NULL,
    verification_code_expires_at = NULL,
    updated_at = NOW()
  WHERE id = v_phone_record.id;
  
  -- Update verification log
  UPDATE phone_verification_logs
  SET status = 'verified', verified_at = NOW()
  WHERE user_phone_id = v_phone_record.id AND verification_code = p_otp;
  
  -- Create default contact discovery settings if not exists
  INSERT INTO contact_discovery_settings (user_id)
  VALUES (p_user_id)
  ON CONFLICT (user_id) DO NOTHING;
  
  RETURN json_build_object(
    'success', TRUE,
    'is_primary', v_is_primary,
    'verified_at', NOW()
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.verify_school(p_school_id uuid, p_verification_type character varying, p_verification_data jsonb DEFAULT '{}'::jsonb, p_verification_token text DEFAULT NULL::text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_verification_id UUID;
  v_current_user_id UUID := auth.uid();
  v_is_superadmin BOOLEAN := FALSE;
  v_is_school_admin BOOLEAN := FALSE;
  v_verification_record RECORD;
  v_result JSON;
  v_error_msg TEXT;
BEGIN
  -- Check user permissions
  IF v_current_user_id IS NOT NULL THEN
    SELECT EXISTS(
      SELECT 1 FROM public.users 
      WHERE id = v_current_user_id AND role = 'superadmin'
    ) INTO v_is_superadmin;
    
    SELECT EXISTS(
      SELECT 1 FROM public.users 
      WHERE id = v_current_user_id 
      AND preschool_id = p_school_id
      AND role IN ('principal', 'preschool_admin')
    ) INTO v_is_school_admin;
  END IF;
  
  -- For token-based verification (email, phone), allow public access
  IF p_verification_token IS NOT NULL THEN
    -- Find verification record by token
    SELECT * INTO v_verification_record
    FROM public.school_verifications
    WHERE school_id = p_school_id
    AND verification_type = p_verification_type
    AND verification_token = p_verification_token
    AND expires_at > NOW()
    AND status = 'pending';
    
    IF NOT FOUND THEN
      RETURN json_build_object(
        'error', 'Invalid or expired verification token'
      );
    END IF;
  ELSE
    -- For manual verification, require admin permissions
    IF NOT (v_is_superadmin OR v_is_school_admin) THEN
      RETURN json_build_object(
        'error', 'Unauthorized: Admin access required for manual verification'
      );
    END IF;
    
    -- Find pending verification record
    SELECT * INTO v_verification_record
    FROM public.school_verifications
    WHERE school_id = p_school_id
    AND verification_type = p_verification_type
    AND status = 'pending'
    ORDER BY created_at DESC
    LIMIT 1;
    
    IF NOT FOUND THEN
      RETURN json_build_object(
        'error', 'No pending verification found for this type'
      );
    END IF;
  END IF;
  
  -- Update verification record
  UPDATE public.school_verifications
  SET 
    status = 'verified',
    verified_by = v_current_user_id,
    verified_at = NOW(),
    verification_data = verification_data || p_verification_data
  WHERE id = v_verification_record.id
  RETURNING id INTO v_verification_id;
  
  -- Check if all required verifications are complete
  IF NOT EXISTS (
    SELECT 1 FROM public.school_verifications
    WHERE school_id = p_school_id
    AND verification_type IN ('email') -- Add other required types as needed
    AND status != 'verified'
  ) THEN
    -- All verifications complete, update school status
    UPDATE public.preschools
    SET verification_status = 'verified'
    WHERE id = p_school_id;
    
    -- Update onboarding progress
    UPDATE public.onboarding_progress
    SET 
      current_step = 'verification_complete',
      completed_steps = array_append(completed_steps, 'verification_complete'),
      step_data = step_data || json_build_object('verified_at', NOW())
    WHERE school_id = p_school_id;
  END IF;
  
  -- Build success response
  v_result := json_build_object(
    'success', TRUE,
    'verification_id', v_verification_id,
    'verification_type', p_verification_type,
    'message', 'Verification completed successfully'
  );
  
  -- Log the verification
  INSERT INTO public.audit_logs (
    user_id,
    action,
    table_name,
    record_id,
    old_values,
    new_values,
    metadata
  )
  VALUES (
    v_current_user_id,
    'school_verification',
    'school_verifications',
    v_verification_id,
    json_build_object('status', 'pending'),
    json_build_object('status', 'verified'),
    json_build_object(
      'school_id', p_school_id,
      'verification_type', p_verification_type,
      'token_used', p_verification_token IS NOT NULL
    )
  );
  
  RETURN v_result;
  
EXCEPTION
  WHEN OTHERS THEN
    GET STACKED DIAGNOSTICS v_error_msg = MESSAGE_TEXT;
    RETURN json_build_object(
      'error', 'Verification failed: ' || v_error_msg
    );
END;
$function$
;

create or replace view "public"."vw_teacher_overview" as  SELECT t.id AS teacher_id,
    t.user_id AS teacher_auth_user_id,
    t.user_id AS public_user_id,
    t.email,
    t.preschool_id,
    (COALESCE(count(DISTINCT c.id), (0)::bigint))::integer AS class_count,
    (COALESCE(count(s.id), (0)::bigint))::integer AS student_count,
    COALESCE(string_agg(DISTINCT c.name, ', '::text ORDER BY c.name), ''::text) AS classes_text
   FROM ((public.teachers t
     LEFT JOIN public.classes c ON (((c.teacher_id = t.user_id) AND (c.active = true) AND (c.preschool_id = t.preschool_id))))
     LEFT JOIN public.students s ON (((s.class_id = c.id) AND (s.is_active = true) AND (s.preschool_id = t.preschool_id))))
  WHERE ((t.is_active = true) AND (t.preschool_id = public.current_preschool_id()))
  GROUP BY t.id, t.user_id, t.email, t.preschool_id;


CREATE OR REPLACE FUNCTION public.check_duplicate_pop_upload()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Only check if status is pending or approved
  IF NEW.status IN ('pending', 'approved') THEN
    -- Check if a POP already exists for this student in the same month
    IF EXISTS (
      SELECT 1 
      FROM pop_uploads
      WHERE student_id = NEW.student_id
        AND DATE_TRUNC('month', payment_date) = DATE_TRUNC('month', NEW.payment_date)
        AND status IN ('pending', 'approved')
        AND id != COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::uuid)
    ) THEN
      RAISE EXCEPTION 'A payment upload already exists for this month. Please wait for it to be reviewed or contact the school.';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.current_preschool_id()
 RETURNS uuid
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO 'public', 'extensions', 'auth'
AS $function$
DECLARE
  preschool_id_claim TEXT;
  result_uuid UUID;
BEGIN
  -- First check if user is authenticated
  IF auth.uid() IS NULL THEN
    RETURN NULL;
  END IF;

  -- Try to get preschool_id from JWT claims first (fastest)
  preschool_id_claim := auth.jwt() ->> 'preschool_id';
  
  IF preschool_id_claim IS NOT NULL AND preschool_id_claim != '' THEN
    BEGIN
      result_uuid := preschool_id_claim::UUID;
      RETURN result_uuid;
    EXCEPTION WHEN invalid_text_representation THEN
      -- Invalid UUID, continue to fallbacks
      NULL;
    END;
  END IF;
  
  -- Fallback: try organization_id claim
  preschool_id_claim := auth.jwt() ->> 'organization_id';
  IF preschool_id_claim IS NOT NULL AND preschool_id_claim != '' THEN
    BEGIN
      result_uuid := preschool_id_claim::UUID;
      RETURN result_uuid;
    EXCEPTION WHEN invalid_text_representation THEN
      NULL;
    END;
  END IF;
  
  -- Fallback: lookup from profiles table (SECURITY DEFINER bypasses RLS)
  SELECT COALESCE(p.organization_id, p.preschool_id) INTO result_uuid
  FROM profiles p
  WHERE p.auth_user_id = auth.uid()
  LIMIT 1;
  
  IF result_uuid IS NOT NULL THEN
    RETURN result_uuid;
  END IF;
  
  -- Legacy fallback: lookup from users table
  SELECT COALESCE(u.organization_id, u.preschool_id) INTO result_uuid
  FROM users u
  WHERE u.auth_user_id = auth.uid()
  LIMIT 1;
  
  RETURN result_uuid;
END;
$function$
;

create or replace view "public"."duplicate_aftercare_registrations" as  SELECT parent_email,
    child_first_name,
    child_last_name,
    child_date_of_birth,
    preschool_id,
    count(*) AS duplicate_count,
    array_agg(id ORDER BY created_at) AS registration_ids,
    array_agg(status ORDER BY created_at) AS statuses,
    array_agg(created_at ORDER BY created_at) AS created_dates
   FROM public.aftercare_registrations
  WHERE (status <> 'cancelled'::text)
  GROUP BY parent_email, child_first_name, child_last_name, child_date_of_birth, preschool_id
 HAVING (count(*) > 1);


CREATE OR REPLACE FUNCTION public.get_current_user_profile()
 RETURNS TABLE(id uuid, auth_user_id uuid, email text, role text, preschool_id uuid, organization_id uuid, first_name text, last_name text)
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public', 'extensions', 'auth'
AS $function$
  SELECT 
    p.id,
    p.auth_user_id,
    p.email,
    p.role,
    p.preschool_id,
    p.organization_id,
    p.first_name,
    p.last_name
  FROM public.profiles p
  WHERE p.auth_user_id = auth.uid()
  LIMIT 1;
$function$
;

CREATE OR REPLACE FUNCTION public.get_learner_document_summary(p_learner_id uuid)
 RETURNS TABLE(document_type character varying, document_count bigint, latest_upload timestamp with time zone, has_verified boolean)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    ld.document_type,
    COUNT(*) as document_count,
    MAX(ld.created_at) as latest_upload,
    BOOL_OR(ld.status = 'verified') as has_verified
  FROM public.learner_documents ld
  WHERE ld.learner_id = p_learner_id
    AND ld.is_active = true
  GROUP BY ld.document_type;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_my_children_class_ids()
 RETURNS SETOF uuid
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public', 'extensions', 'auth'
AS $function$
    SELECT DISTINCT s.class_id FROM students s
    JOIN profiles p ON (s.parent_id = p.id OR s.guardian_id = p.id)
    WHERE p.auth_user_id = auth.uid()
    AND s.class_id IS NOT NULL;
$function$
;

CREATE OR REPLACE FUNCTION public.get_my_children_ids()
 RETURNS SETOF uuid
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public', 'extensions', 'auth'
AS $function$
    SELECT s.id FROM students s
    JOIN profiles p ON (s.parent_id = p.id OR s.guardian_id = p.id)
    WHERE p.auth_user_id = auth.uid();
$function$
;

CREATE OR REPLACE FUNCTION public.get_my_children_preschool_ids()
 RETURNS SETOF uuid
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public', 'extensions', 'auth'
AS $function$
    SELECT DISTINCT s.preschool_id FROM students s
    JOIN profiles p ON (s.parent_id = p.id OR s.guardian_id = p.id)
    WHERE p.auth_user_id = auth.uid()
    AND s.preschool_id IS NOT NULL;
$function$
;

CREATE OR REPLACE FUNCTION public.get_my_profile()
 RETURNS TABLE(id uuid, auth_user_id uuid, email text, first_name text, last_name text, name text, role text, preschool_id uuid, organization_id uuid, avatar_url text, is_active boolean, phone text, last_login_at timestamp with time zone, created_at timestamp with time zone, updated_at timestamp with time zone)
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
 SET row_security TO 'off'
AS $function$
  SELECT
    p.id,
    p.auth_user_id,
    p.email,
    p.first_name,
    p.last_name,
    COALESCE(
      p.full_name,
      NULLIF(TRIM(CONCAT_WS(' ', p.first_name, p.last_name)), '')
    ) AS name,
    p.role,
    p.preschool_id,
    p.organization_id,
    p.avatar_url,
    p.is_active,
    p.phone,
    p.last_login_at,
    p.created_at,
    p.updated_at
  FROM public.profiles AS p
  WHERE p.is_active = true
    AND (
      p.auth_user_id = auth.uid()
      OR p.id = auth.uid()
    )
  LIMIT 1;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_join_request_approval()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
 SET row_security TO 'off'
AS $function$
BEGIN
  -- Only process if status changed to approved
  IF NEW.status = 'approved' AND OLD.status = 'pending' THEN
    -- Set review metadata
    NEW.reviewed_at := COALESCE(NEW.reviewed_at, NOW());
    NEW.reviewed_by := COALESCE(NEW.reviewed_by, auth.uid());

    -- Handle based on request type
    CASE NEW.request_type
      WHEN 'teacher_invite' THEN
        UPDATE profiles
        SET
          organization_id = NEW.organization_id,
          preschool_id = COALESCE(NEW.preschool_id, NEW.organization_id),
          role = 'teacher',
          auth_user_id = COALESCE(auth_user_id, id),
          updated_at = NOW()
        WHERE id = NEW.requester_id;

      WHEN 'parent_join' THEN
        UPDATE profiles
        SET
          organization_id = NEW.organization_id,
          preschool_id = COALESCE(NEW.preschool_id, NEW.organization_id),
          auth_user_id = COALESCE(auth_user_id, id),
          updated_at = NOW()
        WHERE id = NEW.requester_id;

      WHEN 'member_join' THEN
        NULL;

      WHEN 'guardian_claim' THEN
        IF NEW.target_student_id IS NOT NULL THEN
          UPDATE students
          SET
            parent_id = NEW.requester_id,
            updated_at = NOW()
          WHERE id = NEW.target_student_id
            AND parent_id IS NULL;
        END IF;

      WHEN 'staff_invite' THEN
        UPDATE profiles
        SET
          organization_id = NEW.organization_id,
          role = COALESCE(NEW.requested_role, 'admin'),
          auth_user_id = COALESCE(auth_user_id, id),
          updated_at = NOW()
        WHERE id = NEW.requester_id;

      WHEN 'learner_enroll' THEN
        NULL;
    END CASE;
  END IF;

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_parent_of_student(p_student_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO 'public', 'extensions', 'auth'
AS $function$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM students s
        JOIN profiles p ON (s.parent_id = p.id OR s.guardian_id = p.id)
        WHERE s.id = p_student_id
        AND p.auth_user_id = auth.uid()
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_super_admin()
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT EXISTS (
    SELECT 1 FROM public.profiles
    WHERE auth_user_id = auth.uid()
    AND role = 'super_admin'
  )
$function$
;

CREATE OR REPLACE FUNCTION public.link_profile_to_school(p_target_profile_id uuid, p_school_id uuid, p_role text DEFAULT NULL::text)
 RETURNS public.profiles
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
 SET row_security TO 'off'
AS $function$
DECLARE
  actor_role text;
  actor_school_id uuid;
  actor_is_super boolean;
  updated_profile public.profiles;
BEGIN
  -- Resolve the acting user's role and school context.
  SELECT
    p.role,
    COALESCE(p.preschool_id, p.organization_id)
  INTO actor_role, actor_school_id
  FROM public.profiles p
  WHERE p.auth_user_id = auth.uid()
     OR p.id = auth.uid()
  LIMIT 1;

  IF actor_role IS NULL THEN
    RAISE EXCEPTION 'Actor profile not found';
  END IF;

  actor_is_super := actor_role IN ('superadmin', 'super_admin');

  -- Only principals/admins/superadmins can link other profiles.
  IF NOT actor_is_super AND actor_role NOT IN ('principal', 'principal_admin', 'admin') THEN
    RAISE EXCEPTION 'Insufficient permissions to link profiles';
  END IF;

  IF p_school_id IS NULL THEN
    RAISE EXCEPTION 'Target school is required';
  END IF;

  -- Non-super actors can only link within their own school.
  IF NOT actor_is_super THEN
    IF actor_school_id IS NULL THEN
      RAISE EXCEPTION 'Actor has no school context';
    END IF;
    IF actor_school_id <> p_school_id THEN
      RAISE EXCEPTION 'Cannot link profile to a different school';
    END IF;
  END IF;

  -- Perform the linkage.
  UPDATE public.profiles
  SET
    preschool_id = p_school_id,
    organization_id = p_school_id,
    role = COALESCE(p_role, role),
    auth_user_id = COALESCE(auth_user_id, id),
    updated_at = now()
  WHERE id = p_target_profile_id
     OR auth_user_id = p_target_profile_id
  RETURNING * INTO updated_profile;

  IF updated_profile.id IS NULL THEN
    RAISE EXCEPTION 'Target profile not found';
  END IF;

  RETURN updated_profile;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.record_birthday_donation(org_id uuid, donation_day date, donation_amount numeric, donation_method text DEFAULT NULL::text, donation_note text DEFAULT NULL::text, recorded_by_user uuid DEFAULT NULL::uuid)
 RETURNS public.birthday_donation_days
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'extensions', 'auth'
AS $function$
DECLARE
  birthday_count integer := 0;
  target_recorded_by uuid := COALESCE(recorded_by_user, auth.uid());
  day_row public.birthday_donation_days;
BEGIN
  IF org_id IS NULL THEN
    RAISE EXCEPTION 'Organization is required';
  END IF;

  IF donation_day IS NULL THEN
    RAISE EXCEPTION 'Donation date is required';
  END IF;

  IF donation_amount IS NULL OR donation_amount <= 0 THEN
    RAISE EXCEPTION 'Donation amount must be greater than zero';
  END IF;

  SELECT COUNT(*)::int INTO birthday_count
  FROM public.students
  WHERE (organization_id = org_id OR preschool_id = org_id)
    AND is_active IS TRUE
    AND date_of_birth IS NOT NULL
    AND EXTRACT(MONTH FROM date_of_birth) = EXTRACT(MONTH FROM donation_day)
    AND EXTRACT(DAY FROM date_of_birth) = EXTRACT(DAY FROM donation_day);

  IF birthday_count < 1 THEN
    RAISE EXCEPTION 'No birthdays found for this date';
  END IF;

  IF birthday_count > 2 THEN
    RAISE EXCEPTION 'Birthday count exceeds the daily limit of 2';
  END IF;

  INSERT INTO public.birthday_donations (
    organization_id,
    donation_date,
    amount,
    payment_method,
    note,
    recorded_by
  ) VALUES (
    org_id,
    donation_day,
    donation_amount,
    donation_method,
    donation_note,
    target_recorded_by
  );

  INSERT INTO public.birthday_donation_days (
    organization_id,
    donation_date,
    birthday_count,
    expected_amount,
    total_received,
    created_by,
    updated_by
  ) VALUES (
    org_id,
    donation_day,
    birthday_count,
    25,
    donation_amount,
    target_recorded_by,
    target_recorded_by
  )
  ON CONFLICT (organization_id, donation_date)
  DO UPDATE SET
    birthday_count = EXCLUDED.birthday_count,
    total_received = birthday_donation_days.total_received + EXCLUDED.total_received,
    updated_by = target_recorded_by,
    updated_at = now();

  SELECT * INTO day_row
  FROM public.birthday_donation_days
  WHERE organization_id = org_id
    AND donation_date = donation_day;

  RETURN day_row;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.record_birthday_donation(org_id uuid, donation_day date, donation_amount numeric, donation_method text DEFAULT NULL::text, donation_note text DEFAULT NULL::text, recorded_by_user uuid DEFAULT NULL::uuid, p_payer_student_id uuid DEFAULT NULL::uuid, p_birthday_student_id uuid DEFAULT NULL::uuid, p_class_id uuid DEFAULT NULL::uuid)
 RETURNS public.birthday_donation_days
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'extensions', 'auth'
AS $function$
DECLARE
  birthday_count integer := 0;
  target_recorded_by uuid := COALESCE(recorded_by_user, auth.uid());
  day_row public.birthday_donation_days;
BEGIN
  IF org_id IS NULL THEN
    RAISE EXCEPTION 'Organization is required';
  END IF;

  IF donation_day IS NULL THEN
    RAISE EXCEPTION 'Donation date is required';
  END IF;

  IF donation_amount IS NULL OR donation_amount <= 0 THEN
    RAISE EXCEPTION 'Donation amount must be greater than zero';
  END IF;

  IF (p_payer_student_id IS NULL AND p_birthday_student_id IS NOT NULL)
     OR (p_payer_student_id IS NOT NULL AND p_birthday_student_id IS NULL) THEN
    RAISE EXCEPTION 'Payer student and birthday student must be provided together';
  END IF;

  IF p_payer_student_id IS NOT NULL THEN
    PERFORM 1
    FROM public.students
    WHERE id = p_payer_student_id
      AND (organization_id = org_id OR preschool_id = org_id)
      AND COALESCE(is_active, true) IS TRUE;
    IF NOT FOUND THEN
      RAISE EXCEPTION 'Payer student not found for organization';
    END IF;
  END IF;

  IF p_birthday_student_id IS NOT NULL THEN
    PERFORM 1
    FROM public.students
    WHERE id = p_birthday_student_id
      AND (organization_id = org_id OR preschool_id = org_id)
      AND COALESCE(is_active, true) IS TRUE;
    IF NOT FOUND THEN
      RAISE EXCEPTION 'Birthday student not found for organization';
    END IF;
  END IF;

  IF p_class_id IS NOT NULL THEN
    PERFORM 1
    FROM public.classes
    WHERE id = p_class_id
      AND (organization_id = org_id OR preschool_id = org_id);
    IF NOT FOUND THEN
      RAISE EXCEPTION 'Class not found for organization';
    END IF;
  END IF;

  SELECT COUNT(*)::int INTO birthday_count
  FROM public.students
  WHERE (organization_id = org_id OR preschool_id = org_id)
    AND COALESCE(is_active, true) IS TRUE
    AND date_of_birth IS NOT NULL
    AND EXTRACT(MONTH FROM date_of_birth) = EXTRACT(MONTH FROM donation_day)
    AND EXTRACT(DAY FROM date_of_birth) = EXTRACT(DAY FROM donation_day);

  IF birthday_count < 1 THEN
    RAISE EXCEPTION 'No birthdays found for this date';
  END IF;

  IF p_payer_student_id IS NOT NULL AND p_birthday_student_id IS NOT NULL THEN
    IF EXISTS (
      SELECT 1
      FROM public.birthday_donations
      WHERE organization_id = org_id
        AND donation_date = donation_day
        AND public.birthday_donations.payer_student_id = p_payer_student_id
        AND public.birthday_donations.birthday_student_id = p_birthday_student_id
    ) THEN
      SELECT * INTO day_row
      FROM public.birthday_donation_days
      WHERE organization_id = org_id
        AND donation_date = donation_day;

      RETURN day_row;
    END IF;
  END IF;

  INSERT INTO public.birthday_donations (
    organization_id,
    donation_date,
    amount,
    payment_method,
    note,
    recorded_by,
    payer_student_id,
    birthday_student_id,
    class_id
  ) VALUES (
    org_id,
    donation_day,
    donation_amount,
    donation_method,
    donation_note,
    target_recorded_by,
    p_payer_student_id,
    p_birthday_student_id,
    p_class_id
  );

  INSERT INTO public.birthday_donation_days (
    organization_id,
    donation_date,
    birthday_count,
    expected_amount,
    total_received,
    created_by,
    updated_by
  ) VALUES (
    org_id,
    donation_day,
    birthday_count,
    25,
    donation_amount,
    target_recorded_by,
    target_recorded_by
  )
  ON CONFLICT (organization_id, donation_date)
  DO UPDATE SET
    birthday_count = EXCLUDED.birthday_count,
    total_received = birthday_donation_days.total_received + EXCLUDED.total_received,
    updated_by = target_recorded_by,
    updated_at = now();

  SELECT * INTO day_row
  FROM public.birthday_donation_days
  WHERE organization_id = org_id
    AND donation_date = donation_day;

  RETURN day_row;
END;
$function$
;

create or replace view "public"."teacher_rating_summary" as  SELECT candidate_profile_id,
    teacher_user_id,
    (count(*))::integer AS rating_count,
    round(avg(rating_overall), 2) AS avg_rating,
    round(avg(rating_communication), 2) AS avg_communication,
    round(avg(rating_classroom), 2) AS avg_classroom,
    round(avg(rating_planning), 2) AS avg_planning,
    round(avg(rating_professionalism), 2) AS avg_professionalism,
    round(avg(rating_parent_engagement), 2) AS avg_parent_engagement,
    round(avg(rating_reliability), 2) AS avg_reliability,
    max(created_at) AS last_rating_at
   FROM public.teacher_references tr
  GROUP BY candidate_profile_id, teacher_user_id;


CREATE OR REPLACE FUNCTION public.user_can_manage_org_documents(p_user_id uuid, p_org_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
BEGIN
  RETURN EXISTS (
    SELECT 1
    FROM organization_members om
    WHERE om.user_id = p_user_id
      AND om.organization_id = p_org_id
      AND om.membership_status = 'active'
      AND (
        om.role IN ('admin', 'national_admin')
        OR om.member_type IN (
          'ceo', 'president', 'deputy_president', 'secretary_general', 'treasurer',
          'national_admin', 'national_coordinator', 'executive', 'board_member',
          'youth_president', 'youth_deputy', 'youth_secretary', 'youth_treasurer',
          'women_president', 'women_deputy', 'women_secretary', 'women_treasurer',
          'veterans_president', 'regional_manager', 'regional_coordinator',
          'provincial_manager', 'provincial_coordinator', 'branch_manager'
        )
      )
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.user_can_read_profile(profile_user_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO 'public', 'extensions', 'auth'
AS $function$
DECLARE
  current_user_profile RECORD;
  target_profile RECORD;
BEGIN
  -- Get current user's profile
  SELECT * INTO current_user_profile
  FROM public.profiles
  WHERE auth_user_id = auth.uid();  -- FIXED: was id = auth.uid()

  IF current_user_profile IS NULL THEN
    RETURN FALSE;
  END IF;

  -- Superadmins can read any profile
  IF current_user_profile.role IN ('superadmin', 'super_admin') THEN
    RETURN TRUE;
  END IF;

  -- Can always read own profile
  IF current_user_profile.id = profile_user_id OR current_user_profile.auth_user_id = profile_user_id THEN
    RETURN TRUE;
  END IF;

  -- Get target profile
  SELECT * INTO target_profile
  FROM public.profiles
  WHERE id = profile_user_id OR auth_user_id = profile_user_id;

  IF target_profile IS NULL THEN
    RETURN FALSE;
  END IF;

  -- Can read profiles in same organization
  IF COALESCE(current_user_profile.organization_id, current_user_profile.preschool_id) = 
     COALESCE(target_profile.organization_id, target_profile.preschool_id) THEN
    RETURN TRUE;
  END IF;

  -- Also check via organization_members
  RETURN EXISTS (
    SELECT 1
    FROM organization_members om1
    JOIN organization_members om2 ON om1.organization_id = om2.organization_id
    WHERE om1.user_id = profile_user_id
      AND om2.user_id = auth.uid()
      AND om1.seat_status = 'active'
      AND om2.seat_status = 'active'
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.user_can_view_org_document(p_user_id uuid, p_org_id uuid, p_access_level text, p_document_id uuid, p_is_deleted boolean)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
BEGIN
  -- Deleted documents are never visible
  IF p_is_deleted THEN
    RETURN FALSE;
  END IF;

  -- Public documents
  IF p_access_level = 'public' THEN
    RETURN TRUE;
  END IF;

  -- Check custom access grants
  IF EXISTS (
    SELECT 1
    FROM organization_document_access oda
    WHERE oda.document_id = p_document_id
      AND oda.grantee_user_id = p_user_id
      AND oda.revoked_at IS NULL
      AND (oda.valid_until IS NULL OR oda.valid_until > now())
  ) THEN
    RETURN TRUE;
  END IF;

  -- Check organization membership and access level
  RETURN EXISTS (
    SELECT 1
    FROM organization_members om
    WHERE om.user_id = p_user_id
      AND om.organization_id = p_org_id
      AND om.membership_status = 'active'
      AND (
        -- Members level
        (p_access_level = 'members')
        OR
        -- Managers level
        (p_access_level = 'managers' AND (
          om.role IN ('admin', 'national_admin', 'regional_manager', 'branch_manager')
          OR om.member_type IN (
            'regional_manager', 'regional_coordinator', 'provincial_manager',
            'provincial_coordinator', 'branch_manager', 'ceo', 'president',
            'deputy_president', 'secretary_general', 'treasurer', 'national_admin',
            'national_coordinator', 'executive', 'board_member', 'youth_president',
            'youth_deputy', 'youth_secretary', 'youth_treasurer', 'women_president',
            'women_deputy', 'women_secretary', 'women_treasurer', 'veterans_president'
          )
        ))
        OR
        -- Executives level
        (p_access_level = 'executives' AND (
          om.role IN ('admin', 'national_admin')
          OR om.member_type IN (
            'ceo', 'president', 'deputy_president', 'secretary_general', 'treasurer',
            'national_admin', 'national_coordinator', 'executive', 'board_member',
            'youth_president', 'youth_deputy', 'youth_secretary', 'youth_treasurer',
            'women_president', 'women_deputy', 'women_secretary', 'women_treasurer',
            'veterans_president'
          )
        ))
        OR
        -- Admin only
        (p_access_level = 'admin_only' AND (
          om.role IN ('admin', 'national_admin')
          OR om.member_type IN (
            'ceo', 'president', 'deputy_president', 'secretary_general', 'treasurer',
            'national_admin', 'national_coordinator', 'executive', 'board_member',
            'youth_president', 'youth_deputy', 'youth_secretary', 'youth_treasurer',
            'women_president', 'women_deputy', 'women_secretary', 'women_treasurer',
            'veterans_president'
          )
        ))
      )
  );
END;
$function$
;

grant delete on table "public"."active_calls" to "anon";

grant insert on table "public"."active_calls" to "anon";

grant references on table "public"."active_calls" to "anon";

grant select on table "public"."active_calls" to "anon";

grant trigger on table "public"."active_calls" to "anon";

grant truncate on table "public"."active_calls" to "anon";

grant update on table "public"."active_calls" to "anon";

grant delete on table "public"."active_calls" to "authenticated";

grant insert on table "public"."active_calls" to "authenticated";

grant references on table "public"."active_calls" to "authenticated";

grant select on table "public"."active_calls" to "authenticated";

grant trigger on table "public"."active_calls" to "authenticated";

grant truncate on table "public"."active_calls" to "authenticated";

grant update on table "public"."active_calls" to "authenticated";

grant delete on table "public"."active_calls" to "service_role";

grant insert on table "public"."active_calls" to "service_role";

grant references on table "public"."active_calls" to "service_role";

grant select on table "public"."active_calls" to "service_role";

grant trigger on table "public"."active_calls" to "service_role";

grant truncate on table "public"."active_calls" to "service_role";

grant update on table "public"."active_calls" to "service_role";

grant delete on table "public"."activities" to "anon";

grant insert on table "public"."activities" to "anon";

grant references on table "public"."activities" to "anon";

grant select on table "public"."activities" to "anon";

grant trigger on table "public"."activities" to "anon";

grant truncate on table "public"."activities" to "anon";

grant update on table "public"."activities" to "anon";

grant delete on table "public"."activities" to "authenticated";

grant insert on table "public"."activities" to "authenticated";

grant references on table "public"."activities" to "authenticated";

grant select on table "public"."activities" to "authenticated";

grant trigger on table "public"."activities" to "authenticated";

grant truncate on table "public"."activities" to "authenticated";

grant update on table "public"."activities" to "authenticated";

grant delete on table "public"."activities" to "service_role";

grant insert on table "public"."activities" to "service_role";

grant references on table "public"."activities" to "service_role";

grant select on table "public"."activities" to "service_role";

grant trigger on table "public"."activities" to "service_role";

grant truncate on table "public"."activities" to "service_role";

grant update on table "public"."activities" to "service_role";

grant delete on table "public"."activity_attempts" to "anon";

grant insert on table "public"."activity_attempts" to "anon";

grant references on table "public"."activity_attempts" to "anon";

grant select on table "public"."activity_attempts" to "anon";

grant trigger on table "public"."activity_attempts" to "anon";

grant truncate on table "public"."activity_attempts" to "anon";

grant update on table "public"."activity_attempts" to "anon";

grant delete on table "public"."activity_attempts" to "authenticated";

grant insert on table "public"."activity_attempts" to "authenticated";

grant references on table "public"."activity_attempts" to "authenticated";

grant select on table "public"."activity_attempts" to "authenticated";

grant trigger on table "public"."activity_attempts" to "authenticated";

grant truncate on table "public"."activity_attempts" to "authenticated";

grant update on table "public"."activity_attempts" to "authenticated";

grant delete on table "public"."activity_attempts" to "service_role";

grant insert on table "public"."activity_attempts" to "service_role";

grant references on table "public"."activity_attempts" to "service_role";

grant select on table "public"."activity_attempts" to "service_role";

grant trigger on table "public"."activity_attempts" to "service_role";

grant truncate on table "public"."activity_attempts" to "service_role";

grant update on table "public"."activity_attempts" to "service_role";

grant delete on table "public"."activity_feed" to "anon";

grant insert on table "public"."activity_feed" to "anon";

grant references on table "public"."activity_feed" to "anon";

grant select on table "public"."activity_feed" to "anon";

grant trigger on table "public"."activity_feed" to "anon";

grant truncate on table "public"."activity_feed" to "anon";

grant update on table "public"."activity_feed" to "anon";

grant delete on table "public"."activity_feed" to "authenticated";

grant insert on table "public"."activity_feed" to "authenticated";

grant references on table "public"."activity_feed" to "authenticated";

grant select on table "public"."activity_feed" to "authenticated";

grant trigger on table "public"."activity_feed" to "authenticated";

grant truncate on table "public"."activity_feed" to "authenticated";

grant update on table "public"."activity_feed" to "authenticated";

grant delete on table "public"."activity_feed" to "service_role";

grant insert on table "public"."activity_feed" to "service_role";

grant references on table "public"."activity_feed" to "service_role";

grant select on table "public"."activity_feed" to "service_role";

grant trigger on table "public"."activity_feed" to "service_role";

grant truncate on table "public"."activity_feed" to "service_role";

grant update on table "public"."activity_feed" to "service_role";

grant delete on table "public"."activity_logs" to "anon";

grant insert on table "public"."activity_logs" to "anon";

grant references on table "public"."activity_logs" to "anon";

grant select on table "public"."activity_logs" to "anon";

grant trigger on table "public"."activity_logs" to "anon";

grant truncate on table "public"."activity_logs" to "anon";

grant update on table "public"."activity_logs" to "anon";

grant delete on table "public"."activity_logs" to "authenticated";

grant insert on table "public"."activity_logs" to "authenticated";

grant references on table "public"."activity_logs" to "authenticated";

grant select on table "public"."activity_logs" to "authenticated";

grant trigger on table "public"."activity_logs" to "authenticated";

grant truncate on table "public"."activity_logs" to "authenticated";

grant update on table "public"."activity_logs" to "authenticated";

grant delete on table "public"."activity_logs" to "service_role";

grant insert on table "public"."activity_logs" to "service_role";

grant references on table "public"."activity_logs" to "service_role";

grant select on table "public"."activity_logs" to "service_role";

grant trigger on table "public"."activity_logs" to "service_role";

grant truncate on table "public"."activity_logs" to "service_role";

grant update on table "public"."activity_logs" to "service_role";

grant delete on table "public"."activity_submissions" to "anon";

grant insert on table "public"."activity_submissions" to "anon";

grant references on table "public"."activity_submissions" to "anon";

grant select on table "public"."activity_submissions" to "anon";

grant trigger on table "public"."activity_submissions" to "anon";

grant truncate on table "public"."activity_submissions" to "anon";

grant update on table "public"."activity_submissions" to "anon";

grant delete on table "public"."activity_submissions" to "authenticated";

grant insert on table "public"."activity_submissions" to "authenticated";

grant references on table "public"."activity_submissions" to "authenticated";

grant select on table "public"."activity_submissions" to "authenticated";

grant trigger on table "public"."activity_submissions" to "authenticated";

grant truncate on table "public"."activity_submissions" to "authenticated";

grant update on table "public"."activity_submissions" to "authenticated";

grant delete on table "public"."activity_submissions" to "service_role";

grant insert on table "public"."activity_submissions" to "service_role";

grant references on table "public"."activity_submissions" to "service_role";

grant select on table "public"."activity_submissions" to "service_role";

grant trigger on table "public"."activity_submissions" to "service_role";

grant truncate on table "public"."activity_submissions" to "service_role";

grant update on table "public"."activity_submissions" to "service_role";

grant delete on table "public"."ad_impressions" to "anon";

grant insert on table "public"."ad_impressions" to "anon";

grant references on table "public"."ad_impressions" to "anon";

grant select on table "public"."ad_impressions" to "anon";

grant trigger on table "public"."ad_impressions" to "anon";

grant truncate on table "public"."ad_impressions" to "anon";

grant update on table "public"."ad_impressions" to "anon";

grant delete on table "public"."ad_impressions" to "authenticated";

grant insert on table "public"."ad_impressions" to "authenticated";

grant references on table "public"."ad_impressions" to "authenticated";

grant select on table "public"."ad_impressions" to "authenticated";

grant trigger on table "public"."ad_impressions" to "authenticated";

grant truncate on table "public"."ad_impressions" to "authenticated";

grant update on table "public"."ad_impressions" to "authenticated";

grant delete on table "public"."ad_impressions" to "service_role";

grant insert on table "public"."ad_impressions" to "service_role";

grant references on table "public"."ad_impressions" to "service_role";

grant select on table "public"."ad_impressions" to "service_role";

grant trigger on table "public"."ad_impressions" to "service_role";

grant truncate on table "public"."ad_impressions" to "service_role";

grant update on table "public"."ad_impressions" to "service_role";

grant delete on table "public"."addresses" to "anon";

grant insert on table "public"."addresses" to "anon";

grant references on table "public"."addresses" to "anon";

grant select on table "public"."addresses" to "anon";

grant trigger on table "public"."addresses" to "anon";

grant truncate on table "public"."addresses" to "anon";

grant update on table "public"."addresses" to "anon";

grant delete on table "public"."addresses" to "authenticated";

grant insert on table "public"."addresses" to "authenticated";

grant references on table "public"."addresses" to "authenticated";

grant select on table "public"."addresses" to "authenticated";

grant trigger on table "public"."addresses" to "authenticated";

grant truncate on table "public"."addresses" to "authenticated";

grant update on table "public"."addresses" to "authenticated";

grant delete on table "public"."addresses" to "service_role";

grant insert on table "public"."addresses" to "service_role";

grant references on table "public"."addresses" to "service_role";

grant select on table "public"."addresses" to "service_role";

grant trigger on table "public"."addresses" to "service_role";

grant truncate on table "public"."addresses" to "service_role";

grant update on table "public"."addresses" to "service_role";

grant delete on table "public"."admin_users" to "anon";

grant insert on table "public"."admin_users" to "anon";

grant references on table "public"."admin_users" to "anon";

grant select on table "public"."admin_users" to "anon";

grant trigger on table "public"."admin_users" to "anon";

grant truncate on table "public"."admin_users" to "anon";

grant update on table "public"."admin_users" to "anon";

grant delete on table "public"."admin_users" to "authenticated";

grant insert on table "public"."admin_users" to "authenticated";

grant references on table "public"."admin_users" to "authenticated";

grant select on table "public"."admin_users" to "authenticated";

grant trigger on table "public"."admin_users" to "authenticated";

grant truncate on table "public"."admin_users" to "authenticated";

grant update on table "public"."admin_users" to "authenticated";

grant delete on table "public"."admin_users" to "service_role";

grant insert on table "public"."admin_users" to "service_role";

grant references on table "public"."admin_users" to "service_role";

grant select on table "public"."admin_users" to "service_role";

grant trigger on table "public"."admin_users" to "service_role";

grant truncate on table "public"."admin_users" to "service_role";

grant update on table "public"."admin_users" to "service_role";

grant delete on table "public"."age_groups" to "anon";

grant insert on table "public"."age_groups" to "anon";

grant references on table "public"."age_groups" to "anon";

grant select on table "public"."age_groups" to "anon";

grant trigger on table "public"."age_groups" to "anon";

grant truncate on table "public"."age_groups" to "anon";

grant update on table "public"."age_groups" to "anon";

grant delete on table "public"."age_groups" to "authenticated";

grant insert on table "public"."age_groups" to "authenticated";

grant references on table "public"."age_groups" to "authenticated";

grant select on table "public"."age_groups" to "authenticated";

grant trigger on table "public"."age_groups" to "authenticated";

grant truncate on table "public"."age_groups" to "authenticated";

grant update on table "public"."age_groups" to "authenticated";

grant delete on table "public"."age_groups" to "service_role";

grant insert on table "public"."age_groups" to "service_role";

grant references on table "public"."age_groups" to "service_role";

grant select on table "public"."age_groups" to "service_role";

grant trigger on table "public"."age_groups" to "service_role";

grant truncate on table "public"."age_groups" to "service_role";

grant update on table "public"."age_groups" to "service_role";

grant delete on table "public"."ai_admin_actions" to "anon";

grant insert on table "public"."ai_admin_actions" to "anon";

grant references on table "public"."ai_admin_actions" to "anon";

grant select on table "public"."ai_admin_actions" to "anon";

grant trigger on table "public"."ai_admin_actions" to "anon";

grant truncate on table "public"."ai_admin_actions" to "anon";

grant update on table "public"."ai_admin_actions" to "anon";

grant delete on table "public"."ai_admin_actions" to "authenticated";

grant insert on table "public"."ai_admin_actions" to "authenticated";

grant references on table "public"."ai_admin_actions" to "authenticated";

grant select on table "public"."ai_admin_actions" to "authenticated";

grant trigger on table "public"."ai_admin_actions" to "authenticated";

grant truncate on table "public"."ai_admin_actions" to "authenticated";

grant update on table "public"."ai_admin_actions" to "authenticated";

grant delete on table "public"."ai_admin_actions" to "service_role";

grant insert on table "public"."ai_admin_actions" to "service_role";

grant references on table "public"."ai_admin_actions" to "service_role";

grant select on table "public"."ai_admin_actions" to "service_role";

grant trigger on table "public"."ai_admin_actions" to "service_role";

grant truncate on table "public"."ai_admin_actions" to "service_role";

grant update on table "public"."ai_admin_actions" to "service_role";

grant delete on table "public"."ai_allocation_history" to "anon";

grant insert on table "public"."ai_allocation_history" to "anon";

grant references on table "public"."ai_allocation_history" to "anon";

grant select on table "public"."ai_allocation_history" to "anon";

grant trigger on table "public"."ai_allocation_history" to "anon";

grant truncate on table "public"."ai_allocation_history" to "anon";

grant update on table "public"."ai_allocation_history" to "anon";

grant delete on table "public"."ai_allocation_history" to "authenticated";

grant insert on table "public"."ai_allocation_history" to "authenticated";

grant references on table "public"."ai_allocation_history" to "authenticated";

grant select on table "public"."ai_allocation_history" to "authenticated";

grant trigger on table "public"."ai_allocation_history" to "authenticated";

grant truncate on table "public"."ai_allocation_history" to "authenticated";

grant update on table "public"."ai_allocation_history" to "authenticated";

grant delete on table "public"."ai_allocation_history" to "service_role";

grant insert on table "public"."ai_allocation_history" to "service_role";

grant references on table "public"."ai_allocation_history" to "service_role";

grant select on table "public"."ai_allocation_history" to "service_role";

grant trigger on table "public"."ai_allocation_history" to "service_role";

grant truncate on table "public"."ai_allocation_history" to "service_role";

grant update on table "public"."ai_allocation_history" to "service_role";

grant delete on table "public"."ai_allocation_requests" to "anon";

grant insert on table "public"."ai_allocation_requests" to "anon";

grant references on table "public"."ai_allocation_requests" to "anon";

grant select on table "public"."ai_allocation_requests" to "anon";

grant trigger on table "public"."ai_allocation_requests" to "anon";

grant truncate on table "public"."ai_allocation_requests" to "anon";

grant update on table "public"."ai_allocation_requests" to "anon";

grant delete on table "public"."ai_allocation_requests" to "authenticated";

grant insert on table "public"."ai_allocation_requests" to "authenticated";

grant references on table "public"."ai_allocation_requests" to "authenticated";

grant select on table "public"."ai_allocation_requests" to "authenticated";

grant trigger on table "public"."ai_allocation_requests" to "authenticated";

grant truncate on table "public"."ai_allocation_requests" to "authenticated";

grant update on table "public"."ai_allocation_requests" to "authenticated";

grant delete on table "public"."ai_allocation_requests" to "service_role";

grant insert on table "public"."ai_allocation_requests" to "service_role";

grant references on table "public"."ai_allocation_requests" to "service_role";

grant select on table "public"."ai_allocation_requests" to "service_role";

grant trigger on table "public"."ai_allocation_requests" to "service_role";

grant truncate on table "public"."ai_allocation_requests" to "service_role";

grant update on table "public"."ai_allocation_requests" to "service_role";

grant delete on table "public"."ai_attachments" to "anon";

grant insert on table "public"."ai_attachments" to "anon";

grant references on table "public"."ai_attachments" to "anon";

grant select on table "public"."ai_attachments" to "anon";

grant trigger on table "public"."ai_attachments" to "anon";

grant truncate on table "public"."ai_attachments" to "anon";

grant update on table "public"."ai_attachments" to "anon";

grant delete on table "public"."ai_attachments" to "authenticated";

grant insert on table "public"."ai_attachments" to "authenticated";

grant references on table "public"."ai_attachments" to "authenticated";

grant select on table "public"."ai_attachments" to "authenticated";

grant trigger on table "public"."ai_attachments" to "authenticated";

grant truncate on table "public"."ai_attachments" to "authenticated";

grant update on table "public"."ai_attachments" to "authenticated";

grant delete on table "public"."ai_attachments" to "service_role";

grant insert on table "public"."ai_attachments" to "service_role";

grant references on table "public"."ai_attachments" to "service_role";

grant select on table "public"."ai_attachments" to "service_role";

grant trigger on table "public"."ai_attachments" to "service_role";

grant truncate on table "public"."ai_attachments" to "service_role";

grant update on table "public"."ai_attachments" to "service_role";

grant delete on table "public"."ai_autonomy_settings" to "anon";

grant insert on table "public"."ai_autonomy_settings" to "anon";

grant references on table "public"."ai_autonomy_settings" to "anon";

grant select on table "public"."ai_autonomy_settings" to "anon";

grant trigger on table "public"."ai_autonomy_settings" to "anon";

grant truncate on table "public"."ai_autonomy_settings" to "anon";

grant update on table "public"."ai_autonomy_settings" to "anon";

grant delete on table "public"."ai_autonomy_settings" to "authenticated";

grant insert on table "public"."ai_autonomy_settings" to "authenticated";

grant references on table "public"."ai_autonomy_settings" to "authenticated";

grant select on table "public"."ai_autonomy_settings" to "authenticated";

grant trigger on table "public"."ai_autonomy_settings" to "authenticated";

grant truncate on table "public"."ai_autonomy_settings" to "authenticated";

grant update on table "public"."ai_autonomy_settings" to "authenticated";

grant delete on table "public"."ai_autonomy_settings" to "service_role";

grant insert on table "public"."ai_autonomy_settings" to "service_role";

grant references on table "public"."ai_autonomy_settings" to "service_role";

grant select on table "public"."ai_autonomy_settings" to "service_role";

grant trigger on table "public"."ai_autonomy_settings" to "service_role";

grant truncate on table "public"."ai_autonomy_settings" to "service_role";

grant update on table "public"."ai_autonomy_settings" to "service_role";

grant delete on table "public"."ai_context_snapshots" to "anon";

grant insert on table "public"."ai_context_snapshots" to "anon";

grant references on table "public"."ai_context_snapshots" to "anon";

grant select on table "public"."ai_context_snapshots" to "anon";

grant trigger on table "public"."ai_context_snapshots" to "anon";

grant truncate on table "public"."ai_context_snapshots" to "anon";

grant update on table "public"."ai_context_snapshots" to "anon";

grant delete on table "public"."ai_context_snapshots" to "authenticated";

grant insert on table "public"."ai_context_snapshots" to "authenticated";

grant references on table "public"."ai_context_snapshots" to "authenticated";

grant select on table "public"."ai_context_snapshots" to "authenticated";

grant trigger on table "public"."ai_context_snapshots" to "authenticated";

grant truncate on table "public"."ai_context_snapshots" to "authenticated";

grant update on table "public"."ai_context_snapshots" to "authenticated";

grant delete on table "public"."ai_context_snapshots" to "service_role";

grant insert on table "public"."ai_context_snapshots" to "service_role";

grant references on table "public"."ai_context_snapshots" to "service_role";

grant select on table "public"."ai_context_snapshots" to "service_role";

grant trigger on table "public"."ai_context_snapshots" to "service_role";

grant truncate on table "public"."ai_context_snapshots" to "service_role";

grant update on table "public"."ai_context_snapshots" to "service_role";

grant delete on table "public"."ai_conversations" to "anon";

grant insert on table "public"."ai_conversations" to "anon";

grant references on table "public"."ai_conversations" to "anon";

grant select on table "public"."ai_conversations" to "anon";

grant trigger on table "public"."ai_conversations" to "anon";

grant truncate on table "public"."ai_conversations" to "anon";

grant update on table "public"."ai_conversations" to "anon";

grant delete on table "public"."ai_conversations" to "authenticated";

grant insert on table "public"."ai_conversations" to "authenticated";

grant references on table "public"."ai_conversations" to "authenticated";

grant select on table "public"."ai_conversations" to "authenticated";

grant trigger on table "public"."ai_conversations" to "authenticated";

grant truncate on table "public"."ai_conversations" to "authenticated";

grant update on table "public"."ai_conversations" to "authenticated";

grant delete on table "public"."ai_conversations" to "service_role";

grant insert on table "public"."ai_conversations" to "service_role";

grant references on table "public"."ai_conversations" to "service_role";

grant select on table "public"."ai_conversations" to "service_role";

grant trigger on table "public"."ai_conversations" to "service_role";

grant truncate on table "public"."ai_conversations" to "service_role";

grant update on table "public"."ai_conversations" to "service_role";

grant delete on table "public"."ai_events" to "anon";

grant insert on table "public"."ai_events" to "anon";

grant references on table "public"."ai_events" to "anon";

grant select on table "public"."ai_events" to "anon";

grant trigger on table "public"."ai_events" to "anon";

grant truncate on table "public"."ai_events" to "anon";

grant update on table "public"."ai_events" to "anon";

grant delete on table "public"."ai_events" to "authenticated";

grant insert on table "public"."ai_events" to "authenticated";

grant references on table "public"."ai_events" to "authenticated";

grant select on table "public"."ai_events" to "authenticated";

grant trigger on table "public"."ai_events" to "authenticated";

grant truncate on table "public"."ai_events" to "authenticated";

grant update on table "public"."ai_events" to "authenticated";

grant delete on table "public"."ai_events" to "service_role";

grant insert on table "public"."ai_events" to "service_role";

grant references on table "public"."ai_events" to "service_role";

grant select on table "public"."ai_events" to "service_role";

grant trigger on table "public"."ai_events" to "service_role";

grant truncate on table "public"."ai_events" to "service_role";

grant update on table "public"."ai_events" to "service_role";

grant delete on table "public"."ai_feedback" to "anon";

grant insert on table "public"."ai_feedback" to "anon";

grant references on table "public"."ai_feedback" to "anon";

grant select on table "public"."ai_feedback" to "anon";

grant trigger on table "public"."ai_feedback" to "anon";

grant truncate on table "public"."ai_feedback" to "anon";

grant update on table "public"."ai_feedback" to "anon";

grant delete on table "public"."ai_feedback" to "authenticated";

grant insert on table "public"."ai_feedback" to "authenticated";

grant references on table "public"."ai_feedback" to "authenticated";

grant select on table "public"."ai_feedback" to "authenticated";

grant trigger on table "public"."ai_feedback" to "authenticated";

grant truncate on table "public"."ai_feedback" to "authenticated";

grant update on table "public"."ai_feedback" to "authenticated";

grant delete on table "public"."ai_feedback" to "service_role";

grant insert on table "public"."ai_feedback" to "service_role";

grant references on table "public"."ai_feedback" to "service_role";

grant select on table "public"."ai_feedback" to "service_role";

grant trigger on table "public"."ai_feedback" to "service_role";

grant truncate on table "public"."ai_feedback" to "service_role";

grant update on table "public"."ai_feedback" to "service_role";

grant delete on table "public"."ai_generated_content" to "anon";

grant insert on table "public"."ai_generated_content" to "anon";

grant references on table "public"."ai_generated_content" to "anon";

grant select on table "public"."ai_generated_content" to "anon";

grant trigger on table "public"."ai_generated_content" to "anon";

grant truncate on table "public"."ai_generated_content" to "anon";

grant update on table "public"."ai_generated_content" to "anon";

grant delete on table "public"."ai_generated_content" to "authenticated";

grant insert on table "public"."ai_generated_content" to "authenticated";

grant references on table "public"."ai_generated_content" to "authenticated";

grant select on table "public"."ai_generated_content" to "authenticated";

grant trigger on table "public"."ai_generated_content" to "authenticated";

grant truncate on table "public"."ai_generated_content" to "authenticated";

grant update on table "public"."ai_generated_content" to "authenticated";

grant delete on table "public"."ai_generated_content" to "service_role";

grant insert on table "public"."ai_generated_content" to "service_role";

grant references on table "public"."ai_generated_content" to "service_role";

grant select on table "public"."ai_generated_content" to "service_role";

grant trigger on table "public"."ai_generated_content" to "service_role";

grant truncate on table "public"."ai_generated_content" to "service_role";

grant update on table "public"."ai_generated_content" to "service_role";

grant delete on table "public"."ai_generations" to "anon";

grant insert on table "public"."ai_generations" to "anon";

grant references on table "public"."ai_generations" to "anon";

grant select on table "public"."ai_generations" to "anon";

grant trigger on table "public"."ai_generations" to "anon";

grant truncate on table "public"."ai_generations" to "anon";

grant update on table "public"."ai_generations" to "anon";

grant delete on table "public"."ai_generations" to "authenticated";

grant insert on table "public"."ai_generations" to "authenticated";

grant references on table "public"."ai_generations" to "authenticated";

grant select on table "public"."ai_generations" to "authenticated";

grant trigger on table "public"."ai_generations" to "authenticated";

grant truncate on table "public"."ai_generations" to "authenticated";

grant update on table "public"."ai_generations" to "authenticated";

grant delete on table "public"."ai_generations" to "service_role";

grant insert on table "public"."ai_generations" to "service_role";

grant references on table "public"."ai_generations" to "service_role";

grant select on table "public"."ai_generations" to "service_role";

grant trigger on table "public"."ai_generations" to "service_role";

grant truncate on table "public"."ai_generations" to "service_role";

grant update on table "public"."ai_generations" to "service_role";

grant delete on table "public"."ai_global_settings" to "anon";

grant insert on table "public"."ai_global_settings" to "anon";

grant references on table "public"."ai_global_settings" to "anon";

grant select on table "public"."ai_global_settings" to "anon";

grant trigger on table "public"."ai_global_settings" to "anon";

grant truncate on table "public"."ai_global_settings" to "anon";

grant update on table "public"."ai_global_settings" to "anon";

grant delete on table "public"."ai_global_settings" to "authenticated";

grant insert on table "public"."ai_global_settings" to "authenticated";

grant references on table "public"."ai_global_settings" to "authenticated";

grant select on table "public"."ai_global_settings" to "authenticated";

grant trigger on table "public"."ai_global_settings" to "authenticated";

grant truncate on table "public"."ai_global_settings" to "authenticated";

grant update on table "public"."ai_global_settings" to "authenticated";

grant delete on table "public"."ai_global_settings" to "service_role";

grant insert on table "public"."ai_global_settings" to "service_role";

grant references on table "public"."ai_global_settings" to "service_role";

grant select on table "public"."ai_global_settings" to "service_role";

grant trigger on table "public"."ai_global_settings" to "service_role";

grant truncate on table "public"."ai_global_settings" to "service_role";

grant update on table "public"."ai_global_settings" to "service_role";

grant delete on table "public"."ai_insights" to "anon";

grant insert on table "public"."ai_insights" to "anon";

grant references on table "public"."ai_insights" to "anon";

grant select on table "public"."ai_insights" to "anon";

grant trigger on table "public"."ai_insights" to "anon";

grant truncate on table "public"."ai_insights" to "anon";

grant update on table "public"."ai_insights" to "anon";

grant delete on table "public"."ai_insights" to "authenticated";

grant insert on table "public"."ai_insights" to "authenticated";

grant references on table "public"."ai_insights" to "authenticated";

grant select on table "public"."ai_insights" to "authenticated";

grant trigger on table "public"."ai_insights" to "authenticated";

grant truncate on table "public"."ai_insights" to "authenticated";

grant update on table "public"."ai_insights" to "authenticated";

grant delete on table "public"."ai_insights" to "service_role";

grant insert on table "public"."ai_insights" to "service_role";

grant references on table "public"."ai_insights" to "service_role";

grant select on table "public"."ai_insights" to "service_role";

grant trigger on table "public"."ai_insights" to "service_role";

grant truncate on table "public"."ai_insights" to "service_role";

grant update on table "public"."ai_insights" to "service_role";

grant delete on table "public"."ai_memories" to "anon";

grant insert on table "public"."ai_memories" to "anon";

grant references on table "public"."ai_memories" to "anon";

grant select on table "public"."ai_memories" to "anon";

grant trigger on table "public"."ai_memories" to "anon";

grant truncate on table "public"."ai_memories" to "anon";

grant update on table "public"."ai_memories" to "anon";

grant delete on table "public"."ai_memories" to "authenticated";

grant insert on table "public"."ai_memories" to "authenticated";

grant references on table "public"."ai_memories" to "authenticated";

grant select on table "public"."ai_memories" to "authenticated";

grant trigger on table "public"."ai_memories" to "authenticated";

grant truncate on table "public"."ai_memories" to "authenticated";

grant update on table "public"."ai_memories" to "authenticated";

grant delete on table "public"."ai_memories" to "service_role";

grant insert on table "public"."ai_memories" to "service_role";

grant references on table "public"."ai_memories" to "service_role";

grant select on table "public"."ai_memories" to "service_role";

grant trigger on table "public"."ai_memories" to "service_role";

grant truncate on table "public"."ai_memories" to "service_role";

grant update on table "public"."ai_memories" to "service_role";

grant delete on table "public"."ai_messages" to "anon";

grant insert on table "public"."ai_messages" to "anon";

grant references on table "public"."ai_messages" to "anon";

grant select on table "public"."ai_messages" to "anon";

grant trigger on table "public"."ai_messages" to "anon";

grant truncate on table "public"."ai_messages" to "anon";

grant update on table "public"."ai_messages" to "anon";

grant delete on table "public"."ai_messages" to "authenticated";

grant insert on table "public"."ai_messages" to "authenticated";

grant references on table "public"."ai_messages" to "authenticated";

grant select on table "public"."ai_messages" to "authenticated";

grant trigger on table "public"."ai_messages" to "authenticated";

grant truncate on table "public"."ai_messages" to "authenticated";

grant update on table "public"."ai_messages" to "authenticated";

grant delete on table "public"."ai_messages" to "service_role";

grant insert on table "public"."ai_messages" to "service_role";

grant references on table "public"."ai_messages" to "service_role";

grant select on table "public"."ai_messages" to "service_role";

grant trigger on table "public"."ai_messages" to "service_role";

grant truncate on table "public"."ai_messages" to "service_role";

grant update on table "public"."ai_messages" to "service_role";

grant delete on table "public"."ai_model_tiers" to "anon";

grant insert on table "public"."ai_model_tiers" to "anon";

grant references on table "public"."ai_model_tiers" to "anon";

grant select on table "public"."ai_model_tiers" to "anon";

grant trigger on table "public"."ai_model_tiers" to "anon";

grant truncate on table "public"."ai_model_tiers" to "anon";

grant update on table "public"."ai_model_tiers" to "anon";

grant delete on table "public"."ai_model_tiers" to "authenticated";

grant insert on table "public"."ai_model_tiers" to "authenticated";

grant references on table "public"."ai_model_tiers" to "authenticated";

grant select on table "public"."ai_model_tiers" to "authenticated";

grant trigger on table "public"."ai_model_tiers" to "authenticated";

grant truncate on table "public"."ai_model_tiers" to "authenticated";

grant update on table "public"."ai_model_tiers" to "authenticated";

grant delete on table "public"."ai_model_tiers" to "service_role";

grant insert on table "public"."ai_model_tiers" to "service_role";

grant references on table "public"."ai_model_tiers" to "service_role";

grant select on table "public"."ai_model_tiers" to "service_role";

grant trigger on table "public"."ai_model_tiers" to "service_role";

grant truncate on table "public"."ai_model_tiers" to "service_role";

grant update on table "public"."ai_model_tiers" to "service_role";

grant delete on table "public"."ai_overage_logs" to "anon";

grant insert on table "public"."ai_overage_logs" to "anon";

grant references on table "public"."ai_overage_logs" to "anon";

grant select on table "public"."ai_overage_logs" to "anon";

grant trigger on table "public"."ai_overage_logs" to "anon";

grant truncate on table "public"."ai_overage_logs" to "anon";

grant update on table "public"."ai_overage_logs" to "anon";

grant delete on table "public"."ai_overage_logs" to "authenticated";

grant insert on table "public"."ai_overage_logs" to "authenticated";

grant references on table "public"."ai_overage_logs" to "authenticated";

grant select on table "public"."ai_overage_logs" to "authenticated";

grant trigger on table "public"."ai_overage_logs" to "authenticated";

grant truncate on table "public"."ai_overage_logs" to "authenticated";

grant update on table "public"."ai_overage_logs" to "authenticated";

grant delete on table "public"."ai_overage_logs" to "service_role";

grant insert on table "public"."ai_overage_logs" to "service_role";

grant references on table "public"."ai_overage_logs" to "service_role";

grant select on table "public"."ai_overage_logs" to "service_role";

grant trigger on table "public"."ai_overage_logs" to "service_role";

grant truncate on table "public"."ai_overage_logs" to "service_role";

grant update on table "public"."ai_overage_logs" to "service_role";

grant delete on table "public"."ai_provider_config" to "anon";

grant insert on table "public"."ai_provider_config" to "anon";

grant references on table "public"."ai_provider_config" to "anon";

grant select on table "public"."ai_provider_config" to "anon";

grant trigger on table "public"."ai_provider_config" to "anon";

grant truncate on table "public"."ai_provider_config" to "anon";

grant update on table "public"."ai_provider_config" to "anon";

grant delete on table "public"."ai_provider_config" to "authenticated";

grant insert on table "public"."ai_provider_config" to "authenticated";

grant references on table "public"."ai_provider_config" to "authenticated";

grant select on table "public"."ai_provider_config" to "authenticated";

grant trigger on table "public"."ai_provider_config" to "authenticated";

grant truncate on table "public"."ai_provider_config" to "authenticated";

grant update on table "public"."ai_provider_config" to "authenticated";

grant delete on table "public"."ai_provider_config" to "service_role";

grant insert on table "public"."ai_provider_config" to "service_role";

grant references on table "public"."ai_provider_config" to "service_role";

grant select on table "public"."ai_provider_config" to "service_role";

grant trigger on table "public"."ai_provider_config" to "service_role";

grant truncate on table "public"."ai_provider_config" to "service_role";

grant update on table "public"."ai_provider_config" to "service_role";

grant delete on table "public"."ai_recommendations" to "anon";

grant insert on table "public"."ai_recommendations" to "anon";

grant references on table "public"."ai_recommendations" to "anon";

grant select on table "public"."ai_recommendations" to "anon";

grant trigger on table "public"."ai_recommendations" to "anon";

grant truncate on table "public"."ai_recommendations" to "anon";

grant update on table "public"."ai_recommendations" to "anon";

grant delete on table "public"."ai_recommendations" to "authenticated";

grant insert on table "public"."ai_recommendations" to "authenticated";

grant references on table "public"."ai_recommendations" to "authenticated";

grant select on table "public"."ai_recommendations" to "authenticated";

grant trigger on table "public"."ai_recommendations" to "authenticated";

grant truncate on table "public"."ai_recommendations" to "authenticated";

grant update on table "public"."ai_recommendations" to "authenticated";

grant delete on table "public"."ai_recommendations" to "service_role";

grant insert on table "public"."ai_recommendations" to "service_role";

grant references on table "public"."ai_recommendations" to "service_role";

grant select on table "public"."ai_recommendations" to "service_role";

grant trigger on table "public"."ai_recommendations" to "service_role";

grant truncate on table "public"."ai_recommendations" to "service_role";

grant update on table "public"."ai_recommendations" to "service_role";

grant delete on table "public"."ai_request_log" to "anon";

grant insert on table "public"."ai_request_log" to "anon";

grant references on table "public"."ai_request_log" to "anon";

grant select on table "public"."ai_request_log" to "anon";

grant trigger on table "public"."ai_request_log" to "anon";

grant truncate on table "public"."ai_request_log" to "anon";

grant update on table "public"."ai_request_log" to "anon";

grant delete on table "public"."ai_request_log" to "authenticated";

grant insert on table "public"."ai_request_log" to "authenticated";

grant references on table "public"."ai_request_log" to "authenticated";

grant select on table "public"."ai_request_log" to "authenticated";

grant trigger on table "public"."ai_request_log" to "authenticated";

grant truncate on table "public"."ai_request_log" to "authenticated";

grant update on table "public"."ai_request_log" to "authenticated";

grant delete on table "public"."ai_request_log" to "service_role";

grant insert on table "public"."ai_request_log" to "service_role";

grant references on table "public"."ai_request_log" to "service_role";

grant select on table "public"."ai_request_log" to "service_role";

grant trigger on table "public"."ai_request_log" to "service_role";

grant truncate on table "public"."ai_request_log" to "service_role";

grant update on table "public"."ai_request_log" to "service_role";

grant delete on table "public"."ai_services" to "anon";

grant insert on table "public"."ai_services" to "anon";

grant references on table "public"."ai_services" to "anon";

grant select on table "public"."ai_services" to "anon";

grant trigger on table "public"."ai_services" to "anon";

grant truncate on table "public"."ai_services" to "anon";

grant update on table "public"."ai_services" to "anon";

grant delete on table "public"."ai_services" to "authenticated";

grant insert on table "public"."ai_services" to "authenticated";

grant references on table "public"."ai_services" to "authenticated";

grant select on table "public"."ai_services" to "authenticated";

grant trigger on table "public"."ai_services" to "authenticated";

grant truncate on table "public"."ai_services" to "authenticated";

grant update on table "public"."ai_services" to "authenticated";

grant delete on table "public"."ai_services" to "service_role";

grant insert on table "public"."ai_services" to "service_role";

grant references on table "public"."ai_services" to "service_role";

grant select on table "public"."ai_services" to "service_role";

grant trigger on table "public"."ai_services" to "service_role";

grant truncate on table "public"."ai_services" to "service_role";

grant update on table "public"."ai_services" to "service_role";

grant delete on table "public"."ai_task_runs" to "anon";

grant insert on table "public"."ai_task_runs" to "anon";

grant references on table "public"."ai_task_runs" to "anon";

grant select on table "public"."ai_task_runs" to "anon";

grant trigger on table "public"."ai_task_runs" to "anon";

grant truncate on table "public"."ai_task_runs" to "anon";

grant update on table "public"."ai_task_runs" to "anon";

grant delete on table "public"."ai_task_runs" to "authenticated";

grant insert on table "public"."ai_task_runs" to "authenticated";

grant references on table "public"."ai_task_runs" to "authenticated";

grant select on table "public"."ai_task_runs" to "authenticated";

grant trigger on table "public"."ai_task_runs" to "authenticated";

grant truncate on table "public"."ai_task_runs" to "authenticated";

grant update on table "public"."ai_task_runs" to "authenticated";

grant delete on table "public"."ai_task_runs" to "service_role";

grant insert on table "public"."ai_task_runs" to "service_role";

grant references on table "public"."ai_task_runs" to "service_role";

grant select on table "public"."ai_task_runs" to "service_role";

grant trigger on table "public"."ai_task_runs" to "service_role";

grant truncate on table "public"."ai_task_runs" to "service_role";

grant update on table "public"."ai_task_runs" to "service_role";

grant delete on table "public"."ai_usage" to "anon";

grant insert on table "public"."ai_usage" to "anon";

grant references on table "public"."ai_usage" to "anon";

grant select on table "public"."ai_usage" to "anon";

grant trigger on table "public"."ai_usage" to "anon";

grant truncate on table "public"."ai_usage" to "anon";

grant update on table "public"."ai_usage" to "anon";

grant delete on table "public"."ai_usage" to "authenticated";

grant insert on table "public"."ai_usage" to "authenticated";

grant references on table "public"."ai_usage" to "authenticated";

grant select on table "public"."ai_usage" to "authenticated";

grant trigger on table "public"."ai_usage" to "authenticated";

grant truncate on table "public"."ai_usage" to "authenticated";

grant update on table "public"."ai_usage" to "authenticated";

grant delete on table "public"."ai_usage" to "service_role";

grant insert on table "public"."ai_usage" to "service_role";

grant references on table "public"."ai_usage" to "service_role";

grant select on table "public"."ai_usage" to "service_role";

grant trigger on table "public"."ai_usage" to "service_role";

grant truncate on table "public"."ai_usage" to "service_role";

grant update on table "public"."ai_usage" to "service_role";

grant delete on table "public"."ai_usage_logs" to "anon";

grant insert on table "public"."ai_usage_logs" to "anon";

grant references on table "public"."ai_usage_logs" to "anon";

grant select on table "public"."ai_usage_logs" to "anon";

grant trigger on table "public"."ai_usage_logs" to "anon";

grant truncate on table "public"."ai_usage_logs" to "anon";

grant update on table "public"."ai_usage_logs" to "anon";

grant delete on table "public"."ai_usage_logs" to "authenticated";

grant insert on table "public"."ai_usage_logs" to "authenticated";

grant references on table "public"."ai_usage_logs" to "authenticated";

grant select on table "public"."ai_usage_logs" to "authenticated";

grant trigger on table "public"."ai_usage_logs" to "authenticated";

grant truncate on table "public"."ai_usage_logs" to "authenticated";

grant update on table "public"."ai_usage_logs" to "authenticated";

grant delete on table "public"."ai_usage_logs" to "service_role";

grant insert on table "public"."ai_usage_logs" to "service_role";

grant references on table "public"."ai_usage_logs" to "service_role";

grant select on table "public"."ai_usage_logs" to "service_role";

grant trigger on table "public"."ai_usage_logs" to "service_role";

grant truncate on table "public"."ai_usage_logs" to "service_role";

grant update on table "public"."ai_usage_logs" to "service_role";

grant delete on table "public"."ai_usage_resets" to "anon";

grant insert on table "public"."ai_usage_resets" to "anon";

grant references on table "public"."ai_usage_resets" to "anon";

grant select on table "public"."ai_usage_resets" to "anon";

grant trigger on table "public"."ai_usage_resets" to "anon";

grant truncate on table "public"."ai_usage_resets" to "anon";

grant update on table "public"."ai_usage_resets" to "anon";

grant delete on table "public"."ai_usage_resets" to "authenticated";

grant insert on table "public"."ai_usage_resets" to "authenticated";

grant references on table "public"."ai_usage_resets" to "authenticated";

grant select on table "public"."ai_usage_resets" to "authenticated";

grant trigger on table "public"."ai_usage_resets" to "authenticated";

grant truncate on table "public"."ai_usage_resets" to "authenticated";

grant update on table "public"."ai_usage_resets" to "authenticated";

grant delete on table "public"."ai_usage_resets" to "service_role";

grant insert on table "public"."ai_usage_resets" to "service_role";

grant references on table "public"."ai_usage_resets" to "service_role";

grant select on table "public"."ai_usage_resets" to "service_role";

grant trigger on table "public"."ai_usage_resets" to "service_role";

grant truncate on table "public"."ai_usage_resets" to "service_role";

grant update on table "public"."ai_usage_resets" to "service_role";

grant delete on table "public"."ai_usage_tiers" to "anon";

grant insert on table "public"."ai_usage_tiers" to "anon";

grant references on table "public"."ai_usage_tiers" to "anon";

grant select on table "public"."ai_usage_tiers" to "anon";

grant trigger on table "public"."ai_usage_tiers" to "anon";

grant truncate on table "public"."ai_usage_tiers" to "anon";

grant update on table "public"."ai_usage_tiers" to "anon";

grant delete on table "public"."ai_usage_tiers" to "authenticated";

grant insert on table "public"."ai_usage_tiers" to "authenticated";

grant references on table "public"."ai_usage_tiers" to "authenticated";

grant select on table "public"."ai_usage_tiers" to "authenticated";

grant trigger on table "public"."ai_usage_tiers" to "authenticated";

grant truncate on table "public"."ai_usage_tiers" to "authenticated";

grant update on table "public"."ai_usage_tiers" to "authenticated";

grant delete on table "public"."ai_usage_tiers" to "service_role";

grant insert on table "public"."ai_usage_tiers" to "service_role";

grant references on table "public"."ai_usage_tiers" to "service_role";

grant select on table "public"."ai_usage_tiers" to "service_role";

grant trigger on table "public"."ai_usage_tiers" to "service_role";

grant truncate on table "public"."ai_usage_tiers" to "service_role";

grant update on table "public"."ai_usage_tiers" to "service_role";

grant delete on table "public"."announcement_views" to "anon";

grant insert on table "public"."announcement_views" to "anon";

grant references on table "public"."announcement_views" to "anon";

grant select on table "public"."announcement_views" to "anon";

grant trigger on table "public"."announcement_views" to "anon";

grant truncate on table "public"."announcement_views" to "anon";

grant update on table "public"."announcement_views" to "anon";

grant delete on table "public"."announcement_views" to "authenticated";

grant insert on table "public"."announcement_views" to "authenticated";

grant references on table "public"."announcement_views" to "authenticated";

grant select on table "public"."announcement_views" to "authenticated";

grant trigger on table "public"."announcement_views" to "authenticated";

grant truncate on table "public"."announcement_views" to "authenticated";

grant update on table "public"."announcement_views" to "authenticated";

grant delete on table "public"."announcement_views" to "service_role";

grant insert on table "public"."announcement_views" to "service_role";

grant references on table "public"."announcement_views" to "service_role";

grant select on table "public"."announcement_views" to "service_role";

grant trigger on table "public"."announcement_views" to "service_role";

grant truncate on table "public"."announcement_views" to "service_role";

grant update on table "public"."announcement_views" to "service_role";

grant delete on table "public"."announcements" to "anon";

grant insert on table "public"."announcements" to "anon";

grant references on table "public"."announcements" to "anon";

grant select on table "public"."announcements" to "anon";

grant trigger on table "public"."announcements" to "anon";

grant truncate on table "public"."announcements" to "anon";

grant update on table "public"."announcements" to "anon";

grant delete on table "public"."announcements" to "authenticated";

grant insert on table "public"."announcements" to "authenticated";

grant references on table "public"."announcements" to "authenticated";

grant select on table "public"."announcements" to "authenticated";

grant trigger on table "public"."announcements" to "authenticated";

grant truncate on table "public"."announcements" to "authenticated";

grant update on table "public"."announcements" to "authenticated";

grant delete on table "public"."announcements" to "service_role";

grant insert on table "public"."announcements" to "service_role";

grant references on table "public"."announcements" to "service_role";

grant select on table "public"."announcements" to "service_role";

grant trigger on table "public"."announcements" to "service_role";

grant truncate on table "public"."announcements" to "service_role";

grant update on table "public"."announcements" to "service_role";

grant delete on table "public"."assessment_rubrics" to "anon";

grant insert on table "public"."assessment_rubrics" to "anon";

grant references on table "public"."assessment_rubrics" to "anon";

grant select on table "public"."assessment_rubrics" to "anon";

grant trigger on table "public"."assessment_rubrics" to "anon";

grant truncate on table "public"."assessment_rubrics" to "anon";

grant update on table "public"."assessment_rubrics" to "anon";

grant delete on table "public"."assessment_rubrics" to "authenticated";

grant insert on table "public"."assessment_rubrics" to "authenticated";

grant references on table "public"."assessment_rubrics" to "authenticated";

grant select on table "public"."assessment_rubrics" to "authenticated";

grant trigger on table "public"."assessment_rubrics" to "authenticated";

grant truncate on table "public"."assessment_rubrics" to "authenticated";

grant update on table "public"."assessment_rubrics" to "authenticated";

grant delete on table "public"."assessment_rubrics" to "service_role";

grant insert on table "public"."assessment_rubrics" to "service_role";

grant references on table "public"."assessment_rubrics" to "service_role";

grant select on table "public"."assessment_rubrics" to "service_role";

grant trigger on table "public"."assessment_rubrics" to "service_role";

grant truncate on table "public"."assessment_rubrics" to "service_role";

grant update on table "public"."assessment_rubrics" to "service_role";

grant delete on table "public"."assessments" to "anon";

grant insert on table "public"."assessments" to "anon";

grant references on table "public"."assessments" to "anon";

grant select on table "public"."assessments" to "anon";

grant trigger on table "public"."assessments" to "anon";

grant truncate on table "public"."assessments" to "anon";

grant update on table "public"."assessments" to "anon";

grant delete on table "public"."assessments" to "authenticated";

grant insert on table "public"."assessments" to "authenticated";

grant references on table "public"."assessments" to "authenticated";

grant select on table "public"."assessments" to "authenticated";

grant trigger on table "public"."assessments" to "authenticated";

grant truncate on table "public"."assessments" to "authenticated";

grant update on table "public"."assessments" to "authenticated";

grant delete on table "public"."assessments" to "service_role";

grant insert on table "public"."assessments" to "service_role";

grant references on table "public"."assessments" to "service_role";

grant select on table "public"."assessments" to "service_role";

grant trigger on table "public"."assessments" to "service_role";

grant truncate on table "public"."assessments" to "service_role";

grant update on table "public"."assessments" to "service_role";

grant delete on table "public"."assignment_access" to "anon";

grant insert on table "public"."assignment_access" to "anon";

grant references on table "public"."assignment_access" to "anon";

grant select on table "public"."assignment_access" to "anon";

grant trigger on table "public"."assignment_access" to "anon";

grant truncate on table "public"."assignment_access" to "anon";

grant update on table "public"."assignment_access" to "anon";

grant delete on table "public"."assignment_access" to "authenticated";

grant insert on table "public"."assignment_access" to "authenticated";

grant references on table "public"."assignment_access" to "authenticated";

grant select on table "public"."assignment_access" to "authenticated";

grant trigger on table "public"."assignment_access" to "authenticated";

grant truncate on table "public"."assignment_access" to "authenticated";

grant update on table "public"."assignment_access" to "authenticated";

grant delete on table "public"."assignment_access" to "service_role";

grant insert on table "public"."assignment_access" to "service_role";

grant references on table "public"."assignment_access" to "service_role";

grant select on table "public"."assignment_access" to "service_role";

grant trigger on table "public"."assignment_access" to "service_role";

grant truncate on table "public"."assignment_access" to "service_role";

grant update on table "public"."assignment_access" to "service_role";

grant delete on table "public"."assignment_categories" to "anon";

grant insert on table "public"."assignment_categories" to "anon";

grant references on table "public"."assignment_categories" to "anon";

grant select on table "public"."assignment_categories" to "anon";

grant trigger on table "public"."assignment_categories" to "anon";

grant truncate on table "public"."assignment_categories" to "anon";

grant update on table "public"."assignment_categories" to "anon";

grant delete on table "public"."assignment_categories" to "authenticated";

grant insert on table "public"."assignment_categories" to "authenticated";

grant references on table "public"."assignment_categories" to "authenticated";

grant select on table "public"."assignment_categories" to "authenticated";

grant trigger on table "public"."assignment_categories" to "authenticated";

grant truncate on table "public"."assignment_categories" to "authenticated";

grant update on table "public"."assignment_categories" to "authenticated";

grant delete on table "public"."assignment_categories" to "service_role";

grant insert on table "public"."assignment_categories" to "service_role";

grant references on table "public"."assignment_categories" to "service_role";

grant select on table "public"."assignment_categories" to "service_role";

grant trigger on table "public"."assignment_categories" to "service_role";

grant truncate on table "public"."assignment_categories" to "service_role";

grant update on table "public"."assignment_categories" to "service_role";

grant delete on table "public"."assignment_grades" to "anon";

grant insert on table "public"."assignment_grades" to "anon";

grant references on table "public"."assignment_grades" to "anon";

grant select on table "public"."assignment_grades" to "anon";

grant trigger on table "public"."assignment_grades" to "anon";

grant truncate on table "public"."assignment_grades" to "anon";

grant update on table "public"."assignment_grades" to "anon";

grant delete on table "public"."assignment_grades" to "authenticated";

grant insert on table "public"."assignment_grades" to "authenticated";

grant references on table "public"."assignment_grades" to "authenticated";

grant select on table "public"."assignment_grades" to "authenticated";

grant trigger on table "public"."assignment_grades" to "authenticated";

grant truncate on table "public"."assignment_grades" to "authenticated";

grant update on table "public"."assignment_grades" to "authenticated";

grant delete on table "public"."assignment_grades" to "service_role";

grant insert on table "public"."assignment_grades" to "service_role";

grant references on table "public"."assignment_grades" to "service_role";

grant select on table "public"."assignment_grades" to "service_role";

grant trigger on table "public"."assignment_grades" to "service_role";

grant truncate on table "public"."assignment_grades" to "service_role";

grant update on table "public"."assignment_grades" to "service_role";

grant delete on table "public"."assignment_rubrics" to "anon";

grant insert on table "public"."assignment_rubrics" to "anon";

grant references on table "public"."assignment_rubrics" to "anon";

grant select on table "public"."assignment_rubrics" to "anon";

grant trigger on table "public"."assignment_rubrics" to "anon";

grant truncate on table "public"."assignment_rubrics" to "anon";

grant update on table "public"."assignment_rubrics" to "anon";

grant delete on table "public"."assignment_rubrics" to "authenticated";

grant insert on table "public"."assignment_rubrics" to "authenticated";

grant references on table "public"."assignment_rubrics" to "authenticated";

grant select on table "public"."assignment_rubrics" to "authenticated";

grant trigger on table "public"."assignment_rubrics" to "authenticated";

grant truncate on table "public"."assignment_rubrics" to "authenticated";

grant update on table "public"."assignment_rubrics" to "authenticated";

grant delete on table "public"."assignment_rubrics" to "service_role";

grant insert on table "public"."assignment_rubrics" to "service_role";

grant references on table "public"."assignment_rubrics" to "service_role";

grant select on table "public"."assignment_rubrics" to "service_role";

grant trigger on table "public"."assignment_rubrics" to "service_role";

grant truncate on table "public"."assignment_rubrics" to "service_role";

grant update on table "public"."assignment_rubrics" to "service_role";

grant delete on table "public"."assignment_submissions" to "anon";

grant insert on table "public"."assignment_submissions" to "anon";

grant references on table "public"."assignment_submissions" to "anon";

grant select on table "public"."assignment_submissions" to "anon";

grant trigger on table "public"."assignment_submissions" to "anon";

grant truncate on table "public"."assignment_submissions" to "anon";

grant update on table "public"."assignment_submissions" to "anon";

grant delete on table "public"."assignment_submissions" to "authenticated";

grant insert on table "public"."assignment_submissions" to "authenticated";

grant references on table "public"."assignment_submissions" to "authenticated";

grant select on table "public"."assignment_submissions" to "authenticated";

grant trigger on table "public"."assignment_submissions" to "authenticated";

grant truncate on table "public"."assignment_submissions" to "authenticated";

grant update on table "public"."assignment_submissions" to "authenticated";

grant delete on table "public"."assignment_submissions" to "service_role";

grant insert on table "public"."assignment_submissions" to "service_role";

grant references on table "public"."assignment_submissions" to "service_role";

grant select on table "public"."assignment_submissions" to "service_role";

grant trigger on table "public"."assignment_submissions" to "service_role";

grant truncate on table "public"."assignment_submissions" to "service_role";

grant update on table "public"."assignment_submissions" to "service_role";

grant delete on table "public"."assignments" to "anon";

grant insert on table "public"."assignments" to "anon";

grant references on table "public"."assignments" to "anon";

grant select on table "public"."assignments" to "anon";

grant trigger on table "public"."assignments" to "anon";

grant truncate on table "public"."assignments" to "anon";

grant update on table "public"."assignments" to "anon";

grant delete on table "public"."assignments" to "authenticated";

grant insert on table "public"."assignments" to "authenticated";

grant references on table "public"."assignments" to "authenticated";

grant select on table "public"."assignments" to "authenticated";

grant trigger on table "public"."assignments" to "authenticated";

grant truncate on table "public"."assignments" to "authenticated";

grant update on table "public"."assignments" to "authenticated";

grant delete on table "public"."assignments" to "service_role";

grant insert on table "public"."assignments" to "service_role";

grant references on table "public"."assignments" to "service_role";

grant select on table "public"."assignments" to "service_role";

grant trigger on table "public"."assignments" to "service_role";

grant truncate on table "public"."assignments" to "service_role";

grant update on table "public"."assignments" to "service_role";

grant delete on table "public"."attendance" to "anon";

grant insert on table "public"."attendance" to "anon";

grant references on table "public"."attendance" to "anon";

grant select on table "public"."attendance" to "anon";

grant trigger on table "public"."attendance" to "anon";

grant truncate on table "public"."attendance" to "anon";

grant update on table "public"."attendance" to "anon";

grant delete on table "public"."attendance" to "authenticated";

grant insert on table "public"."attendance" to "authenticated";

grant references on table "public"."attendance" to "authenticated";

grant select on table "public"."attendance" to "authenticated";

grant trigger on table "public"."attendance" to "authenticated";

grant truncate on table "public"."attendance" to "authenticated";

grant update on table "public"."attendance" to "authenticated";

grant delete on table "public"."attendance" to "service_role";

grant insert on table "public"."attendance" to "service_role";

grant references on table "public"."attendance" to "service_role";

grant select on table "public"."attendance" to "service_role";

grant trigger on table "public"."attendance" to "service_role";

grant truncate on table "public"."attendance" to "service_role";

grant update on table "public"."attendance" to "service_role";

grant delete on table "public"."attendance_records" to "anon";

grant insert on table "public"."attendance_records" to "anon";

grant references on table "public"."attendance_records" to "anon";

grant select on table "public"."attendance_records" to "anon";

grant trigger on table "public"."attendance_records" to "anon";

grant truncate on table "public"."attendance_records" to "anon";

grant update on table "public"."attendance_records" to "anon";

grant delete on table "public"."attendance_records" to "authenticated";

grant insert on table "public"."attendance_records" to "authenticated";

grant references on table "public"."attendance_records" to "authenticated";

grant select on table "public"."attendance_records" to "authenticated";

grant trigger on table "public"."attendance_records" to "authenticated";

grant truncate on table "public"."attendance_records" to "authenticated";

grant update on table "public"."attendance_records" to "authenticated";

grant delete on table "public"."attendance_records" to "service_role";

grant insert on table "public"."attendance_records" to "service_role";

grant references on table "public"."attendance_records" to "service_role";

grant select on table "public"."attendance_records" to "service_role";

grant trigger on table "public"."attendance_records" to "service_role";

grant truncate on table "public"."attendance_records" to "service_role";

grant update on table "public"."attendance_records" to "service_role";

grant delete on table "public"."audit_logs" to "anon";

grant insert on table "public"."audit_logs" to "anon";

grant references on table "public"."audit_logs" to "anon";

grant select on table "public"."audit_logs" to "anon";

grant trigger on table "public"."audit_logs" to "anon";

grant truncate on table "public"."audit_logs" to "anon";

grant update on table "public"."audit_logs" to "anon";

grant delete on table "public"."audit_logs" to "authenticated";

grant insert on table "public"."audit_logs" to "authenticated";

grant references on table "public"."audit_logs" to "authenticated";

grant select on table "public"."audit_logs" to "authenticated";

grant trigger on table "public"."audit_logs" to "authenticated";

grant truncate on table "public"."audit_logs" to "authenticated";

grant update on table "public"."audit_logs" to "authenticated";

grant delete on table "public"."audit_logs" to "service_role";

grant insert on table "public"."audit_logs" to "service_role";

grant references on table "public"."audit_logs" to "service_role";

grant select on table "public"."audit_logs" to "service_role";

grant trigger on table "public"."audit_logs" to "service_role";

grant truncate on table "public"."audit_logs" to "service_role";

grant update on table "public"."audit_logs" to "service_role";

grant delete on table "public"."beta_feedback" to "anon";

grant insert on table "public"."beta_feedback" to "anon";

grant references on table "public"."beta_feedback" to "anon";

grant select on table "public"."beta_feedback" to "anon";

grant trigger on table "public"."beta_feedback" to "anon";

grant truncate on table "public"."beta_feedback" to "anon";

grant update on table "public"."beta_feedback" to "anon";

grant delete on table "public"."beta_feedback" to "authenticated";

grant insert on table "public"."beta_feedback" to "authenticated";

grant references on table "public"."beta_feedback" to "authenticated";

grant select on table "public"."beta_feedback" to "authenticated";

grant trigger on table "public"."beta_feedback" to "authenticated";

grant truncate on table "public"."beta_feedback" to "authenticated";

grant update on table "public"."beta_feedback" to "authenticated";

grant delete on table "public"."beta_feedback" to "service_role";

grant insert on table "public"."beta_feedback" to "service_role";

grant references on table "public"."beta_feedback" to "service_role";

grant select on table "public"."beta_feedback" to "service_role";

grant trigger on table "public"."beta_feedback" to "service_role";

grant truncate on table "public"."beta_feedback" to "service_role";

grant update on table "public"."beta_feedback" to "service_role";

grant delete on table "public"."beta_feedback_attachments" to "anon";

grant insert on table "public"."beta_feedback_attachments" to "anon";

grant references on table "public"."beta_feedback_attachments" to "anon";

grant select on table "public"."beta_feedback_attachments" to "anon";

grant trigger on table "public"."beta_feedback_attachments" to "anon";

grant truncate on table "public"."beta_feedback_attachments" to "anon";

grant update on table "public"."beta_feedback_attachments" to "anon";

grant delete on table "public"."beta_feedback_attachments" to "authenticated";

grant insert on table "public"."beta_feedback_attachments" to "authenticated";

grant references on table "public"."beta_feedback_attachments" to "authenticated";

grant select on table "public"."beta_feedback_attachments" to "authenticated";

grant trigger on table "public"."beta_feedback_attachments" to "authenticated";

grant truncate on table "public"."beta_feedback_attachments" to "authenticated";

grant update on table "public"."beta_feedback_attachments" to "authenticated";

grant delete on table "public"."beta_feedback_attachments" to "service_role";

grant insert on table "public"."beta_feedback_attachments" to "service_role";

grant references on table "public"."beta_feedback_attachments" to "service_role";

grant select on table "public"."beta_feedback_attachments" to "service_role";

grant trigger on table "public"."beta_feedback_attachments" to "service_role";

grant truncate on table "public"."beta_feedback_attachments" to "service_role";

grant update on table "public"."beta_feedback_attachments" to "service_role";

grant delete on table "public"."billing_cycles" to "anon";

grant insert on table "public"."billing_cycles" to "anon";

grant references on table "public"."billing_cycles" to "anon";

grant select on table "public"."billing_cycles" to "anon";

grant trigger on table "public"."billing_cycles" to "anon";

grant truncate on table "public"."billing_cycles" to "anon";

grant update on table "public"."billing_cycles" to "anon";

grant delete on table "public"."billing_cycles" to "authenticated";

grant insert on table "public"."billing_cycles" to "authenticated";

grant references on table "public"."billing_cycles" to "authenticated";

grant select on table "public"."billing_cycles" to "authenticated";

grant trigger on table "public"."billing_cycles" to "authenticated";

grant truncate on table "public"."billing_cycles" to "authenticated";

grant update on table "public"."billing_cycles" to "authenticated";

grant delete on table "public"."billing_cycles" to "service_role";

grant insert on table "public"."billing_cycles" to "service_role";

grant references on table "public"."billing_cycles" to "service_role";

grant select on table "public"."billing_cycles" to "service_role";

grant trigger on table "public"."billing_cycles" to "service_role";

grant truncate on table "public"."billing_cycles" to "service_role";

grant update on table "public"."billing_cycles" to "service_role";

grant delete on table "public"."billing_invoices" to "anon";

grant insert on table "public"."billing_invoices" to "anon";

grant references on table "public"."billing_invoices" to "anon";

grant select on table "public"."billing_invoices" to "anon";

grant trigger on table "public"."billing_invoices" to "anon";

grant truncate on table "public"."billing_invoices" to "anon";

grant update on table "public"."billing_invoices" to "anon";

grant delete on table "public"."billing_invoices" to "authenticated";

grant insert on table "public"."billing_invoices" to "authenticated";

grant references on table "public"."billing_invoices" to "authenticated";

grant select on table "public"."billing_invoices" to "authenticated";

grant trigger on table "public"."billing_invoices" to "authenticated";

grant truncate on table "public"."billing_invoices" to "authenticated";

grant update on table "public"."billing_invoices" to "authenticated";

grant delete on table "public"."billing_invoices" to "service_role";

grant insert on table "public"."billing_invoices" to "service_role";

grant references on table "public"."billing_invoices" to "service_role";

grant select on table "public"."billing_invoices" to "service_role";

grant trigger on table "public"."billing_invoices" to "service_role";

grant truncate on table "public"."billing_invoices" to "service_role";

grant update on table "public"."billing_invoices" to "service_role";

grant delete on table "public"."billing_plans" to "anon";

grant insert on table "public"."billing_plans" to "anon";

grant references on table "public"."billing_plans" to "anon";

grant select on table "public"."billing_plans" to "anon";

grant trigger on table "public"."billing_plans" to "anon";

grant truncate on table "public"."billing_plans" to "anon";

grant update on table "public"."billing_plans" to "anon";

grant delete on table "public"."billing_plans" to "authenticated";

grant insert on table "public"."billing_plans" to "authenticated";

grant references on table "public"."billing_plans" to "authenticated";

grant select on table "public"."billing_plans" to "authenticated";

grant trigger on table "public"."billing_plans" to "authenticated";

grant truncate on table "public"."billing_plans" to "authenticated";

grant update on table "public"."billing_plans" to "authenticated";

grant delete on table "public"."billing_plans" to "service_role";

grant insert on table "public"."billing_plans" to "service_role";

grant references on table "public"."billing_plans" to "service_role";

grant select on table "public"."billing_plans" to "service_role";

grant trigger on table "public"."billing_plans" to "service_role";

grant truncate on table "public"."billing_plans" to "service_role";

grant update on table "public"."billing_plans" to "service_role";

grant delete on table "public"."billing_preferences" to "anon";

grant insert on table "public"."billing_preferences" to "anon";

grant references on table "public"."billing_preferences" to "anon";

grant select on table "public"."billing_preferences" to "anon";

grant trigger on table "public"."billing_preferences" to "anon";

grant truncate on table "public"."billing_preferences" to "anon";

grant update on table "public"."billing_preferences" to "anon";

grant delete on table "public"."billing_preferences" to "authenticated";

grant insert on table "public"."billing_preferences" to "authenticated";

grant references on table "public"."billing_preferences" to "authenticated";

grant select on table "public"."billing_preferences" to "authenticated";

grant trigger on table "public"."billing_preferences" to "authenticated";

grant truncate on table "public"."billing_preferences" to "authenticated";

grant update on table "public"."billing_preferences" to "authenticated";

grant delete on table "public"."billing_preferences" to "service_role";

grant insert on table "public"."billing_preferences" to "service_role";

grant references on table "public"."billing_preferences" to "service_role";

grant select on table "public"."billing_preferences" to "service_role";

grant trigger on table "public"."billing_preferences" to "service_role";

grant truncate on table "public"."billing_preferences" to "service_role";

grant update on table "public"."billing_preferences" to "service_role";

grant delete on table "public"."blocked_content" to "anon";

grant insert on table "public"."blocked_content" to "anon";

grant references on table "public"."blocked_content" to "anon";

grant select on table "public"."blocked_content" to "anon";

grant trigger on table "public"."blocked_content" to "anon";

grant truncate on table "public"."blocked_content" to "anon";

grant update on table "public"."blocked_content" to "anon";

grant delete on table "public"."blocked_content" to "authenticated";

grant insert on table "public"."blocked_content" to "authenticated";

grant references on table "public"."blocked_content" to "authenticated";

grant select on table "public"."blocked_content" to "authenticated";

grant trigger on table "public"."blocked_content" to "authenticated";

grant truncate on table "public"."blocked_content" to "authenticated";

grant update on table "public"."blocked_content" to "authenticated";

grant delete on table "public"."blocked_content" to "service_role";

grant insert on table "public"."blocked_content" to "service_role";

grant references on table "public"."blocked_content" to "service_role";

grant select on table "public"."blocked_content" to "service_role";

grant trigger on table "public"."blocked_content" to "service_role";

grant truncate on table "public"."blocked_content" to "service_role";

grant update on table "public"."blocked_content" to "service_role";

grant delete on table "public"."books" to "anon";

grant insert on table "public"."books" to "anon";

grant references on table "public"."books" to "anon";

grant select on table "public"."books" to "anon";

grant trigger on table "public"."books" to "anon";

grant truncate on table "public"."books" to "anon";

grant update on table "public"."books" to "anon";

grant delete on table "public"."books" to "authenticated";

grant insert on table "public"."books" to "authenticated";

grant references on table "public"."books" to "authenticated";

grant select on table "public"."books" to "authenticated";

grant trigger on table "public"."books" to "authenticated";

grant truncate on table "public"."books" to "authenticated";

grant update on table "public"."books" to "authenticated";

grant delete on table "public"."books" to "service_role";

grant insert on table "public"."books" to "service_role";

grant references on table "public"."books" to "service_role";

grant select on table "public"."books" to "service_role";

grant trigger on table "public"."books" to "service_role";

grant truncate on table "public"."books" to "service_role";

grant update on table "public"."books" to "service_role";

grant delete on table "public"."calendar_event_mappings" to "anon";

grant insert on table "public"."calendar_event_mappings" to "anon";

grant references on table "public"."calendar_event_mappings" to "anon";

grant select on table "public"."calendar_event_mappings" to "anon";

grant trigger on table "public"."calendar_event_mappings" to "anon";

grant truncate on table "public"."calendar_event_mappings" to "anon";

grant update on table "public"."calendar_event_mappings" to "anon";

grant delete on table "public"."calendar_event_mappings" to "authenticated";

grant insert on table "public"."calendar_event_mappings" to "authenticated";

grant references on table "public"."calendar_event_mappings" to "authenticated";

grant select on table "public"."calendar_event_mappings" to "authenticated";

grant trigger on table "public"."calendar_event_mappings" to "authenticated";

grant truncate on table "public"."calendar_event_mappings" to "authenticated";

grant update on table "public"."calendar_event_mappings" to "authenticated";

grant delete on table "public"."calendar_event_mappings" to "service_role";

grant insert on table "public"."calendar_event_mappings" to "service_role";

grant references on table "public"."calendar_event_mappings" to "service_role";

grant select on table "public"."calendar_event_mappings" to "service_role";

grant trigger on table "public"."calendar_event_mappings" to "service_role";

grant truncate on table "public"."calendar_event_mappings" to "service_role";

grant update on table "public"."calendar_event_mappings" to "service_role";

grant delete on table "public"."call_signals" to "anon";

grant insert on table "public"."call_signals" to "anon";

grant references on table "public"."call_signals" to "anon";

grant select on table "public"."call_signals" to "anon";

grant trigger on table "public"."call_signals" to "anon";

grant truncate on table "public"."call_signals" to "anon";

grant update on table "public"."call_signals" to "anon";

grant delete on table "public"."call_signals" to "authenticated";

grant insert on table "public"."call_signals" to "authenticated";

grant references on table "public"."call_signals" to "authenticated";

grant select on table "public"."call_signals" to "authenticated";

grant trigger on table "public"."call_signals" to "authenticated";

grant truncate on table "public"."call_signals" to "authenticated";

grant update on table "public"."call_signals" to "authenticated";

grant delete on table "public"."call_signals" to "service_role";

grant insert on table "public"."call_signals" to "service_role";

grant references on table "public"."call_signals" to "service_role";

grant select on table "public"."call_signals" to "service_role";

grant trigger on table "public"."call_signals" to "service_role";

grant truncate on table "public"."call_signals" to "service_role";

grant update on table "public"."call_signals" to "service_role";

grant delete on table "public"."campaign_redemptions" to "anon";

grant insert on table "public"."campaign_redemptions" to "anon";

grant references on table "public"."campaign_redemptions" to "anon";

grant select on table "public"."campaign_redemptions" to "anon";

grant trigger on table "public"."campaign_redemptions" to "anon";

grant truncate on table "public"."campaign_redemptions" to "anon";

grant update on table "public"."campaign_redemptions" to "anon";

grant delete on table "public"."campaign_redemptions" to "authenticated";

grant insert on table "public"."campaign_redemptions" to "authenticated";

grant references on table "public"."campaign_redemptions" to "authenticated";

grant select on table "public"."campaign_redemptions" to "authenticated";

grant trigger on table "public"."campaign_redemptions" to "authenticated";

grant truncate on table "public"."campaign_redemptions" to "authenticated";

grant update on table "public"."campaign_redemptions" to "authenticated";

grant delete on table "public"."campaign_redemptions" to "service_role";

grant insert on table "public"."campaign_redemptions" to "service_role";

grant references on table "public"."campaign_redemptions" to "service_role";

grant select on table "public"."campaign_redemptions" to "service_role";

grant trigger on table "public"."campaign_redemptions" to "service_role";

grant truncate on table "public"."campaign_redemptions" to "service_role";

grant update on table "public"."campaign_redemptions" to "service_role";

grant delete on table "public"."caps_chunks" to "anon";

grant insert on table "public"."caps_chunks" to "anon";

grant references on table "public"."caps_chunks" to "anon";

grant select on table "public"."caps_chunks" to "anon";

grant trigger on table "public"."caps_chunks" to "anon";

grant truncate on table "public"."caps_chunks" to "anon";

grant update on table "public"."caps_chunks" to "anon";

grant delete on table "public"."caps_chunks" to "authenticated";

grant insert on table "public"."caps_chunks" to "authenticated";

grant references on table "public"."caps_chunks" to "authenticated";

grant select on table "public"."caps_chunks" to "authenticated";

grant trigger on table "public"."caps_chunks" to "authenticated";

grant truncate on table "public"."caps_chunks" to "authenticated";

grant update on table "public"."caps_chunks" to "authenticated";

grant delete on table "public"."caps_chunks" to "service_role";

grant insert on table "public"."caps_chunks" to "service_role";

grant references on table "public"."caps_chunks" to "service_role";

grant select on table "public"."caps_chunks" to "service_role";

grant trigger on table "public"."caps_chunks" to "service_role";

grant truncate on table "public"."caps_chunks" to "service_role";

grant update on table "public"."caps_chunks" to "service_role";

grant delete on table "public"."caps_content_chunks" to "anon";

grant insert on table "public"."caps_content_chunks" to "anon";

grant references on table "public"."caps_content_chunks" to "anon";

grant select on table "public"."caps_content_chunks" to "anon";

grant trigger on table "public"."caps_content_chunks" to "anon";

grant truncate on table "public"."caps_content_chunks" to "anon";

grant update on table "public"."caps_content_chunks" to "anon";

grant delete on table "public"."caps_content_chunks" to "authenticated";

grant insert on table "public"."caps_content_chunks" to "authenticated";

grant references on table "public"."caps_content_chunks" to "authenticated";

grant select on table "public"."caps_content_chunks" to "authenticated";

grant trigger on table "public"."caps_content_chunks" to "authenticated";

grant truncate on table "public"."caps_content_chunks" to "authenticated";

grant update on table "public"."caps_content_chunks" to "authenticated";

grant delete on table "public"."caps_content_chunks" to "service_role";

grant insert on table "public"."caps_content_chunks" to "service_role";

grant references on table "public"."caps_content_chunks" to "service_role";

grant select on table "public"."caps_content_chunks" to "service_role";

grant trigger on table "public"."caps_content_chunks" to "service_role";

grant truncate on table "public"."caps_content_chunks" to "service_role";

grant update on table "public"."caps_content_chunks" to "service_role";

grant delete on table "public"."caps_documents" to "anon";

grant insert on table "public"."caps_documents" to "anon";

grant references on table "public"."caps_documents" to "anon";

grant select on table "public"."caps_documents" to "anon";

grant trigger on table "public"."caps_documents" to "anon";

grant truncate on table "public"."caps_documents" to "anon";

grant update on table "public"."caps_documents" to "anon";

grant delete on table "public"."caps_documents" to "authenticated";

grant insert on table "public"."caps_documents" to "authenticated";

grant references on table "public"."caps_documents" to "authenticated";

grant select on table "public"."caps_documents" to "authenticated";

grant trigger on table "public"."caps_documents" to "authenticated";

grant truncate on table "public"."caps_documents" to "authenticated";

grant update on table "public"."caps_documents" to "authenticated";

grant delete on table "public"."caps_documents" to "service_role";

grant insert on table "public"."caps_documents" to "service_role";

grant references on table "public"."caps_documents" to "service_role";

grant select on table "public"."caps_documents" to "service_role";

grant trigger on table "public"."caps_documents" to "service_role";

grant truncate on table "public"."caps_documents" to "service_role";

grant update on table "public"."caps_documents" to "service_role";

grant delete on table "public"."caps_exam_patterns" to "anon";

grant insert on table "public"."caps_exam_patterns" to "anon";

grant references on table "public"."caps_exam_patterns" to "anon";

grant select on table "public"."caps_exam_patterns" to "anon";

grant trigger on table "public"."caps_exam_patterns" to "anon";

grant truncate on table "public"."caps_exam_patterns" to "anon";

grant update on table "public"."caps_exam_patterns" to "anon";

grant delete on table "public"."caps_exam_patterns" to "authenticated";

grant insert on table "public"."caps_exam_patterns" to "authenticated";

grant references on table "public"."caps_exam_patterns" to "authenticated";

grant select on table "public"."caps_exam_patterns" to "authenticated";

grant trigger on table "public"."caps_exam_patterns" to "authenticated";

grant truncate on table "public"."caps_exam_patterns" to "authenticated";

grant update on table "public"."caps_exam_patterns" to "authenticated";

grant delete on table "public"."caps_exam_patterns" to "service_role";

grant insert on table "public"."caps_exam_patterns" to "service_role";

grant references on table "public"."caps_exam_patterns" to "service_role";

grant select on table "public"."caps_exam_patterns" to "service_role";

grant trigger on table "public"."caps_exam_patterns" to "service_role";

grant truncate on table "public"."caps_exam_patterns" to "service_role";

grant update on table "public"."caps_exam_patterns" to "service_role";

grant delete on table "public"."caps_exam_questions" to "anon";

grant insert on table "public"."caps_exam_questions" to "anon";

grant references on table "public"."caps_exam_questions" to "anon";

grant select on table "public"."caps_exam_questions" to "anon";

grant trigger on table "public"."caps_exam_questions" to "anon";

grant truncate on table "public"."caps_exam_questions" to "anon";

grant update on table "public"."caps_exam_questions" to "anon";

grant delete on table "public"."caps_exam_questions" to "authenticated";

grant insert on table "public"."caps_exam_questions" to "authenticated";

grant references on table "public"."caps_exam_questions" to "authenticated";

grant select on table "public"."caps_exam_questions" to "authenticated";

grant trigger on table "public"."caps_exam_questions" to "authenticated";

grant truncate on table "public"."caps_exam_questions" to "authenticated";

grant update on table "public"."caps_exam_questions" to "authenticated";

grant delete on table "public"."caps_exam_questions" to "service_role";

grant insert on table "public"."caps_exam_questions" to "service_role";

grant references on table "public"."caps_exam_questions" to "service_role";

grant select on table "public"."caps_exam_questions" to "service_role";

grant trigger on table "public"."caps_exam_questions" to "service_role";

grant truncate on table "public"."caps_exam_questions" to "service_role";

grant update on table "public"."caps_exam_questions" to "service_role";

grant delete on table "public"."caps_textbook_mapping" to "anon";

grant insert on table "public"."caps_textbook_mapping" to "anon";

grant references on table "public"."caps_textbook_mapping" to "anon";

grant select on table "public"."caps_textbook_mapping" to "anon";

grant trigger on table "public"."caps_textbook_mapping" to "anon";

grant truncate on table "public"."caps_textbook_mapping" to "anon";

grant update on table "public"."caps_textbook_mapping" to "anon";

grant delete on table "public"."caps_textbook_mapping" to "authenticated";

grant insert on table "public"."caps_textbook_mapping" to "authenticated";

grant references on table "public"."caps_textbook_mapping" to "authenticated";

grant select on table "public"."caps_textbook_mapping" to "authenticated";

grant trigger on table "public"."caps_textbook_mapping" to "authenticated";

grant truncate on table "public"."caps_textbook_mapping" to "authenticated";

grant update on table "public"."caps_textbook_mapping" to "authenticated";

grant delete on table "public"."caps_textbook_mapping" to "service_role";

grant insert on table "public"."caps_textbook_mapping" to "service_role";

grant references on table "public"."caps_textbook_mapping" to "service_role";

grant select on table "public"."caps_textbook_mapping" to "service_role";

grant trigger on table "public"."caps_textbook_mapping" to "service_role";

grant truncate on table "public"."caps_textbook_mapping" to "service_role";

grant update on table "public"."caps_textbook_mapping" to "service_role";

grant delete on table "public"."caps_topics" to "anon";

grant insert on table "public"."caps_topics" to "anon";

grant references on table "public"."caps_topics" to "anon";

grant select on table "public"."caps_topics" to "anon";

grant trigger on table "public"."caps_topics" to "anon";

grant truncate on table "public"."caps_topics" to "anon";

grant update on table "public"."caps_topics" to "anon";

grant delete on table "public"."caps_topics" to "authenticated";

grant insert on table "public"."caps_topics" to "authenticated";

grant references on table "public"."caps_topics" to "authenticated";

grant select on table "public"."caps_topics" to "authenticated";

grant trigger on table "public"."caps_topics" to "authenticated";

grant truncate on table "public"."caps_topics" to "authenticated";

grant update on table "public"."caps_topics" to "authenticated";

grant delete on table "public"."caps_topics" to "service_role";

grant insert on table "public"."caps_topics" to "service_role";

grant references on table "public"."caps_topics" to "service_role";

grant select on table "public"."caps_topics" to "service_role";

grant trigger on table "public"."caps_topics" to "service_role";

grant truncate on table "public"."caps_topics" to "service_role";

grant update on table "public"."caps_topics" to "service_role";

grant delete on table "public"."chat_images" to "anon";

grant insert on table "public"."chat_images" to "anon";

grant references on table "public"."chat_images" to "anon";

grant select on table "public"."chat_images" to "anon";

grant trigger on table "public"."chat_images" to "anon";

grant truncate on table "public"."chat_images" to "anon";

grant update on table "public"."chat_images" to "anon";

grant delete on table "public"."chat_images" to "authenticated";

grant insert on table "public"."chat_images" to "authenticated";

grant references on table "public"."chat_images" to "authenticated";

grant select on table "public"."chat_images" to "authenticated";

grant trigger on table "public"."chat_images" to "authenticated";

grant truncate on table "public"."chat_images" to "authenticated";

grant update on table "public"."chat_images" to "authenticated";

grant delete on table "public"."chat_images" to "service_role";

grant insert on table "public"."chat_images" to "service_role";

grant references on table "public"."chat_images" to "service_role";

grant select on table "public"."chat_images" to "service_role";

grant trigger on table "public"."chat_images" to "service_role";

grant truncate on table "public"."chat_images" to "service_role";

grant update on table "public"."chat_images" to "service_role";

grant delete on table "public"."class_assignments" to "anon";

grant insert on table "public"."class_assignments" to "anon";

grant references on table "public"."class_assignments" to "anon";

grant select on table "public"."class_assignments" to "anon";

grant trigger on table "public"."class_assignments" to "anon";

grant truncate on table "public"."class_assignments" to "anon";

grant update on table "public"."class_assignments" to "anon";

grant delete on table "public"."class_assignments" to "authenticated";

grant insert on table "public"."class_assignments" to "authenticated";

grant references on table "public"."class_assignments" to "authenticated";

grant select on table "public"."class_assignments" to "authenticated";

grant trigger on table "public"."class_assignments" to "authenticated";

grant truncate on table "public"."class_assignments" to "authenticated";

grant update on table "public"."class_assignments" to "authenticated";

grant delete on table "public"."class_assignments" to "service_role";

grant insert on table "public"."class_assignments" to "service_role";

grant references on table "public"."class_assignments" to "service_role";

grant select on table "public"."class_assignments" to "service_role";

grant trigger on table "public"."class_assignments" to "service_role";

grant truncate on table "public"."class_assignments" to "service_role";

grant update on table "public"."class_assignments" to "service_role";

grant delete on table "public"."class_events" to "anon";

grant insert on table "public"."class_events" to "anon";

grant references on table "public"."class_events" to "anon";

grant select on table "public"."class_events" to "anon";

grant trigger on table "public"."class_events" to "anon";

grant truncate on table "public"."class_events" to "anon";

grant update on table "public"."class_events" to "anon";

grant delete on table "public"."class_events" to "authenticated";

grant insert on table "public"."class_events" to "authenticated";

grant references on table "public"."class_events" to "authenticated";

grant select on table "public"."class_events" to "authenticated";

grant trigger on table "public"."class_events" to "authenticated";

grant truncate on table "public"."class_events" to "authenticated";

grant update on table "public"."class_events" to "authenticated";

grant delete on table "public"."class_events" to "service_role";

grant insert on table "public"."class_events" to "service_role";

grant references on table "public"."class_events" to "service_role";

grant select on table "public"."class_events" to "service_role";

grant trigger on table "public"."class_events" to "service_role";

grant truncate on table "public"."class_events" to "service_role";

grant update on table "public"."class_events" to "service_role";

grant delete on table "public"."classroom_reports" to "anon";

grant insert on table "public"."classroom_reports" to "anon";

grant references on table "public"."classroom_reports" to "anon";

grant select on table "public"."classroom_reports" to "anon";

grant trigger on table "public"."classroom_reports" to "anon";

grant truncate on table "public"."classroom_reports" to "anon";

grant update on table "public"."classroom_reports" to "anon";

grant delete on table "public"."classroom_reports" to "authenticated";

grant insert on table "public"."classroom_reports" to "authenticated";

grant references on table "public"."classroom_reports" to "authenticated";

grant select on table "public"."classroom_reports" to "authenticated";

grant trigger on table "public"."classroom_reports" to "authenticated";

grant truncate on table "public"."classroom_reports" to "authenticated";

grant update on table "public"."classroom_reports" to "authenticated";

grant delete on table "public"."classroom_reports" to "service_role";

grant insert on table "public"."classroom_reports" to "service_role";

grant references on table "public"."classroom_reports" to "service_role";

grant select on table "public"."classroom_reports" to "service_role";

grant trigger on table "public"."classroom_reports" to "service_role";

grant truncate on table "public"."classroom_reports" to "service_role";

grant update on table "public"."classroom_reports" to "service_role";

grant delete on table "public"."config_kv" to "anon";

grant insert on table "public"."config_kv" to "anon";

grant references on table "public"."config_kv" to "anon";

grant select on table "public"."config_kv" to "anon";

grant trigger on table "public"."config_kv" to "anon";

grant truncate on table "public"."config_kv" to "anon";

grant update on table "public"."config_kv" to "anon";

grant delete on table "public"."config_kv" to "authenticated";

grant insert on table "public"."config_kv" to "authenticated";

grant references on table "public"."config_kv" to "authenticated";

grant select on table "public"."config_kv" to "authenticated";

grant trigger on table "public"."config_kv" to "authenticated";

grant truncate on table "public"."config_kv" to "authenticated";

grant update on table "public"."config_kv" to "authenticated";

grant delete on table "public"."config_kv" to "service_role";

grant insert on table "public"."config_kv" to "service_role";

grant references on table "public"."config_kv" to "service_role";

grant select on table "public"."config_kv" to "service_role";

grant trigger on table "public"."config_kv" to "service_role";

grant truncate on table "public"."config_kv" to "service_role";

grant update on table "public"."config_kv" to "service_role";

grant delete on table "public"."contact_discovery_settings" to "anon";

grant insert on table "public"."contact_discovery_settings" to "anon";

grant references on table "public"."contact_discovery_settings" to "anon";

grant select on table "public"."contact_discovery_settings" to "anon";

grant trigger on table "public"."contact_discovery_settings" to "anon";

grant truncate on table "public"."contact_discovery_settings" to "anon";

grant update on table "public"."contact_discovery_settings" to "anon";

grant delete on table "public"."contact_discovery_settings" to "authenticated";

grant insert on table "public"."contact_discovery_settings" to "authenticated";

grant references on table "public"."contact_discovery_settings" to "authenticated";

grant select on table "public"."contact_discovery_settings" to "authenticated";

grant trigger on table "public"."contact_discovery_settings" to "authenticated";

grant truncate on table "public"."contact_discovery_settings" to "authenticated";

grant update on table "public"."contact_discovery_settings" to "authenticated";

grant delete on table "public"."contact_discovery_settings" to "service_role";

grant insert on table "public"."contact_discovery_settings" to "service_role";

grant references on table "public"."contact_discovery_settings" to "service_role";

grant select on table "public"."contact_discovery_settings" to "service_role";

grant trigger on table "public"."contact_discovery_settings" to "service_role";

grant truncate on table "public"."contact_discovery_settings" to "service_role";

grant update on table "public"."contact_discovery_settings" to "service_role";

grant delete on table "public"."contact_suggestions" to "anon";

grant insert on table "public"."contact_suggestions" to "anon";

grant references on table "public"."contact_suggestions" to "anon";

grant select on table "public"."contact_suggestions" to "anon";

grant trigger on table "public"."contact_suggestions" to "anon";

grant truncate on table "public"."contact_suggestions" to "anon";

grant update on table "public"."contact_suggestions" to "anon";

grant delete on table "public"."contact_suggestions" to "authenticated";

grant insert on table "public"."contact_suggestions" to "authenticated";

grant references on table "public"."contact_suggestions" to "authenticated";

grant select on table "public"."contact_suggestions" to "authenticated";

grant trigger on table "public"."contact_suggestions" to "authenticated";

grant truncate on table "public"."contact_suggestions" to "authenticated";

grant update on table "public"."contact_suggestions" to "authenticated";

grant delete on table "public"."contact_suggestions" to "service_role";

grant insert on table "public"."contact_suggestions" to "service_role";

grant references on table "public"."contact_suggestions" to "service_role";

grant select on table "public"."contact_suggestions" to "service_role";

grant trigger on table "public"."contact_suggestions" to "service_role";

grant truncate on table "public"."contact_suggestions" to "service_role";

grant update on table "public"."contact_suggestions" to "service_role";

grant delete on table "public"."content_reports" to "anon";

grant insert on table "public"."content_reports" to "anon";

grant references on table "public"."content_reports" to "anon";

grant select on table "public"."content_reports" to "anon";

grant trigger on table "public"."content_reports" to "anon";

grant truncate on table "public"."content_reports" to "anon";

grant update on table "public"."content_reports" to "anon";

grant delete on table "public"."content_reports" to "authenticated";

grant insert on table "public"."content_reports" to "authenticated";

grant references on table "public"."content_reports" to "authenticated";

grant select on table "public"."content_reports" to "authenticated";

grant trigger on table "public"."content_reports" to "authenticated";

grant truncate on table "public"."content_reports" to "authenticated";

grant update on table "public"."content_reports" to "authenticated";

grant delete on table "public"."content_reports" to "service_role";

grant insert on table "public"."content_reports" to "service_role";

grant references on table "public"."content_reports" to "service_role";

grant select on table "public"."content_reports" to "service_role";

grant trigger on table "public"."content_reports" to "service_role";

grant truncate on table "public"."content_reports" to "service_role";

grant update on table "public"."content_reports" to "service_role";

grant delete on table "public"."conversation_members" to "anon";

grant insert on table "public"."conversation_members" to "anon";

grant references on table "public"."conversation_members" to "anon";

grant select on table "public"."conversation_members" to "anon";

grant trigger on table "public"."conversation_members" to "anon";

grant truncate on table "public"."conversation_members" to "anon";

grant update on table "public"."conversation_members" to "anon";

grant delete on table "public"."conversation_members" to "authenticated";

grant insert on table "public"."conversation_members" to "authenticated";

grant references on table "public"."conversation_members" to "authenticated";

grant select on table "public"."conversation_members" to "authenticated";

grant trigger on table "public"."conversation_members" to "authenticated";

grant truncate on table "public"."conversation_members" to "authenticated";

grant update on table "public"."conversation_members" to "authenticated";

grant delete on table "public"."conversation_members" to "service_role";

grant insert on table "public"."conversation_members" to "service_role";

grant references on table "public"."conversation_members" to "service_role";

grant select on table "public"."conversation_members" to "service_role";

grant trigger on table "public"."conversation_members" to "service_role";

grant truncate on table "public"."conversation_members" to "service_role";

grant update on table "public"."conversation_members" to "service_role";

grant delete on table "public"."conversations" to "anon";

grant insert on table "public"."conversations" to "anon";

grant references on table "public"."conversations" to "anon";

grant select on table "public"."conversations" to "anon";

grant trigger on table "public"."conversations" to "anon";

grant truncate on table "public"."conversations" to "anon";

grant update on table "public"."conversations" to "anon";

grant delete on table "public"."conversations" to "authenticated";

grant insert on table "public"."conversations" to "authenticated";

grant references on table "public"."conversations" to "authenticated";

grant select on table "public"."conversations" to "authenticated";

grant trigger on table "public"."conversations" to "authenticated";

grant truncate on table "public"."conversations" to "authenticated";

grant update on table "public"."conversations" to "authenticated";

grant delete on table "public"."conversations" to "service_role";

grant insert on table "public"."conversations" to "service_role";

grant references on table "public"."conversations" to "service_role";

grant select on table "public"."conversations" to "service_role";

grant trigger on table "public"."conversations" to "service_role";

grant truncate on table "public"."conversations" to "service_role";

grant update on table "public"."conversations" to "service_role";

grant delete on table "public"."course_grades" to "anon";

grant insert on table "public"."course_grades" to "anon";

grant references on table "public"."course_grades" to "anon";

grant select on table "public"."course_grades" to "anon";

grant trigger on table "public"."course_grades" to "anon";

grant truncate on table "public"."course_grades" to "anon";

grant update on table "public"."course_grades" to "anon";

grant delete on table "public"."course_grades" to "authenticated";

grant insert on table "public"."course_grades" to "authenticated";

grant references on table "public"."course_grades" to "authenticated";

grant select on table "public"."course_grades" to "authenticated";

grant trigger on table "public"."course_grades" to "authenticated";

grant truncate on table "public"."course_grades" to "authenticated";

grant update on table "public"."course_grades" to "authenticated";

grant delete on table "public"."course_grades" to "service_role";

grant insert on table "public"."course_grades" to "service_role";

grant references on table "public"."course_grades" to "service_role";

grant select on table "public"."course_grades" to "service_role";

grant trigger on table "public"."course_grades" to "service_role";

grant truncate on table "public"."course_grades" to "service_role";

grant update on table "public"."course_grades" to "service_role";

grant delete on table "public"."course_join_requests" to "anon";

grant insert on table "public"."course_join_requests" to "anon";

grant references on table "public"."course_join_requests" to "anon";

grant select on table "public"."course_join_requests" to "anon";

grant trigger on table "public"."course_join_requests" to "anon";

grant truncate on table "public"."course_join_requests" to "anon";

grant update on table "public"."course_join_requests" to "anon";

grant delete on table "public"."course_join_requests" to "authenticated";

grant insert on table "public"."course_join_requests" to "authenticated";

grant references on table "public"."course_join_requests" to "authenticated";

grant select on table "public"."course_join_requests" to "authenticated";

grant trigger on table "public"."course_join_requests" to "authenticated";

grant truncate on table "public"."course_join_requests" to "authenticated";

grant update on table "public"."course_join_requests" to "authenticated";

grant delete on table "public"."course_join_requests" to "service_role";

grant insert on table "public"."course_join_requests" to "service_role";

grant references on table "public"."course_join_requests" to "service_role";

grant select on table "public"."course_join_requests" to "service_role";

grant trigger on table "public"."course_join_requests" to "service_role";

grant truncate on table "public"."course_join_requests" to "service_role";

grant update on table "public"."course_join_requests" to "service_role";

grant delete on table "public"."courses" to "anon";

grant insert on table "public"."courses" to "anon";

grant references on table "public"."courses" to "anon";

grant select on table "public"."courses" to "anon";

grant trigger on table "public"."courses" to "anon";

grant truncate on table "public"."courses" to "anon";

grant update on table "public"."courses" to "anon";

grant delete on table "public"."courses" to "authenticated";

grant insert on table "public"."courses" to "authenticated";

grant references on table "public"."courses" to "authenticated";

grant select on table "public"."courses" to "authenticated";

grant trigger on table "public"."courses" to "authenticated";

grant truncate on table "public"."courses" to "authenticated";

grant update on table "public"."courses" to "authenticated";

grant delete on table "public"."courses" to "service_role";

grant insert on table "public"."courses" to "service_role";

grant references on table "public"."courses" to "service_role";

grant select on table "public"."courses" to "service_role";

grant trigger on table "public"."courses" to "service_role";

grant truncate on table "public"."courses" to "service_role";

grant update on table "public"."courses" to "service_role";

grant delete on table "public"."cv_templates" to "anon";

grant insert on table "public"."cv_templates" to "anon";

grant references on table "public"."cv_templates" to "anon";

grant select on table "public"."cv_templates" to "anon";

grant trigger on table "public"."cv_templates" to "anon";

grant truncate on table "public"."cv_templates" to "anon";

grant update on table "public"."cv_templates" to "anon";

grant delete on table "public"."cv_templates" to "authenticated";

grant insert on table "public"."cv_templates" to "authenticated";

grant references on table "public"."cv_templates" to "authenticated";

grant select on table "public"."cv_templates" to "authenticated";

grant trigger on table "public"."cv_templates" to "authenticated";

grant truncate on table "public"."cv_templates" to "authenticated";

grant update on table "public"."cv_templates" to "authenticated";

grant delete on table "public"."cv_templates" to "service_role";

grant insert on table "public"."cv_templates" to "service_role";

grant references on table "public"."cv_templates" to "service_role";

grant select on table "public"."cv_templates" to "service_role";

grant trigger on table "public"."cv_templates" to "service_role";

grant truncate on table "public"."cv_templates" to "service_role";

grant update on table "public"."cv_templates" to "service_role";

grant delete on table "public"."cv_uploads" to "anon";

grant insert on table "public"."cv_uploads" to "anon";

grant references on table "public"."cv_uploads" to "anon";

grant select on table "public"."cv_uploads" to "anon";

grant trigger on table "public"."cv_uploads" to "anon";

grant truncate on table "public"."cv_uploads" to "anon";

grant update on table "public"."cv_uploads" to "anon";

grant delete on table "public"."cv_uploads" to "authenticated";

grant insert on table "public"."cv_uploads" to "authenticated";

grant references on table "public"."cv_uploads" to "authenticated";

grant select on table "public"."cv_uploads" to "authenticated";

grant trigger on table "public"."cv_uploads" to "authenticated";

grant truncate on table "public"."cv_uploads" to "authenticated";

grant update on table "public"."cv_uploads" to "authenticated";

grant delete on table "public"."cv_uploads" to "service_role";

grant insert on table "public"."cv_uploads" to "service_role";

grant references on table "public"."cv_uploads" to "service_role";

grant select on table "public"."cv_uploads" to "service_role";

grant trigger on table "public"."cv_uploads" to "service_role";

grant truncate on table "public"."cv_uploads" to "service_role";

grant update on table "public"."cv_uploads" to "service_role";

grant delete on table "public"."daily_activities" to "anon";

grant insert on table "public"."daily_activities" to "anon";

grant references on table "public"."daily_activities" to "anon";

grant select on table "public"."daily_activities" to "anon";

grant trigger on table "public"."daily_activities" to "anon";

grant truncate on table "public"."daily_activities" to "anon";

grant update on table "public"."daily_activities" to "anon";

grant delete on table "public"."daily_activities" to "authenticated";

grant insert on table "public"."daily_activities" to "authenticated";

grant references on table "public"."daily_activities" to "authenticated";

grant select on table "public"."daily_activities" to "authenticated";

grant trigger on table "public"."daily_activities" to "authenticated";

grant truncate on table "public"."daily_activities" to "authenticated";

grant update on table "public"."daily_activities" to "authenticated";

grant delete on table "public"."daily_activities" to "service_role";

grant insert on table "public"."daily_activities" to "service_role";

grant references on table "public"."daily_activities" to "service_role";

grant select on table "public"."daily_activities" to "service_role";

grant trigger on table "public"."daily_activities" to "service_role";

grant truncate on table "public"."daily_activities" to "service_role";

grant update on table "public"."daily_activities" to "service_role";

grant delete on table "public"."dash_agent_instances" to "anon";

grant insert on table "public"."dash_agent_instances" to "anon";

grant references on table "public"."dash_agent_instances" to "anon";

grant select on table "public"."dash_agent_instances" to "anon";

grant trigger on table "public"."dash_agent_instances" to "anon";

grant truncate on table "public"."dash_agent_instances" to "anon";

grant update on table "public"."dash_agent_instances" to "anon";

grant delete on table "public"."dash_agent_instances" to "authenticated";

grant insert on table "public"."dash_agent_instances" to "authenticated";

grant references on table "public"."dash_agent_instances" to "authenticated";

grant select on table "public"."dash_agent_instances" to "authenticated";

grant trigger on table "public"."dash_agent_instances" to "authenticated";

grant truncate on table "public"."dash_agent_instances" to "authenticated";

grant update on table "public"."dash_agent_instances" to "authenticated";

grant delete on table "public"."dash_agent_instances" to "service_role";

grant insert on table "public"."dash_agent_instances" to "service_role";

grant references on table "public"."dash_agent_instances" to "service_role";

grant select on table "public"."dash_agent_instances" to "service_role";

grant trigger on table "public"."dash_agent_instances" to "service_role";

grant truncate on table "public"."dash_agent_instances" to "service_role";

grant update on table "public"."dash_agent_instances" to "service_role";

grant delete on table "public"."dash_conversation_facts" to "anon";

grant insert on table "public"."dash_conversation_facts" to "anon";

grant references on table "public"."dash_conversation_facts" to "anon";

grant select on table "public"."dash_conversation_facts" to "anon";

grant trigger on table "public"."dash_conversation_facts" to "anon";

grant truncate on table "public"."dash_conversation_facts" to "anon";

grant update on table "public"."dash_conversation_facts" to "anon";

grant delete on table "public"."dash_conversation_facts" to "authenticated";

grant insert on table "public"."dash_conversation_facts" to "authenticated";

grant references on table "public"."dash_conversation_facts" to "authenticated";

grant select on table "public"."dash_conversation_facts" to "authenticated";

grant trigger on table "public"."dash_conversation_facts" to "authenticated";

grant truncate on table "public"."dash_conversation_facts" to "authenticated";

grant update on table "public"."dash_conversation_facts" to "authenticated";

grant delete on table "public"."dash_conversation_facts" to "service_role";

grant insert on table "public"."dash_conversation_facts" to "service_role";

grant references on table "public"."dash_conversation_facts" to "service_role";

grant select on table "public"."dash_conversation_facts" to "service_role";

grant trigger on table "public"."dash_conversation_facts" to "service_role";

grant truncate on table "public"."dash_conversation_facts" to "service_role";

grant update on table "public"."dash_conversation_facts" to "service_role";

grant delete on table "public"."dash_curriculum_memory" to "anon";

grant insert on table "public"."dash_curriculum_memory" to "anon";

grant references on table "public"."dash_curriculum_memory" to "anon";

grant select on table "public"."dash_curriculum_memory" to "anon";

grant trigger on table "public"."dash_curriculum_memory" to "anon";

grant truncate on table "public"."dash_curriculum_memory" to "anon";

grant update on table "public"."dash_curriculum_memory" to "anon";

grant delete on table "public"."dash_curriculum_memory" to "authenticated";

grant insert on table "public"."dash_curriculum_memory" to "authenticated";

grant references on table "public"."dash_curriculum_memory" to "authenticated";

grant select on table "public"."dash_curriculum_memory" to "authenticated";

grant trigger on table "public"."dash_curriculum_memory" to "authenticated";

grant truncate on table "public"."dash_curriculum_memory" to "authenticated";

grant update on table "public"."dash_curriculum_memory" to "authenticated";

grant delete on table "public"."dash_curriculum_memory" to "service_role";

grant insert on table "public"."dash_curriculum_memory" to "service_role";

grant references on table "public"."dash_curriculum_memory" to "service_role";

grant select on table "public"."dash_curriculum_memory" to "service_role";

grant trigger on table "public"."dash_curriculum_memory" to "service_role";

grant truncate on table "public"."dash_curriculum_memory" to "service_role";

grant update on table "public"."dash_curriculum_memory" to "service_role";

grant delete on table "public"."dash_reminders" to "anon";

grant insert on table "public"."dash_reminders" to "anon";

grant references on table "public"."dash_reminders" to "anon";

grant select on table "public"."dash_reminders" to "anon";

grant trigger on table "public"."dash_reminders" to "anon";

grant truncate on table "public"."dash_reminders" to "anon";

grant update on table "public"."dash_reminders" to "anon";

grant delete on table "public"."dash_reminders" to "authenticated";

grant insert on table "public"."dash_reminders" to "authenticated";

grant references on table "public"."dash_reminders" to "authenticated";

grant select on table "public"."dash_reminders" to "authenticated";

grant trigger on table "public"."dash_reminders" to "authenticated";

grant truncate on table "public"."dash_reminders" to "authenticated";

grant update on table "public"."dash_reminders" to "authenticated";

grant delete on table "public"."dash_reminders" to "service_role";

grant insert on table "public"."dash_reminders" to "service_role";

grant references on table "public"."dash_reminders" to "service_role";

grant select on table "public"."dash_reminders" to "service_role";

grant trigger on table "public"."dash_reminders" to "service_role";

grant truncate on table "public"."dash_reminders" to "service_role";

grant update on table "public"."dash_reminders" to "service_role";

grant delete on table "public"."dash_storage" to "anon";

grant insert on table "public"."dash_storage" to "anon";

grant references on table "public"."dash_storage" to "anon";

grant select on table "public"."dash_storage" to "anon";

grant trigger on table "public"."dash_storage" to "anon";

grant truncate on table "public"."dash_storage" to "anon";

grant update on table "public"."dash_storage" to "anon";

grant delete on table "public"."dash_storage" to "authenticated";

grant insert on table "public"."dash_storage" to "authenticated";

grant references on table "public"."dash_storage" to "authenticated";

grant select on table "public"."dash_storage" to "authenticated";

grant trigger on table "public"."dash_storage" to "authenticated";

grant truncate on table "public"."dash_storage" to "authenticated";

grant update on table "public"."dash_storage" to "authenticated";

grant delete on table "public"."dash_storage" to "service_role";

grant insert on table "public"."dash_storage" to "service_role";

grant references on table "public"."dash_storage" to "service_role";

grant select on table "public"."dash_storage" to "service_role";

grant trigger on table "public"."dash_storage" to "service_role";

grant truncate on table "public"."dash_storage" to "service_role";

grant update on table "public"."dash_storage" to "service_role";

grant delete on table "public"."dash_user_contexts" to "anon";

grant insert on table "public"."dash_user_contexts" to "anon";

grant references on table "public"."dash_user_contexts" to "anon";

grant select on table "public"."dash_user_contexts" to "anon";

grant trigger on table "public"."dash_user_contexts" to "anon";

grant truncate on table "public"."dash_user_contexts" to "anon";

grant update on table "public"."dash_user_contexts" to "anon";

grant delete on table "public"."dash_user_contexts" to "authenticated";

grant insert on table "public"."dash_user_contexts" to "authenticated";

grant references on table "public"."dash_user_contexts" to "authenticated";

grant select on table "public"."dash_user_contexts" to "authenticated";

grant trigger on table "public"."dash_user_contexts" to "authenticated";

grant truncate on table "public"."dash_user_contexts" to "authenticated";

grant update on table "public"."dash_user_contexts" to "authenticated";

grant delete on table "public"."dash_user_contexts" to "service_role";

grant insert on table "public"."dash_user_contexts" to "service_role";

grant references on table "public"."dash_user_contexts" to "service_role";

grant select on table "public"."dash_user_contexts" to "service_role";

grant trigger on table "public"."dash_user_contexts" to "service_role";

grant truncate on table "public"."dash_user_contexts" to "service_role";

grant update on table "public"."dash_user_contexts" to "service_role";

grant delete on table "public"."dashboard_voice_notes" to "anon";

grant insert on table "public"."dashboard_voice_notes" to "anon";

grant references on table "public"."dashboard_voice_notes" to "anon";

grant select on table "public"."dashboard_voice_notes" to "anon";

grant trigger on table "public"."dashboard_voice_notes" to "anon";

grant truncate on table "public"."dashboard_voice_notes" to "anon";

grant update on table "public"."dashboard_voice_notes" to "anon";

grant delete on table "public"."dashboard_voice_notes" to "authenticated";

grant insert on table "public"."dashboard_voice_notes" to "authenticated";

grant references on table "public"."dashboard_voice_notes" to "authenticated";

grant select on table "public"."dashboard_voice_notes" to "authenticated";

grant trigger on table "public"."dashboard_voice_notes" to "authenticated";

grant truncate on table "public"."dashboard_voice_notes" to "authenticated";

grant update on table "public"."dashboard_voice_notes" to "authenticated";

grant delete on table "public"."dashboard_voice_notes" to "service_role";

grant insert on table "public"."dashboard_voice_notes" to "service_role";

grant references on table "public"."dashboard_voice_notes" to "service_role";

grant select on table "public"."dashboard_voice_notes" to "service_role";

grant trigger on table "public"."dashboard_voice_notes" to "service_role";

grant truncate on table "public"."dashboard_voice_notes" to "service_role";

grant update on table "public"."dashboard_voice_notes" to "service_role";

grant delete on table "public"."deletion_requests" to "anon";

grant insert on table "public"."deletion_requests" to "anon";

grant references on table "public"."deletion_requests" to "anon";

grant select on table "public"."deletion_requests" to "anon";

grant trigger on table "public"."deletion_requests" to "anon";

grant truncate on table "public"."deletion_requests" to "anon";

grant update on table "public"."deletion_requests" to "anon";

grant delete on table "public"."deletion_requests" to "authenticated";

grant insert on table "public"."deletion_requests" to "authenticated";

grant references on table "public"."deletion_requests" to "authenticated";

grant select on table "public"."deletion_requests" to "authenticated";

grant trigger on table "public"."deletion_requests" to "authenticated";

grant truncate on table "public"."deletion_requests" to "authenticated";

grant update on table "public"."deletion_requests" to "authenticated";

grant delete on table "public"."deletion_requests" to "service_role";

grant insert on table "public"."deletion_requests" to "service_role";

grant references on table "public"."deletion_requests" to "service_role";

grant select on table "public"."deletion_requests" to "service_role";

grant trigger on table "public"."deletion_requests" to "service_role";

grant truncate on table "public"."deletion_requests" to "service_role";

grant update on table "public"."deletion_requests" to "service_role";

grant delete on table "public"."delivery_providers" to "anon";

grant insert on table "public"."delivery_providers" to "anon";

grant references on table "public"."delivery_providers" to "anon";

grant select on table "public"."delivery_providers" to "anon";

grant trigger on table "public"."delivery_providers" to "anon";

grant truncate on table "public"."delivery_providers" to "anon";

grant update on table "public"."delivery_providers" to "anon";

grant delete on table "public"."delivery_providers" to "authenticated";

grant insert on table "public"."delivery_providers" to "authenticated";

grant references on table "public"."delivery_providers" to "authenticated";

grant select on table "public"."delivery_providers" to "authenticated";

grant trigger on table "public"."delivery_providers" to "authenticated";

grant truncate on table "public"."delivery_providers" to "authenticated";

grant update on table "public"."delivery_providers" to "authenticated";

grant delete on table "public"."delivery_providers" to "service_role";

grant insert on table "public"."delivery_providers" to "service_role";

grant references on table "public"."delivery_providers" to "service_role";

grant select on table "public"."delivery_providers" to "service_role";

grant trigger on table "public"."delivery_providers" to "service_role";

grant truncate on table "public"."delivery_providers" to "service_role";

grant update on table "public"."delivery_providers" to "service_role";

grant delete on table "public"."delivery_retry_queue" to "anon";

grant insert on table "public"."delivery_retry_queue" to "anon";

grant references on table "public"."delivery_retry_queue" to "anon";

grant select on table "public"."delivery_retry_queue" to "anon";

grant trigger on table "public"."delivery_retry_queue" to "anon";

grant truncate on table "public"."delivery_retry_queue" to "anon";

grant update on table "public"."delivery_retry_queue" to "anon";

grant delete on table "public"."delivery_retry_queue" to "authenticated";

grant insert on table "public"."delivery_retry_queue" to "authenticated";

grant references on table "public"."delivery_retry_queue" to "authenticated";

grant select on table "public"."delivery_retry_queue" to "authenticated";

grant trigger on table "public"."delivery_retry_queue" to "authenticated";

grant truncate on table "public"."delivery_retry_queue" to "authenticated";

grant update on table "public"."delivery_retry_queue" to "authenticated";

grant delete on table "public"."delivery_retry_queue" to "service_role";

grant insert on table "public"."delivery_retry_queue" to "service_role";

grant references on table "public"."delivery_retry_queue" to "service_role";

grant select on table "public"."delivery_retry_queue" to "service_role";

grant trigger on table "public"."delivery_retry_queue" to "service_role";

grant truncate on table "public"."delivery_retry_queue" to "service_role";

grant update on table "public"."delivery_retry_queue" to "service_role";

grant delete on table "public"."delivery_webhooks" to "anon";

grant insert on table "public"."delivery_webhooks" to "anon";

grant references on table "public"."delivery_webhooks" to "anon";

grant select on table "public"."delivery_webhooks" to "anon";

grant trigger on table "public"."delivery_webhooks" to "anon";

grant truncate on table "public"."delivery_webhooks" to "anon";

grant update on table "public"."delivery_webhooks" to "anon";

grant delete on table "public"."delivery_webhooks" to "authenticated";

grant insert on table "public"."delivery_webhooks" to "authenticated";

grant references on table "public"."delivery_webhooks" to "authenticated";

grant select on table "public"."delivery_webhooks" to "authenticated";

grant trigger on table "public"."delivery_webhooks" to "authenticated";

grant truncate on table "public"."delivery_webhooks" to "authenticated";

grant update on table "public"."delivery_webhooks" to "authenticated";

grant delete on table "public"."delivery_webhooks" to "service_role";

grant insert on table "public"."delivery_webhooks" to "service_role";

grant references on table "public"."delivery_webhooks" to "service_role";

grant select on table "public"."delivery_webhooks" to "service_role";

grant trigger on table "public"."delivery_webhooks" to "service_role";

grant truncate on table "public"."delivery_webhooks" to "service_role";

grant update on table "public"."delivery_webhooks" to "service_role";

grant delete on table "public"."dm_settings" to "anon";

grant insert on table "public"."dm_settings" to "anon";

grant references on table "public"."dm_settings" to "anon";

grant select on table "public"."dm_settings" to "anon";

grant trigger on table "public"."dm_settings" to "anon";

grant truncate on table "public"."dm_settings" to "anon";

grant update on table "public"."dm_settings" to "anon";

grant delete on table "public"."dm_settings" to "authenticated";

grant insert on table "public"."dm_settings" to "authenticated";

grant references on table "public"."dm_settings" to "authenticated";

grant select on table "public"."dm_settings" to "authenticated";

grant trigger on table "public"."dm_settings" to "authenticated";

grant truncate on table "public"."dm_settings" to "authenticated";

grant update on table "public"."dm_settings" to "authenticated";

grant delete on table "public"."dm_settings" to "service_role";

grant insert on table "public"."dm_settings" to "service_role";

grant references on table "public"."dm_settings" to "service_role";

grant select on table "public"."dm_settings" to "service_role";

grant trigger on table "public"."dm_settings" to "service_role";

grant truncate on table "public"."dm_settings" to "service_role";

grant update on table "public"."dm_settings" to "service_role";

grant delete on table "public"."early_access_signups" to "anon";

grant insert on table "public"."early_access_signups" to "anon";

grant references on table "public"."early_access_signups" to "anon";

grant select on table "public"."early_access_signups" to "anon";

grant trigger on table "public"."early_access_signups" to "anon";

grant truncate on table "public"."early_access_signups" to "anon";

grant update on table "public"."early_access_signups" to "anon";

grant delete on table "public"."early_access_signups" to "authenticated";

grant insert on table "public"."early_access_signups" to "authenticated";

grant references on table "public"."early_access_signups" to "authenticated";

grant select on table "public"."early_access_signups" to "authenticated";

grant trigger on table "public"."early_access_signups" to "authenticated";

grant truncate on table "public"."early_access_signups" to "authenticated";

grant update on table "public"."early_access_signups" to "authenticated";

grant delete on table "public"."early_access_signups" to "service_role";

grant insert on table "public"."early_access_signups" to "service_role";

grant references on table "public"."early_access_signups" to "service_role";

grant select on table "public"."early_access_signups" to "service_role";

grant trigger on table "public"."early_access_signups" to "service_role";

grant truncate on table "public"."early_access_signups" to "service_role";

grant update on table "public"."early_access_signups" to "service_role";

grant delete on table "public"."email_logs" to "anon";

grant insert on table "public"."email_logs" to "anon";

grant references on table "public"."email_logs" to "anon";

grant select on table "public"."email_logs" to "anon";

grant trigger on table "public"."email_logs" to "anon";

grant truncate on table "public"."email_logs" to "anon";

grant update on table "public"."email_logs" to "anon";

grant delete on table "public"."email_logs" to "authenticated";

grant insert on table "public"."email_logs" to "authenticated";

grant references on table "public"."email_logs" to "authenticated";

grant select on table "public"."email_logs" to "authenticated";

grant trigger on table "public"."email_logs" to "authenticated";

grant truncate on table "public"."email_logs" to "authenticated";

grant update on table "public"."email_logs" to "authenticated";

grant delete on table "public"."email_logs" to "service_role";

grant insert on table "public"."email_logs" to "service_role";

grant references on table "public"."email_logs" to "service_role";

grant select on table "public"."email_logs" to "service_role";

grant trigger on table "public"."email_logs" to "service_role";

grant truncate on table "public"."email_logs" to "service_role";

grant update on table "public"."email_logs" to "service_role";

grant delete on table "public"."email_preferences" to "anon";

grant insert on table "public"."email_preferences" to "anon";

grant references on table "public"."email_preferences" to "anon";

grant select on table "public"."email_preferences" to "anon";

grant trigger on table "public"."email_preferences" to "anon";

grant truncate on table "public"."email_preferences" to "anon";

grant update on table "public"."email_preferences" to "anon";

grant delete on table "public"."email_preferences" to "authenticated";

grant insert on table "public"."email_preferences" to "authenticated";

grant references on table "public"."email_preferences" to "authenticated";

grant select on table "public"."email_preferences" to "authenticated";

grant trigger on table "public"."email_preferences" to "authenticated";

grant truncate on table "public"."email_preferences" to "authenticated";

grant update on table "public"."email_preferences" to "authenticated";

grant delete on table "public"."email_preferences" to "service_role";

grant insert on table "public"."email_preferences" to "service_role";

grant references on table "public"."email_preferences" to "service_role";

grant select on table "public"."email_preferences" to "service_role";

grant trigger on table "public"."email_preferences" to "service_role";

grant truncate on table "public"."email_preferences" to "service_role";

grant update on table "public"."email_preferences" to "service_role";

grant delete on table "public"."email_templates" to "anon";

grant insert on table "public"."email_templates" to "anon";

grant references on table "public"."email_templates" to "anon";

grant select on table "public"."email_templates" to "anon";

grant trigger on table "public"."email_templates" to "anon";

grant truncate on table "public"."email_templates" to "anon";

grant update on table "public"."email_templates" to "anon";

grant delete on table "public"."email_templates" to "authenticated";

grant insert on table "public"."email_templates" to "authenticated";

grant references on table "public"."email_templates" to "authenticated";

grant select on table "public"."email_templates" to "authenticated";

grant trigger on table "public"."email_templates" to "authenticated";

grant truncate on table "public"."email_templates" to "authenticated";

grant update on table "public"."email_templates" to "authenticated";

grant delete on table "public"."email_templates" to "service_role";

grant insert on table "public"."email_templates" to "service_role";

grant references on table "public"."email_templates" to "service_role";

grant select on table "public"."email_templates" to "service_role";

grant trigger on table "public"."email_templates" to "service_role";

grant truncate on table "public"."email_templates" to "service_role";

grant update on table "public"."email_templates" to "service_role";

grant delete on table "public"."emergency_contacts" to "anon";

grant insert on table "public"."emergency_contacts" to "anon";

grant references on table "public"."emergency_contacts" to "anon";

grant select on table "public"."emergency_contacts" to "anon";

grant trigger on table "public"."emergency_contacts" to "anon";

grant truncate on table "public"."emergency_contacts" to "anon";

grant update on table "public"."emergency_contacts" to "anon";

grant delete on table "public"."emergency_contacts" to "authenticated";

grant insert on table "public"."emergency_contacts" to "authenticated";

grant references on table "public"."emergency_contacts" to "authenticated";

grant select on table "public"."emergency_contacts" to "authenticated";

grant trigger on table "public"."emergency_contacts" to "authenticated";

grant truncate on table "public"."emergency_contacts" to "authenticated";

grant update on table "public"."emergency_contacts" to "authenticated";

grant delete on table "public"."emergency_contacts" to "service_role";

grant insert on table "public"."emergency_contacts" to "service_role";

grant references on table "public"."emergency_contacts" to "service_role";

grant select on table "public"."emergency_contacts" to "service_role";

grant trigger on table "public"."emergency_contacts" to "service_role";

grant truncate on table "public"."emergency_contacts" to "service_role";

grant update on table "public"."emergency_contacts" to "service_role";

grant delete on table "public"."enrollment_applications" to "anon";

grant insert on table "public"."enrollment_applications" to "anon";

grant references on table "public"."enrollment_applications" to "anon";

grant select on table "public"."enrollment_applications" to "anon";

grant trigger on table "public"."enrollment_applications" to "anon";

grant truncate on table "public"."enrollment_applications" to "anon";

grant update on table "public"."enrollment_applications" to "anon";

grant delete on table "public"."enrollment_applications" to "authenticated";

grant insert on table "public"."enrollment_applications" to "authenticated";

grant references on table "public"."enrollment_applications" to "authenticated";

grant select on table "public"."enrollment_applications" to "authenticated";

grant trigger on table "public"."enrollment_applications" to "authenticated";

grant truncate on table "public"."enrollment_applications" to "authenticated";

grant update on table "public"."enrollment_applications" to "authenticated";

grant delete on table "public"."enrollment_applications" to "service_role";

grant insert on table "public"."enrollment_applications" to "service_role";

grant references on table "public"."enrollment_applications" to "service_role";

grant select on table "public"."enrollment_applications" to "service_role";

grant trigger on table "public"."enrollment_applications" to "service_role";

grant truncate on table "public"."enrollment_applications" to "service_role";

grant update on table "public"."enrollment_applications" to "service_role";

grant delete on table "public"."enrollments" to "anon";

grant insert on table "public"."enrollments" to "anon";

grant references on table "public"."enrollments" to "anon";

grant select on table "public"."enrollments" to "anon";

grant trigger on table "public"."enrollments" to "anon";

grant truncate on table "public"."enrollments" to "anon";

grant update on table "public"."enrollments" to "anon";

grant delete on table "public"."enrollments" to "authenticated";

grant insert on table "public"."enrollments" to "authenticated";

grant references on table "public"."enrollments" to "authenticated";

grant select on table "public"."enrollments" to "authenticated";

grant trigger on table "public"."enrollments" to "authenticated";

grant truncate on table "public"."enrollments" to "authenticated";

grant update on table "public"."enrollments" to "authenticated";

grant delete on table "public"."enrollments" to "service_role";

grant insert on table "public"."enrollments" to "service_role";

grant references on table "public"."enrollments" to "service_role";

grant select on table "public"."enrollments" to "service_role";

grant trigger on table "public"."enrollments" to "service_role";

grant truncate on table "public"."enrollments" to "service_role";

grant update on table "public"."enrollments" to "service_role";

grant delete on table "public"."enterprise_leads" to "anon";

grant insert on table "public"."enterprise_leads" to "anon";

grant references on table "public"."enterprise_leads" to "anon";

grant select on table "public"."enterprise_leads" to "anon";

grant trigger on table "public"."enterprise_leads" to "anon";

grant truncate on table "public"."enterprise_leads" to "anon";

grant update on table "public"."enterprise_leads" to "anon";

grant delete on table "public"."enterprise_leads" to "authenticated";

grant insert on table "public"."enterprise_leads" to "authenticated";

grant references on table "public"."enterprise_leads" to "authenticated";

grant select on table "public"."enterprise_leads" to "authenticated";

grant trigger on table "public"."enterprise_leads" to "authenticated";

grant truncate on table "public"."enterprise_leads" to "authenticated";

grant update on table "public"."enterprise_leads" to "authenticated";

grant delete on table "public"."enterprise_leads" to "service_role";

grant insert on table "public"."enterprise_leads" to "service_role";

grant references on table "public"."enterprise_leads" to "service_role";

grant select on table "public"."enterprise_leads" to "service_role";

grant trigger on table "public"."enterprise_leads" to "service_role";

grant truncate on table "public"."enterprise_leads" to "service_role";

grant update on table "public"."enterprise_leads" to "service_role";

grant delete on table "public"."error_logs" to "anon";

grant insert on table "public"."error_logs" to "anon";

grant references on table "public"."error_logs" to "anon";

grant select on table "public"."error_logs" to "anon";

grant trigger on table "public"."error_logs" to "anon";

grant truncate on table "public"."error_logs" to "anon";

grant update on table "public"."error_logs" to "anon";

grant delete on table "public"."error_logs" to "authenticated";

grant insert on table "public"."error_logs" to "authenticated";

grant references on table "public"."error_logs" to "authenticated";

grant select on table "public"."error_logs" to "authenticated";

grant trigger on table "public"."error_logs" to "authenticated";

grant truncate on table "public"."error_logs" to "authenticated";

grant update on table "public"."error_logs" to "authenticated";

grant delete on table "public"."error_logs" to "service_role";

grant insert on table "public"."error_logs" to "service_role";

grant references on table "public"."error_logs" to "service_role";

grant select on table "public"."error_logs" to "service_role";

grant trigger on table "public"."error_logs" to "service_role";

grant truncate on table "public"."error_logs" to "service_role";

grant update on table "public"."error_logs" to "service_role";

grant delete on table "public"."event_attendees" to "anon";

grant insert on table "public"."event_attendees" to "anon";

grant references on table "public"."event_attendees" to "anon";

grant select on table "public"."event_attendees" to "anon";

grant trigger on table "public"."event_attendees" to "anon";

grant truncate on table "public"."event_attendees" to "anon";

grant update on table "public"."event_attendees" to "anon";

grant delete on table "public"."event_attendees" to "authenticated";

grant insert on table "public"."event_attendees" to "authenticated";

grant references on table "public"."event_attendees" to "authenticated";

grant select on table "public"."event_attendees" to "authenticated";

grant trigger on table "public"."event_attendees" to "authenticated";

grant truncate on table "public"."event_attendees" to "authenticated";

grant update on table "public"."event_attendees" to "authenticated";

grant delete on table "public"."event_attendees" to "service_role";

grant insert on table "public"."event_attendees" to "service_role";

grant references on table "public"."event_attendees" to "service_role";

grant select on table "public"."event_attendees" to "service_role";

grant trigger on table "public"."event_attendees" to "service_role";

grant truncate on table "public"."event_attendees" to "service_role";

grant update on table "public"."event_attendees" to "service_role";

grant delete on table "public"."event_audiences" to "anon";

grant insert on table "public"."event_audiences" to "anon";

grant references on table "public"."event_audiences" to "anon";

grant select on table "public"."event_audiences" to "anon";

grant trigger on table "public"."event_audiences" to "anon";

grant truncate on table "public"."event_audiences" to "anon";

grant update on table "public"."event_audiences" to "anon";

grant delete on table "public"."event_audiences" to "authenticated";

grant insert on table "public"."event_audiences" to "authenticated";

grant references on table "public"."event_audiences" to "authenticated";

grant select on table "public"."event_audiences" to "authenticated";

grant trigger on table "public"."event_audiences" to "authenticated";

grant truncate on table "public"."event_audiences" to "authenticated";

grant update on table "public"."event_audiences" to "authenticated";

grant delete on table "public"."event_audiences" to "service_role";

grant insert on table "public"."event_audiences" to "service_role";

grant references on table "public"."event_audiences" to "service_role";

grant select on table "public"."event_audiences" to "service_role";

grant trigger on table "public"."event_audiences" to "service_role";

grant truncate on table "public"."event_audiences" to "service_role";

grant update on table "public"."event_audiences" to "service_role";

grant delete on table "public"."event_invitations" to "anon";

grant insert on table "public"."event_invitations" to "anon";

grant references on table "public"."event_invitations" to "anon";

grant select on table "public"."event_invitations" to "anon";

grant trigger on table "public"."event_invitations" to "anon";

grant truncate on table "public"."event_invitations" to "anon";

grant update on table "public"."event_invitations" to "anon";

grant delete on table "public"."event_invitations" to "authenticated";

grant insert on table "public"."event_invitations" to "authenticated";

grant references on table "public"."event_invitations" to "authenticated";

grant select on table "public"."event_invitations" to "authenticated";

grant trigger on table "public"."event_invitations" to "authenticated";

grant truncate on table "public"."event_invitations" to "authenticated";

grant update on table "public"."event_invitations" to "authenticated";

grant delete on table "public"."event_invitations" to "service_role";

grant insert on table "public"."event_invitations" to "service_role";

grant references on table "public"."event_invitations" to "service_role";

grant select on table "public"."event_invitations" to "service_role";

grant trigger on table "public"."event_invitations" to "service_role";

grant truncate on table "public"."event_invitations" to "service_role";

grant update on table "public"."event_invitations" to "service_role";

grant delete on table "public"."event_media" to "anon";

grant insert on table "public"."event_media" to "anon";

grant references on table "public"."event_media" to "anon";

grant select on table "public"."event_media" to "anon";

grant trigger on table "public"."event_media" to "anon";

grant truncate on table "public"."event_media" to "anon";

grant update on table "public"."event_media" to "anon";

grant delete on table "public"."event_media" to "authenticated";

grant insert on table "public"."event_media" to "authenticated";

grant references on table "public"."event_media" to "authenticated";

grant select on table "public"."event_media" to "authenticated";

grant trigger on table "public"."event_media" to "authenticated";

grant truncate on table "public"."event_media" to "authenticated";

grant update on table "public"."event_media" to "authenticated";

grant delete on table "public"."event_media" to "service_role";

grant insert on table "public"."event_media" to "service_role";

grant references on table "public"."event_media" to "service_role";

grant select on table "public"."event_media" to "service_role";

grant trigger on table "public"."event_media" to "service_role";

grant truncate on table "public"."event_media" to "service_role";

grant update on table "public"."event_media" to "service_role";

grant delete on table "public"."event_notifications" to "anon";

grant insert on table "public"."event_notifications" to "anon";

grant references on table "public"."event_notifications" to "anon";

grant select on table "public"."event_notifications" to "anon";

grant trigger on table "public"."event_notifications" to "anon";

grant truncate on table "public"."event_notifications" to "anon";

grant update on table "public"."event_notifications" to "anon";

grant delete on table "public"."event_notifications" to "authenticated";

grant insert on table "public"."event_notifications" to "authenticated";

grant references on table "public"."event_notifications" to "authenticated";

grant select on table "public"."event_notifications" to "authenticated";

grant trigger on table "public"."event_notifications" to "authenticated";

grant truncate on table "public"."event_notifications" to "authenticated";

grant update on table "public"."event_notifications" to "authenticated";

grant delete on table "public"."event_notifications" to "service_role";

grant insert on table "public"."event_notifications" to "service_role";

grant references on table "public"."event_notifications" to "service_role";

grant select on table "public"."event_notifications" to "service_role";

grant trigger on table "public"."event_notifications" to "service_role";

grant truncate on table "public"."event_notifications" to "service_role";

grant update on table "public"."event_notifications" to "service_role";

grant delete on table "public"."event_participants" to "anon";

grant insert on table "public"."event_participants" to "anon";

grant references on table "public"."event_participants" to "anon";

grant select on table "public"."event_participants" to "anon";

grant trigger on table "public"."event_participants" to "anon";

grant truncate on table "public"."event_participants" to "anon";

grant update on table "public"."event_participants" to "anon";

grant delete on table "public"."event_participants" to "authenticated";

grant insert on table "public"."event_participants" to "authenticated";

grant references on table "public"."event_participants" to "authenticated";

grant select on table "public"."event_participants" to "authenticated";

grant trigger on table "public"."event_participants" to "authenticated";

grant truncate on table "public"."event_participants" to "authenticated";

grant update on table "public"."event_participants" to "authenticated";

grant delete on table "public"."event_participants" to "service_role";

grant insert on table "public"."event_participants" to "service_role";

grant references on table "public"."event_participants" to "service_role";

grant select on table "public"."event_participants" to "service_role";

grant trigger on table "public"."event_participants" to "service_role";

grant truncate on table "public"."event_participants" to "service_role";

grant update on table "public"."event_participants" to "service_role";

grant delete on table "public"."event_reactions" to "anon";

grant insert on table "public"."event_reactions" to "anon";

grant references on table "public"."event_reactions" to "anon";

grant select on table "public"."event_reactions" to "anon";

grant trigger on table "public"."event_reactions" to "anon";

grant truncate on table "public"."event_reactions" to "anon";

grant update on table "public"."event_reactions" to "anon";

grant delete on table "public"."event_reactions" to "authenticated";

grant insert on table "public"."event_reactions" to "authenticated";

grant references on table "public"."event_reactions" to "authenticated";

grant select on table "public"."event_reactions" to "authenticated";

grant trigger on table "public"."event_reactions" to "authenticated";

grant truncate on table "public"."event_reactions" to "authenticated";

grant update on table "public"."event_reactions" to "authenticated";

grant delete on table "public"."event_reactions" to "service_role";

grant insert on table "public"."event_reactions" to "service_role";

grant references on table "public"."event_reactions" to "service_role";

grant select on table "public"."event_reactions" to "service_role";

grant trigger on table "public"."event_reactions" to "service_role";

grant truncate on table "public"."event_reactions" to "service_role";

grant update on table "public"."event_reactions" to "service_role";

grant delete on table "public"."event_rsvps" to "anon";

grant insert on table "public"."event_rsvps" to "anon";

grant references on table "public"."event_rsvps" to "anon";

grant select on table "public"."event_rsvps" to "anon";

grant trigger on table "public"."event_rsvps" to "anon";

grant truncate on table "public"."event_rsvps" to "anon";

grant update on table "public"."event_rsvps" to "anon";

grant delete on table "public"."event_rsvps" to "authenticated";

grant insert on table "public"."event_rsvps" to "authenticated";

grant references on table "public"."event_rsvps" to "authenticated";

grant select on table "public"."event_rsvps" to "authenticated";

grant trigger on table "public"."event_rsvps" to "authenticated";

grant truncate on table "public"."event_rsvps" to "authenticated";

grant update on table "public"."event_rsvps" to "authenticated";

grant delete on table "public"."event_rsvps" to "service_role";

grant insert on table "public"."event_rsvps" to "service_role";

grant references on table "public"."event_rsvps" to "service_role";

grant select on table "public"."event_rsvps" to "service_role";

grant trigger on table "public"."event_rsvps" to "service_role";

grant truncate on table "public"."event_rsvps" to "service_role";

grant update on table "public"."event_rsvps" to "service_role";

grant delete on table "public"."event_updates" to "anon";

grant insert on table "public"."event_updates" to "anon";

grant references on table "public"."event_updates" to "anon";

grant select on table "public"."event_updates" to "anon";

grant trigger on table "public"."event_updates" to "anon";

grant truncate on table "public"."event_updates" to "anon";

grant update on table "public"."event_updates" to "anon";

grant delete on table "public"."event_updates" to "authenticated";

grant insert on table "public"."event_updates" to "authenticated";

grant references on table "public"."event_updates" to "authenticated";

grant select on table "public"."event_updates" to "authenticated";

grant trigger on table "public"."event_updates" to "authenticated";

grant truncate on table "public"."event_updates" to "authenticated";

grant update on table "public"."event_updates" to "authenticated";

grant delete on table "public"."event_updates" to "service_role";

grant insert on table "public"."event_updates" to "service_role";

grant references on table "public"."event_updates" to "service_role";

grant select on table "public"."event_updates" to "service_role";

grant trigger on table "public"."event_updates" to "service_role";

grant truncate on table "public"."event_updates" to "service_role";

grant update on table "public"."event_updates" to "service_role";

grant delete on table "public"."events" to "anon";

grant insert on table "public"."events" to "anon";

grant references on table "public"."events" to "anon";

grant select on table "public"."events" to "anon";

grant trigger on table "public"."events" to "anon";

grant truncate on table "public"."events" to "anon";

grant update on table "public"."events" to "anon";

grant delete on table "public"."events" to "authenticated";

grant insert on table "public"."events" to "authenticated";

grant references on table "public"."events" to "authenticated";

grant select on table "public"."events" to "authenticated";

grant trigger on table "public"."events" to "authenticated";

grant truncate on table "public"."events" to "authenticated";

grant update on table "public"."events" to "authenticated";

grant delete on table "public"."events" to "service_role";

grant insert on table "public"."events" to "service_role";

grant references on table "public"."events" to "service_role";

grant select on table "public"."events" to "service_role";

grant trigger on table "public"."events" to "service_role";

grant truncate on table "public"."events" to "service_role";

grant update on table "public"."events" to "service_role";

grant delete on table "public"."exam_assignments" to "anon";

grant insert on table "public"."exam_assignments" to "anon";

grant references on table "public"."exam_assignments" to "anon";

grant select on table "public"."exam_assignments" to "anon";

grant trigger on table "public"."exam_assignments" to "anon";

grant truncate on table "public"."exam_assignments" to "anon";

grant update on table "public"."exam_assignments" to "anon";

grant delete on table "public"."exam_assignments" to "authenticated";

grant insert on table "public"."exam_assignments" to "authenticated";

grant references on table "public"."exam_assignments" to "authenticated";

grant select on table "public"."exam_assignments" to "authenticated";

grant trigger on table "public"."exam_assignments" to "authenticated";

grant truncate on table "public"."exam_assignments" to "authenticated";

grant update on table "public"."exam_assignments" to "authenticated";

grant delete on table "public"."exam_assignments" to "service_role";

grant insert on table "public"."exam_assignments" to "service_role";

grant references on table "public"."exam_assignments" to "service_role";

grant select on table "public"."exam_assignments" to "service_role";

grant trigger on table "public"."exam_assignments" to "service_role";

grant truncate on table "public"."exam_assignments" to "service_role";

grant update on table "public"."exam_assignments" to "service_role";

grant delete on table "public"."exam_attempts" to "anon";

grant insert on table "public"."exam_attempts" to "anon";

grant references on table "public"."exam_attempts" to "anon";

grant select on table "public"."exam_attempts" to "anon";

grant trigger on table "public"."exam_attempts" to "anon";

grant truncate on table "public"."exam_attempts" to "anon";

grant update on table "public"."exam_attempts" to "anon";

grant delete on table "public"."exam_attempts" to "authenticated";

grant insert on table "public"."exam_attempts" to "authenticated";

grant references on table "public"."exam_attempts" to "authenticated";

grant select on table "public"."exam_attempts" to "authenticated";

grant trigger on table "public"."exam_attempts" to "authenticated";

grant truncate on table "public"."exam_attempts" to "authenticated";

grant update on table "public"."exam_attempts" to "authenticated";

grant delete on table "public"."exam_attempts" to "service_role";

grant insert on table "public"."exam_attempts" to "service_role";

grant references on table "public"."exam_attempts" to "service_role";

grant select on table "public"."exam_attempts" to "service_role";

grant trigger on table "public"."exam_attempts" to "service_role";

grant truncate on table "public"."exam_attempts" to "service_role";

grant update on table "public"."exam_attempts" to "service_role";

grant delete on table "public"."exam_generations" to "anon";

grant insert on table "public"."exam_generations" to "anon";

grant references on table "public"."exam_generations" to "anon";

grant select on table "public"."exam_generations" to "anon";

grant trigger on table "public"."exam_generations" to "anon";

grant truncate on table "public"."exam_generations" to "anon";

grant update on table "public"."exam_generations" to "anon";

grant delete on table "public"."exam_generations" to "authenticated";

grant insert on table "public"."exam_generations" to "authenticated";

grant references on table "public"."exam_generations" to "authenticated";

grant select on table "public"."exam_generations" to "authenticated";

grant trigger on table "public"."exam_generations" to "authenticated";

grant truncate on table "public"."exam_generations" to "authenticated";

grant update on table "public"."exam_generations" to "authenticated";

grant delete on table "public"."exam_generations" to "service_role";

grant insert on table "public"."exam_generations" to "service_role";

grant references on table "public"."exam_generations" to "service_role";

grant select on table "public"."exam_generations" to "service_role";

grant trigger on table "public"."exam_generations" to "service_role";

grant truncate on table "public"."exam_generations" to "service_role";

grant update on table "public"."exam_generations" to "service_role";

grant delete on table "public"."exam_papers" to "anon";

grant insert on table "public"."exam_papers" to "anon";

grant references on table "public"."exam_papers" to "anon";

grant select on table "public"."exam_papers" to "anon";

grant trigger on table "public"."exam_papers" to "anon";

grant truncate on table "public"."exam_papers" to "anon";

grant update on table "public"."exam_papers" to "anon";

grant delete on table "public"."exam_papers" to "authenticated";

grant insert on table "public"."exam_papers" to "authenticated";

grant references on table "public"."exam_papers" to "authenticated";

grant select on table "public"."exam_papers" to "authenticated";

grant trigger on table "public"."exam_papers" to "authenticated";

grant truncate on table "public"."exam_papers" to "authenticated";

grant update on table "public"."exam_papers" to "authenticated";

grant delete on table "public"."exam_papers" to "service_role";

grant insert on table "public"."exam_papers" to "service_role";

grant references on table "public"."exam_papers" to "service_role";

grant select on table "public"."exam_papers" to "service_role";

grant trigger on table "public"."exam_papers" to "service_role";

grant truncate on table "public"."exam_papers" to "service_role";

grant update on table "public"."exam_papers" to "service_role";

grant delete on table "public"."exam_submissions" to "anon";

grant insert on table "public"."exam_submissions" to "anon";

grant references on table "public"."exam_submissions" to "anon";

grant select on table "public"."exam_submissions" to "anon";

grant trigger on table "public"."exam_submissions" to "anon";

grant truncate on table "public"."exam_submissions" to "anon";

grant update on table "public"."exam_submissions" to "anon";

grant delete on table "public"."exam_submissions" to "authenticated";

grant insert on table "public"."exam_submissions" to "authenticated";

grant references on table "public"."exam_submissions" to "authenticated";

grant select on table "public"."exam_submissions" to "authenticated";

grant trigger on table "public"."exam_submissions" to "authenticated";

grant truncate on table "public"."exam_submissions" to "authenticated";

grant update on table "public"."exam_submissions" to "authenticated";

grant delete on table "public"."exam_submissions" to "service_role";

grant insert on table "public"."exam_submissions" to "service_role";

grant references on table "public"."exam_submissions" to "service_role";

grant select on table "public"."exam_submissions" to "service_role";

grant trigger on table "public"."exam_submissions" to "service_role";

grant truncate on table "public"."exam_submissions" to "service_role";

grant update on table "public"."exam_submissions" to "service_role";

grant delete on table "public"."exam_user_progress" to "anon";

grant insert on table "public"."exam_user_progress" to "anon";

grant references on table "public"."exam_user_progress" to "anon";

grant select on table "public"."exam_user_progress" to "anon";

grant trigger on table "public"."exam_user_progress" to "anon";

grant truncate on table "public"."exam_user_progress" to "anon";

grant update on table "public"."exam_user_progress" to "anon";

grant delete on table "public"."exam_user_progress" to "authenticated";

grant insert on table "public"."exam_user_progress" to "authenticated";

grant references on table "public"."exam_user_progress" to "authenticated";

grant select on table "public"."exam_user_progress" to "authenticated";

grant trigger on table "public"."exam_user_progress" to "authenticated";

grant truncate on table "public"."exam_user_progress" to "authenticated";

grant update on table "public"."exam_user_progress" to "authenticated";

grant delete on table "public"."exam_user_progress" to "service_role";

grant insert on table "public"."exam_user_progress" to "service_role";

grant references on table "public"."exam_user_progress" to "service_role";

grant select on table "public"."exam_user_progress" to "service_role";

grant trigger on table "public"."exam_user_progress" to "service_role";

grant truncate on table "public"."exam_user_progress" to "service_role";

grant update on table "public"."exam_user_progress" to "service_role";

grant delete on table "public"."expense_categories" to "anon";

grant insert on table "public"."expense_categories" to "anon";

grant references on table "public"."expense_categories" to "anon";

grant select on table "public"."expense_categories" to "anon";

grant trigger on table "public"."expense_categories" to "anon";

grant truncate on table "public"."expense_categories" to "anon";

grant update on table "public"."expense_categories" to "anon";

grant delete on table "public"."expense_categories" to "authenticated";

grant insert on table "public"."expense_categories" to "authenticated";

grant references on table "public"."expense_categories" to "authenticated";

grant select on table "public"."expense_categories" to "authenticated";

grant trigger on table "public"."expense_categories" to "authenticated";

grant truncate on table "public"."expense_categories" to "authenticated";

grant update on table "public"."expense_categories" to "authenticated";

grant delete on table "public"."expense_categories" to "service_role";

grant insert on table "public"."expense_categories" to "service_role";

grant references on table "public"."expense_categories" to "service_role";

grant select on table "public"."expense_categories" to "service_role";

grant trigger on table "public"."expense_categories" to "service_role";

grant truncate on table "public"."expense_categories" to "service_role";

grant update on table "public"."expense_categories" to "service_role";

grant delete on table "public"."feature_flags" to "anon";

grant insert on table "public"."feature_flags" to "anon";

grant references on table "public"."feature_flags" to "anon";

grant select on table "public"."feature_flags" to "anon";

grant trigger on table "public"."feature_flags" to "anon";

grant truncate on table "public"."feature_flags" to "anon";

grant update on table "public"."feature_flags" to "anon";

grant delete on table "public"."feature_flags" to "authenticated";

grant insert on table "public"."feature_flags" to "authenticated";

grant references on table "public"."feature_flags" to "authenticated";

grant select on table "public"."feature_flags" to "authenticated";

grant trigger on table "public"."feature_flags" to "authenticated";

grant truncate on table "public"."feature_flags" to "authenticated";

grant update on table "public"."feature_flags" to "authenticated";

grant delete on table "public"."feature_flags" to "service_role";

grant insert on table "public"."feature_flags" to "service_role";

grant references on table "public"."feature_flags" to "service_role";

grant select on table "public"."feature_flags" to "service_role";

grant trigger on table "public"."feature_flags" to "service_role";

grant truncate on table "public"."feature_flags" to "service_role";

grant update on table "public"."feature_flags" to "service_role";

grant delete on table "public"."fee_payments" to "anon";

grant insert on table "public"."fee_payments" to "anon";

grant references on table "public"."fee_payments" to "anon";

grant select on table "public"."fee_payments" to "anon";

grant trigger on table "public"."fee_payments" to "anon";

grant truncate on table "public"."fee_payments" to "anon";

grant update on table "public"."fee_payments" to "anon";

grant delete on table "public"."fee_payments" to "authenticated";

grant insert on table "public"."fee_payments" to "authenticated";

grant references on table "public"."fee_payments" to "authenticated";

grant select on table "public"."fee_payments" to "authenticated";

grant trigger on table "public"."fee_payments" to "authenticated";

grant truncate on table "public"."fee_payments" to "authenticated";

grant update on table "public"."fee_payments" to "authenticated";

grant delete on table "public"."fee_payments" to "service_role";

grant insert on table "public"."fee_payments" to "service_role";

grant references on table "public"."fee_payments" to "service_role";

grant select on table "public"."fee_payments" to "service_role";

grant trigger on table "public"."fee_payments" to "service_role";

grant truncate on table "public"."fee_payments" to "service_role";

grant update on table "public"."fee_payments" to "service_role";

grant delete on table "public"."financial_transactions" to "anon";

grant insert on table "public"."financial_transactions" to "anon";

grant references on table "public"."financial_transactions" to "anon";

grant select on table "public"."financial_transactions" to "anon";

grant trigger on table "public"."financial_transactions" to "anon";

grant truncate on table "public"."financial_transactions" to "anon";

grant update on table "public"."financial_transactions" to "anon";

grant delete on table "public"."financial_transactions" to "authenticated";

grant insert on table "public"."financial_transactions" to "authenticated";

grant references on table "public"."financial_transactions" to "authenticated";

grant select on table "public"."financial_transactions" to "authenticated";

grant trigger on table "public"."financial_transactions" to "authenticated";

grant truncate on table "public"."financial_transactions" to "authenticated";

grant update on table "public"."financial_transactions" to "authenticated";

grant delete on table "public"."financial_transactions" to "service_role";

grant insert on table "public"."financial_transactions" to "service_role";

grant references on table "public"."financial_transactions" to "service_role";

grant select on table "public"."financial_transactions" to "service_role";

grant trigger on table "public"."financial_transactions" to "service_role";

grant truncate on table "public"."financial_transactions" to "service_role";

grant update on table "public"."financial_transactions" to "service_role";

grant delete on table "public"."gradebook_entries" to "anon";

grant insert on table "public"."gradebook_entries" to "anon";

grant references on table "public"."gradebook_entries" to "anon";

grant select on table "public"."gradebook_entries" to "anon";

grant trigger on table "public"."gradebook_entries" to "anon";

grant truncate on table "public"."gradebook_entries" to "anon";

grant update on table "public"."gradebook_entries" to "anon";

grant delete on table "public"."gradebook_entries" to "authenticated";

grant insert on table "public"."gradebook_entries" to "authenticated";

grant references on table "public"."gradebook_entries" to "authenticated";

grant select on table "public"."gradebook_entries" to "authenticated";

grant trigger on table "public"."gradebook_entries" to "authenticated";

grant truncate on table "public"."gradebook_entries" to "authenticated";

grant update on table "public"."gradebook_entries" to "authenticated";

grant delete on table "public"."gradebook_entries" to "service_role";

grant insert on table "public"."gradebook_entries" to "service_role";

grant references on table "public"."gradebook_entries" to "service_role";

grant select on table "public"."gradebook_entries" to "service_role";

grant trigger on table "public"."gradebook_entries" to "service_role";

grant truncate on table "public"."gradebook_entries" to "service_role";

grant update on table "public"."gradebook_entries" to "service_role";

grant delete on table "public"."grades" to "anon";

grant insert on table "public"."grades" to "anon";

grant references on table "public"."grades" to "anon";

grant select on table "public"."grades" to "anon";

grant trigger on table "public"."grades" to "anon";

grant truncate on table "public"."grades" to "anon";

grant update on table "public"."grades" to "anon";

grant delete on table "public"."grades" to "authenticated";

grant insert on table "public"."grades" to "authenticated";

grant references on table "public"."grades" to "authenticated";

grant select on table "public"."grades" to "authenticated";

grant trigger on table "public"."grades" to "authenticated";

grant truncate on table "public"."grades" to "authenticated";

grant update on table "public"."grades" to "authenticated";

grant delete on table "public"."grades" to "service_role";

grant insert on table "public"."grades" to "service_role";

grant references on table "public"."grades" to "service_role";

grant select on table "public"."grades" to "service_role";

grant trigger on table "public"."grades" to "service_role";

grant truncate on table "public"."grades" to "service_role";

grant update on table "public"."grades" to "service_role";

grant delete on table "public"."group_invitations" to "anon";

grant insert on table "public"."group_invitations" to "anon";

grant references on table "public"."group_invitations" to "anon";

grant select on table "public"."group_invitations" to "anon";

grant trigger on table "public"."group_invitations" to "anon";

grant truncate on table "public"."group_invitations" to "anon";

grant update on table "public"."group_invitations" to "anon";

grant delete on table "public"."group_invitations" to "authenticated";

grant insert on table "public"."group_invitations" to "authenticated";

grant references on table "public"."group_invitations" to "authenticated";

grant select on table "public"."group_invitations" to "authenticated";

grant trigger on table "public"."group_invitations" to "authenticated";

grant truncate on table "public"."group_invitations" to "authenticated";

grant update on table "public"."group_invitations" to "authenticated";

grant delete on table "public"."group_invitations" to "service_role";

grant insert on table "public"."group_invitations" to "service_role";

grant references on table "public"."group_invitations" to "service_role";

grant select on table "public"."group_invitations" to "service_role";

grant trigger on table "public"."group_invitations" to "service_role";

grant truncate on table "public"."group_invitations" to "service_role";

grant update on table "public"."group_invitations" to "service_role";

grant delete on table "public"."group_members" to "anon";

grant insert on table "public"."group_members" to "anon";

grant references on table "public"."group_members" to "anon";

grant select on table "public"."group_members" to "anon";

grant trigger on table "public"."group_members" to "anon";

grant truncate on table "public"."group_members" to "anon";

grant update on table "public"."group_members" to "anon";

grant delete on table "public"."group_members" to "authenticated";

grant insert on table "public"."group_members" to "authenticated";

grant references on table "public"."group_members" to "authenticated";

grant select on table "public"."group_members" to "authenticated";

grant trigger on table "public"."group_members" to "authenticated";

grant truncate on table "public"."group_members" to "authenticated";

grant update on table "public"."group_members" to "authenticated";

grant delete on table "public"."group_members" to "service_role";

grant insert on table "public"."group_members" to "service_role";

grant references on table "public"."group_members" to "service_role";

grant select on table "public"."group_members" to "service_role";

grant trigger on table "public"."group_members" to "service_role";

grant truncate on table "public"."group_members" to "service_role";

grant update on table "public"."group_members" to "service_role";

grant delete on table "public"."groups" to "anon";

grant insert on table "public"."groups" to "anon";

grant references on table "public"."groups" to "anon";

grant select on table "public"."groups" to "anon";

grant trigger on table "public"."groups" to "anon";

grant truncate on table "public"."groups" to "anon";

grant update on table "public"."groups" to "anon";

grant delete on table "public"."groups" to "authenticated";

grant insert on table "public"."groups" to "authenticated";

grant references on table "public"."groups" to "authenticated";

grant select on table "public"."groups" to "authenticated";

grant trigger on table "public"."groups" to "authenticated";

grant truncate on table "public"."groups" to "authenticated";

grant update on table "public"."groups" to "authenticated";

grant delete on table "public"."groups" to "service_role";

grant insert on table "public"."groups" to "service_role";

grant references on table "public"."groups" to "service_role";

grant select on table "public"."groups" to "service_role";

grant trigger on table "public"."groups" to "service_role";

grant truncate on table "public"."groups" to "service_role";

grant update on table "public"."groups" to "service_role";

grant delete on table "public"."guardian_requests" to "anon";

grant insert on table "public"."guardian_requests" to "anon";

grant references on table "public"."guardian_requests" to "anon";

grant select on table "public"."guardian_requests" to "anon";

grant trigger on table "public"."guardian_requests" to "anon";

grant truncate on table "public"."guardian_requests" to "anon";

grant update on table "public"."guardian_requests" to "anon";

grant delete on table "public"."guardian_requests" to "authenticated";

grant insert on table "public"."guardian_requests" to "authenticated";

grant references on table "public"."guardian_requests" to "authenticated";

grant select on table "public"."guardian_requests" to "authenticated";

grant trigger on table "public"."guardian_requests" to "authenticated";

grant truncate on table "public"."guardian_requests" to "authenticated";

grant update on table "public"."guardian_requests" to "authenticated";

grant delete on table "public"."guardian_requests" to "service_role";

grant insert on table "public"."guardian_requests" to "service_role";

grant references on table "public"."guardian_requests" to "service_role";

grant select on table "public"."guardian_requests" to "service_role";

grant trigger on table "public"."guardian_requests" to "service_role";

grant truncate on table "public"."guardian_requests" to "service_role";

grant update on table "public"."guardian_requests" to "service_role";

grant delete on table "public"."guest_usage_log" to "anon";

grant insert on table "public"."guest_usage_log" to "anon";

grant references on table "public"."guest_usage_log" to "anon";

grant select on table "public"."guest_usage_log" to "anon";

grant trigger on table "public"."guest_usage_log" to "anon";

grant truncate on table "public"."guest_usage_log" to "anon";

grant update on table "public"."guest_usage_log" to "anon";

grant delete on table "public"."guest_usage_log" to "authenticated";

grant insert on table "public"."guest_usage_log" to "authenticated";

grant references on table "public"."guest_usage_log" to "authenticated";

grant select on table "public"."guest_usage_log" to "authenticated";

grant trigger on table "public"."guest_usage_log" to "authenticated";

grant truncate on table "public"."guest_usage_log" to "authenticated";

grant update on table "public"."guest_usage_log" to "authenticated";

grant delete on table "public"."guest_usage_log" to "service_role";

grant insert on table "public"."guest_usage_log" to "service_role";

grant references on table "public"."guest_usage_log" to "service_role";

grant select on table "public"."guest_usage_log" to "service_role";

grant trigger on table "public"."guest_usage_log" to "service_role";

grant truncate on table "public"."guest_usage_log" to "service_role";

grant update on table "public"."guest_usage_log" to "service_role";

grant delete on table "public"."homework_activity_log" to "anon";

grant insert on table "public"."homework_activity_log" to "anon";

grant references on table "public"."homework_activity_log" to "anon";

grant select on table "public"."homework_activity_log" to "anon";

grant trigger on table "public"."homework_activity_log" to "anon";

grant truncate on table "public"."homework_activity_log" to "anon";

grant update on table "public"."homework_activity_log" to "anon";

grant delete on table "public"."homework_activity_log" to "authenticated";

grant insert on table "public"."homework_activity_log" to "authenticated";

grant references on table "public"."homework_activity_log" to "authenticated";

grant select on table "public"."homework_activity_log" to "authenticated";

grant trigger on table "public"."homework_activity_log" to "authenticated";

grant truncate on table "public"."homework_activity_log" to "authenticated";

grant update on table "public"."homework_activity_log" to "authenticated";

grant delete on table "public"."homework_activity_log" to "service_role";

grant insert on table "public"."homework_activity_log" to "service_role";

grant references on table "public"."homework_activity_log" to "service_role";

grant select on table "public"."homework_activity_log" to "service_role";

grant trigger on table "public"."homework_activity_log" to "service_role";

grant truncate on table "public"."homework_activity_log" to "service_role";

grant update on table "public"."homework_activity_log" to "service_role";

grant delete on table "public"."homework_assignment_targets" to "anon";

grant insert on table "public"."homework_assignment_targets" to "anon";

grant references on table "public"."homework_assignment_targets" to "anon";

grant select on table "public"."homework_assignment_targets" to "anon";

grant trigger on table "public"."homework_assignment_targets" to "anon";

grant truncate on table "public"."homework_assignment_targets" to "anon";

grant update on table "public"."homework_assignment_targets" to "anon";

grant delete on table "public"."homework_assignment_targets" to "authenticated";

grant insert on table "public"."homework_assignment_targets" to "authenticated";

grant references on table "public"."homework_assignment_targets" to "authenticated";

grant select on table "public"."homework_assignment_targets" to "authenticated";

grant trigger on table "public"."homework_assignment_targets" to "authenticated";

grant truncate on table "public"."homework_assignment_targets" to "authenticated";

grant update on table "public"."homework_assignment_targets" to "authenticated";

grant delete on table "public"."homework_assignment_targets" to "service_role";

grant insert on table "public"."homework_assignment_targets" to "service_role";

grant references on table "public"."homework_assignment_targets" to "service_role";

grant select on table "public"."homework_assignment_targets" to "service_role";

grant trigger on table "public"."homework_assignment_targets" to "service_role";

grant truncate on table "public"."homework_assignment_targets" to "service_role";

grant update on table "public"."homework_assignment_targets" to "service_role";

grant delete on table "public"."homework_assignments" to "anon";

grant insert on table "public"."homework_assignments" to "anon";

grant references on table "public"."homework_assignments" to "anon";

grant select on table "public"."homework_assignments" to "anon";

grant trigger on table "public"."homework_assignments" to "anon";

grant truncate on table "public"."homework_assignments" to "anon";

grant update on table "public"."homework_assignments" to "anon";

grant delete on table "public"."homework_assignments" to "authenticated";

grant insert on table "public"."homework_assignments" to "authenticated";

grant references on table "public"."homework_assignments" to "authenticated";

grant select on table "public"."homework_assignments" to "authenticated";

grant trigger on table "public"."homework_assignments" to "authenticated";

grant truncate on table "public"."homework_assignments" to "authenticated";

grant update on table "public"."homework_assignments" to "authenticated";

grant delete on table "public"."homework_assignments" to "service_role";

grant insert on table "public"."homework_assignments" to "service_role";

grant references on table "public"."homework_assignments" to "service_role";

grant select on table "public"."homework_assignments" to "service_role";

grant trigger on table "public"."homework_assignments" to "service_role";

grant truncate on table "public"."homework_assignments" to "service_role";

grant update on table "public"."homework_assignments" to "service_role";

grant delete on table "public"."homework_notifications" to "anon";

grant insert on table "public"."homework_notifications" to "anon";

grant references on table "public"."homework_notifications" to "anon";

grant select on table "public"."homework_notifications" to "anon";

grant trigger on table "public"."homework_notifications" to "anon";

grant truncate on table "public"."homework_notifications" to "anon";

grant update on table "public"."homework_notifications" to "anon";

grant delete on table "public"."homework_notifications" to "authenticated";

grant insert on table "public"."homework_notifications" to "authenticated";

grant references on table "public"."homework_notifications" to "authenticated";

grant select on table "public"."homework_notifications" to "authenticated";

grant trigger on table "public"."homework_notifications" to "authenticated";

grant truncate on table "public"."homework_notifications" to "authenticated";

grant update on table "public"."homework_notifications" to "authenticated";

grant delete on table "public"."homework_notifications" to "service_role";

grant insert on table "public"."homework_notifications" to "service_role";

grant references on table "public"."homework_notifications" to "service_role";

grant select on table "public"."homework_notifications" to "service_role";

grant trigger on table "public"."homework_notifications" to "service_role";

grant truncate on table "public"."homework_notifications" to "service_role";

grant update on table "public"."homework_notifications" to "service_role";

grant delete on table "public"."homework_submissions" to "anon";

grant insert on table "public"."homework_submissions" to "anon";

grant references on table "public"."homework_submissions" to "anon";

grant select on table "public"."homework_submissions" to "anon";

grant trigger on table "public"."homework_submissions" to "anon";

grant truncate on table "public"."homework_submissions" to "anon";

grant update on table "public"."homework_submissions" to "anon";

grant delete on table "public"."homework_submissions" to "authenticated";

grant insert on table "public"."homework_submissions" to "authenticated";

grant references on table "public"."homework_submissions" to "authenticated";

grant select on table "public"."homework_submissions" to "authenticated";

grant trigger on table "public"."homework_submissions" to "authenticated";

grant truncate on table "public"."homework_submissions" to "authenticated";

grant update on table "public"."homework_submissions" to "authenticated";

grant delete on table "public"."homework_submissions" to "service_role";

grant insert on table "public"."homework_submissions" to "service_role";

grant references on table "public"."homework_submissions" to "service_role";

grant select on table "public"."homework_submissions" to "service_role";

grant trigger on table "public"."homework_submissions" to "service_role";

grant truncate on table "public"."homework_submissions" to "service_role";

grant update on table "public"."homework_submissions" to "service_role";

grant delete on table "public"."in_app_notifications" to "anon";

grant insert on table "public"."in_app_notifications" to "anon";

grant references on table "public"."in_app_notifications" to "anon";

grant select on table "public"."in_app_notifications" to "anon";

grant trigger on table "public"."in_app_notifications" to "anon";

grant truncate on table "public"."in_app_notifications" to "anon";

grant update on table "public"."in_app_notifications" to "anon";

grant delete on table "public"."in_app_notifications" to "authenticated";

grant insert on table "public"."in_app_notifications" to "authenticated";

grant references on table "public"."in_app_notifications" to "authenticated";

grant select on table "public"."in_app_notifications" to "authenticated";

grant trigger on table "public"."in_app_notifications" to "authenticated";

grant truncate on table "public"."in_app_notifications" to "authenticated";

grant update on table "public"."in_app_notifications" to "authenticated";

grant delete on table "public"."in_app_notifications" to "service_role";

grant insert on table "public"."in_app_notifications" to "service_role";

grant references on table "public"."in_app_notifications" to "service_role";

grant select on table "public"."in_app_notifications" to "service_role";

grant trigger on table "public"."in_app_notifications" to "service_role";

grant truncate on table "public"."in_app_notifications" to "service_role";

grant update on table "public"."in_app_notifications" to "service_role";

grant delete on table "public"."independent_children" to "anon";

grant insert on table "public"."independent_children" to "anon";

grant references on table "public"."independent_children" to "anon";

grant select on table "public"."independent_children" to "anon";

grant trigger on table "public"."independent_children" to "anon";

grant truncate on table "public"."independent_children" to "anon";

grant update on table "public"."independent_children" to "anon";

grant delete on table "public"."independent_children" to "authenticated";

grant insert on table "public"."independent_children" to "authenticated";

grant references on table "public"."independent_children" to "authenticated";

grant select on table "public"."independent_children" to "authenticated";

grant trigger on table "public"."independent_children" to "authenticated";

grant truncate on table "public"."independent_children" to "authenticated";

grant update on table "public"."independent_children" to "authenticated";

grant delete on table "public"."independent_children" to "service_role";

grant insert on table "public"."independent_children" to "service_role";

grant references on table "public"."independent_children" to "service_role";

grant select on table "public"."independent_children" to "service_role";

grant trigger on table "public"."independent_children" to "service_role";

grant truncate on table "public"."independent_children" to "service_role";

grant update on table "public"."independent_children" to "service_role";

grant delete on table "public"."independent_content_library" to "anon";

grant insert on table "public"."independent_content_library" to "anon";

grant references on table "public"."independent_content_library" to "anon";

grant select on table "public"."independent_content_library" to "anon";

grant trigger on table "public"."independent_content_library" to "anon";

grant truncate on table "public"."independent_content_library" to "anon";

grant update on table "public"."independent_content_library" to "anon";

grant delete on table "public"."independent_content_library" to "authenticated";

grant insert on table "public"."independent_content_library" to "authenticated";

grant references on table "public"."independent_content_library" to "authenticated";

grant select on table "public"."independent_content_library" to "authenticated";

grant trigger on table "public"."independent_content_library" to "authenticated";

grant truncate on table "public"."independent_content_library" to "authenticated";

grant update on table "public"."independent_content_library" to "authenticated";

grant delete on table "public"."independent_content_library" to "service_role";

grant insert on table "public"."independent_content_library" to "service_role";

grant references on table "public"."independent_content_library" to "service_role";

grant select on table "public"."independent_content_library" to "service_role";

grant trigger on table "public"."independent_content_library" to "service_role";

grant truncate on table "public"."independent_content_library" to "service_role";

grant update on table "public"."independent_content_library" to "service_role";

grant delete on table "public"."integration_audit_log" to "anon";

grant insert on table "public"."integration_audit_log" to "anon";

grant references on table "public"."integration_audit_log" to "anon";

grant select on table "public"."integration_audit_log" to "anon";

grant trigger on table "public"."integration_audit_log" to "anon";

grant truncate on table "public"."integration_audit_log" to "anon";

grant update on table "public"."integration_audit_log" to "anon";

grant delete on table "public"."integration_audit_log" to "authenticated";

grant insert on table "public"."integration_audit_log" to "authenticated";

grant references on table "public"."integration_audit_log" to "authenticated";

grant select on table "public"."integration_audit_log" to "authenticated";

grant trigger on table "public"."integration_audit_log" to "authenticated";

grant truncate on table "public"."integration_audit_log" to "authenticated";

grant update on table "public"."integration_audit_log" to "authenticated";

grant delete on table "public"."integration_audit_log" to "service_role";

grant insert on table "public"."integration_audit_log" to "service_role";

grant references on table "public"."integration_audit_log" to "service_role";

grant select on table "public"."integration_audit_log" to "service_role";

grant trigger on table "public"."integration_audit_log" to "service_role";

grant truncate on table "public"."integration_audit_log" to "service_role";

grant update on table "public"."integration_audit_log" to "service_role";

grant delete on table "public"."interactive_activities" to "anon";

grant insert on table "public"."interactive_activities" to "anon";

grant references on table "public"."interactive_activities" to "anon";

grant select on table "public"."interactive_activities" to "anon";

grant trigger on table "public"."interactive_activities" to "anon";

grant truncate on table "public"."interactive_activities" to "anon";

grant update on table "public"."interactive_activities" to "anon";

grant delete on table "public"."interactive_activities" to "authenticated";

grant insert on table "public"."interactive_activities" to "authenticated";

grant references on table "public"."interactive_activities" to "authenticated";

grant select on table "public"."interactive_activities" to "authenticated";

grant trigger on table "public"."interactive_activities" to "authenticated";

grant truncate on table "public"."interactive_activities" to "authenticated";

grant update on table "public"."interactive_activities" to "authenticated";

grant delete on table "public"."interactive_activities" to "service_role";

grant insert on table "public"."interactive_activities" to "service_role";

grant references on table "public"."interactive_activities" to "service_role";

grant select on table "public"."interactive_activities" to "service_role";

grant trigger on table "public"."interactive_activities" to "service_role";

grant truncate on table "public"."interactive_activities" to "service_role";

grant update on table "public"."interactive_activities" to "service_role";

grant delete on table "public"."interview_schedules" to "anon";

grant insert on table "public"."interview_schedules" to "anon";

grant references on table "public"."interview_schedules" to "anon";

grant select on table "public"."interview_schedules" to "anon";

grant trigger on table "public"."interview_schedules" to "anon";

grant truncate on table "public"."interview_schedules" to "anon";

grant update on table "public"."interview_schedules" to "anon";

grant delete on table "public"."interview_schedules" to "authenticated";

grant insert on table "public"."interview_schedules" to "authenticated";

grant references on table "public"."interview_schedules" to "authenticated";

grant select on table "public"."interview_schedules" to "authenticated";

grant trigger on table "public"."interview_schedules" to "authenticated";

grant truncate on table "public"."interview_schedules" to "authenticated";

grant update on table "public"."interview_schedules" to "authenticated";

grant delete on table "public"."interview_schedules" to "service_role";

grant insert on table "public"."interview_schedules" to "service_role";

grant references on table "public"."interview_schedules" to "service_role";

grant select on table "public"."interview_schedules" to "service_role";

grant trigger on table "public"."interview_schedules" to "service_role";

grant truncate on table "public"."interview_schedules" to "service_role";

grant update on table "public"."interview_schedules" to "service_role";

grant delete on table "public"."invitation_codes" to "anon";

grant insert on table "public"."invitation_codes" to "anon";

grant references on table "public"."invitation_codes" to "anon";

grant select on table "public"."invitation_codes" to "anon";

grant trigger on table "public"."invitation_codes" to "anon";

grant truncate on table "public"."invitation_codes" to "anon";

grant update on table "public"."invitation_codes" to "anon";

grant delete on table "public"."invitation_codes" to "authenticated";

grant insert on table "public"."invitation_codes" to "authenticated";

grant references on table "public"."invitation_codes" to "authenticated";

grant select on table "public"."invitation_codes" to "authenticated";

grant trigger on table "public"."invitation_codes" to "authenticated";

grant truncate on table "public"."invitation_codes" to "authenticated";

grant update on table "public"."invitation_codes" to "authenticated";

grant delete on table "public"."invitation_codes" to "service_role";

grant insert on table "public"."invitation_codes" to "service_role";

grant references on table "public"."invitation_codes" to "service_role";

grant select on table "public"."invitation_codes" to "service_role";

grant trigger on table "public"."invitation_codes" to "service_role";

grant truncate on table "public"."invitation_codes" to "service_role";

grant update on table "public"."invitation_codes" to "service_role";

grant delete on table "public"."invitations" to "anon";

grant insert on table "public"."invitations" to "anon";

grant references on table "public"."invitations" to "anon";

grant select on table "public"."invitations" to "anon";

grant trigger on table "public"."invitations" to "anon";

grant truncate on table "public"."invitations" to "anon";

grant update on table "public"."invitations" to "anon";

grant delete on table "public"."invitations" to "authenticated";

grant insert on table "public"."invitations" to "authenticated";

grant references on table "public"."invitations" to "authenticated";

grant select on table "public"."invitations" to "authenticated";

grant trigger on table "public"."invitations" to "authenticated";

grant truncate on table "public"."invitations" to "authenticated";

grant update on table "public"."invitations" to "authenticated";

grant delete on table "public"."invitations" to "service_role";

grant insert on table "public"."invitations" to "service_role";

grant references on table "public"."invitations" to "service_role";

grant select on table "public"."invitations" to "service_role";

grant trigger on table "public"."invitations" to "service_role";

grant truncate on table "public"."invitations" to "service_role";

grant update on table "public"."invitations" to "service_role";

grant delete on table "public"."invite_logs" to "anon";

grant insert on table "public"."invite_logs" to "anon";

grant references on table "public"."invite_logs" to "anon";

grant select on table "public"."invite_logs" to "anon";

grant trigger on table "public"."invite_logs" to "anon";

grant truncate on table "public"."invite_logs" to "anon";

grant update on table "public"."invite_logs" to "anon";

grant delete on table "public"."invite_logs" to "authenticated";

grant insert on table "public"."invite_logs" to "authenticated";

grant references on table "public"."invite_logs" to "authenticated";

grant select on table "public"."invite_logs" to "authenticated";

grant trigger on table "public"."invite_logs" to "authenticated";

grant truncate on table "public"."invite_logs" to "authenticated";

grant update on table "public"."invite_logs" to "authenticated";

grant delete on table "public"."invite_logs" to "service_role";

grant insert on table "public"."invite_logs" to "service_role";

grant references on table "public"."invite_logs" to "service_role";

grant select on table "public"."invite_logs" to "service_role";

grant trigger on table "public"."invite_logs" to "service_role";

grant truncate on table "public"."invite_logs" to "service_role";

grant update on table "public"."invite_logs" to "service_role";

grant delete on table "public"."invoice_audit_log" to "anon";

grant insert on table "public"."invoice_audit_log" to "anon";

grant references on table "public"."invoice_audit_log" to "anon";

grant select on table "public"."invoice_audit_log" to "anon";

grant trigger on table "public"."invoice_audit_log" to "anon";

grant truncate on table "public"."invoice_audit_log" to "anon";

grant update on table "public"."invoice_audit_log" to "anon";

grant delete on table "public"."invoice_audit_log" to "authenticated";

grant insert on table "public"."invoice_audit_log" to "authenticated";

grant references on table "public"."invoice_audit_log" to "authenticated";

grant select on table "public"."invoice_audit_log" to "authenticated";

grant trigger on table "public"."invoice_audit_log" to "authenticated";

grant truncate on table "public"."invoice_audit_log" to "authenticated";

grant update on table "public"."invoice_audit_log" to "authenticated";

grant delete on table "public"."invoice_audit_log" to "service_role";

grant insert on table "public"."invoice_audit_log" to "service_role";

grant references on table "public"."invoice_audit_log" to "service_role";

grant select on table "public"."invoice_audit_log" to "service_role";

grant trigger on table "public"."invoice_audit_log" to "service_role";

grant truncate on table "public"."invoice_audit_log" to "service_role";

grant update on table "public"."invoice_audit_log" to "service_role";

grant delete on table "public"."invoice_items" to "anon";

grant insert on table "public"."invoice_items" to "anon";

grant references on table "public"."invoice_items" to "anon";

grant select on table "public"."invoice_items" to "anon";

grant trigger on table "public"."invoice_items" to "anon";

grant truncate on table "public"."invoice_items" to "anon";

grant update on table "public"."invoice_items" to "anon";

grant delete on table "public"."invoice_items" to "authenticated";

grant insert on table "public"."invoice_items" to "authenticated";

grant references on table "public"."invoice_items" to "authenticated";

grant select on table "public"."invoice_items" to "authenticated";

grant trigger on table "public"."invoice_items" to "authenticated";

grant truncate on table "public"."invoice_items" to "authenticated";

grant update on table "public"."invoice_items" to "authenticated";

grant delete on table "public"."invoice_items" to "service_role";

grant insert on table "public"."invoice_items" to "service_role";

grant references on table "public"."invoice_items" to "service_role";

grant select on table "public"."invoice_items" to "service_role";

grant trigger on table "public"."invoice_items" to "service_role";

grant truncate on table "public"."invoice_items" to "service_role";

grant update on table "public"."invoice_items" to "service_role";

grant delete on table "public"."invoice_payments" to "anon";

grant insert on table "public"."invoice_payments" to "anon";

grant references on table "public"."invoice_payments" to "anon";

grant select on table "public"."invoice_payments" to "anon";

grant trigger on table "public"."invoice_payments" to "anon";

grant truncate on table "public"."invoice_payments" to "anon";

grant update on table "public"."invoice_payments" to "anon";

grant delete on table "public"."invoice_payments" to "authenticated";

grant insert on table "public"."invoice_payments" to "authenticated";

grant references on table "public"."invoice_payments" to "authenticated";

grant select on table "public"."invoice_payments" to "authenticated";

grant trigger on table "public"."invoice_payments" to "authenticated";

grant truncate on table "public"."invoice_payments" to "authenticated";

grant update on table "public"."invoice_payments" to "authenticated";

grant delete on table "public"."invoice_payments" to "service_role";

grant insert on table "public"."invoice_payments" to "service_role";

grant references on table "public"."invoice_payments" to "service_role";

grant select on table "public"."invoice_payments" to "service_role";

grant trigger on table "public"."invoice_payments" to "service_role";

grant truncate on table "public"."invoice_payments" to "service_role";

grant update on table "public"."invoice_payments" to "service_role";

grant delete on table "public"."invoice_templates" to "anon";

grant insert on table "public"."invoice_templates" to "anon";

grant references on table "public"."invoice_templates" to "anon";

grant select on table "public"."invoice_templates" to "anon";

grant trigger on table "public"."invoice_templates" to "anon";

grant truncate on table "public"."invoice_templates" to "anon";

grant update on table "public"."invoice_templates" to "anon";

grant delete on table "public"."invoice_templates" to "authenticated";

grant insert on table "public"."invoice_templates" to "authenticated";

grant references on table "public"."invoice_templates" to "authenticated";

grant select on table "public"."invoice_templates" to "authenticated";

grant trigger on table "public"."invoice_templates" to "authenticated";

grant truncate on table "public"."invoice_templates" to "authenticated";

grant update on table "public"."invoice_templates" to "authenticated";

grant delete on table "public"."invoice_templates" to "service_role";

grant insert on table "public"."invoice_templates" to "service_role";

grant references on table "public"."invoice_templates" to "service_role";

grant select on table "public"."invoice_templates" to "service_role";

grant trigger on table "public"."invoice_templates" to "service_role";

grant truncate on table "public"."invoice_templates" to "service_role";

grant update on table "public"."invoice_templates" to "service_role";

grant delete on table "public"."invoices" to "anon";

grant insert on table "public"."invoices" to "anon";

grant references on table "public"."invoices" to "anon";

grant select on table "public"."invoices" to "anon";

grant trigger on table "public"."invoices" to "anon";

grant truncate on table "public"."invoices" to "anon";

grant update on table "public"."invoices" to "anon";

grant delete on table "public"."invoices" to "authenticated";

grant insert on table "public"."invoices" to "authenticated";

grant references on table "public"."invoices" to "authenticated";

grant select on table "public"."invoices" to "authenticated";

grant trigger on table "public"."invoices" to "authenticated";

grant truncate on table "public"."invoices" to "authenticated";

grant update on table "public"."invoices" to "authenticated";

grant delete on table "public"."invoices" to "service_role";

grant insert on table "public"."invoices" to "service_role";

grant references on table "public"."invoices" to "service_role";

grant select on table "public"."invoices" to "service_role";

grant trigger on table "public"."invoices" to "service_role";

grant truncate on table "public"."invoices" to "service_role";

grant update on table "public"."invoices" to "service_role";

grant delete on table "public"."job_alerts" to "anon";

grant insert on table "public"."job_alerts" to "anon";

grant references on table "public"."job_alerts" to "anon";

grant select on table "public"."job_alerts" to "anon";

grant trigger on table "public"."job_alerts" to "anon";

grant truncate on table "public"."job_alerts" to "anon";

grant update on table "public"."job_alerts" to "anon";

grant delete on table "public"."job_alerts" to "authenticated";

grant insert on table "public"."job_alerts" to "authenticated";

grant references on table "public"."job_alerts" to "authenticated";

grant select on table "public"."job_alerts" to "authenticated";

grant trigger on table "public"."job_alerts" to "authenticated";

grant truncate on table "public"."job_alerts" to "authenticated";

grant update on table "public"."job_alerts" to "authenticated";

grant delete on table "public"."job_alerts" to "service_role";

grant insert on table "public"."job_alerts" to "service_role";

grant references on table "public"."job_alerts" to "service_role";

grant select on table "public"."job_alerts" to "service_role";

grant trigger on table "public"."job_alerts" to "service_role";

grant truncate on table "public"."job_alerts" to "service_role";

grant update on table "public"."job_alerts" to "service_role";

grant delete on table "public"."job_applications" to "anon";

grant insert on table "public"."job_applications" to "anon";

grant references on table "public"."job_applications" to "anon";

grant select on table "public"."job_applications" to "anon";

grant trigger on table "public"."job_applications" to "anon";

grant truncate on table "public"."job_applications" to "anon";

grant update on table "public"."job_applications" to "anon";

grant delete on table "public"."job_applications" to "authenticated";

grant insert on table "public"."job_applications" to "authenticated";

grant references on table "public"."job_applications" to "authenticated";

grant select on table "public"."job_applications" to "authenticated";

grant trigger on table "public"."job_applications" to "authenticated";

grant truncate on table "public"."job_applications" to "authenticated";

grant update on table "public"."job_applications" to "authenticated";

grant delete on table "public"."job_applications" to "service_role";

grant insert on table "public"."job_applications" to "service_role";

grant references on table "public"."job_applications" to "service_role";

grant select on table "public"."job_applications" to "service_role";

grant trigger on table "public"."job_applications" to "service_role";

grant truncate on table "public"."job_applications" to "service_role";

grant update on table "public"."job_applications" to "service_role";

grant delete on table "public"."job_distributions" to "anon";

grant insert on table "public"."job_distributions" to "anon";

grant references on table "public"."job_distributions" to "anon";

grant select on table "public"."job_distributions" to "anon";

grant trigger on table "public"."job_distributions" to "anon";

grant truncate on table "public"."job_distributions" to "anon";

grant update on table "public"."job_distributions" to "anon";

grant delete on table "public"."job_distributions" to "authenticated";

grant insert on table "public"."job_distributions" to "authenticated";

grant references on table "public"."job_distributions" to "authenticated";

grant select on table "public"."job_distributions" to "authenticated";

grant trigger on table "public"."job_distributions" to "authenticated";

grant truncate on table "public"."job_distributions" to "authenticated";

grant update on table "public"."job_distributions" to "authenticated";

grant delete on table "public"."job_distributions" to "service_role";

grant insert on table "public"."job_distributions" to "service_role";

grant references on table "public"."job_distributions" to "service_role";

grant select on table "public"."job_distributions" to "service_role";

grant trigger on table "public"."job_distributions" to "service_role";

grant truncate on table "public"."job_distributions" to "service_role";

grant update on table "public"."job_distributions" to "service_role";

grant delete on table "public"."job_postings" to "anon";

grant insert on table "public"."job_postings" to "anon";

grant references on table "public"."job_postings" to "anon";

grant select on table "public"."job_postings" to "anon";

grant trigger on table "public"."job_postings" to "anon";

grant truncate on table "public"."job_postings" to "anon";

grant update on table "public"."job_postings" to "anon";

grant delete on table "public"."job_postings" to "authenticated";

grant insert on table "public"."job_postings" to "authenticated";

grant references on table "public"."job_postings" to "authenticated";

grant select on table "public"."job_postings" to "authenticated";

grant trigger on table "public"."job_postings" to "authenticated";

grant truncate on table "public"."job_postings" to "authenticated";

grant update on table "public"."job_postings" to "authenticated";

grant delete on table "public"."job_postings" to "service_role";

grant insert on table "public"."job_postings" to "service_role";

grant references on table "public"."job_postings" to "service_role";

grant select on table "public"."job_postings" to "service_role";

grant trigger on table "public"."job_postings" to "service_role";

grant truncate on table "public"."job_postings" to "service_role";

grant update on table "public"."job_postings" to "service_role";

grant delete on table "public"."join_requests" to "anon";

grant insert on table "public"."join_requests" to "anon";

grant references on table "public"."join_requests" to "anon";

grant select on table "public"."join_requests" to "anon";

grant trigger on table "public"."join_requests" to "anon";

grant truncate on table "public"."join_requests" to "anon";

grant update on table "public"."join_requests" to "anon";

grant delete on table "public"."join_requests" to "authenticated";

grant insert on table "public"."join_requests" to "authenticated";

grant references on table "public"."join_requests" to "authenticated";

grant select on table "public"."join_requests" to "authenticated";

grant trigger on table "public"."join_requests" to "authenticated";

grant truncate on table "public"."join_requests" to "authenticated";

grant update on table "public"."join_requests" to "authenticated";

grant delete on table "public"."join_requests" to "service_role";

grant insert on table "public"."join_requests" to "service_role";

grant references on table "public"."join_requests" to "service_role";

grant select on table "public"."join_requests" to "service_role";

grant trigger on table "public"."join_requests" to "service_role";

grant truncate on table "public"."join_requests" to "service_role";

grant update on table "public"."join_requests" to "service_role";

grant delete on table "public"."learner_connections" to "anon";

grant insert on table "public"."learner_connections" to "anon";

grant references on table "public"."learner_connections" to "anon";

grant select on table "public"."learner_connections" to "anon";

grant trigger on table "public"."learner_connections" to "anon";

grant truncate on table "public"."learner_connections" to "anon";

grant update on table "public"."learner_connections" to "anon";

grant delete on table "public"."learner_connections" to "authenticated";

grant insert on table "public"."learner_connections" to "authenticated";

grant references on table "public"."learner_connections" to "authenticated";

grant select on table "public"."learner_connections" to "authenticated";

grant trigger on table "public"."learner_connections" to "authenticated";

grant truncate on table "public"."learner_connections" to "authenticated";

grant update on table "public"."learner_connections" to "authenticated";

grant delete on table "public"."learner_connections" to "service_role";

grant insert on table "public"."learner_connections" to "service_role";

grant references on table "public"."learner_connections" to "service_role";

grant select on table "public"."learner_connections" to "service_role";

grant trigger on table "public"."learner_connections" to "service_role";

grant truncate on table "public"."learner_connections" to "service_role";

grant update on table "public"."learner_connections" to "service_role";

grant delete on table "public"."learner_cvs" to "anon";

grant insert on table "public"."learner_cvs" to "anon";

grant references on table "public"."learner_cvs" to "anon";

grant select on table "public"."learner_cvs" to "anon";

grant trigger on table "public"."learner_cvs" to "anon";

grant truncate on table "public"."learner_cvs" to "anon";

grant update on table "public"."learner_cvs" to "anon";

grant delete on table "public"."learner_cvs" to "authenticated";

grant insert on table "public"."learner_cvs" to "authenticated";

grant references on table "public"."learner_cvs" to "authenticated";

grant select on table "public"."learner_cvs" to "authenticated";

grant trigger on table "public"."learner_cvs" to "authenticated";

grant truncate on table "public"."learner_cvs" to "authenticated";

grant update on table "public"."learner_cvs" to "authenticated";

grant delete on table "public"."learner_cvs" to "service_role";

grant insert on table "public"."learner_cvs" to "service_role";

grant references on table "public"."learner_cvs" to "service_role";

grant select on table "public"."learner_cvs" to "service_role";

grant trigger on table "public"."learner_cvs" to "service_role";

grant truncate on table "public"."learner_cvs" to "service_role";

grant update on table "public"."learner_cvs" to "service_role";

grant delete on table "public"."learning_activities" to "anon";

grant insert on table "public"."learning_activities" to "anon";

grant references on table "public"."learning_activities" to "anon";

grant select on table "public"."learning_activities" to "anon";

grant trigger on table "public"."learning_activities" to "anon";

grant truncate on table "public"."learning_activities" to "anon";

grant update on table "public"."learning_activities" to "anon";

grant delete on table "public"."learning_activities" to "authenticated";

grant insert on table "public"."learning_activities" to "authenticated";

grant references on table "public"."learning_activities" to "authenticated";

grant select on table "public"."learning_activities" to "authenticated";

grant trigger on table "public"."learning_activities" to "authenticated";

grant truncate on table "public"."learning_activities" to "authenticated";

grant update on table "public"."learning_activities" to "authenticated";

grant delete on table "public"."learning_activities" to "service_role";

grant insert on table "public"."learning_activities" to "service_role";

grant references on table "public"."learning_activities" to "service_role";

grant select on table "public"."learning_activities" to "service_role";

grant trigger on table "public"."learning_activities" to "service_role";

grant truncate on table "public"."learning_activities" to "service_role";

grant update on table "public"."learning_activities" to "service_role";

grant delete on table "public"."lesson_approvals" to "anon";

grant insert on table "public"."lesson_approvals" to "anon";

grant references on table "public"."lesson_approvals" to "anon";

grant select on table "public"."lesson_approvals" to "anon";

grant trigger on table "public"."lesson_approvals" to "anon";

grant truncate on table "public"."lesson_approvals" to "anon";

grant update on table "public"."lesson_approvals" to "anon";

grant delete on table "public"."lesson_approvals" to "authenticated";

grant insert on table "public"."lesson_approvals" to "authenticated";

grant references on table "public"."lesson_approvals" to "authenticated";

grant select on table "public"."lesson_approvals" to "authenticated";

grant trigger on table "public"."lesson_approvals" to "authenticated";

grant truncate on table "public"."lesson_approvals" to "authenticated";

grant update on table "public"."lesson_approvals" to "authenticated";

grant delete on table "public"."lesson_approvals" to "service_role";

grant insert on table "public"."lesson_approvals" to "service_role";

grant references on table "public"."lesson_approvals" to "service_role";

grant select on table "public"."lesson_approvals" to "service_role";

grant trigger on table "public"."lesson_approvals" to "service_role";

grant truncate on table "public"."lesson_approvals" to "service_role";

grant update on table "public"."lesson_approvals" to "service_role";

grant delete on table "public"."lesson_categories" to "anon";

grant insert on table "public"."lesson_categories" to "anon";

grant references on table "public"."lesson_categories" to "anon";

grant select on table "public"."lesson_categories" to "anon";

grant trigger on table "public"."lesson_categories" to "anon";

grant truncate on table "public"."lesson_categories" to "anon";

grant update on table "public"."lesson_categories" to "anon";

grant delete on table "public"."lesson_categories" to "authenticated";

grant insert on table "public"."lesson_categories" to "authenticated";

grant references on table "public"."lesson_categories" to "authenticated";

grant select on table "public"."lesson_categories" to "authenticated";

grant trigger on table "public"."lesson_categories" to "authenticated";

grant truncate on table "public"."lesson_categories" to "authenticated";

grant update on table "public"."lesson_categories" to "authenticated";

grant delete on table "public"."lesson_categories" to "service_role";

grant insert on table "public"."lesson_categories" to "service_role";

grant references on table "public"."lesson_categories" to "service_role";

grant select on table "public"."lesson_categories" to "service_role";

grant trigger on table "public"."lesson_categories" to "service_role";

grant truncate on table "public"."lesson_categories" to "service_role";

grant update on table "public"."lesson_categories" to "service_role";

grant delete on table "public"."marketing_campaigns" to "anon";

grant insert on table "public"."marketing_campaigns" to "anon";

grant references on table "public"."marketing_campaigns" to "anon";

grant select on table "public"."marketing_campaigns" to "anon";

grant trigger on table "public"."marketing_campaigns" to "anon";

grant truncate on table "public"."marketing_campaigns" to "anon";

grant update on table "public"."marketing_campaigns" to "anon";

grant delete on table "public"."marketing_campaigns" to "authenticated";

grant insert on table "public"."marketing_campaigns" to "authenticated";

grant references on table "public"."marketing_campaigns" to "authenticated";

grant select on table "public"."marketing_campaigns" to "authenticated";

grant trigger on table "public"."marketing_campaigns" to "authenticated";

grant truncate on table "public"."marketing_campaigns" to "authenticated";

grant update on table "public"."marketing_campaigns" to "authenticated";

grant delete on table "public"."marketing_campaigns" to "service_role";

grant insert on table "public"."marketing_campaigns" to "service_role";

grant references on table "public"."marketing_campaigns" to "service_role";

grant select on table "public"."marketing_campaigns" to "service_role";

grant trigger on table "public"."marketing_campaigns" to "service_role";

grant truncate on table "public"."marketing_campaigns" to "service_role";

grant update on table "public"."marketing_campaigns" to "service_role";

grant delete on table "public"."media_uploads" to "anon";

grant insert on table "public"."media_uploads" to "anon";

grant references on table "public"."media_uploads" to "anon";

grant select on table "public"."media_uploads" to "anon";

grant trigger on table "public"."media_uploads" to "anon";

grant truncate on table "public"."media_uploads" to "anon";

grant update on table "public"."media_uploads" to "anon";

grant delete on table "public"."media_uploads" to "authenticated";

grant insert on table "public"."media_uploads" to "authenticated";

grant references on table "public"."media_uploads" to "authenticated";

grant select on table "public"."media_uploads" to "authenticated";

grant trigger on table "public"."media_uploads" to "authenticated";

grant truncate on table "public"."media_uploads" to "authenticated";

grant update on table "public"."media_uploads" to "authenticated";

grant delete on table "public"."media_uploads" to "service_role";

grant insert on table "public"."media_uploads" to "service_role";

grant references on table "public"."media_uploads" to "service_role";

grant select on table "public"."media_uploads" to "service_role";

grant trigger on table "public"."media_uploads" to "service_role";

grant truncate on table "public"."media_uploads" to "service_role";

grant update on table "public"."media_uploads" to "service_role";

grant delete on table "public"."meeting_action_items" to "anon";

grant insert on table "public"."meeting_action_items" to "anon";

grant references on table "public"."meeting_action_items" to "anon";

grant select on table "public"."meeting_action_items" to "anon";

grant trigger on table "public"."meeting_action_items" to "anon";

grant truncate on table "public"."meeting_action_items" to "anon";

grant update on table "public"."meeting_action_items" to "anon";

grant delete on table "public"."meeting_action_items" to "authenticated";

grant insert on table "public"."meeting_action_items" to "authenticated";

grant references on table "public"."meeting_action_items" to "authenticated";

grant select on table "public"."meeting_action_items" to "authenticated";

grant trigger on table "public"."meeting_action_items" to "authenticated";

grant truncate on table "public"."meeting_action_items" to "authenticated";

grant update on table "public"."meeting_action_items" to "authenticated";

grant delete on table "public"."meeting_action_items" to "service_role";

grant insert on table "public"."meeting_action_items" to "service_role";

grant references on table "public"."meeting_action_items" to "service_role";

grant select on table "public"."meeting_action_items" to "service_role";

grant trigger on table "public"."meeting_action_items" to "service_role";

grant truncate on table "public"."meeting_action_items" to "service_role";

grant update on table "public"."meeting_action_items" to "service_role";

grant delete on table "public"."meeting_participants" to "anon";

grant insert on table "public"."meeting_participants" to "anon";

grant references on table "public"."meeting_participants" to "anon";

grant select on table "public"."meeting_participants" to "anon";

grant trigger on table "public"."meeting_participants" to "anon";

grant truncate on table "public"."meeting_participants" to "anon";

grant update on table "public"."meeting_participants" to "anon";

grant delete on table "public"."meeting_participants" to "authenticated";

grant insert on table "public"."meeting_participants" to "authenticated";

grant references on table "public"."meeting_participants" to "authenticated";

grant select on table "public"."meeting_participants" to "authenticated";

grant trigger on table "public"."meeting_participants" to "authenticated";

grant truncate on table "public"."meeting_participants" to "authenticated";

grant update on table "public"."meeting_participants" to "authenticated";

grant delete on table "public"."meeting_participants" to "service_role";

grant insert on table "public"."meeting_participants" to "service_role";

grant references on table "public"."meeting_participants" to "service_role";

grant select on table "public"."meeting_participants" to "service_role";

grant trigger on table "public"."meeting_participants" to "service_role";

grant truncate on table "public"."meeting_participants" to "service_role";

grant update on table "public"."meeting_participants" to "service_role";

grant delete on table "public"."meeting_rooms" to "anon";

grant insert on table "public"."meeting_rooms" to "anon";

grant references on table "public"."meeting_rooms" to "anon";

grant select on table "public"."meeting_rooms" to "anon";

grant trigger on table "public"."meeting_rooms" to "anon";

grant truncate on table "public"."meeting_rooms" to "anon";

grant update on table "public"."meeting_rooms" to "anon";

grant delete on table "public"."meeting_rooms" to "authenticated";

grant insert on table "public"."meeting_rooms" to "authenticated";

grant references on table "public"."meeting_rooms" to "authenticated";

grant select on table "public"."meeting_rooms" to "authenticated";

grant trigger on table "public"."meeting_rooms" to "authenticated";

grant truncate on table "public"."meeting_rooms" to "authenticated";

grant update on table "public"."meeting_rooms" to "authenticated";

grant delete on table "public"."meeting_rooms" to "service_role";

grant insert on table "public"."meeting_rooms" to "service_role";

grant references on table "public"."meeting_rooms" to "service_role";

grant select on table "public"."meeting_rooms" to "service_role";

grant trigger on table "public"."meeting_rooms" to "service_role";

grant truncate on table "public"."meeting_rooms" to "service_role";

grant update on table "public"."meeting_rooms" to "service_role";

grant delete on table "public"."meeting_sessions" to "anon";

grant insert on table "public"."meeting_sessions" to "anon";

grant references on table "public"."meeting_sessions" to "anon";

grant select on table "public"."meeting_sessions" to "anon";

grant trigger on table "public"."meeting_sessions" to "anon";

grant truncate on table "public"."meeting_sessions" to "anon";

grant update on table "public"."meeting_sessions" to "anon";

grant delete on table "public"."meeting_sessions" to "authenticated";

grant insert on table "public"."meeting_sessions" to "authenticated";

grant references on table "public"."meeting_sessions" to "authenticated";

grant select on table "public"."meeting_sessions" to "authenticated";

grant trigger on table "public"."meeting_sessions" to "authenticated";

grant truncate on table "public"."meeting_sessions" to "authenticated";

grant update on table "public"."meeting_sessions" to "authenticated";

grant delete on table "public"."meeting_sessions" to "service_role";

grant insert on table "public"."meeting_sessions" to "service_role";

grant references on table "public"."meeting_sessions" to "service_role";

grant select on table "public"."meeting_sessions" to "service_role";

grant trigger on table "public"."meeting_sessions" to "service_role";

grant truncate on table "public"."meeting_sessions" to "service_role";

grant update on table "public"."meeting_sessions" to "service_role";

grant delete on table "public"."meeting_shared_resources" to "anon";

grant insert on table "public"."meeting_shared_resources" to "anon";

grant references on table "public"."meeting_shared_resources" to "anon";

grant select on table "public"."meeting_shared_resources" to "anon";

grant trigger on table "public"."meeting_shared_resources" to "anon";

grant truncate on table "public"."meeting_shared_resources" to "anon";

grant update on table "public"."meeting_shared_resources" to "anon";

grant delete on table "public"."meeting_shared_resources" to "authenticated";

grant insert on table "public"."meeting_shared_resources" to "authenticated";

grant references on table "public"."meeting_shared_resources" to "authenticated";

grant select on table "public"."meeting_shared_resources" to "authenticated";

grant trigger on table "public"."meeting_shared_resources" to "authenticated";

grant truncate on table "public"."meeting_shared_resources" to "authenticated";

grant update on table "public"."meeting_shared_resources" to "authenticated";

grant delete on table "public"."meeting_shared_resources" to "service_role";

grant insert on table "public"."meeting_shared_resources" to "service_role";

grant references on table "public"."meeting_shared_resources" to "service_role";

grant select on table "public"."meeting_shared_resources" to "service_role";

grant trigger on table "public"."meeting_shared_resources" to "service_role";

grant truncate on table "public"."meeting_shared_resources" to "service_role";

grant update on table "public"."meeting_shared_resources" to "service_role";

grant delete on table "public"."member_events" to "anon";

grant insert on table "public"."member_events" to "anon";

grant references on table "public"."member_events" to "anon";

grant select on table "public"."member_events" to "anon";

grant trigger on table "public"."member_events" to "anon";

grant truncate on table "public"."member_events" to "anon";

grant update on table "public"."member_events" to "anon";

grant delete on table "public"."member_events" to "authenticated";

grant insert on table "public"."member_events" to "authenticated";

grant references on table "public"."member_events" to "authenticated";

grant select on table "public"."member_events" to "authenticated";

grant trigger on table "public"."member_events" to "authenticated";

grant truncate on table "public"."member_events" to "authenticated";

grant update on table "public"."member_events" to "authenticated";

grant delete on table "public"."member_events" to "service_role";

grant insert on table "public"."member_events" to "service_role";

grant references on table "public"."member_events" to "service_role";

grant select on table "public"."member_events" to "service_role";

grant trigger on table "public"."member_events" to "service_role";

grant truncate on table "public"."member_events" to "service_role";

grant update on table "public"."member_events" to "service_role";

grant delete on table "public"."member_fees" to "anon";

grant insert on table "public"."member_fees" to "anon";

grant references on table "public"."member_fees" to "anon";

grant select on table "public"."member_fees" to "anon";

grant trigger on table "public"."member_fees" to "anon";

grant truncate on table "public"."member_fees" to "anon";

grant update on table "public"."member_fees" to "anon";

grant delete on table "public"."member_fees" to "authenticated";

grant insert on table "public"."member_fees" to "authenticated";

grant references on table "public"."member_fees" to "authenticated";

grant select on table "public"."member_fees" to "authenticated";

grant trigger on table "public"."member_fees" to "authenticated";

grant truncate on table "public"."member_fees" to "authenticated";

grant update on table "public"."member_fees" to "authenticated";

grant delete on table "public"."member_fees" to "service_role";

grant insert on table "public"."member_fees" to "service_role";

grant references on table "public"."member_fees" to "service_role";

grant select on table "public"."member_fees" to "service_role";

grant trigger on table "public"."member_fees" to "service_role";

grant truncate on table "public"."member_fees" to "service_role";

grant update on table "public"."member_fees" to "service_role";

grant delete on table "public"."member_id_cards" to "anon";

grant insert on table "public"."member_id_cards" to "anon";

grant references on table "public"."member_id_cards" to "anon";

grant select on table "public"."member_id_cards" to "anon";

grant trigger on table "public"."member_id_cards" to "anon";

grant truncate on table "public"."member_id_cards" to "anon";

grant update on table "public"."member_id_cards" to "anon";

grant delete on table "public"."member_id_cards" to "authenticated";

grant insert on table "public"."member_id_cards" to "authenticated";

grant references on table "public"."member_id_cards" to "authenticated";

grant select on table "public"."member_id_cards" to "authenticated";

grant trigger on table "public"."member_id_cards" to "authenticated";

grant truncate on table "public"."member_id_cards" to "authenticated";

grant update on table "public"."member_id_cards" to "authenticated";

grant delete on table "public"."member_id_cards" to "service_role";

grant insert on table "public"."member_id_cards" to "service_role";

grant references on table "public"."member_id_cards" to "service_role";

grant select on table "public"."member_id_cards" to "service_role";

grant trigger on table "public"."member_id_cards" to "service_role";

grant truncate on table "public"."member_id_cards" to "service_role";

grant update on table "public"."member_id_cards" to "service_role";

grant delete on table "public"."member_invoices" to "anon";

grant insert on table "public"."member_invoices" to "anon";

grant references on table "public"."member_invoices" to "anon";

grant select on table "public"."member_invoices" to "anon";

grant trigger on table "public"."member_invoices" to "anon";

grant truncate on table "public"."member_invoices" to "anon";

grant update on table "public"."member_invoices" to "anon";

grant delete on table "public"."member_invoices" to "authenticated";

grant insert on table "public"."member_invoices" to "authenticated";

grant references on table "public"."member_invoices" to "authenticated";

grant select on table "public"."member_invoices" to "authenticated";

grant trigger on table "public"."member_invoices" to "authenticated";

grant truncate on table "public"."member_invoices" to "authenticated";

grant update on table "public"."member_invoices" to "authenticated";

grant delete on table "public"."member_invoices" to "service_role";

grant insert on table "public"."member_invoices" to "service_role";

grant references on table "public"."member_invoices" to "service_role";

grant select on table "public"."member_invoices" to "service_role";

grant trigger on table "public"."member_invoices" to "service_role";

grant truncate on table "public"."member_invoices" to "service_role";

grant update on table "public"."member_invoices" to "service_role";

grant delete on table "public"."membership_fee_structure" to "anon";

grant insert on table "public"."membership_fee_structure" to "anon";

grant references on table "public"."membership_fee_structure" to "anon";

grant select on table "public"."membership_fee_structure" to "anon";

grant trigger on table "public"."membership_fee_structure" to "anon";

grant truncate on table "public"."membership_fee_structure" to "anon";

grant update on table "public"."membership_fee_structure" to "anon";

grant delete on table "public"."membership_fee_structure" to "authenticated";

grant insert on table "public"."membership_fee_structure" to "authenticated";

grant references on table "public"."membership_fee_structure" to "authenticated";

grant select on table "public"."membership_fee_structure" to "authenticated";

grant trigger on table "public"."membership_fee_structure" to "authenticated";

grant truncate on table "public"."membership_fee_structure" to "authenticated";

grant update on table "public"."membership_fee_structure" to "authenticated";

grant delete on table "public"."membership_fee_structure" to "service_role";

grant insert on table "public"."membership_fee_structure" to "service_role";

grant references on table "public"."membership_fee_structure" to "service_role";

grant select on table "public"."membership_fee_structure" to "service_role";

grant trigger on table "public"."membership_fee_structure" to "service_role";

grant truncate on table "public"."membership_fee_structure" to "service_role";

grant update on table "public"."membership_fee_structure" to "service_role";

grant delete on table "public"."membership_pop_uploads" to "anon";

grant insert on table "public"."membership_pop_uploads" to "anon";

grant references on table "public"."membership_pop_uploads" to "anon";

grant select on table "public"."membership_pop_uploads" to "anon";

grant trigger on table "public"."membership_pop_uploads" to "anon";

grant truncate on table "public"."membership_pop_uploads" to "anon";

grant update on table "public"."membership_pop_uploads" to "anon";

grant delete on table "public"."membership_pop_uploads" to "authenticated";

grant insert on table "public"."membership_pop_uploads" to "authenticated";

grant references on table "public"."membership_pop_uploads" to "authenticated";

grant select on table "public"."membership_pop_uploads" to "authenticated";

grant trigger on table "public"."membership_pop_uploads" to "authenticated";

grant truncate on table "public"."membership_pop_uploads" to "authenticated";

grant update on table "public"."membership_pop_uploads" to "authenticated";

grant delete on table "public"."membership_pop_uploads" to "service_role";

grant insert on table "public"."membership_pop_uploads" to "service_role";

grant references on table "public"."membership_pop_uploads" to "service_role";

grant select on table "public"."membership_pop_uploads" to "service_role";

grant trigger on table "public"."membership_pop_uploads" to "service_role";

grant truncate on table "public"."membership_pop_uploads" to "service_role";

grant update on table "public"."membership_pop_uploads" to "service_role";

grant delete on table "public"."message_drafts" to "anon";

grant insert on table "public"."message_drafts" to "anon";

grant references on table "public"."message_drafts" to "anon";

grant select on table "public"."message_drafts" to "anon";

grant trigger on table "public"."message_drafts" to "anon";

grant truncate on table "public"."message_drafts" to "anon";

grant update on table "public"."message_drafts" to "anon";

grant delete on table "public"."message_drafts" to "authenticated";

grant insert on table "public"."message_drafts" to "authenticated";

grant references on table "public"."message_drafts" to "authenticated";

grant select on table "public"."message_drafts" to "authenticated";

grant trigger on table "public"."message_drafts" to "authenticated";

grant truncate on table "public"."message_drafts" to "authenticated";

grant update on table "public"."message_drafts" to "authenticated";

grant delete on table "public"."message_drafts" to "service_role";

grant insert on table "public"."message_drafts" to "service_role";

grant references on table "public"."message_drafts" to "service_role";

grant select on table "public"."message_drafts" to "service_role";

grant trigger on table "public"."message_drafts" to "service_role";

grant truncate on table "public"."message_drafts" to "service_role";

grant update on table "public"."message_drafts" to "service_role";

grant delete on table "public"."message_participants" to "anon";

grant insert on table "public"."message_participants" to "anon";

grant references on table "public"."message_participants" to "anon";

grant select on table "public"."message_participants" to "anon";

grant trigger on table "public"."message_participants" to "anon";

grant truncate on table "public"."message_participants" to "anon";

grant update on table "public"."message_participants" to "anon";

grant delete on table "public"."message_participants" to "authenticated";

grant insert on table "public"."message_participants" to "authenticated";

grant references on table "public"."message_participants" to "authenticated";

grant select on table "public"."message_participants" to "authenticated";

grant trigger on table "public"."message_participants" to "authenticated";

grant truncate on table "public"."message_participants" to "authenticated";

grant update on table "public"."message_participants" to "authenticated";

grant delete on table "public"."message_participants" to "service_role";

grant insert on table "public"."message_participants" to "service_role";

grant references on table "public"."message_participants" to "service_role";

grant select on table "public"."message_participants" to "service_role";

grant trigger on table "public"."message_participants" to "service_role";

grant truncate on table "public"."message_participants" to "service_role";

grant update on table "public"."message_participants" to "service_role";

grant delete on table "public"."message_reactions" to "anon";

grant insert on table "public"."message_reactions" to "anon";

grant references on table "public"."message_reactions" to "anon";

grant select on table "public"."message_reactions" to "anon";

grant trigger on table "public"."message_reactions" to "anon";

grant truncate on table "public"."message_reactions" to "anon";

grant update on table "public"."message_reactions" to "anon";

grant delete on table "public"."message_reactions" to "authenticated";

grant insert on table "public"."message_reactions" to "authenticated";

grant references on table "public"."message_reactions" to "authenticated";

grant select on table "public"."message_reactions" to "authenticated";

grant trigger on table "public"."message_reactions" to "authenticated";

grant truncate on table "public"."message_reactions" to "authenticated";

grant update on table "public"."message_reactions" to "authenticated";

grant delete on table "public"."message_reactions" to "service_role";

grant insert on table "public"."message_reactions" to "service_role";

grant references on table "public"."message_reactions" to "service_role";

grant select on table "public"."message_reactions" to "service_role";

grant trigger on table "public"."message_reactions" to "service_role";

grant truncate on table "public"."message_reactions" to "service_role";

grant update on table "public"."message_reactions" to "service_role";

grant delete on table "public"."message_recipients" to "anon";

grant insert on table "public"."message_recipients" to "anon";

grant references on table "public"."message_recipients" to "anon";

grant select on table "public"."message_recipients" to "anon";

grant trigger on table "public"."message_recipients" to "anon";

grant truncate on table "public"."message_recipients" to "anon";

grant update on table "public"."message_recipients" to "anon";

grant delete on table "public"."message_recipients" to "authenticated";

grant insert on table "public"."message_recipients" to "authenticated";

grant references on table "public"."message_recipients" to "authenticated";

grant select on table "public"."message_recipients" to "authenticated";

grant trigger on table "public"."message_recipients" to "authenticated";

grant truncate on table "public"."message_recipients" to "authenticated";

grant update on table "public"."message_recipients" to "authenticated";

grant delete on table "public"."message_recipients" to "service_role";

grant insert on table "public"."message_recipients" to "service_role";

grant references on table "public"."message_recipients" to "service_role";

grant select on table "public"."message_recipients" to "service_role";

grant trigger on table "public"."message_recipients" to "service_role";

grant truncate on table "public"."message_recipients" to "service_role";

grant update on table "public"."message_recipients" to "service_role";

grant delete on table "public"."message_threads" to "anon";

grant insert on table "public"."message_threads" to "anon";

grant references on table "public"."message_threads" to "anon";

grant select on table "public"."message_threads" to "anon";

grant trigger on table "public"."message_threads" to "anon";

grant truncate on table "public"."message_threads" to "anon";

grant update on table "public"."message_threads" to "anon";

grant delete on table "public"."message_threads" to "authenticated";

grant insert on table "public"."message_threads" to "authenticated";

grant references on table "public"."message_threads" to "authenticated";

grant select on table "public"."message_threads" to "authenticated";

grant trigger on table "public"."message_threads" to "authenticated";

grant truncate on table "public"."message_threads" to "authenticated";

grant update on table "public"."message_threads" to "authenticated";

grant delete on table "public"."message_threads" to "service_role";

grant insert on table "public"."message_threads" to "service_role";

grant references on table "public"."message_threads" to "service_role";

grant select on table "public"."message_threads" to "service_role";

grant trigger on table "public"."message_threads" to "service_role";

grant truncate on table "public"."message_threads" to "service_role";

grant update on table "public"."message_threads" to "service_role";

grant delete on table "public"."messages" to "anon";

grant insert on table "public"."messages" to "anon";

grant references on table "public"."messages" to "anon";

grant select on table "public"."messages" to "anon";

grant trigger on table "public"."messages" to "anon";

grant truncate on table "public"."messages" to "anon";

grant update on table "public"."messages" to "anon";

grant delete on table "public"."messages" to "authenticated";

grant insert on table "public"."messages" to "authenticated";

grant references on table "public"."messages" to "authenticated";

grant select on table "public"."messages" to "authenticated";

grant trigger on table "public"."messages" to "authenticated";

grant truncate on table "public"."messages" to "authenticated";

grant update on table "public"."messages" to "authenticated";

grant delete on table "public"."messages" to "service_role";

grant insert on table "public"."messages" to "service_role";

grant references on table "public"."messages" to "service_role";

grant select on table "public"."messages" to "service_role";

grant trigger on table "public"."messages" to "service_role";

grant truncate on table "public"."messages" to "service_role";

grant update on table "public"."messages" to "service_role";

grant delete on table "public"."migration_logs" to "anon";

grant insert on table "public"."migration_logs" to "anon";

grant references on table "public"."migration_logs" to "anon";

grant select on table "public"."migration_logs" to "anon";

grant trigger on table "public"."migration_logs" to "anon";

grant truncate on table "public"."migration_logs" to "anon";

grant update on table "public"."migration_logs" to "anon";

grant delete on table "public"."migration_logs" to "authenticated";

grant insert on table "public"."migration_logs" to "authenticated";

grant references on table "public"."migration_logs" to "authenticated";

grant select on table "public"."migration_logs" to "authenticated";

grant trigger on table "public"."migration_logs" to "authenticated";

grant truncate on table "public"."migration_logs" to "authenticated";

grant update on table "public"."migration_logs" to "authenticated";

grant delete on table "public"."migration_logs" to "service_role";

grant insert on table "public"."migration_logs" to "service_role";

grant references on table "public"."migration_logs" to "service_role";

grant select on table "public"."migration_logs" to "service_role";

grant trigger on table "public"."migration_logs" to "service_role";

grant truncate on table "public"."migration_logs" to "service_role";

grant update on table "public"."migration_logs" to "service_role";

grant delete on table "public"."moderation_actions" to "anon";

grant insert on table "public"."moderation_actions" to "anon";

grant references on table "public"."moderation_actions" to "anon";

grant select on table "public"."moderation_actions" to "anon";

grant trigger on table "public"."moderation_actions" to "anon";

grant truncate on table "public"."moderation_actions" to "anon";

grant update on table "public"."moderation_actions" to "anon";

grant delete on table "public"."moderation_actions" to "authenticated";

grant insert on table "public"."moderation_actions" to "authenticated";

grant references on table "public"."moderation_actions" to "authenticated";

grant select on table "public"."moderation_actions" to "authenticated";

grant trigger on table "public"."moderation_actions" to "authenticated";

grant truncate on table "public"."moderation_actions" to "authenticated";

grant update on table "public"."moderation_actions" to "authenticated";

grant delete on table "public"."moderation_actions" to "service_role";

grant insert on table "public"."moderation_actions" to "service_role";

grant references on table "public"."moderation_actions" to "service_role";

grant select on table "public"."moderation_actions" to "service_role";

grant trigger on table "public"."moderation_actions" to "service_role";

grant truncate on table "public"."moderation_actions" to "service_role";

grant update on table "public"."moderation_actions" to "service_role";

grant delete on table "public"."moderation_queue" to "anon";

grant insert on table "public"."moderation_queue" to "anon";

grant references on table "public"."moderation_queue" to "anon";

grant select on table "public"."moderation_queue" to "anon";

grant trigger on table "public"."moderation_queue" to "anon";

grant truncate on table "public"."moderation_queue" to "anon";

grant update on table "public"."moderation_queue" to "anon";

grant delete on table "public"."moderation_queue" to "authenticated";

grant insert on table "public"."moderation_queue" to "authenticated";

grant references on table "public"."moderation_queue" to "authenticated";

grant select on table "public"."moderation_queue" to "authenticated";

grant trigger on table "public"."moderation_queue" to "authenticated";

grant truncate on table "public"."moderation_queue" to "authenticated";

grant update on table "public"."moderation_queue" to "authenticated";

grant delete on table "public"."moderation_queue" to "service_role";

grant insert on table "public"."moderation_queue" to "service_role";

grant references on table "public"."moderation_queue" to "service_role";

grant select on table "public"."moderation_queue" to "service_role";

grant trigger on table "public"."moderation_queue" to "service_role";

grant truncate on table "public"."moderation_queue" to "service_role";

grant update on table "public"."moderation_queue" to "service_role";

grant delete on table "public"."newsletter_recipients" to "anon";

grant insert on table "public"."newsletter_recipients" to "anon";

grant references on table "public"."newsletter_recipients" to "anon";

grant select on table "public"."newsletter_recipients" to "anon";

grant trigger on table "public"."newsletter_recipients" to "anon";

grant truncate on table "public"."newsletter_recipients" to "anon";

grant update on table "public"."newsletter_recipients" to "anon";

grant delete on table "public"."newsletter_recipients" to "authenticated";

grant insert on table "public"."newsletter_recipients" to "authenticated";

grant references on table "public"."newsletter_recipients" to "authenticated";

grant select on table "public"."newsletter_recipients" to "authenticated";

grant trigger on table "public"."newsletter_recipients" to "authenticated";

grant truncate on table "public"."newsletter_recipients" to "authenticated";

grant update on table "public"."newsletter_recipients" to "authenticated";

grant delete on table "public"."newsletter_recipients" to "service_role";

grant insert on table "public"."newsletter_recipients" to "service_role";

grant references on table "public"."newsletter_recipients" to "service_role";

grant select on table "public"."newsletter_recipients" to "service_role";

grant trigger on table "public"."newsletter_recipients" to "service_role";

grant truncate on table "public"."newsletter_recipients" to "service_role";

grant update on table "public"."newsletter_recipients" to "service_role";

grant delete on table "public"."newsletters" to "anon";

grant insert on table "public"."newsletters" to "anon";

grant references on table "public"."newsletters" to "anon";

grant select on table "public"."newsletters" to "anon";

grant trigger on table "public"."newsletters" to "anon";

grant truncate on table "public"."newsletters" to "anon";

grant update on table "public"."newsletters" to "anon";

grant delete on table "public"."newsletters" to "authenticated";

grant insert on table "public"."newsletters" to "authenticated";

grant references on table "public"."newsletters" to "authenticated";

grant select on table "public"."newsletters" to "authenticated";

grant trigger on table "public"."newsletters" to "authenticated";

grant truncate on table "public"."newsletters" to "authenticated";

grant update on table "public"."newsletters" to "authenticated";

grant delete on table "public"."newsletters" to "service_role";

grant insert on table "public"."newsletters" to "service_role";

grant references on table "public"."newsletters" to "service_role";

grant select on table "public"."newsletters" to "service_role";

grant trigger on table "public"."newsletters" to "service_role";

grant truncate on table "public"."newsletters" to "service_role";

grant update on table "public"."newsletters" to "service_role";

grant delete on table "public"."notification_deliveries" to "anon";

grant insert on table "public"."notification_deliveries" to "anon";

grant references on table "public"."notification_deliveries" to "anon";

grant select on table "public"."notification_deliveries" to "anon";

grant trigger on table "public"."notification_deliveries" to "anon";

grant truncate on table "public"."notification_deliveries" to "anon";

grant update on table "public"."notification_deliveries" to "anon";

grant delete on table "public"."notification_deliveries" to "authenticated";

grant insert on table "public"."notification_deliveries" to "authenticated";

grant references on table "public"."notification_deliveries" to "authenticated";

grant select on table "public"."notification_deliveries" to "authenticated";

grant trigger on table "public"."notification_deliveries" to "authenticated";

grant truncate on table "public"."notification_deliveries" to "authenticated";

grant update on table "public"."notification_deliveries" to "authenticated";

grant delete on table "public"."notification_deliveries" to "service_role";

grant insert on table "public"."notification_deliveries" to "service_role";

grant references on table "public"."notification_deliveries" to "service_role";

grant select on table "public"."notification_deliveries" to "service_role";

grant trigger on table "public"."notification_deliveries" to "service_role";

grant truncate on table "public"."notification_deliveries" to "service_role";

grant update on table "public"."notification_deliveries" to "service_role";

grant delete on table "public"."notification_history" to "anon";

grant insert on table "public"."notification_history" to "anon";

grant references on table "public"."notification_history" to "anon";

grant select on table "public"."notification_history" to "anon";

grant trigger on table "public"."notification_history" to "anon";

grant truncate on table "public"."notification_history" to "anon";

grant update on table "public"."notification_history" to "anon";

grant delete on table "public"."notification_history" to "authenticated";

grant insert on table "public"."notification_history" to "authenticated";

grant references on table "public"."notification_history" to "authenticated";

grant select on table "public"."notification_history" to "authenticated";

grant trigger on table "public"."notification_history" to "authenticated";

grant truncate on table "public"."notification_history" to "authenticated";

grant update on table "public"."notification_history" to "authenticated";

grant delete on table "public"."notification_history" to "service_role";

grant insert on table "public"."notification_history" to "service_role";

grant references on table "public"."notification_history" to "service_role";

grant select on table "public"."notification_history" to "service_role";

grant trigger on table "public"."notification_history" to "service_role";

grant truncate on table "public"."notification_history" to "service_role";

grant update on table "public"."notification_history" to "service_role";

grant delete on table "public"."notification_logs" to "anon";

grant insert on table "public"."notification_logs" to "anon";

grant references on table "public"."notification_logs" to "anon";

grant select on table "public"."notification_logs" to "anon";

grant trigger on table "public"."notification_logs" to "anon";

grant truncate on table "public"."notification_logs" to "anon";

grant update on table "public"."notification_logs" to "anon";

grant delete on table "public"."notification_logs" to "authenticated";

grant insert on table "public"."notification_logs" to "authenticated";

grant references on table "public"."notification_logs" to "authenticated";

grant select on table "public"."notification_logs" to "authenticated";

grant trigger on table "public"."notification_logs" to "authenticated";

grant truncate on table "public"."notification_logs" to "authenticated";

grant update on table "public"."notification_logs" to "authenticated";

grant delete on table "public"."notification_logs" to "service_role";

grant insert on table "public"."notification_logs" to "service_role";

grant references on table "public"."notification_logs" to "service_role";

grant select on table "public"."notification_logs" to "service_role";

grant trigger on table "public"."notification_logs" to "service_role";

grant truncate on table "public"."notification_logs" to "service_role";

grant update on table "public"."notification_logs" to "service_role";

grant delete on table "public"."notification_templates" to "anon";

grant insert on table "public"."notification_templates" to "anon";

grant references on table "public"."notification_templates" to "anon";

grant select on table "public"."notification_templates" to "anon";

grant trigger on table "public"."notification_templates" to "anon";

grant truncate on table "public"."notification_templates" to "anon";

grant update on table "public"."notification_templates" to "anon";

grant delete on table "public"."notification_templates" to "authenticated";

grant insert on table "public"."notification_templates" to "authenticated";

grant references on table "public"."notification_templates" to "authenticated";

grant select on table "public"."notification_templates" to "authenticated";

grant trigger on table "public"."notification_templates" to "authenticated";

grant truncate on table "public"."notification_templates" to "authenticated";

grant update on table "public"."notification_templates" to "authenticated";

grant delete on table "public"."notification_templates" to "service_role";

grant insert on table "public"."notification_templates" to "service_role";

grant references on table "public"."notification_templates" to "service_role";

grant select on table "public"."notification_templates" to "service_role";

grant trigger on table "public"."notification_templates" to "service_role";

grant truncate on table "public"."notification_templates" to "service_role";

grant update on table "public"."notification_templates" to "service_role";

grant delete on table "public"."oauth_tokens" to "anon";

grant insert on table "public"."oauth_tokens" to "anon";

grant references on table "public"."oauth_tokens" to "anon";

grant select on table "public"."oauth_tokens" to "anon";

grant trigger on table "public"."oauth_tokens" to "anon";

grant truncate on table "public"."oauth_tokens" to "anon";

grant update on table "public"."oauth_tokens" to "anon";

grant delete on table "public"."oauth_tokens" to "authenticated";

grant insert on table "public"."oauth_tokens" to "authenticated";

grant references on table "public"."oauth_tokens" to "authenticated";

grant select on table "public"."oauth_tokens" to "authenticated";

grant trigger on table "public"."oauth_tokens" to "authenticated";

grant truncate on table "public"."oauth_tokens" to "authenticated";

grant update on table "public"."oauth_tokens" to "authenticated";

grant delete on table "public"."oauth_tokens" to "service_role";

grant insert on table "public"."oauth_tokens" to "service_role";

grant references on table "public"."oauth_tokens" to "service_role";

grant select on table "public"."oauth_tokens" to "service_role";

grant trigger on table "public"."oauth_tokens" to "service_role";

grant truncate on table "public"."oauth_tokens" to "service_role";

grant update on table "public"."oauth_tokens" to "service_role";

grant delete on table "public"."offer_letters" to "anon";

grant insert on table "public"."offer_letters" to "anon";

grant references on table "public"."offer_letters" to "anon";

grant select on table "public"."offer_letters" to "anon";

grant trigger on table "public"."offer_letters" to "anon";

grant truncate on table "public"."offer_letters" to "anon";

grant update on table "public"."offer_letters" to "anon";

grant delete on table "public"."offer_letters" to "authenticated";

grant insert on table "public"."offer_letters" to "authenticated";

grant references on table "public"."offer_letters" to "authenticated";

grant select on table "public"."offer_letters" to "authenticated";

grant trigger on table "public"."offer_letters" to "authenticated";

grant truncate on table "public"."offer_letters" to "authenticated";

grant update on table "public"."offer_letters" to "authenticated";

grant delete on table "public"."offer_letters" to "service_role";

grant insert on table "public"."offer_letters" to "service_role";

grant references on table "public"."offer_letters" to "service_role";

grant select on table "public"."offer_letters" to "service_role";

grant trigger on table "public"."offer_letters" to "service_role";

grant truncate on table "public"."offer_letters" to "service_role";

grant update on table "public"."offer_letters" to "service_role";

grant delete on table "public"."onboarding_progress" to "anon";

grant insert on table "public"."onboarding_progress" to "anon";

grant references on table "public"."onboarding_progress" to "anon";

grant select on table "public"."onboarding_progress" to "anon";

grant trigger on table "public"."onboarding_progress" to "anon";

grant truncate on table "public"."onboarding_progress" to "anon";

grant update on table "public"."onboarding_progress" to "anon";

grant delete on table "public"."onboarding_progress" to "authenticated";

grant insert on table "public"."onboarding_progress" to "authenticated";

grant references on table "public"."onboarding_progress" to "authenticated";

grant select on table "public"."onboarding_progress" to "authenticated";

grant trigger on table "public"."onboarding_progress" to "authenticated";

grant truncate on table "public"."onboarding_progress" to "authenticated";

grant update on table "public"."onboarding_progress" to "authenticated";

grant delete on table "public"."onboarding_progress" to "service_role";

grant insert on table "public"."onboarding_progress" to "service_role";

grant references on table "public"."onboarding_progress" to "service_role";

grant select on table "public"."onboarding_progress" to "service_role";

grant trigger on table "public"."onboarding_progress" to "service_role";

grant truncate on table "public"."onboarding_progress" to "service_role";

grant update on table "public"."onboarding_progress" to "service_role";

grant delete on table "public"."onboarding_requests" to "anon";

grant insert on table "public"."onboarding_requests" to "anon";

grant references on table "public"."onboarding_requests" to "anon";

grant select on table "public"."onboarding_requests" to "anon";

grant trigger on table "public"."onboarding_requests" to "anon";

grant truncate on table "public"."onboarding_requests" to "anon";

grant update on table "public"."onboarding_requests" to "anon";

grant delete on table "public"."onboarding_requests" to "authenticated";

grant insert on table "public"."onboarding_requests" to "authenticated";

grant references on table "public"."onboarding_requests" to "authenticated";

grant select on table "public"."onboarding_requests" to "authenticated";

grant trigger on table "public"."onboarding_requests" to "authenticated";

grant truncate on table "public"."onboarding_requests" to "authenticated";

grant update on table "public"."onboarding_requests" to "authenticated";

grant delete on table "public"."onboarding_requests" to "service_role";

grant insert on table "public"."onboarding_requests" to "service_role";

grant references on table "public"."onboarding_requests" to "service_role";

grant select on table "public"."onboarding_requests" to "service_role";

grant trigger on table "public"."onboarding_requests" to "service_role";

grant truncate on table "public"."onboarding_requests" to "service_role";

grant update on table "public"."onboarding_requests" to "service_role";

grant delete on table "public"."org_dashboard_features" to "anon";

grant insert on table "public"."org_dashboard_features" to "anon";

grant references on table "public"."org_dashboard_features" to "anon";

grant select on table "public"."org_dashboard_features" to "anon";

grant trigger on table "public"."org_dashboard_features" to "anon";

grant truncate on table "public"."org_dashboard_features" to "anon";

grant update on table "public"."org_dashboard_features" to "anon";

grant delete on table "public"."org_dashboard_features" to "authenticated";

grant insert on table "public"."org_dashboard_features" to "authenticated";

grant references on table "public"."org_dashboard_features" to "authenticated";

grant select on table "public"."org_dashboard_features" to "authenticated";

grant trigger on table "public"."org_dashboard_features" to "authenticated";

grant truncate on table "public"."org_dashboard_features" to "authenticated";

grant update on table "public"."org_dashboard_features" to "authenticated";

grant delete on table "public"."org_dashboard_features" to "service_role";

grant insert on table "public"."org_dashboard_features" to "service_role";

grant references on table "public"."org_dashboard_features" to "service_role";

grant select on table "public"."org_dashboard_features" to "service_role";

grant trigger on table "public"."org_dashboard_features" to "service_role";

grant truncate on table "public"."org_dashboard_features" to "service_role";

grant update on table "public"."org_dashboard_features" to "service_role";

grant delete on table "public"."org_invites" to "anon";

grant insert on table "public"."org_invites" to "anon";

grant references on table "public"."org_invites" to "anon";

grant select on table "public"."org_invites" to "anon";

grant trigger on table "public"."org_invites" to "anon";

grant truncate on table "public"."org_invites" to "anon";

grant update on table "public"."org_invites" to "anon";

grant delete on table "public"."org_invites" to "authenticated";

grant insert on table "public"."org_invites" to "authenticated";

grant references on table "public"."org_invites" to "authenticated";

grant select on table "public"."org_invites" to "authenticated";

grant trigger on table "public"."org_invites" to "authenticated";

grant truncate on table "public"."org_invites" to "authenticated";

grant update on table "public"."org_invites" to "authenticated";

grant delete on table "public"."org_invites" to "service_role";

grant insert on table "public"."org_invites" to "service_role";

grant references on table "public"."org_invites" to "service_role";

grant select on table "public"."org_invites" to "service_role";

grant trigger on table "public"."org_invites" to "service_role";

grant truncate on table "public"."org_invites" to "service_role";

grant update on table "public"."org_invites" to "service_role";

grant delete on table "public"."organization_announcement_recipients" to "anon";

grant insert on table "public"."organization_announcement_recipients" to "anon";

grant references on table "public"."organization_announcement_recipients" to "anon";

grant select on table "public"."organization_announcement_recipients" to "anon";

grant trigger on table "public"."organization_announcement_recipients" to "anon";

grant truncate on table "public"."organization_announcement_recipients" to "anon";

grant update on table "public"."organization_announcement_recipients" to "anon";

grant delete on table "public"."organization_announcement_recipients" to "authenticated";

grant insert on table "public"."organization_announcement_recipients" to "authenticated";

grant references on table "public"."organization_announcement_recipients" to "authenticated";

grant select on table "public"."organization_announcement_recipients" to "authenticated";

grant trigger on table "public"."organization_announcement_recipients" to "authenticated";

grant truncate on table "public"."organization_announcement_recipients" to "authenticated";

grant update on table "public"."organization_announcement_recipients" to "authenticated";

grant delete on table "public"."organization_announcement_recipients" to "service_role";

grant insert on table "public"."organization_announcement_recipients" to "service_role";

grant references on table "public"."organization_announcement_recipients" to "service_role";

grant select on table "public"."organization_announcement_recipients" to "service_role";

grant trigger on table "public"."organization_announcement_recipients" to "service_role";

grant truncate on table "public"."organization_announcement_recipients" to "service_role";

grant update on table "public"."organization_announcement_recipients" to "service_role";

grant delete on table "public"."organization_announcements" to "anon";

grant insert on table "public"."organization_announcements" to "anon";

grant references on table "public"."organization_announcements" to "anon";

grant select on table "public"."organization_announcements" to "anon";

grant trigger on table "public"."organization_announcements" to "anon";

grant truncate on table "public"."organization_announcements" to "anon";

grant update on table "public"."organization_announcements" to "anon";

grant delete on table "public"."organization_announcements" to "authenticated";

grant insert on table "public"."organization_announcements" to "authenticated";

grant references on table "public"."organization_announcements" to "authenticated";

grant select on table "public"."organization_announcements" to "authenticated";

grant trigger on table "public"."organization_announcements" to "authenticated";

grant truncate on table "public"."organization_announcements" to "authenticated";

grant update on table "public"."organization_announcements" to "authenticated";

grant delete on table "public"."organization_announcements" to "service_role";

grant insert on table "public"."organization_announcements" to "service_role";

grant references on table "public"."organization_announcements" to "service_role";

grant select on table "public"."organization_announcements" to "service_role";

grant trigger on table "public"."organization_announcements" to "service_role";

grant truncate on table "public"."organization_announcements" to "service_role";

grant update on table "public"."organization_announcements" to "service_role";

grant delete on table "public"."organization_bank_accounts" to "anon";

grant insert on table "public"."organization_bank_accounts" to "anon";

grant references on table "public"."organization_bank_accounts" to "anon";

grant select on table "public"."organization_bank_accounts" to "anon";

grant trigger on table "public"."organization_bank_accounts" to "anon";

grant truncate on table "public"."organization_bank_accounts" to "anon";

grant update on table "public"."organization_bank_accounts" to "anon";

grant delete on table "public"."organization_bank_accounts" to "authenticated";

grant insert on table "public"."organization_bank_accounts" to "authenticated";

grant references on table "public"."organization_bank_accounts" to "authenticated";

grant select on table "public"."organization_bank_accounts" to "authenticated";

grant trigger on table "public"."organization_bank_accounts" to "authenticated";

grant truncate on table "public"."organization_bank_accounts" to "authenticated";

grant update on table "public"."organization_bank_accounts" to "authenticated";

grant delete on table "public"."organization_bank_accounts" to "service_role";

grant insert on table "public"."organization_bank_accounts" to "service_role";

grant references on table "public"."organization_bank_accounts" to "service_role";

grant select on table "public"."organization_bank_accounts" to "service_role";

grant trigger on table "public"."organization_bank_accounts" to "service_role";

grant truncate on table "public"."organization_bank_accounts" to "service_role";

grant update on table "public"."organization_bank_accounts" to "service_role";

grant delete on table "public"."organization_board_positions" to "anon";

grant insert on table "public"."organization_board_positions" to "anon";

grant references on table "public"."organization_board_positions" to "anon";

grant select on table "public"."organization_board_positions" to "anon";

grant trigger on table "public"."organization_board_positions" to "anon";

grant truncate on table "public"."organization_board_positions" to "anon";

grant update on table "public"."organization_board_positions" to "anon";

grant delete on table "public"."organization_board_positions" to "authenticated";

grant insert on table "public"."organization_board_positions" to "authenticated";

grant references on table "public"."organization_board_positions" to "authenticated";

grant select on table "public"."organization_board_positions" to "authenticated";

grant trigger on table "public"."organization_board_positions" to "authenticated";

grant truncate on table "public"."organization_board_positions" to "authenticated";

grant update on table "public"."organization_board_positions" to "authenticated";

grant delete on table "public"."organization_board_positions" to "service_role";

grant insert on table "public"."organization_board_positions" to "service_role";

grant references on table "public"."organization_board_positions" to "service_role";

grant select on table "public"."organization_board_positions" to "service_role";

grant trigger on table "public"."organization_board_positions" to "service_role";

grant truncate on table "public"."organization_board_positions" to "service_role";

grant update on table "public"."organization_board_positions" to "service_role";

grant delete on table "public"."organization_budgets" to "anon";

grant insert on table "public"."organization_budgets" to "anon";

grant references on table "public"."organization_budgets" to "anon";

grant select on table "public"."organization_budgets" to "anon";

grant trigger on table "public"."organization_budgets" to "anon";

grant truncate on table "public"."organization_budgets" to "anon";

grant update on table "public"."organization_budgets" to "anon";

grant delete on table "public"."organization_budgets" to "authenticated";

grant insert on table "public"."organization_budgets" to "authenticated";

grant references on table "public"."organization_budgets" to "authenticated";

grant select on table "public"."organization_budgets" to "authenticated";

grant trigger on table "public"."organization_budgets" to "authenticated";

grant truncate on table "public"."organization_budgets" to "authenticated";

grant update on table "public"."organization_budgets" to "authenticated";

grant delete on table "public"."organization_budgets" to "service_role";

grant insert on table "public"."organization_budgets" to "service_role";

grant references on table "public"."organization_budgets" to "service_role";

grant select on table "public"."organization_budgets" to "service_role";

grant trigger on table "public"."organization_budgets" to "service_role";

grant truncate on table "public"."organization_budgets" to "service_role";

grant update on table "public"."organization_budgets" to "service_role";

grant delete on table "public"."organization_document_access" to "anon";

grant insert on table "public"."organization_document_access" to "anon";

grant references on table "public"."organization_document_access" to "anon";

grant select on table "public"."organization_document_access" to "anon";

grant trigger on table "public"."organization_document_access" to "anon";

grant truncate on table "public"."organization_document_access" to "anon";

grant update on table "public"."organization_document_access" to "anon";

grant delete on table "public"."organization_document_access" to "authenticated";

grant insert on table "public"."organization_document_access" to "authenticated";

grant references on table "public"."organization_document_access" to "authenticated";

grant select on table "public"."organization_document_access" to "authenticated";

grant trigger on table "public"."organization_document_access" to "authenticated";

grant truncate on table "public"."organization_document_access" to "authenticated";

grant update on table "public"."organization_document_access" to "authenticated";

grant delete on table "public"."organization_document_access" to "service_role";

grant insert on table "public"."organization_document_access" to "service_role";

grant references on table "public"."organization_document_access" to "service_role";

grant select on table "public"."organization_document_access" to "service_role";

grant trigger on table "public"."organization_document_access" to "service_role";

grant truncate on table "public"."organization_document_access" to "service_role";

grant update on table "public"."organization_document_access" to "service_role";

grant delete on table "public"."organization_document_access_requests" to "anon";

grant insert on table "public"."organization_document_access_requests" to "anon";

grant references on table "public"."organization_document_access_requests" to "anon";

grant select on table "public"."organization_document_access_requests" to "anon";

grant trigger on table "public"."organization_document_access_requests" to "anon";

grant truncate on table "public"."organization_document_access_requests" to "anon";

grant update on table "public"."organization_document_access_requests" to "anon";

grant delete on table "public"."organization_document_access_requests" to "authenticated";

grant insert on table "public"."organization_document_access_requests" to "authenticated";

grant references on table "public"."organization_document_access_requests" to "authenticated";

grant select on table "public"."organization_document_access_requests" to "authenticated";

grant trigger on table "public"."organization_document_access_requests" to "authenticated";

grant truncate on table "public"."organization_document_access_requests" to "authenticated";

grant update on table "public"."organization_document_access_requests" to "authenticated";

grant delete on table "public"."organization_document_access_requests" to "service_role";

grant insert on table "public"."organization_document_access_requests" to "service_role";

grant references on table "public"."organization_document_access_requests" to "service_role";

grant select on table "public"."organization_document_access_requests" to "service_role";

grant trigger on table "public"."organization_document_access_requests" to "service_role";

grant truncate on table "public"."organization_document_access_requests" to "service_role";

grant update on table "public"."organization_document_access_requests" to "service_role";

grant delete on table "public"."organization_document_audit_log" to "anon";

grant insert on table "public"."organization_document_audit_log" to "anon";

grant references on table "public"."organization_document_audit_log" to "anon";

grant select on table "public"."organization_document_audit_log" to "anon";

grant trigger on table "public"."organization_document_audit_log" to "anon";

grant truncate on table "public"."organization_document_audit_log" to "anon";

grant update on table "public"."organization_document_audit_log" to "anon";

grant delete on table "public"."organization_document_audit_log" to "authenticated";

grant insert on table "public"."organization_document_audit_log" to "authenticated";

grant references on table "public"."organization_document_audit_log" to "authenticated";

grant select on table "public"."organization_document_audit_log" to "authenticated";

grant trigger on table "public"."organization_document_audit_log" to "authenticated";

grant truncate on table "public"."organization_document_audit_log" to "authenticated";

grant update on table "public"."organization_document_audit_log" to "authenticated";

grant delete on table "public"."organization_document_audit_log" to "service_role";

grant insert on table "public"."organization_document_audit_log" to "service_role";

grant references on table "public"."organization_document_audit_log" to "service_role";

grant select on table "public"."organization_document_audit_log" to "service_role";

grant trigger on table "public"."organization_document_audit_log" to "service_role";

grant truncate on table "public"."organization_document_audit_log" to "service_role";

grant update on table "public"."organization_document_audit_log" to "service_role";

grant delete on table "public"."organization_payment_methods" to "anon";

grant insert on table "public"."organization_payment_methods" to "anon";

grant references on table "public"."organization_payment_methods" to "anon";

grant select on table "public"."organization_payment_methods" to "anon";

grant trigger on table "public"."organization_payment_methods" to "anon";

grant truncate on table "public"."organization_payment_methods" to "anon";

grant update on table "public"."organization_payment_methods" to "anon";

grant delete on table "public"."organization_payment_methods" to "authenticated";

grant insert on table "public"."organization_payment_methods" to "authenticated";

grant references on table "public"."organization_payment_methods" to "authenticated";

grant select on table "public"."organization_payment_methods" to "authenticated";

grant trigger on table "public"."organization_payment_methods" to "authenticated";

grant truncate on table "public"."organization_payment_methods" to "authenticated";

grant update on table "public"."organization_payment_methods" to "authenticated";

grant delete on table "public"."organization_payment_methods" to "service_role";

grant insert on table "public"."organization_payment_methods" to "service_role";

grant references on table "public"."organization_payment_methods" to "service_role";

grant select on table "public"."organization_payment_methods" to "service_role";

grant trigger on table "public"."organization_payment_methods" to "service_role";

grant truncate on table "public"."organization_payment_methods" to "service_role";

grant update on table "public"."organization_payment_methods" to "service_role";

grant delete on table "public"."organization_petty_cash" to "anon";

grant insert on table "public"."organization_petty_cash" to "anon";

grant references on table "public"."organization_petty_cash" to "anon";

grant select on table "public"."organization_petty_cash" to "anon";

grant trigger on table "public"."organization_petty_cash" to "anon";

grant truncate on table "public"."organization_petty_cash" to "anon";

grant update on table "public"."organization_petty_cash" to "anon";

grant delete on table "public"."organization_petty_cash" to "authenticated";

grant insert on table "public"."organization_petty_cash" to "authenticated";

grant references on table "public"."organization_petty_cash" to "authenticated";

grant select on table "public"."organization_petty_cash" to "authenticated";

grant trigger on table "public"."organization_petty_cash" to "authenticated";

grant truncate on table "public"."organization_petty_cash" to "authenticated";

grant update on table "public"."organization_petty_cash" to "authenticated";

grant delete on table "public"."organization_petty_cash" to "service_role";

grant insert on table "public"."organization_petty_cash" to "service_role";

grant references on table "public"."organization_petty_cash" to "service_role";

grant select on table "public"."organization_petty_cash" to "service_role";

grant trigger on table "public"."organization_petty_cash" to "service_role";

grant truncate on table "public"."organization_petty_cash" to "service_role";

grant update on table "public"."organization_petty_cash" to "service_role";

grant delete on table "public"."organization_roles" to "anon";

grant insert on table "public"."organization_roles" to "anon";

grant references on table "public"."organization_roles" to "anon";

grant select on table "public"."organization_roles" to "anon";

grant trigger on table "public"."organization_roles" to "anon";

grant truncate on table "public"."organization_roles" to "anon";

grant update on table "public"."organization_roles" to "anon";

grant delete on table "public"."organization_roles" to "authenticated";

grant insert on table "public"."organization_roles" to "authenticated";

grant references on table "public"."organization_roles" to "authenticated";

grant select on table "public"."organization_roles" to "authenticated";

grant trigger on table "public"."organization_roles" to "authenticated";

grant truncate on table "public"."organization_roles" to "authenticated";

grant update on table "public"."organization_roles" to "authenticated";

grant delete on table "public"."organization_roles" to "service_role";

grant insert on table "public"."organization_roles" to "service_role";

grant references on table "public"."organization_roles" to "service_role";

grant select on table "public"."organization_roles" to "service_role";

grant trigger on table "public"."organization_roles" to "service_role";

grant truncate on table "public"."organization_roles" to "service_role";

grant update on table "public"."organization_roles" to "service_role";

grant delete on table "public"."organization_transactions" to "anon";

grant insert on table "public"."organization_transactions" to "anon";

grant references on table "public"."organization_transactions" to "anon";

grant select on table "public"."organization_transactions" to "anon";

grant trigger on table "public"."organization_transactions" to "anon";

grant truncate on table "public"."organization_transactions" to "anon";

grant update on table "public"."organization_transactions" to "anon";

grant delete on table "public"."organization_transactions" to "authenticated";

grant insert on table "public"."organization_transactions" to "authenticated";

grant references on table "public"."organization_transactions" to "authenticated";

grant select on table "public"."organization_transactions" to "authenticated";

grant trigger on table "public"."organization_transactions" to "authenticated";

grant truncate on table "public"."organization_transactions" to "authenticated";

grant update on table "public"."organization_transactions" to "authenticated";

grant delete on table "public"."organization_transactions" to "service_role";

grant insert on table "public"."organization_transactions" to "service_role";

grant references on table "public"."organization_transactions" to "service_role";

grant select on table "public"."organization_transactions" to "service_role";

grant trigger on table "public"."organization_transactions" to "service_role";

grant truncate on table "public"."organization_transactions" to "service_role";

grant update on table "public"."organization_transactions" to "service_role";

grant delete on table "public"."organization_wings" to "anon";

grant insert on table "public"."organization_wings" to "anon";

grant references on table "public"."organization_wings" to "anon";

grant select on table "public"."organization_wings" to "anon";

grant trigger on table "public"."organization_wings" to "anon";

grant truncate on table "public"."organization_wings" to "anon";

grant update on table "public"."organization_wings" to "anon";

grant delete on table "public"."organization_wings" to "authenticated";

grant insert on table "public"."organization_wings" to "authenticated";

grant references on table "public"."organization_wings" to "authenticated";

grant select on table "public"."organization_wings" to "authenticated";

grant trigger on table "public"."organization_wings" to "authenticated";

grant truncate on table "public"."organization_wings" to "authenticated";

grant update on table "public"."organization_wings" to "authenticated";

grant delete on table "public"."organization_wings" to "service_role";

grant insert on table "public"."organization_wings" to "service_role";

grant references on table "public"."organization_wings" to "service_role";

grant select on table "public"."organization_wings" to "service_role";

grant trigger on table "public"."organization_wings" to "service_role";

grant truncate on table "public"."organization_wings" to "service_role";

grant update on table "public"."organization_wings" to "service_role";

grant delete on table "public"."overage_billing_records" to "anon";

grant insert on table "public"."overage_billing_records" to "anon";

grant references on table "public"."overage_billing_records" to "anon";

grant select on table "public"."overage_billing_records" to "anon";

grant trigger on table "public"."overage_billing_records" to "anon";

grant truncate on table "public"."overage_billing_records" to "anon";

grant update on table "public"."overage_billing_records" to "anon";

grant delete on table "public"."overage_billing_records" to "authenticated";

grant insert on table "public"."overage_billing_records" to "authenticated";

grant references on table "public"."overage_billing_records" to "authenticated";

grant select on table "public"."overage_billing_records" to "authenticated";

grant trigger on table "public"."overage_billing_records" to "authenticated";

grant truncate on table "public"."overage_billing_records" to "authenticated";

grant update on table "public"."overage_billing_records" to "authenticated";

grant delete on table "public"."overage_billing_records" to "service_role";

grant insert on table "public"."overage_billing_records" to "service_role";

grant references on table "public"."overage_billing_records" to "service_role";

grant select on table "public"."overage_billing_records" to "service_role";

grant trigger on table "public"."overage_billing_records" to "service_role";

grant truncate on table "public"."overage_billing_records" to "service_role";

grant update on table "public"."overage_billing_records" to "service_role";

grant delete on table "public"."overage_notifications" to "anon";

grant insert on table "public"."overage_notifications" to "anon";

grant references on table "public"."overage_notifications" to "anon";

grant select on table "public"."overage_notifications" to "anon";

grant trigger on table "public"."overage_notifications" to "anon";

grant truncate on table "public"."overage_notifications" to "anon";

grant update on table "public"."overage_notifications" to "anon";

grant delete on table "public"."overage_notifications" to "authenticated";

grant insert on table "public"."overage_notifications" to "authenticated";

grant references on table "public"."overage_notifications" to "authenticated";

grant select on table "public"."overage_notifications" to "authenticated";

grant trigger on table "public"."overage_notifications" to "authenticated";

grant truncate on table "public"."overage_notifications" to "authenticated";

grant update on table "public"."overage_notifications" to "authenticated";

grant delete on table "public"."overage_notifications" to "service_role";

grant insert on table "public"."overage_notifications" to "service_role";

grant references on table "public"."overage_notifications" to "service_role";

grant select on table "public"."overage_notifications" to "service_role";

grant trigger on table "public"."overage_notifications" to "service_role";

grant truncate on table "public"."overage_notifications" to "service_role";

grant update on table "public"."overage_notifications" to "service_role";

grant delete on table "public"."parent_access_codes" to "anon";

grant insert on table "public"."parent_access_codes" to "anon";

grant references on table "public"."parent_access_codes" to "anon";

grant select on table "public"."parent_access_codes" to "anon";

grant trigger on table "public"."parent_access_codes" to "anon";

grant truncate on table "public"."parent_access_codes" to "anon";

grant update on table "public"."parent_access_codes" to "anon";

grant delete on table "public"."parent_access_codes" to "authenticated";

grant insert on table "public"."parent_access_codes" to "authenticated";

grant references on table "public"."parent_access_codes" to "authenticated";

grant select on table "public"."parent_access_codes" to "authenticated";

grant trigger on table "public"."parent_access_codes" to "authenticated";

grant truncate on table "public"."parent_access_codes" to "authenticated";

grant update on table "public"."parent_access_codes" to "authenticated";

grant delete on table "public"."parent_access_codes" to "service_role";

grant insert on table "public"."parent_access_codes" to "service_role";

grant references on table "public"."parent_access_codes" to "service_role";

grant select on table "public"."parent_access_codes" to "service_role";

grant trigger on table "public"."parent_access_codes" to "service_role";

grant truncate on table "public"."parent_access_codes" to "service_role";

grant update on table "public"."parent_access_codes" to "service_role";

grant delete on table "public"."parent_child_links" to "anon";

grant insert on table "public"."parent_child_links" to "anon";

grant references on table "public"."parent_child_links" to "anon";

grant select on table "public"."parent_child_links" to "anon";

grant trigger on table "public"."parent_child_links" to "anon";

grant truncate on table "public"."parent_child_links" to "anon";

grant update on table "public"."parent_child_links" to "anon";

grant delete on table "public"."parent_child_links" to "authenticated";

grant insert on table "public"."parent_child_links" to "authenticated";

grant references on table "public"."parent_child_links" to "authenticated";

grant select on table "public"."parent_child_links" to "authenticated";

grant trigger on table "public"."parent_child_links" to "authenticated";

grant truncate on table "public"."parent_child_links" to "authenticated";

grant update on table "public"."parent_child_links" to "authenticated";

grant delete on table "public"."parent_child_links" to "service_role";

grant insert on table "public"."parent_child_links" to "service_role";

grant references on table "public"."parent_child_links" to "service_role";

grant select on table "public"."parent_child_links" to "service_role";

grant trigger on table "public"."parent_child_links" to "service_role";

grant truncate on table "public"."parent_child_links" to "service_role";

grant update on table "public"."parent_child_links" to "service_role";

grant delete on table "public"."parent_join_requests" to "anon";

grant insert on table "public"."parent_join_requests" to "anon";

grant references on table "public"."parent_join_requests" to "anon";

grant select on table "public"."parent_join_requests" to "anon";

grant trigger on table "public"."parent_join_requests" to "anon";

grant truncate on table "public"."parent_join_requests" to "anon";

grant update on table "public"."parent_join_requests" to "anon";

grant delete on table "public"."parent_join_requests" to "authenticated";

grant insert on table "public"."parent_join_requests" to "authenticated";

grant references on table "public"."parent_join_requests" to "authenticated";

grant select on table "public"."parent_join_requests" to "authenticated";

grant trigger on table "public"."parent_join_requests" to "authenticated";

grant truncate on table "public"."parent_join_requests" to "authenticated";

grant update on table "public"."parent_join_requests" to "authenticated";

grant delete on table "public"."parent_join_requests" to "service_role";

grant insert on table "public"."parent_join_requests" to "service_role";

grant references on table "public"."parent_join_requests" to "service_role";

grant select on table "public"."parent_join_requests" to "service_role";

grant trigger on table "public"."parent_join_requests" to "service_role";

grant truncate on table "public"."parent_join_requests" to "service_role";

grant update on table "public"."parent_join_requests" to "service_role";

grant delete on table "public"."parent_payments" to "anon";

grant insert on table "public"."parent_payments" to "anon";

grant references on table "public"."parent_payments" to "anon";

grant select on table "public"."parent_payments" to "anon";

grant trigger on table "public"."parent_payments" to "anon";

grant truncate on table "public"."parent_payments" to "anon";

grant update on table "public"."parent_payments" to "anon";

grant delete on table "public"."parent_payments" to "authenticated";

grant insert on table "public"."parent_payments" to "authenticated";

grant references on table "public"."parent_payments" to "authenticated";

grant select on table "public"."parent_payments" to "authenticated";

grant trigger on table "public"."parent_payments" to "authenticated";

grant truncate on table "public"."parent_payments" to "authenticated";

grant update on table "public"."parent_payments" to "authenticated";

grant delete on table "public"."parent_payments" to "service_role";

grant insert on table "public"."parent_payments" to "service_role";

grant references on table "public"."parent_payments" to "service_role";

grant select on table "public"."parent_payments" to "service_role";

grant trigger on table "public"."parent_payments" to "service_role";

grant truncate on table "public"."parent_payments" to "service_role";

grant update on table "public"."parent_payments" to "service_role";

grant delete on table "public"."past_papers" to "anon";

grant insert on table "public"."past_papers" to "anon";

grant references on table "public"."past_papers" to "anon";

grant select on table "public"."past_papers" to "anon";

grant trigger on table "public"."past_papers" to "anon";

grant truncate on table "public"."past_papers" to "anon";

grant update on table "public"."past_papers" to "anon";

grant delete on table "public"."past_papers" to "authenticated";

grant insert on table "public"."past_papers" to "authenticated";

grant references on table "public"."past_papers" to "authenticated";

grant select on table "public"."past_papers" to "authenticated";

grant trigger on table "public"."past_papers" to "authenticated";

grant truncate on table "public"."past_papers" to "authenticated";

grant update on table "public"."past_papers" to "authenticated";

grant delete on table "public"."past_papers" to "service_role";

grant insert on table "public"."past_papers" to "service_role";

grant references on table "public"."past_papers" to "service_role";

grant select on table "public"."past_papers" to "service_role";

grant trigger on table "public"."past_papers" to "service_role";

grant truncate on table "public"."past_papers" to "service_role";

grant update on table "public"."past_papers" to "service_role";

grant delete on table "public"."payfast_itn_logs" to "anon";

grant insert on table "public"."payfast_itn_logs" to "anon";

grant references on table "public"."payfast_itn_logs" to "anon";

grant select on table "public"."payfast_itn_logs" to "anon";

grant trigger on table "public"."payfast_itn_logs" to "anon";

grant truncate on table "public"."payfast_itn_logs" to "anon";

grant update on table "public"."payfast_itn_logs" to "anon";

grant delete on table "public"."payfast_itn_logs" to "authenticated";

grant insert on table "public"."payfast_itn_logs" to "authenticated";

grant references on table "public"."payfast_itn_logs" to "authenticated";

grant select on table "public"."payfast_itn_logs" to "authenticated";

grant trigger on table "public"."payfast_itn_logs" to "authenticated";

grant truncate on table "public"."payfast_itn_logs" to "authenticated";

grant update on table "public"."payfast_itn_logs" to "authenticated";

grant delete on table "public"."payfast_itn_logs" to "service_role";

grant insert on table "public"."payfast_itn_logs" to "service_role";

grant references on table "public"."payfast_itn_logs" to "service_role";

grant select on table "public"."payfast_itn_logs" to "service_role";

grant trigger on table "public"."payfast_itn_logs" to "service_role";

grant truncate on table "public"."payfast_itn_logs" to "service_role";

grant update on table "public"."payfast_itn_logs" to "service_role";

grant delete on table "public"."payment_reminders" to "anon";

grant insert on table "public"."payment_reminders" to "anon";

grant references on table "public"."payment_reminders" to "anon";

grant select on table "public"."payment_reminders" to "anon";

grant trigger on table "public"."payment_reminders" to "anon";

grant truncate on table "public"."payment_reminders" to "anon";

grant update on table "public"."payment_reminders" to "anon";

grant delete on table "public"."payment_reminders" to "authenticated";

grant insert on table "public"."payment_reminders" to "authenticated";

grant references on table "public"."payment_reminders" to "authenticated";

grant select on table "public"."payment_reminders" to "authenticated";

grant trigger on table "public"."payment_reminders" to "authenticated";

grant truncate on table "public"."payment_reminders" to "authenticated";

grant update on table "public"."payment_reminders" to "authenticated";

grant delete on table "public"."payment_reminders" to "service_role";

grant insert on table "public"."payment_reminders" to "service_role";

grant references on table "public"."payment_reminders" to "service_role";

grant select on table "public"."payment_reminders" to "service_role";

grant trigger on table "public"."payment_reminders" to "service_role";

grant truncate on table "public"."payment_reminders" to "service_role";

grant update on table "public"."payment_reminders" to "service_role";

grant delete on table "public"."payment_transactions" to "anon";

grant insert on table "public"."payment_transactions" to "anon";

grant references on table "public"."payment_transactions" to "anon";

grant select on table "public"."payment_transactions" to "anon";

grant trigger on table "public"."payment_transactions" to "anon";

grant truncate on table "public"."payment_transactions" to "anon";

grant update on table "public"."payment_transactions" to "anon";

grant delete on table "public"."payment_transactions" to "authenticated";

grant insert on table "public"."payment_transactions" to "authenticated";

grant references on table "public"."payment_transactions" to "authenticated";

grant select on table "public"."payment_transactions" to "authenticated";

grant trigger on table "public"."payment_transactions" to "authenticated";

grant truncate on table "public"."payment_transactions" to "authenticated";

grant update on table "public"."payment_transactions" to "authenticated";

grant delete on table "public"."payment_transactions" to "service_role";

grant insert on table "public"."payment_transactions" to "service_role";

grant references on table "public"."payment_transactions" to "service_role";

grant select on table "public"."payment_transactions" to "service_role";

grant trigger on table "public"."payment_transactions" to "service_role";

grant truncate on table "public"."payment_transactions" to "service_role";

grant update on table "public"."payment_transactions" to "service_role";

grant delete on table "public"."payments" to "anon";

grant insert on table "public"."payments" to "anon";

grant references on table "public"."payments" to "anon";

grant select on table "public"."payments" to "anon";

grant trigger on table "public"."payments" to "anon";

grant truncate on table "public"."payments" to "anon";

grant update on table "public"."payments" to "anon";

grant delete on table "public"."payments" to "authenticated";

grant insert on table "public"."payments" to "authenticated";

grant references on table "public"."payments" to "authenticated";

grant select on table "public"."payments" to "authenticated";

grant trigger on table "public"."payments" to "authenticated";

grant truncate on table "public"."payments" to "authenticated";

grant update on table "public"."payments" to "authenticated";

grant delete on table "public"."payments" to "service_role";

grant insert on table "public"."payments" to "service_role";

grant references on table "public"."payments" to "service_role";

grant select on table "public"."payments" to "service_role";

grant trigger on table "public"."payments" to "service_role";

grant truncate on table "public"."payments" to "service_role";

grant update on table "public"."payments" to "service_role";

grant delete on table "public"."pdf_custom_templates" to "anon";

grant insert on table "public"."pdf_custom_templates" to "anon";

grant references on table "public"."pdf_custom_templates" to "anon";

grant select on table "public"."pdf_custom_templates" to "anon";

grant trigger on table "public"."pdf_custom_templates" to "anon";

grant truncate on table "public"."pdf_custom_templates" to "anon";

grant update on table "public"."pdf_custom_templates" to "anon";

grant delete on table "public"."pdf_custom_templates" to "authenticated";

grant insert on table "public"."pdf_custom_templates" to "authenticated";

grant references on table "public"."pdf_custom_templates" to "authenticated";

grant select on table "public"."pdf_custom_templates" to "authenticated";

grant trigger on table "public"."pdf_custom_templates" to "authenticated";

grant truncate on table "public"."pdf_custom_templates" to "authenticated";

grant update on table "public"."pdf_custom_templates" to "authenticated";

grant delete on table "public"."pdf_custom_templates" to "service_role";

grant insert on table "public"."pdf_custom_templates" to "service_role";

grant references on table "public"."pdf_custom_templates" to "service_role";

grant select on table "public"."pdf_custom_templates" to "service_role";

grant trigger on table "public"."pdf_custom_templates" to "service_role";

grant truncate on table "public"."pdf_custom_templates" to "service_role";

grant update on table "public"."pdf_custom_templates" to "service_role";

grant delete on table "public"."pdf_documents" to "anon";

grant insert on table "public"."pdf_documents" to "anon";

grant references on table "public"."pdf_documents" to "anon";

grant select on table "public"."pdf_documents" to "anon";

grant trigger on table "public"."pdf_documents" to "anon";

grant truncate on table "public"."pdf_documents" to "anon";

grant update on table "public"."pdf_documents" to "anon";

grant delete on table "public"."pdf_documents" to "authenticated";

grant insert on table "public"."pdf_documents" to "authenticated";

grant references on table "public"."pdf_documents" to "authenticated";

grant select on table "public"."pdf_documents" to "authenticated";

grant trigger on table "public"."pdf_documents" to "authenticated";

grant truncate on table "public"."pdf_documents" to "authenticated";

grant update on table "public"."pdf_documents" to "authenticated";

grant delete on table "public"."pdf_documents" to "service_role";

grant insert on table "public"."pdf_documents" to "service_role";

grant references on table "public"."pdf_documents" to "service_role";

grant select on table "public"."pdf_documents" to "service_role";

grant trigger on table "public"."pdf_documents" to "service_role";

grant truncate on table "public"."pdf_documents" to "service_role";

grant update on table "public"."pdf_documents" to "service_role";

grant delete on table "public"."pdf_user_preferences" to "anon";

grant insert on table "public"."pdf_user_preferences" to "anon";

grant references on table "public"."pdf_user_preferences" to "anon";

grant select on table "public"."pdf_user_preferences" to "anon";

grant trigger on table "public"."pdf_user_preferences" to "anon";

grant truncate on table "public"."pdf_user_preferences" to "anon";

grant update on table "public"."pdf_user_preferences" to "anon";

grant delete on table "public"."pdf_user_preferences" to "authenticated";

grant insert on table "public"."pdf_user_preferences" to "authenticated";

grant references on table "public"."pdf_user_preferences" to "authenticated";

grant select on table "public"."pdf_user_preferences" to "authenticated";

grant trigger on table "public"."pdf_user_preferences" to "authenticated";

grant truncate on table "public"."pdf_user_preferences" to "authenticated";

grant update on table "public"."pdf_user_preferences" to "authenticated";

grant delete on table "public"."pdf_user_preferences" to "service_role";

grant insert on table "public"."pdf_user_preferences" to "service_role";

grant references on table "public"."pdf_user_preferences" to "service_role";

grant select on table "public"."pdf_user_preferences" to "service_role";

grant trigger on table "public"."pdf_user_preferences" to "service_role";

grant truncate on table "public"."pdf_user_preferences" to "service_role";

grant update on table "public"."pdf_user_preferences" to "service_role";

grant delete on table "public"."petty_cash_accounts" to "anon";

grant insert on table "public"."petty_cash_accounts" to "anon";

grant references on table "public"."petty_cash_accounts" to "anon";

grant select on table "public"."petty_cash_accounts" to "anon";

grant trigger on table "public"."petty_cash_accounts" to "anon";

grant truncate on table "public"."petty_cash_accounts" to "anon";

grant update on table "public"."petty_cash_accounts" to "anon";

grant delete on table "public"."petty_cash_accounts" to "authenticated";

grant insert on table "public"."petty_cash_accounts" to "authenticated";

grant references on table "public"."petty_cash_accounts" to "authenticated";

grant select on table "public"."petty_cash_accounts" to "authenticated";

grant trigger on table "public"."petty_cash_accounts" to "authenticated";

grant truncate on table "public"."petty_cash_accounts" to "authenticated";

grant update on table "public"."petty_cash_accounts" to "authenticated";

grant delete on table "public"."petty_cash_accounts" to "service_role";

grant insert on table "public"."petty_cash_accounts" to "service_role";

grant references on table "public"."petty_cash_accounts" to "service_role";

grant select on table "public"."petty_cash_accounts" to "service_role";

grant trigger on table "public"."petty_cash_accounts" to "service_role";

grant truncate on table "public"."petty_cash_accounts" to "service_role";

grant update on table "public"."petty_cash_accounts" to "service_role";

grant delete on table "public"."petty_cash_receipts" to "anon";

grant insert on table "public"."petty_cash_receipts" to "anon";

grant references on table "public"."petty_cash_receipts" to "anon";

grant select on table "public"."petty_cash_receipts" to "anon";

grant trigger on table "public"."petty_cash_receipts" to "anon";

grant truncate on table "public"."petty_cash_receipts" to "anon";

grant update on table "public"."petty_cash_receipts" to "anon";

grant delete on table "public"."petty_cash_receipts" to "authenticated";

grant insert on table "public"."petty_cash_receipts" to "authenticated";

grant references on table "public"."petty_cash_receipts" to "authenticated";

grant select on table "public"."petty_cash_receipts" to "authenticated";

grant trigger on table "public"."petty_cash_receipts" to "authenticated";

grant truncate on table "public"."petty_cash_receipts" to "authenticated";

grant update on table "public"."petty_cash_receipts" to "authenticated";

grant delete on table "public"."petty_cash_receipts" to "service_role";

grant insert on table "public"."petty_cash_receipts" to "service_role";

grant references on table "public"."petty_cash_receipts" to "service_role";

grant select on table "public"."petty_cash_receipts" to "service_role";

grant trigger on table "public"."petty_cash_receipts" to "service_role";

grant truncate on table "public"."petty_cash_receipts" to "service_role";

grant update on table "public"."petty_cash_receipts" to "service_role";

grant delete on table "public"."petty_cash_reconciliations" to "anon";

grant insert on table "public"."petty_cash_reconciliations" to "anon";

grant references on table "public"."petty_cash_reconciliations" to "anon";

grant select on table "public"."petty_cash_reconciliations" to "anon";

grant trigger on table "public"."petty_cash_reconciliations" to "anon";

grant truncate on table "public"."petty_cash_reconciliations" to "anon";

grant update on table "public"."petty_cash_reconciliations" to "anon";

grant delete on table "public"."petty_cash_reconciliations" to "authenticated";

grant insert on table "public"."petty_cash_reconciliations" to "authenticated";

grant references on table "public"."petty_cash_reconciliations" to "authenticated";

grant select on table "public"."petty_cash_reconciliations" to "authenticated";

grant trigger on table "public"."petty_cash_reconciliations" to "authenticated";

grant truncate on table "public"."petty_cash_reconciliations" to "authenticated";

grant update on table "public"."petty_cash_reconciliations" to "authenticated";

grant delete on table "public"."petty_cash_reconciliations" to "service_role";

grant insert on table "public"."petty_cash_reconciliations" to "service_role";

grant references on table "public"."petty_cash_reconciliations" to "service_role";

grant select on table "public"."petty_cash_reconciliations" to "service_role";

grant trigger on table "public"."petty_cash_reconciliations" to "service_role";

grant truncate on table "public"."petty_cash_reconciliations" to "service_role";

grant update on table "public"."petty_cash_reconciliations" to "service_role";

grant delete on table "public"."petty_cash_transactions" to "anon";

grant insert on table "public"."petty_cash_transactions" to "anon";

grant references on table "public"."petty_cash_transactions" to "anon";

grant select on table "public"."petty_cash_transactions" to "anon";

grant trigger on table "public"."petty_cash_transactions" to "anon";

grant truncate on table "public"."petty_cash_transactions" to "anon";

grant update on table "public"."petty_cash_transactions" to "anon";

grant delete on table "public"."petty_cash_transactions" to "authenticated";

grant insert on table "public"."petty_cash_transactions" to "authenticated";

grant references on table "public"."petty_cash_transactions" to "authenticated";

grant select on table "public"."petty_cash_transactions" to "authenticated";

grant trigger on table "public"."petty_cash_transactions" to "authenticated";

grant truncate on table "public"."petty_cash_transactions" to "authenticated";

grant update on table "public"."petty_cash_transactions" to "authenticated";

grant delete on table "public"."petty_cash_transactions" to "service_role";

grant insert on table "public"."petty_cash_transactions" to "service_role";

grant references on table "public"."petty_cash_transactions" to "service_role";

grant select on table "public"."petty_cash_transactions" to "service_role";

grant trigger on table "public"."petty_cash_transactions" to "service_role";

grant truncate on table "public"."petty_cash_transactions" to "service_role";

grant update on table "public"."petty_cash_transactions" to "service_role";

grant delete on table "public"."phone_verification_logs" to "anon";

grant insert on table "public"."phone_verification_logs" to "anon";

grant references on table "public"."phone_verification_logs" to "anon";

grant select on table "public"."phone_verification_logs" to "anon";

grant trigger on table "public"."phone_verification_logs" to "anon";

grant truncate on table "public"."phone_verification_logs" to "anon";

grant update on table "public"."phone_verification_logs" to "anon";

grant delete on table "public"."phone_verification_logs" to "authenticated";

grant insert on table "public"."phone_verification_logs" to "authenticated";

grant references on table "public"."phone_verification_logs" to "authenticated";

grant select on table "public"."phone_verification_logs" to "authenticated";

grant trigger on table "public"."phone_verification_logs" to "authenticated";

grant truncate on table "public"."phone_verification_logs" to "authenticated";

grant update on table "public"."phone_verification_logs" to "authenticated";

grant delete on table "public"."phone_verification_logs" to "service_role";

grant insert on table "public"."phone_verification_logs" to "service_role";

grant references on table "public"."phone_verification_logs" to "service_role";

grant select on table "public"."phone_verification_logs" to "service_role";

grant trigger on table "public"."phone_verification_logs" to "service_role";

grant truncate on table "public"."phone_verification_logs" to "service_role";

grant update on table "public"."phone_verification_logs" to "service_role";

grant delete on table "public"."plan_quotas" to "anon";

grant insert on table "public"."plan_quotas" to "anon";

grant references on table "public"."plan_quotas" to "anon";

grant select on table "public"."plan_quotas" to "anon";

grant trigger on table "public"."plan_quotas" to "anon";

grant truncate on table "public"."plan_quotas" to "anon";

grant update on table "public"."plan_quotas" to "anon";

grant delete on table "public"."plan_quotas" to "authenticated";

grant insert on table "public"."plan_quotas" to "authenticated";

grant references on table "public"."plan_quotas" to "authenticated";

grant select on table "public"."plan_quotas" to "authenticated";

grant trigger on table "public"."plan_quotas" to "authenticated";

grant truncate on table "public"."plan_quotas" to "authenticated";

grant update on table "public"."plan_quotas" to "authenticated";

grant delete on table "public"."plan_quotas" to "service_role";

grant insert on table "public"."plan_quotas" to "service_role";

grant references on table "public"."plan_quotas" to "service_role";

grant select on table "public"."plan_quotas" to "service_role";

grant trigger on table "public"."plan_quotas" to "service_role";

grant truncate on table "public"."plan_quotas" to "service_role";

grant update on table "public"."plan_quotas" to "service_role";

grant delete on table "public"."platform_analytics" to "anon";

grant insert on table "public"."platform_analytics" to "anon";

grant references on table "public"."platform_analytics" to "anon";

grant select on table "public"."platform_analytics" to "anon";

grant trigger on table "public"."platform_analytics" to "anon";

grant truncate on table "public"."platform_analytics" to "anon";

grant update on table "public"."platform_analytics" to "anon";

grant delete on table "public"."platform_analytics" to "authenticated";

grant insert on table "public"."platform_analytics" to "authenticated";

grant references on table "public"."platform_analytics" to "authenticated";

grant select on table "public"."platform_analytics" to "authenticated";

grant trigger on table "public"."platform_analytics" to "authenticated";

grant truncate on table "public"."platform_analytics" to "authenticated";

grant update on table "public"."platform_analytics" to "authenticated";

grant delete on table "public"."platform_analytics" to "service_role";

grant insert on table "public"."platform_analytics" to "service_role";

grant references on table "public"."platform_analytics" to "service_role";

grant select on table "public"."platform_analytics" to "service_role";

grant trigger on table "public"."platform_analytics" to "service_role";

grant truncate on table "public"."platform_analytics" to "service_role";

grant update on table "public"."platform_analytics" to "service_role";

grant delete on table "public"."platform_collected_payments" to "anon";

grant insert on table "public"."platform_collected_payments" to "anon";

grant references on table "public"."platform_collected_payments" to "anon";

grant select on table "public"."platform_collected_payments" to "anon";

grant trigger on table "public"."platform_collected_payments" to "anon";

grant truncate on table "public"."platform_collected_payments" to "anon";

grant update on table "public"."platform_collected_payments" to "anon";

grant delete on table "public"."platform_collected_payments" to "authenticated";

grant insert on table "public"."platform_collected_payments" to "authenticated";

grant references on table "public"."platform_collected_payments" to "authenticated";

grant select on table "public"."platform_collected_payments" to "authenticated";

grant trigger on table "public"."platform_collected_payments" to "authenticated";

grant truncate on table "public"."platform_collected_payments" to "authenticated";

grant update on table "public"."platform_collected_payments" to "authenticated";

grant delete on table "public"."platform_collected_payments" to "service_role";

grant insert on table "public"."platform_collected_payments" to "service_role";

grant references on table "public"."platform_collected_payments" to "service_role";

grant select on table "public"."platform_collected_payments" to "service_role";

grant trigger on table "public"."platform_collected_payments" to "service_role";

grant truncate on table "public"."platform_collected_payments" to "service_role";

grant update on table "public"."platform_collected_payments" to "service_role";

grant delete on table "public"."platform_disbursements" to "anon";

grant insert on table "public"."platform_disbursements" to "anon";

grant references on table "public"."platform_disbursements" to "anon";

grant select on table "public"."platform_disbursements" to "anon";

grant trigger on table "public"."platform_disbursements" to "anon";

grant truncate on table "public"."platform_disbursements" to "anon";

grant update on table "public"."platform_disbursements" to "anon";

grant delete on table "public"."platform_disbursements" to "authenticated";

grant insert on table "public"."platform_disbursements" to "authenticated";

grant references on table "public"."platform_disbursements" to "authenticated";

grant select on table "public"."platform_disbursements" to "authenticated";

grant trigger on table "public"."platform_disbursements" to "authenticated";

grant truncate on table "public"."platform_disbursements" to "authenticated";

grant update on table "public"."platform_disbursements" to "authenticated";

grant delete on table "public"."platform_disbursements" to "service_role";

grant insert on table "public"."platform_disbursements" to "service_role";

grant references on table "public"."platform_disbursements" to "service_role";

grant select on table "public"."platform_disbursements" to "service_role";

grant trigger on table "public"."platform_disbursements" to "service_role";

grant truncate on table "public"."platform_disbursements" to "service_role";

grant update on table "public"."platform_disbursements" to "service_role";

grant delete on table "public"."platform_subscriptions" to "anon";

grant insert on table "public"."platform_subscriptions" to "anon";

grant references on table "public"."platform_subscriptions" to "anon";

grant select on table "public"."platform_subscriptions" to "anon";

grant trigger on table "public"."platform_subscriptions" to "anon";

grant truncate on table "public"."platform_subscriptions" to "anon";

grant update on table "public"."platform_subscriptions" to "anon";

grant delete on table "public"."platform_subscriptions" to "authenticated";

grant insert on table "public"."platform_subscriptions" to "authenticated";

grant references on table "public"."platform_subscriptions" to "authenticated";

grant select on table "public"."platform_subscriptions" to "authenticated";

grant trigger on table "public"."platform_subscriptions" to "authenticated";

grant truncate on table "public"."platform_subscriptions" to "authenticated";

grant update on table "public"."platform_subscriptions" to "authenticated";

grant delete on table "public"."platform_subscriptions" to "service_role";

grant insert on table "public"."platform_subscriptions" to "service_role";

grant references on table "public"."platform_subscriptions" to "service_role";

grant select on table "public"."platform_subscriptions" to "service_role";

grant trigger on table "public"."platform_subscriptions" to "service_role";

grant truncate on table "public"."platform_subscriptions" to "service_role";

grant update on table "public"."platform_subscriptions" to "service_role";

grant delete on table "public"."portfolio_items" to "anon";

grant insert on table "public"."portfolio_items" to "anon";

grant references on table "public"."portfolio_items" to "anon";

grant select on table "public"."portfolio_items" to "anon";

grant trigger on table "public"."portfolio_items" to "anon";

grant truncate on table "public"."portfolio_items" to "anon";

grant update on table "public"."portfolio_items" to "anon";

grant delete on table "public"."portfolio_items" to "authenticated";

grant insert on table "public"."portfolio_items" to "authenticated";

grant references on table "public"."portfolio_items" to "authenticated";

grant select on table "public"."portfolio_items" to "authenticated";

grant trigger on table "public"."portfolio_items" to "authenticated";

grant truncate on table "public"."portfolio_items" to "authenticated";

grant update on table "public"."portfolio_items" to "authenticated";

grant delete on table "public"."portfolio_items" to "service_role";

grant insert on table "public"."portfolio_items" to "service_role";

grant references on table "public"."portfolio_items" to "service_role";

grant select on table "public"."portfolio_items" to "service_role";

grant trigger on table "public"."portfolio_items" to "service_role";

grant truncate on table "public"."portfolio_items" to "service_role";

grant update on table "public"."portfolio_items" to "service_role";

grant delete on table "public"."preschool_onboarding_requests" to "anon";

grant insert on table "public"."preschool_onboarding_requests" to "anon";

grant references on table "public"."preschool_onboarding_requests" to "anon";

grant select on table "public"."preschool_onboarding_requests" to "anon";

grant trigger on table "public"."preschool_onboarding_requests" to "anon";

grant truncate on table "public"."preschool_onboarding_requests" to "anon";

grant update on table "public"."preschool_onboarding_requests" to "anon";

grant delete on table "public"."preschool_onboarding_requests" to "authenticated";

grant insert on table "public"."preschool_onboarding_requests" to "authenticated";

grant references on table "public"."preschool_onboarding_requests" to "authenticated";

grant select on table "public"."preschool_onboarding_requests" to "authenticated";

grant trigger on table "public"."preschool_onboarding_requests" to "authenticated";

grant truncate on table "public"."preschool_onboarding_requests" to "authenticated";

grant update on table "public"."preschool_onboarding_requests" to "authenticated";

grant delete on table "public"."preschool_onboarding_requests" to "service_role";

grant insert on table "public"."preschool_onboarding_requests" to "service_role";

grant references on table "public"."preschool_onboarding_requests" to "service_role";

grant select on table "public"."preschool_onboarding_requests" to "service_role";

grant trigger on table "public"."preschool_onboarding_requests" to "service_role";

grant truncate on table "public"."preschool_onboarding_requests" to "service_role";

grant update on table "public"."preschool_onboarding_requests" to "service_role";

grant delete on table "public"."preschool_settings" to "anon";

grant insert on table "public"."preschool_settings" to "anon";

grant references on table "public"."preschool_settings" to "anon";

grant select on table "public"."preschool_settings" to "anon";

grant trigger on table "public"."preschool_settings" to "anon";

grant truncate on table "public"."preschool_settings" to "anon";

grant update on table "public"."preschool_settings" to "anon";

grant delete on table "public"."preschool_settings" to "authenticated";

grant insert on table "public"."preschool_settings" to "authenticated";

grant references on table "public"."preschool_settings" to "authenticated";

grant select on table "public"."preschool_settings" to "authenticated";

grant trigger on table "public"."preschool_settings" to "authenticated";

grant truncate on table "public"."preschool_settings" to "authenticated";

grant update on table "public"."preschool_settings" to "authenticated";

grant delete on table "public"."preschool_settings" to "service_role";

grant insert on table "public"."preschool_settings" to "service_role";

grant references on table "public"."preschool_settings" to "service_role";

grant select on table "public"."preschool_settings" to "service_role";

grant trigger on table "public"."preschool_settings" to "service_role";

grant truncate on table "public"."preschool_settings" to "service_role";

grant update on table "public"."preschool_settings" to "service_role";

grant delete on table "public"."preschool_voice_usage" to "anon";

grant insert on table "public"."preschool_voice_usage" to "anon";

grant references on table "public"."preschool_voice_usage" to "anon";

grant select on table "public"."preschool_voice_usage" to "anon";

grant trigger on table "public"."preschool_voice_usage" to "anon";

grant truncate on table "public"."preschool_voice_usage" to "anon";

grant update on table "public"."preschool_voice_usage" to "anon";

grant delete on table "public"."preschool_voice_usage" to "authenticated";

grant insert on table "public"."preschool_voice_usage" to "authenticated";

grant references on table "public"."preschool_voice_usage" to "authenticated";

grant select on table "public"."preschool_voice_usage" to "authenticated";

grant trigger on table "public"."preschool_voice_usage" to "authenticated";

grant truncate on table "public"."preschool_voice_usage" to "authenticated";

grant update on table "public"."preschool_voice_usage" to "authenticated";

grant delete on table "public"."preschool_voice_usage" to "service_role";

grant insert on table "public"."preschool_voice_usage" to "service_role";

grant references on table "public"."preschool_voice_usage" to "service_role";

grant select on table "public"."preschool_voice_usage" to "service_role";

grant trigger on table "public"."preschool_voice_usage" to "service_role";

grant truncate on table "public"."preschool_voice_usage" to "service_role";

grant update on table "public"."preschool_voice_usage" to "service_role";

grant delete on table "public"."principal_groups" to "anon";

grant insert on table "public"."principal_groups" to "anon";

grant references on table "public"."principal_groups" to "anon";

grant select on table "public"."principal_groups" to "anon";

grant trigger on table "public"."principal_groups" to "anon";

grant truncate on table "public"."principal_groups" to "anon";

grant update on table "public"."principal_groups" to "anon";

grant delete on table "public"."principal_groups" to "authenticated";

grant insert on table "public"."principal_groups" to "authenticated";

grant references on table "public"."principal_groups" to "authenticated";

grant select on table "public"."principal_groups" to "authenticated";

grant trigger on table "public"."principal_groups" to "authenticated";

grant truncate on table "public"."principal_groups" to "authenticated";

grant update on table "public"."principal_groups" to "authenticated";

grant delete on table "public"."principal_groups" to "service_role";

grant insert on table "public"."principal_groups" to "service_role";

grant references on table "public"."principal_groups" to "service_role";

grant select on table "public"."principal_groups" to "service_role";

grant trigger on table "public"."principal_groups" to "service_role";

grant truncate on table "public"."principal_groups" to "service_role";

grant update on table "public"."principal_groups" to "service_role";

grant delete on table "public"."progress_reports" to "anon";

grant insert on table "public"."progress_reports" to "anon";

grant references on table "public"."progress_reports" to "anon";

grant select on table "public"."progress_reports" to "anon";

grant trigger on table "public"."progress_reports" to "anon";

grant truncate on table "public"."progress_reports" to "anon";

grant update on table "public"."progress_reports" to "anon";

grant delete on table "public"."progress_reports" to "authenticated";

grant insert on table "public"."progress_reports" to "authenticated";

grant references on table "public"."progress_reports" to "authenticated";

grant select on table "public"."progress_reports" to "authenticated";

grant trigger on table "public"."progress_reports" to "authenticated";

grant truncate on table "public"."progress_reports" to "authenticated";

grant update on table "public"."progress_reports" to "authenticated";

grant delete on table "public"."progress_reports" to "service_role";

grant insert on table "public"."progress_reports" to "service_role";

grant references on table "public"."progress_reports" to "service_role";

grant select on table "public"."progress_reports" to "service_role";

grant trigger on table "public"."progress_reports" to "service_role";

grant truncate on table "public"."progress_reports" to "service_role";

grant update on table "public"."progress_reports" to "service_role";

grant delete on table "public"."promotional_campaigns" to "anon";

grant insert on table "public"."promotional_campaigns" to "anon";

grant references on table "public"."promotional_campaigns" to "anon";

grant select on table "public"."promotional_campaigns" to "anon";

grant trigger on table "public"."promotional_campaigns" to "anon";

grant truncate on table "public"."promotional_campaigns" to "anon";

grant update on table "public"."promotional_campaigns" to "anon";

grant delete on table "public"."promotional_campaigns" to "authenticated";

grant insert on table "public"."promotional_campaigns" to "authenticated";

grant references on table "public"."promotional_campaigns" to "authenticated";

grant select on table "public"."promotional_campaigns" to "authenticated";

grant trigger on table "public"."promotional_campaigns" to "authenticated";

grant truncate on table "public"."promotional_campaigns" to "authenticated";

grant update on table "public"."promotional_campaigns" to "authenticated";

grant delete on table "public"."promotional_campaigns" to "service_role";

grant insert on table "public"."promotional_campaigns" to "service_role";

grant references on table "public"."promotional_campaigns" to "service_role";

grant select on table "public"."promotional_campaigns" to "service_role";

grant trigger on table "public"."promotional_campaigns" to "service_role";

grant truncate on table "public"."promotional_campaigns" to "service_role";

grant update on table "public"."promotional_campaigns" to "service_role";

grant delete on table "public"."push_device_tokens" to "anon";

grant insert on table "public"."push_device_tokens" to "anon";

grant references on table "public"."push_device_tokens" to "anon";

grant select on table "public"."push_device_tokens" to "anon";

grant trigger on table "public"."push_device_tokens" to "anon";

grant truncate on table "public"."push_device_tokens" to "anon";

grant update on table "public"."push_device_tokens" to "anon";

grant delete on table "public"."push_device_tokens" to "authenticated";

grant insert on table "public"."push_device_tokens" to "authenticated";

grant references on table "public"."push_device_tokens" to "authenticated";

grant select on table "public"."push_device_tokens" to "authenticated";

grant trigger on table "public"."push_device_tokens" to "authenticated";

grant truncate on table "public"."push_device_tokens" to "authenticated";

grant update on table "public"."push_device_tokens" to "authenticated";

grant delete on table "public"."push_device_tokens" to "service_role";

grant insert on table "public"."push_device_tokens" to "service_role";

grant references on table "public"."push_device_tokens" to "service_role";

grant select on table "public"."push_device_tokens" to "service_role";

grant trigger on table "public"."push_device_tokens" to "service_role";

grant truncate on table "public"."push_device_tokens" to "service_role";

grant update on table "public"."push_device_tokens" to "service_role";

grant delete on table "public"."push_devices" to "anon";

grant insert on table "public"."push_devices" to "anon";

grant references on table "public"."push_devices" to "anon";

grant select on table "public"."push_devices" to "anon";

grant trigger on table "public"."push_devices" to "anon";

grant truncate on table "public"."push_devices" to "anon";

grant update on table "public"."push_devices" to "anon";

grant delete on table "public"."push_devices" to "authenticated";

grant insert on table "public"."push_devices" to "authenticated";

grant references on table "public"."push_devices" to "authenticated";

grant select on table "public"."push_devices" to "authenticated";

grant trigger on table "public"."push_devices" to "authenticated";

grant truncate on table "public"."push_devices" to "authenticated";

grant update on table "public"."push_devices" to "authenticated";

grant delete on table "public"."push_devices" to "service_role";

grant insert on table "public"."push_devices" to "service_role";

grant references on table "public"."push_devices" to "service_role";

grant select on table "public"."push_devices" to "service_role";

grant trigger on table "public"."push_devices" to "service_role";

grant truncate on table "public"."push_devices" to "service_role";

grant update on table "public"."push_devices" to "service_role";

grant delete on table "public"."push_notification_queue" to "anon";

grant insert on table "public"."push_notification_queue" to "anon";

grant references on table "public"."push_notification_queue" to "anon";

grant select on table "public"."push_notification_queue" to "anon";

grant trigger on table "public"."push_notification_queue" to "anon";

grant truncate on table "public"."push_notification_queue" to "anon";

grant update on table "public"."push_notification_queue" to "anon";

grant delete on table "public"."push_notification_queue" to "authenticated";

grant insert on table "public"."push_notification_queue" to "authenticated";

grant references on table "public"."push_notification_queue" to "authenticated";

grant select on table "public"."push_notification_queue" to "authenticated";

grant trigger on table "public"."push_notification_queue" to "authenticated";

grant truncate on table "public"."push_notification_queue" to "authenticated";

grant update on table "public"."push_notification_queue" to "authenticated";

grant delete on table "public"."push_notification_queue" to "service_role";

grant insert on table "public"."push_notification_queue" to "service_role";

grant references on table "public"."push_notification_queue" to "service_role";

grant select on table "public"."push_notification_queue" to "service_role";

grant trigger on table "public"."push_notification_queue" to "service_role";

grant truncate on table "public"."push_notification_queue" to "service_role";

grant update on table "public"."push_notification_queue" to "service_role";

grant delete on table "public"."push_notifications" to "anon";

grant insert on table "public"."push_notifications" to "anon";

grant references on table "public"."push_notifications" to "anon";

grant select on table "public"."push_notifications" to "anon";

grant trigger on table "public"."push_notifications" to "anon";

grant truncate on table "public"."push_notifications" to "anon";

grant update on table "public"."push_notifications" to "anon";

grant delete on table "public"."push_notifications" to "authenticated";

grant insert on table "public"."push_notifications" to "authenticated";

grant references on table "public"."push_notifications" to "authenticated";

grant select on table "public"."push_notifications" to "authenticated";

grant trigger on table "public"."push_notifications" to "authenticated";

grant truncate on table "public"."push_notifications" to "authenticated";

grant update on table "public"."push_notifications" to "authenticated";

grant delete on table "public"."push_notifications" to "service_role";

grant insert on table "public"."push_notifications" to "service_role";

grant references on table "public"."push_notifications" to "service_role";

grant select on table "public"."push_notifications" to "service_role";

grant trigger on table "public"."push_notifications" to "service_role";

grant truncate on table "public"."push_notifications" to "service_role";

grant update on table "public"."push_notifications" to "service_role";

grant delete on table "public"."push_subscriptions" to "anon";

grant insert on table "public"."push_subscriptions" to "anon";

grant references on table "public"."push_subscriptions" to "anon";

grant select on table "public"."push_subscriptions" to "anon";

grant trigger on table "public"."push_subscriptions" to "anon";

grant truncate on table "public"."push_subscriptions" to "anon";

grant update on table "public"."push_subscriptions" to "anon";

grant delete on table "public"."push_subscriptions" to "authenticated";

grant insert on table "public"."push_subscriptions" to "authenticated";

grant references on table "public"."push_subscriptions" to "authenticated";

grant select on table "public"."push_subscriptions" to "authenticated";

grant trigger on table "public"."push_subscriptions" to "authenticated";

grant truncate on table "public"."push_subscriptions" to "authenticated";

grant update on table "public"."push_subscriptions" to "authenticated";

grant delete on table "public"."push_subscriptions" to "service_role";

grant insert on table "public"."push_subscriptions" to "service_role";

grant references on table "public"."push_subscriptions" to "service_role";

grant select on table "public"."push_subscriptions" to "service_role";

grant trigger on table "public"."push_subscriptions" to "service_role";

grant truncate on table "public"."push_subscriptions" to "service_role";

grant update on table "public"."push_subscriptions" to "service_role";

grant delete on table "public"."rag_chunks" to "anon";

grant insert on table "public"."rag_chunks" to "anon";

grant references on table "public"."rag_chunks" to "anon";

grant select on table "public"."rag_chunks" to "anon";

grant trigger on table "public"."rag_chunks" to "anon";

grant truncate on table "public"."rag_chunks" to "anon";

grant update on table "public"."rag_chunks" to "anon";

grant delete on table "public"."rag_chunks" to "authenticated";

grant insert on table "public"."rag_chunks" to "authenticated";

grant references on table "public"."rag_chunks" to "authenticated";

grant select on table "public"."rag_chunks" to "authenticated";

grant trigger on table "public"."rag_chunks" to "authenticated";

grant truncate on table "public"."rag_chunks" to "authenticated";

grant update on table "public"."rag_chunks" to "authenticated";

grant delete on table "public"."rag_chunks" to "service_role";

grant insert on table "public"."rag_chunks" to "service_role";

grant references on table "public"."rag_chunks" to "service_role";

grant select on table "public"."rag_chunks" to "service_role";

grant trigger on table "public"."rag_chunks" to "service_role";

grant truncate on table "public"."rag_chunks" to "service_role";

grant update on table "public"."rag_chunks" to "service_role";

grant delete on table "public"."rag_documents" to "anon";

grant insert on table "public"."rag_documents" to "anon";

grant references on table "public"."rag_documents" to "anon";

grant select on table "public"."rag_documents" to "anon";

grant trigger on table "public"."rag_documents" to "anon";

grant truncate on table "public"."rag_documents" to "anon";

grant update on table "public"."rag_documents" to "anon";

grant delete on table "public"."rag_documents" to "authenticated";

grant insert on table "public"."rag_documents" to "authenticated";

grant references on table "public"."rag_documents" to "authenticated";

grant select on table "public"."rag_documents" to "authenticated";

grant trigger on table "public"."rag_documents" to "authenticated";

grant truncate on table "public"."rag_documents" to "authenticated";

grant update on table "public"."rag_documents" to "authenticated";

grant delete on table "public"."rag_documents" to "service_role";

grant insert on table "public"."rag_documents" to "service_role";

grant references on table "public"."rag_documents" to "service_role";

grant select on table "public"."rag_documents" to "service_role";

grant trigger on table "public"."rag_documents" to "service_role";

grant truncate on table "public"."rag_documents" to "service_role";

grant update on table "public"."rag_documents" to "service_role";

grant delete on table "public"."rag_ingestion_logs" to "anon";

grant insert on table "public"."rag_ingestion_logs" to "anon";

grant references on table "public"."rag_ingestion_logs" to "anon";

grant select on table "public"."rag_ingestion_logs" to "anon";

grant trigger on table "public"."rag_ingestion_logs" to "anon";

grant truncate on table "public"."rag_ingestion_logs" to "anon";

grant update on table "public"."rag_ingestion_logs" to "anon";

grant delete on table "public"."rag_ingestion_logs" to "authenticated";

grant insert on table "public"."rag_ingestion_logs" to "authenticated";

grant references on table "public"."rag_ingestion_logs" to "authenticated";

grant select on table "public"."rag_ingestion_logs" to "authenticated";

grant trigger on table "public"."rag_ingestion_logs" to "authenticated";

grant truncate on table "public"."rag_ingestion_logs" to "authenticated";

grant update on table "public"."rag_ingestion_logs" to "authenticated";

grant delete on table "public"."rag_ingestion_logs" to "service_role";

grant insert on table "public"."rag_ingestion_logs" to "service_role";

grant references on table "public"."rag_ingestion_logs" to "service_role";

grant select on table "public"."rag_ingestion_logs" to "service_role";

grant trigger on table "public"."rag_ingestion_logs" to "service_role";

grant truncate on table "public"."rag_ingestion_logs" to "service_role";

grant update on table "public"."rag_ingestion_logs" to "service_role";

grant delete on table "public"."reading_progress" to "anon";

grant insert on table "public"."reading_progress" to "anon";

grant references on table "public"."reading_progress" to "anon";

grant select on table "public"."reading_progress" to "anon";

grant trigger on table "public"."reading_progress" to "anon";

grant truncate on table "public"."reading_progress" to "anon";

grant update on table "public"."reading_progress" to "anon";

grant delete on table "public"."reading_progress" to "authenticated";

grant insert on table "public"."reading_progress" to "authenticated";

grant references on table "public"."reading_progress" to "authenticated";

grant select on table "public"."reading_progress" to "authenticated";

grant trigger on table "public"."reading_progress" to "authenticated";

grant truncate on table "public"."reading_progress" to "authenticated";

grant update on table "public"."reading_progress" to "authenticated";

grant delete on table "public"."reading_progress" to "service_role";

grant insert on table "public"."reading_progress" to "service_role";

grant references on table "public"."reading_progress" to "service_role";

grant select on table "public"."reading_progress" to "service_role";

grant trigger on table "public"."reading_progress" to "service_role";

grant truncate on table "public"."reading_progress" to "service_role";

grant update on table "public"."reading_progress" to "service_role";

grant delete on table "public"."region_invite_codes" to "anon";

grant insert on table "public"."region_invite_codes" to "anon";

grant references on table "public"."region_invite_codes" to "anon";

grant select on table "public"."region_invite_codes" to "anon";

grant trigger on table "public"."region_invite_codes" to "anon";

grant truncate on table "public"."region_invite_codes" to "anon";

grant update on table "public"."region_invite_codes" to "anon";

grant delete on table "public"."region_invite_codes" to "authenticated";

grant insert on table "public"."region_invite_codes" to "authenticated";

grant references on table "public"."region_invite_codes" to "authenticated";

grant select on table "public"."region_invite_codes" to "authenticated";

grant trigger on table "public"."region_invite_codes" to "authenticated";

grant truncate on table "public"."region_invite_codes" to "authenticated";

grant update on table "public"."region_invite_codes" to "authenticated";

grant delete on table "public"."region_invite_codes" to "service_role";

grant insert on table "public"."region_invite_codes" to "service_role";

grant references on table "public"."region_invite_codes" to "service_role";

grant select on table "public"."region_invite_codes" to "service_role";

grant trigger on table "public"."region_invite_codes" to "service_role";

grant truncate on table "public"."region_invite_codes" to "service_role";

grant update on table "public"."region_invite_codes" to "service_role";

grant delete on table "public"."registration_requests" to "anon";

grant insert on table "public"."registration_requests" to "anon";

grant references on table "public"."registration_requests" to "anon";

grant select on table "public"."registration_requests" to "anon";

grant trigger on table "public"."registration_requests" to "anon";

grant truncate on table "public"."registration_requests" to "anon";

grant update on table "public"."registration_requests" to "anon";

grant delete on table "public"."registration_requests" to "authenticated";

grant insert on table "public"."registration_requests" to "authenticated";

grant references on table "public"."registration_requests" to "authenticated";

grant select on table "public"."registration_requests" to "authenticated";

grant trigger on table "public"."registration_requests" to "authenticated";

grant truncate on table "public"."registration_requests" to "authenticated";

grant update on table "public"."registration_requests" to "authenticated";

grant delete on table "public"."registration_requests" to "service_role";

grant insert on table "public"."registration_requests" to "service_role";

grant references on table "public"."registration_requests" to "service_role";

grant select on table "public"."registration_requests" to "service_role";

grant trigger on table "public"."registration_requests" to "service_role";

grant truncate on table "public"."registration_requests" to "service_role";

grant update on table "public"."registration_requests" to "service_role";

grant delete on table "public"."resource_categories" to "anon";

grant insert on table "public"."resource_categories" to "anon";

grant references on table "public"."resource_categories" to "anon";

grant select on table "public"."resource_categories" to "anon";

grant trigger on table "public"."resource_categories" to "anon";

grant truncate on table "public"."resource_categories" to "anon";

grant update on table "public"."resource_categories" to "anon";

grant delete on table "public"."resource_categories" to "authenticated";

grant insert on table "public"."resource_categories" to "authenticated";

grant references on table "public"."resource_categories" to "authenticated";

grant select on table "public"."resource_categories" to "authenticated";

grant trigger on table "public"."resource_categories" to "authenticated";

grant truncate on table "public"."resource_categories" to "authenticated";

grant update on table "public"."resource_categories" to "authenticated";

grant delete on table "public"."resource_categories" to "service_role";

grant insert on table "public"."resource_categories" to "service_role";

grant references on table "public"."resource_categories" to "service_role";

grant select on table "public"."resource_categories" to "service_role";

grant trigger on table "public"."resource_categories" to "service_role";

grant truncate on table "public"."resource_categories" to "service_role";

grant update on table "public"."resource_categories" to "service_role";

grant delete on table "public"."resource_permissions" to "anon";

grant insert on table "public"."resource_permissions" to "anon";

grant references on table "public"."resource_permissions" to "anon";

grant select on table "public"."resource_permissions" to "anon";

grant trigger on table "public"."resource_permissions" to "anon";

grant truncate on table "public"."resource_permissions" to "anon";

grant update on table "public"."resource_permissions" to "anon";

grant delete on table "public"."resource_permissions" to "authenticated";

grant insert on table "public"."resource_permissions" to "authenticated";

grant references on table "public"."resource_permissions" to "authenticated";

grant select on table "public"."resource_permissions" to "authenticated";

grant trigger on table "public"."resource_permissions" to "authenticated";

grant truncate on table "public"."resource_permissions" to "authenticated";

grant update on table "public"."resource_permissions" to "authenticated";

grant delete on table "public"."resource_permissions" to "service_role";

grant insert on table "public"."resource_permissions" to "service_role";

grant references on table "public"."resource_permissions" to "service_role";

grant select on table "public"."resource_permissions" to "service_role";

grant trigger on table "public"."resource_permissions" to "service_role";

grant truncate on table "public"."resource_permissions" to "service_role";

grant update on table "public"."resource_permissions" to "service_role";

grant delete on table "public"."resource_reviews" to "anon";

grant insert on table "public"."resource_reviews" to "anon";

grant references on table "public"."resource_reviews" to "anon";

grant select on table "public"."resource_reviews" to "anon";

grant trigger on table "public"."resource_reviews" to "anon";

grant truncate on table "public"."resource_reviews" to "anon";

grant update on table "public"."resource_reviews" to "anon";

grant delete on table "public"."resource_reviews" to "authenticated";

grant insert on table "public"."resource_reviews" to "authenticated";

grant references on table "public"."resource_reviews" to "authenticated";

grant select on table "public"."resource_reviews" to "authenticated";

grant trigger on table "public"."resource_reviews" to "authenticated";

grant truncate on table "public"."resource_reviews" to "authenticated";

grant update on table "public"."resource_reviews" to "authenticated";

grant delete on table "public"."resource_reviews" to "service_role";

grant insert on table "public"."resource_reviews" to "service_role";

grant references on table "public"."resource_reviews" to "service_role";

grant select on table "public"."resource_reviews" to "service_role";

grant trigger on table "public"."resource_reviews" to "service_role";

grant truncate on table "public"."resource_reviews" to "service_role";

grant update on table "public"."resource_reviews" to "service_role";

grant delete on table "public"."resources" to "anon";

grant insert on table "public"."resources" to "anon";

grant references on table "public"."resources" to "anon";

grant select on table "public"."resources" to "anon";

grant trigger on table "public"."resources" to "anon";

grant truncate on table "public"."resources" to "anon";

grant update on table "public"."resources" to "anon";

grant delete on table "public"."resources" to "authenticated";

grant insert on table "public"."resources" to "authenticated";

grant references on table "public"."resources" to "authenticated";

grant select on table "public"."resources" to "authenticated";

grant trigger on table "public"."resources" to "authenticated";

grant truncate on table "public"."resources" to "authenticated";

grant update on table "public"."resources" to "authenticated";

grant delete on table "public"."resources" to "service_role";

grant insert on table "public"."resources" to "service_role";

grant references on table "public"."resources" to "service_role";

grant select on table "public"."resources" to "service_role";

grant trigger on table "public"."resources" to "service_role";

grant truncate on table "public"."resources" to "service_role";

grant update on table "public"."resources" to "service_role";

grant delete on table "public"."revenuecat_webhook_events" to "anon";

grant insert on table "public"."revenuecat_webhook_events" to "anon";

grant references on table "public"."revenuecat_webhook_events" to "anon";

grant select on table "public"."revenuecat_webhook_events" to "anon";

grant trigger on table "public"."revenuecat_webhook_events" to "anon";

grant truncate on table "public"."revenuecat_webhook_events" to "anon";

grant update on table "public"."revenuecat_webhook_events" to "anon";

grant delete on table "public"."revenuecat_webhook_events" to "authenticated";

grant insert on table "public"."revenuecat_webhook_events" to "authenticated";

grant references on table "public"."revenuecat_webhook_events" to "authenticated";

grant select on table "public"."revenuecat_webhook_events" to "authenticated";

grant trigger on table "public"."revenuecat_webhook_events" to "authenticated";

grant truncate on table "public"."revenuecat_webhook_events" to "authenticated";

grant update on table "public"."revenuecat_webhook_events" to "authenticated";

grant delete on table "public"."revenuecat_webhook_events" to "service_role";

grant insert on table "public"."revenuecat_webhook_events" to "service_role";

grant references on table "public"."revenuecat_webhook_events" to "service_role";

grant select on table "public"."revenuecat_webhook_events" to "service_role";

grant trigger on table "public"."revenuecat_webhook_events" to "service_role";

grant truncate on table "public"."revenuecat_webhook_events" to "service_role";

grant update on table "public"."revenuecat_webhook_events" to "service_role";

grant delete on table "public"."rubric_grades" to "anon";

grant insert on table "public"."rubric_grades" to "anon";

grant references on table "public"."rubric_grades" to "anon";

grant select on table "public"."rubric_grades" to "anon";

grant trigger on table "public"."rubric_grades" to "anon";

grant truncate on table "public"."rubric_grades" to "anon";

grant update on table "public"."rubric_grades" to "anon";

grant delete on table "public"."rubric_grades" to "authenticated";

grant insert on table "public"."rubric_grades" to "authenticated";

grant references on table "public"."rubric_grades" to "authenticated";

grant select on table "public"."rubric_grades" to "authenticated";

grant trigger on table "public"."rubric_grades" to "authenticated";

grant truncate on table "public"."rubric_grades" to "authenticated";

grant update on table "public"."rubric_grades" to "authenticated";

grant delete on table "public"."rubric_grades" to "service_role";

grant insert on table "public"."rubric_grades" to "service_role";

grant references on table "public"."rubric_grades" to "service_role";

grant select on table "public"."rubric_grades" to "service_role";

grant trigger on table "public"."rubric_grades" to "service_role";

grant truncate on table "public"."rubric_grades" to "service_role";

grant update on table "public"."rubric_grades" to "service_role";

grant delete on table "public"."scheduled_lessons" to "anon";

grant insert on table "public"."scheduled_lessons" to "anon";

grant references on table "public"."scheduled_lessons" to "anon";

grant select on table "public"."scheduled_lessons" to "anon";

grant trigger on table "public"."scheduled_lessons" to "anon";

grant truncate on table "public"."scheduled_lessons" to "anon";

grant update on table "public"."scheduled_lessons" to "anon";

grant delete on table "public"."scheduled_lessons" to "authenticated";

grant insert on table "public"."scheduled_lessons" to "authenticated";

grant references on table "public"."scheduled_lessons" to "authenticated";

grant select on table "public"."scheduled_lessons" to "authenticated";

grant trigger on table "public"."scheduled_lessons" to "authenticated";

grant truncate on table "public"."scheduled_lessons" to "authenticated";

grant update on table "public"."scheduled_lessons" to "authenticated";

grant delete on table "public"."scheduled_lessons" to "service_role";

grant insert on table "public"."scheduled_lessons" to "service_role";

grant references on table "public"."scheduled_lessons" to "service_role";

grant select on table "public"."scheduled_lessons" to "service_role";

grant trigger on table "public"."scheduled_lessons" to "service_role";

grant truncate on table "public"."scheduled_lessons" to "service_role";

grant update on table "public"."scheduled_lessons" to "service_role";

grant delete on table "public"."scheduled_tasks" to "anon";

grant insert on table "public"."scheduled_tasks" to "anon";

grant references on table "public"."scheduled_tasks" to "anon";

grant select on table "public"."scheduled_tasks" to "anon";

grant trigger on table "public"."scheduled_tasks" to "anon";

grant truncate on table "public"."scheduled_tasks" to "anon";

grant update on table "public"."scheduled_tasks" to "anon";

grant delete on table "public"."scheduled_tasks" to "authenticated";

grant insert on table "public"."scheduled_tasks" to "authenticated";

grant references on table "public"."scheduled_tasks" to "authenticated";

grant select on table "public"."scheduled_tasks" to "authenticated";

grant trigger on table "public"."scheduled_tasks" to "authenticated";

grant truncate on table "public"."scheduled_tasks" to "authenticated";

grant update on table "public"."scheduled_tasks" to "authenticated";

grant delete on table "public"."scheduled_tasks" to "service_role";

grant insert on table "public"."scheduled_tasks" to "service_role";

grant references on table "public"."scheduled_tasks" to "service_role";

grant select on table "public"."scheduled_tasks" to "service_role";

grant trigger on table "public"."scheduled_tasks" to "service_role";

grant truncate on table "public"."scheduled_tasks" to "service_role";

grant update on table "public"."scheduled_tasks" to "service_role";

grant delete on table "public"."school_ai_subscriptions" to "anon";

grant insert on table "public"."school_ai_subscriptions" to "anon";

grant references on table "public"."school_ai_subscriptions" to "anon";

grant select on table "public"."school_ai_subscriptions" to "anon";

grant trigger on table "public"."school_ai_subscriptions" to "anon";

grant truncate on table "public"."school_ai_subscriptions" to "anon";

grant update on table "public"."school_ai_subscriptions" to "anon";

grant delete on table "public"."school_ai_subscriptions" to "authenticated";

grant insert on table "public"."school_ai_subscriptions" to "authenticated";

grant references on table "public"."school_ai_subscriptions" to "authenticated";

grant select on table "public"."school_ai_subscriptions" to "authenticated";

grant trigger on table "public"."school_ai_subscriptions" to "authenticated";

grant truncate on table "public"."school_ai_subscriptions" to "authenticated";

grant update on table "public"."school_ai_subscriptions" to "authenticated";

grant delete on table "public"."school_ai_subscriptions" to "service_role";

grant insert on table "public"."school_ai_subscriptions" to "service_role";

grant references on table "public"."school_ai_subscriptions" to "service_role";

grant select on table "public"."school_ai_subscriptions" to "service_role";

grant trigger on table "public"."school_ai_subscriptions" to "service_role";

grant truncate on table "public"."school_ai_subscriptions" to "service_role";

grant update on table "public"."school_ai_subscriptions" to "service_role";

grant delete on table "public"."school_branding" to "anon";

grant insert on table "public"."school_branding" to "anon";

grant references on table "public"."school_branding" to "anon";

grant select on table "public"."school_branding" to "anon";

grant trigger on table "public"."school_branding" to "anon";

grant truncate on table "public"."school_branding" to "anon";

grant update on table "public"."school_branding" to "anon";

grant delete on table "public"."school_branding" to "authenticated";

grant insert on table "public"."school_branding" to "authenticated";

grant references on table "public"."school_branding" to "authenticated";

grant select on table "public"."school_branding" to "authenticated";

grant trigger on table "public"."school_branding" to "authenticated";

grant truncate on table "public"."school_branding" to "authenticated";

grant update on table "public"."school_branding" to "authenticated";

grant delete on table "public"."school_branding" to "service_role";

grant insert on table "public"."school_branding" to "service_role";

grant references on table "public"."school_branding" to "service_role";

grant select on table "public"."school_branding" to "service_role";

grant trigger on table "public"."school_branding" to "service_role";

grant truncate on table "public"."school_branding" to "service_role";

grant update on table "public"."school_branding" to "service_role";

grant delete on table "public"."school_events" to "anon";

grant insert on table "public"."school_events" to "anon";

grant references on table "public"."school_events" to "anon";

grant select on table "public"."school_events" to "anon";

grant trigger on table "public"."school_events" to "anon";

grant truncate on table "public"."school_events" to "anon";

grant update on table "public"."school_events" to "anon";

grant delete on table "public"."school_events" to "authenticated";

grant insert on table "public"."school_events" to "authenticated";

grant references on table "public"."school_events" to "authenticated";

grant select on table "public"."school_events" to "authenticated";

grant trigger on table "public"."school_events" to "authenticated";

grant truncate on table "public"."school_events" to "authenticated";

grant update on table "public"."school_events" to "authenticated";

grant delete on table "public"."school_events" to "service_role";

grant insert on table "public"."school_events" to "service_role";

grant references on table "public"."school_events" to "service_role";

grant select on table "public"."school_events" to "service_role";

grant trigger on table "public"."school_events" to "service_role";

grant truncate on table "public"."school_events" to "service_role";

grant update on table "public"."school_events" to "service_role";

grant delete on table "public"."school_fee_structures" to "anon";

grant insert on table "public"."school_fee_structures" to "anon";

grant references on table "public"."school_fee_structures" to "anon";

grant select on table "public"."school_fee_structures" to "anon";

grant trigger on table "public"."school_fee_structures" to "anon";

grant truncate on table "public"."school_fee_structures" to "anon";

grant update on table "public"."school_fee_structures" to "anon";

grant delete on table "public"."school_fee_structures" to "authenticated";

grant insert on table "public"."school_fee_structures" to "authenticated";

grant references on table "public"."school_fee_structures" to "authenticated";

grant select on table "public"."school_fee_structures" to "authenticated";

grant trigger on table "public"."school_fee_structures" to "authenticated";

grant truncate on table "public"."school_fee_structures" to "authenticated";

grant update on table "public"."school_fee_structures" to "authenticated";

grant delete on table "public"."school_fee_structures" to "service_role";

grant insert on table "public"."school_fee_structures" to "service_role";

grant references on table "public"."school_fee_structures" to "service_role";

grant select on table "public"."school_fee_structures" to "service_role";

grant trigger on table "public"."school_fee_structures" to "service_role";

grant truncate on table "public"."school_fee_structures" to "service_role";

grant update on table "public"."school_fee_structures" to "service_role";

grant delete on table "public"."school_invitation_codes" to "anon";

grant insert on table "public"."school_invitation_codes" to "anon";

grant references on table "public"."school_invitation_codes" to "anon";

grant select on table "public"."school_invitation_codes" to "anon";

grant trigger on table "public"."school_invitation_codes" to "anon";

grant truncate on table "public"."school_invitation_codes" to "anon";

grant update on table "public"."school_invitation_codes" to "anon";

grant delete on table "public"."school_invitation_codes" to "authenticated";

grant insert on table "public"."school_invitation_codes" to "authenticated";

grant references on table "public"."school_invitation_codes" to "authenticated";

grant select on table "public"."school_invitation_codes" to "authenticated";

grant trigger on table "public"."school_invitation_codes" to "authenticated";

grant truncate on table "public"."school_invitation_codes" to "authenticated";

grant update on table "public"."school_invitation_codes" to "authenticated";

grant delete on table "public"."school_invitation_codes" to "service_role";

grant insert on table "public"."school_invitation_codes" to "service_role";

grant references on table "public"."school_invitation_codes" to "service_role";

grant select on table "public"."school_invitation_codes" to "service_role";

grant trigger on table "public"."school_invitation_codes" to "service_role";

grant truncate on table "public"."school_invitation_codes" to "service_role";

grant update on table "public"."school_invitation_codes" to "service_role";

grant delete on table "public"."school_settings" to "anon";

grant insert on table "public"."school_settings" to "anon";

grant references on table "public"."school_settings" to "anon";

grant select on table "public"."school_settings" to "anon";

grant trigger on table "public"."school_settings" to "anon";

grant truncate on table "public"."school_settings" to "anon";

grant update on table "public"."school_settings" to "anon";

grant delete on table "public"."school_settings" to "authenticated";

grant insert on table "public"."school_settings" to "authenticated";

grant references on table "public"."school_settings" to "authenticated";

grant select on table "public"."school_settings" to "authenticated";

grant trigger on table "public"."school_settings" to "authenticated";

grant truncate on table "public"."school_settings" to "authenticated";

grant update on table "public"."school_settings" to "authenticated";

grant delete on table "public"."school_settings" to "service_role";

grant insert on table "public"."school_settings" to "service_role";

grant references on table "public"."school_settings" to "service_role";

grant select on table "public"."school_settings" to "service_role";

grant trigger on table "public"."school_settings" to "service_role";

grant truncate on table "public"."school_settings" to "service_role";

grant update on table "public"."school_settings" to "service_role";

grant delete on table "public"."school_verifications" to "anon";

grant insert on table "public"."school_verifications" to "anon";

grant references on table "public"."school_verifications" to "anon";

grant select on table "public"."school_verifications" to "anon";

grant trigger on table "public"."school_verifications" to "anon";

grant truncate on table "public"."school_verifications" to "anon";

grant update on table "public"."school_verifications" to "anon";

grant delete on table "public"."school_verifications" to "authenticated";

grant insert on table "public"."school_verifications" to "authenticated";

grant references on table "public"."school_verifications" to "authenticated";

grant select on table "public"."school_verifications" to "authenticated";

grant trigger on table "public"."school_verifications" to "authenticated";

grant truncate on table "public"."school_verifications" to "authenticated";

grant update on table "public"."school_verifications" to "authenticated";

grant delete on table "public"."school_verifications" to "service_role";

grant insert on table "public"."school_verifications" to "service_role";

grant references on table "public"."school_verifications" to "service_role";

grant select on table "public"."school_verifications" to "service_role";

grant trigger on table "public"."school_verifications" to "service_role";

grant truncate on table "public"."school_verifications" to "service_role";

grant update on table "public"."school_verifications" to "service_role";

grant delete on table "public"."schools" to "anon";

grant insert on table "public"."schools" to "anon";

grant references on table "public"."schools" to "anon";

grant select on table "public"."schools" to "anon";

grant trigger on table "public"."schools" to "anon";

grant truncate on table "public"."schools" to "anon";

grant update on table "public"."schools" to "anon";

grant delete on table "public"."schools" to "authenticated";

grant insert on table "public"."schools" to "authenticated";

grant references on table "public"."schools" to "authenticated";

grant select on table "public"."schools" to "authenticated";

grant trigger on table "public"."schools" to "authenticated";

grant truncate on table "public"."schools" to "authenticated";

grant update on table "public"."schools" to "authenticated";

grant delete on table "public"."schools" to "service_role";

grant insert on table "public"."schools" to "service_role";

grant references on table "public"."schools" to "service_role";

grant select on table "public"."schools" to "service_role";

grant trigger on table "public"."schools" to "service_role";

grant truncate on table "public"."schools" to "service_role";

grant update on table "public"."schools" to "service_role";

grant delete on table "public"."seats" to "anon";

grant insert on table "public"."seats" to "anon";

grant references on table "public"."seats" to "anon";

grant select on table "public"."seats" to "anon";

grant trigger on table "public"."seats" to "anon";

grant truncate on table "public"."seats" to "anon";

grant update on table "public"."seats" to "anon";

grant delete on table "public"."seats" to "authenticated";

grant insert on table "public"."seats" to "authenticated";

grant references on table "public"."seats" to "authenticated";

grant select on table "public"."seats" to "authenticated";

grant trigger on table "public"."seats" to "authenticated";

grant truncate on table "public"."seats" to "authenticated";

grant update on table "public"."seats" to "authenticated";

grant delete on table "public"."seats" to "service_role";

grant insert on table "public"."seats" to "service_role";

grant references on table "public"."seats" to "service_role";

grant select on table "public"."seats" to "service_role";

grant trigger on table "public"."seats" to "service_role";

grant truncate on table "public"."seats" to "service_role";

grant update on table "public"."seats" to "service_role";

grant delete on table "public"."security_events" to "anon";

grant insert on table "public"."security_events" to "anon";

grant references on table "public"."security_events" to "anon";

grant select on table "public"."security_events" to "anon";

grant trigger on table "public"."security_events" to "anon";

grant truncate on table "public"."security_events" to "anon";

grant update on table "public"."security_events" to "anon";

grant delete on table "public"."security_events" to "authenticated";

grant insert on table "public"."security_events" to "authenticated";

grant references on table "public"."security_events" to "authenticated";

grant select on table "public"."security_events" to "authenticated";

grant trigger on table "public"."security_events" to "authenticated";

grant truncate on table "public"."security_events" to "authenticated";

grant update on table "public"."security_events" to "authenticated";

grant delete on table "public"."security_events" to "service_role";

grant insert on table "public"."security_events" to "service_role";

grant references on table "public"."security_events" to "service_role";

grant select on table "public"."security_events" to "service_role";

grant trigger on table "public"."security_events" to "service_role";

grant truncate on table "public"."security_events" to "service_role";

grant update on table "public"."security_events" to "service_role";

grant delete on table "public"."service_alert_config" to "anon";

grant insert on table "public"."service_alert_config" to "anon";

grant references on table "public"."service_alert_config" to "anon";

grant select on table "public"."service_alert_config" to "anon";

grant trigger on table "public"."service_alert_config" to "anon";

grant truncate on table "public"."service_alert_config" to "anon";

grant update on table "public"."service_alert_config" to "anon";

grant delete on table "public"."service_alert_config" to "authenticated";

grant insert on table "public"."service_alert_config" to "authenticated";

grant references on table "public"."service_alert_config" to "authenticated";

grant select on table "public"."service_alert_config" to "authenticated";

grant trigger on table "public"."service_alert_config" to "authenticated";

grant truncate on table "public"."service_alert_config" to "authenticated";

grant update on table "public"."service_alert_config" to "authenticated";

grant delete on table "public"."service_alert_config" to "service_role";

grant insert on table "public"."service_alert_config" to "service_role";

grant references on table "public"."service_alert_config" to "service_role";

grant select on table "public"."service_alert_config" to "service_role";

grant trigger on table "public"."service_alert_config" to "service_role";

grant truncate on table "public"."service_alert_config" to "service_role";

grant update on table "public"."service_alert_config" to "service_role";

grant delete on table "public"."service_alerts" to "anon";

grant insert on table "public"."service_alerts" to "anon";

grant references on table "public"."service_alerts" to "anon";

grant select on table "public"."service_alerts" to "anon";

grant trigger on table "public"."service_alerts" to "anon";

grant truncate on table "public"."service_alerts" to "anon";

grant update on table "public"."service_alerts" to "anon";

grant delete on table "public"."service_alerts" to "authenticated";

grant insert on table "public"."service_alerts" to "authenticated";

grant references on table "public"."service_alerts" to "authenticated";

grant select on table "public"."service_alerts" to "authenticated";

grant trigger on table "public"."service_alerts" to "authenticated";

grant truncate on table "public"."service_alerts" to "authenticated";

grant update on table "public"."service_alerts" to "authenticated";

grant delete on table "public"."service_alerts" to "service_role";

grant insert on table "public"."service_alerts" to "service_role";

grant references on table "public"."service_alerts" to "service_role";

grant select on table "public"."service_alerts" to "service_role";

grant trigger on table "public"."service_alerts" to "service_role";

grant truncate on table "public"."service_alerts" to "service_role";

grant update on table "public"."service_alerts" to "service_role";

grant delete on table "public"."service_api_keys" to "anon";

grant insert on table "public"."service_api_keys" to "anon";

grant references on table "public"."service_api_keys" to "anon";

grant select on table "public"."service_api_keys" to "anon";

grant trigger on table "public"."service_api_keys" to "anon";

grant truncate on table "public"."service_api_keys" to "anon";

grant update on table "public"."service_api_keys" to "anon";

grant delete on table "public"."service_api_keys" to "authenticated";

grant insert on table "public"."service_api_keys" to "authenticated";

grant references on table "public"."service_api_keys" to "authenticated";

grant select on table "public"."service_api_keys" to "authenticated";

grant trigger on table "public"."service_api_keys" to "authenticated";

grant truncate on table "public"."service_api_keys" to "authenticated";

grant update on table "public"."service_api_keys" to "authenticated";

grant delete on table "public"."service_api_keys" to "service_role";

grant insert on table "public"."service_api_keys" to "service_role";

grant references on table "public"."service_api_keys" to "service_role";

grant select on table "public"."service_api_keys" to "service_role";

grant trigger on table "public"."service_api_keys" to "service_role";

grant truncate on table "public"."service_api_keys" to "service_role";

grant update on table "public"."service_api_keys" to "service_role";

grant delete on table "public"."service_cost_tracking" to "anon";

grant insert on table "public"."service_cost_tracking" to "anon";

grant references on table "public"."service_cost_tracking" to "anon";

grant select on table "public"."service_cost_tracking" to "anon";

grant trigger on table "public"."service_cost_tracking" to "anon";

grant truncate on table "public"."service_cost_tracking" to "anon";

grant update on table "public"."service_cost_tracking" to "anon";

grant delete on table "public"."service_cost_tracking" to "authenticated";

grant insert on table "public"."service_cost_tracking" to "authenticated";

grant references on table "public"."service_cost_tracking" to "authenticated";

grant select on table "public"."service_cost_tracking" to "authenticated";

grant trigger on table "public"."service_cost_tracking" to "authenticated";

grant truncate on table "public"."service_cost_tracking" to "authenticated";

grant update on table "public"."service_cost_tracking" to "authenticated";

grant delete on table "public"."service_cost_tracking" to "service_role";

grant insert on table "public"."service_cost_tracking" to "service_role";

grant references on table "public"."service_cost_tracking" to "service_role";

grant select on table "public"."service_cost_tracking" to "service_role";

grant trigger on table "public"."service_cost_tracking" to "service_role";

grant truncate on table "public"."service_cost_tracking" to "service_role";

grant update on table "public"."service_cost_tracking" to "service_role";

grant delete on table "public"."service_health_status" to "anon";

grant insert on table "public"."service_health_status" to "anon";

grant references on table "public"."service_health_status" to "anon";

grant select on table "public"."service_health_status" to "anon";

grant trigger on table "public"."service_health_status" to "anon";

grant truncate on table "public"."service_health_status" to "anon";

grant update on table "public"."service_health_status" to "anon";

grant delete on table "public"."service_health_status" to "authenticated";

grant insert on table "public"."service_health_status" to "authenticated";

grant references on table "public"."service_health_status" to "authenticated";

grant select on table "public"."service_health_status" to "authenticated";

grant trigger on table "public"."service_health_status" to "authenticated";

grant truncate on table "public"."service_health_status" to "authenticated";

grant update on table "public"."service_health_status" to "authenticated";

grant delete on table "public"."service_health_status" to "service_role";

grant insert on table "public"."service_health_status" to "service_role";

grant references on table "public"."service_health_status" to "service_role";

grant select on table "public"."service_health_status" to "service_role";

grant trigger on table "public"."service_health_status" to "service_role";

grant truncate on table "public"."service_health_status" to "service_role";

grant update on table "public"."service_health_status" to "service_role";

grant delete on table "public"."service_incidents" to "anon";

grant insert on table "public"."service_incidents" to "anon";

grant references on table "public"."service_incidents" to "anon";

grant select on table "public"."service_incidents" to "anon";

grant trigger on table "public"."service_incidents" to "anon";

grant truncate on table "public"."service_incidents" to "anon";

grant update on table "public"."service_incidents" to "anon";

grant delete on table "public"."service_incidents" to "authenticated";

grant insert on table "public"."service_incidents" to "authenticated";

grant references on table "public"."service_incidents" to "authenticated";

grant select on table "public"."service_incidents" to "authenticated";

grant trigger on table "public"."service_incidents" to "authenticated";

grant truncate on table "public"."service_incidents" to "authenticated";

grant update on table "public"."service_incidents" to "authenticated";

grant delete on table "public"."service_incidents" to "service_role";

grant insert on table "public"."service_incidents" to "service_role";

grant references on table "public"."service_incidents" to "service_role";

grant select on table "public"."service_incidents" to "service_role";

grant trigger on table "public"."service_incidents" to "service_role";

grant truncate on table "public"."service_incidents" to "service_role";

grant update on table "public"."service_incidents" to "service_role";

grant delete on table "public"."service_usage_limits" to "anon";

grant insert on table "public"."service_usage_limits" to "anon";

grant references on table "public"."service_usage_limits" to "anon";

grant select on table "public"."service_usage_limits" to "anon";

grant trigger on table "public"."service_usage_limits" to "anon";

grant truncate on table "public"."service_usage_limits" to "anon";

grant update on table "public"."service_usage_limits" to "anon";

grant delete on table "public"."service_usage_limits" to "authenticated";

grant insert on table "public"."service_usage_limits" to "authenticated";

grant references on table "public"."service_usage_limits" to "authenticated";

grant select on table "public"."service_usage_limits" to "authenticated";

grant trigger on table "public"."service_usage_limits" to "authenticated";

grant truncate on table "public"."service_usage_limits" to "authenticated";

grant update on table "public"."service_usage_limits" to "authenticated";

grant delete on table "public"."service_usage_limits" to "service_role";

grant insert on table "public"."service_usage_limits" to "service_role";

grant references on table "public"."service_usage_limits" to "service_role";

grant select on table "public"."service_usage_limits" to "service_role";

grant trigger on table "public"."service_usage_limits" to "service_role";

grant truncate on table "public"."service_usage_limits" to "service_role";

grant update on table "public"."service_usage_limits" to "service_role";

grant delete on table "public"."sms_messages" to "anon";

grant insert on table "public"."sms_messages" to "anon";

grant references on table "public"."sms_messages" to "anon";

grant select on table "public"."sms_messages" to "anon";

grant trigger on table "public"."sms_messages" to "anon";

grant truncate on table "public"."sms_messages" to "anon";

grant update on table "public"."sms_messages" to "anon";

grant delete on table "public"."sms_messages" to "authenticated";

grant insert on table "public"."sms_messages" to "authenticated";

grant references on table "public"."sms_messages" to "authenticated";

grant select on table "public"."sms_messages" to "authenticated";

grant trigger on table "public"."sms_messages" to "authenticated";

grant truncate on table "public"."sms_messages" to "authenticated";

grant update on table "public"."sms_messages" to "authenticated";

grant delete on table "public"."sms_messages" to "service_role";

grant insert on table "public"."sms_messages" to "service_role";

grant references on table "public"."sms_messages" to "service_role";

grant select on table "public"."sms_messages" to "service_role";

grant trigger on table "public"."sms_messages" to "service_role";

grant truncate on table "public"."sms_messages" to "service_role";

grant update on table "public"."sms_messages" to "service_role";

grant delete on table "public"."sms_opt_outs" to "anon";

grant insert on table "public"."sms_opt_outs" to "anon";

grant references on table "public"."sms_opt_outs" to "anon";

grant select on table "public"."sms_opt_outs" to "anon";

grant trigger on table "public"."sms_opt_outs" to "anon";

grant truncate on table "public"."sms_opt_outs" to "anon";

grant update on table "public"."sms_opt_outs" to "anon";

grant delete on table "public"."sms_opt_outs" to "authenticated";

grant insert on table "public"."sms_opt_outs" to "authenticated";

grant references on table "public"."sms_opt_outs" to "authenticated";

grant select on table "public"."sms_opt_outs" to "authenticated";

grant trigger on table "public"."sms_opt_outs" to "authenticated";

grant truncate on table "public"."sms_opt_outs" to "authenticated";

grant update on table "public"."sms_opt_outs" to "authenticated";

grant delete on table "public"."sms_opt_outs" to "service_role";

grant insert on table "public"."sms_opt_outs" to "service_role";

grant references on table "public"."sms_opt_outs" to "service_role";

grant select on table "public"."sms_opt_outs" to "service_role";

grant trigger on table "public"."sms_opt_outs" to "service_role";

grant truncate on table "public"."sms_opt_outs" to "service_role";

grant update on table "public"."sms_opt_outs" to "service_role";

grant delete on table "public"."sound_alert_settings" to "anon";

grant insert on table "public"."sound_alert_settings" to "anon";

grant references on table "public"."sound_alert_settings" to "anon";

grant select on table "public"."sound_alert_settings" to "anon";

grant trigger on table "public"."sound_alert_settings" to "anon";

grant truncate on table "public"."sound_alert_settings" to "anon";

grant update on table "public"."sound_alert_settings" to "anon";

grant delete on table "public"."sound_alert_settings" to "authenticated";

grant insert on table "public"."sound_alert_settings" to "authenticated";

grant references on table "public"."sound_alert_settings" to "authenticated";

grant select on table "public"."sound_alert_settings" to "authenticated";

grant trigger on table "public"."sound_alert_settings" to "authenticated";

grant truncate on table "public"."sound_alert_settings" to "authenticated";

grant update on table "public"."sound_alert_settings" to "authenticated";

grant delete on table "public"."sound_alert_settings" to "service_role";

grant insert on table "public"."sound_alert_settings" to "service_role";

grant references on table "public"."sound_alert_settings" to "service_role";

grant select on table "public"."sound_alert_settings" to "service_role";

grant trigger on table "public"."sound_alert_settings" to "service_role";

grant truncate on table "public"."sound_alert_settings" to "service_role";

grant update on table "public"."sound_alert_settings" to "service_role";

grant delete on table "public"."spatial_ref_sys" to "anon";

grant insert on table "public"."spatial_ref_sys" to "anon";

grant references on table "public"."spatial_ref_sys" to "anon";

grant select on table "public"."spatial_ref_sys" to "anon";

grant trigger on table "public"."spatial_ref_sys" to "anon";

grant truncate on table "public"."spatial_ref_sys" to "anon";

grant update on table "public"."spatial_ref_sys" to "anon";

grant delete on table "public"."spatial_ref_sys" to "authenticated";

grant insert on table "public"."spatial_ref_sys" to "authenticated";

grant references on table "public"."spatial_ref_sys" to "authenticated";

grant select on table "public"."spatial_ref_sys" to "authenticated";

grant trigger on table "public"."spatial_ref_sys" to "authenticated";

grant truncate on table "public"."spatial_ref_sys" to "authenticated";

grant update on table "public"."spatial_ref_sys" to "authenticated";

grant delete on table "public"."spatial_ref_sys" to "postgres";

grant insert on table "public"."spatial_ref_sys" to "postgres";

grant references on table "public"."spatial_ref_sys" to "postgres";

grant select on table "public"."spatial_ref_sys" to "postgres";

grant trigger on table "public"."spatial_ref_sys" to "postgres";

grant truncate on table "public"."spatial_ref_sys" to "postgres";

grant update on table "public"."spatial_ref_sys" to "postgres";

grant delete on table "public"."spatial_ref_sys" to "service_role";

grant insert on table "public"."spatial_ref_sys" to "service_role";

grant references on table "public"."spatial_ref_sys" to "service_role";

grant select on table "public"."spatial_ref_sys" to "service_role";

grant trigger on table "public"."spatial_ref_sys" to "service_role";

grant truncate on table "public"."spatial_ref_sys" to "service_role";

grant update on table "public"."spatial_ref_sys" to "service_role";

grant delete on table "public"."standalone_users" to "anon";

grant insert on table "public"."standalone_users" to "anon";

grant references on table "public"."standalone_users" to "anon";

grant select on table "public"."standalone_users" to "anon";

grant trigger on table "public"."standalone_users" to "anon";

grant truncate on table "public"."standalone_users" to "anon";

grant update on table "public"."standalone_users" to "anon";

grant delete on table "public"."standalone_users" to "authenticated";

grant insert on table "public"."standalone_users" to "authenticated";

grant references on table "public"."standalone_users" to "authenticated";

grant select on table "public"."standalone_users" to "authenticated";

grant trigger on table "public"."standalone_users" to "authenticated";

grant truncate on table "public"."standalone_users" to "authenticated";

grant update on table "public"."standalone_users" to "authenticated";

grant delete on table "public"."standalone_users" to "service_role";

grant insert on table "public"."standalone_users" to "service_role";

grant references on table "public"."standalone_users" to "service_role";

grant select on table "public"."standalone_users" to "service_role";

grant trigger on table "public"."standalone_users" to "service_role";

grant truncate on table "public"."standalone_users" to "service_role";

grant update on table "public"."standalone_users" to "service_role";

grant delete on table "public"."stem_progress" to "anon";

grant insert on table "public"."stem_progress" to "anon";

grant references on table "public"."stem_progress" to "anon";

grant select on table "public"."stem_progress" to "anon";

grant trigger on table "public"."stem_progress" to "anon";

grant truncate on table "public"."stem_progress" to "anon";

grant update on table "public"."stem_progress" to "anon";

grant delete on table "public"."stem_progress" to "authenticated";

grant insert on table "public"."stem_progress" to "authenticated";

grant references on table "public"."stem_progress" to "authenticated";

grant select on table "public"."stem_progress" to "authenticated";

grant trigger on table "public"."stem_progress" to "authenticated";

grant truncate on table "public"."stem_progress" to "authenticated";

grant update on table "public"."stem_progress" to "authenticated";

grant delete on table "public"."stem_progress" to "service_role";

grant insert on table "public"."stem_progress" to "service_role";

grant references on table "public"."stem_progress" to "service_role";

grant select on table "public"."stem_progress" to "service_role";

grant trigger on table "public"."stem_progress" to "service_role";

grant truncate on table "public"."stem_progress" to "service_role";

grant update on table "public"."stem_progress" to "service_role";

grant delete on table "public"."student_achievements" to "anon";

grant insert on table "public"."student_achievements" to "anon";

grant references on table "public"."student_achievements" to "anon";

grant select on table "public"."student_achievements" to "anon";

grant trigger on table "public"."student_achievements" to "anon";

grant truncate on table "public"."student_achievements" to "anon";

grant update on table "public"."student_achievements" to "anon";

grant delete on table "public"."student_achievements" to "authenticated";

grant insert on table "public"."student_achievements" to "authenticated";

grant references on table "public"."student_achievements" to "authenticated";

grant select on table "public"."student_achievements" to "authenticated";

grant trigger on table "public"."student_achievements" to "authenticated";

grant truncate on table "public"."student_achievements" to "authenticated";

grant update on table "public"."student_achievements" to "authenticated";

grant delete on table "public"."student_achievements" to "service_role";

grant insert on table "public"."student_achievements" to "service_role";

grant references on table "public"."student_achievements" to "service_role";

grant select on table "public"."student_achievements" to "service_role";

grant trigger on table "public"."student_achievements" to "service_role";

grant truncate on table "public"."student_achievements" to "service_role";

grant update on table "public"."student_achievements" to "service_role";

grant delete on table "public"."student_enrollments" to "anon";

grant insert on table "public"."student_enrollments" to "anon";

grant references on table "public"."student_enrollments" to "anon";

grant select on table "public"."student_enrollments" to "anon";

grant trigger on table "public"."student_enrollments" to "anon";

grant truncate on table "public"."student_enrollments" to "anon";

grant update on table "public"."student_enrollments" to "anon";

grant delete on table "public"."student_enrollments" to "authenticated";

grant insert on table "public"."student_enrollments" to "authenticated";

grant references on table "public"."student_enrollments" to "authenticated";

grant select on table "public"."student_enrollments" to "authenticated";

grant trigger on table "public"."student_enrollments" to "authenticated";

grant truncate on table "public"."student_enrollments" to "authenticated";

grant update on table "public"."student_enrollments" to "authenticated";

grant delete on table "public"."student_enrollments" to "service_role";

grant insert on table "public"."student_enrollments" to "service_role";

grant references on table "public"."student_enrollments" to "service_role";

grant select on table "public"."student_enrollments" to "service_role";

grant trigger on table "public"."student_enrollments" to "service_role";

grant truncate on table "public"."student_enrollments" to "service_role";

grant update on table "public"."student_enrollments" to "service_role";

grant delete on table "public"."student_fee_assignments" to "anon";

grant insert on table "public"."student_fee_assignments" to "anon";

grant references on table "public"."student_fee_assignments" to "anon";

grant select on table "public"."student_fee_assignments" to "anon";

grant trigger on table "public"."student_fee_assignments" to "anon";

grant truncate on table "public"."student_fee_assignments" to "anon";

grant update on table "public"."student_fee_assignments" to "anon";

grant delete on table "public"."student_fee_assignments" to "authenticated";

grant insert on table "public"."student_fee_assignments" to "authenticated";

grant references on table "public"."student_fee_assignments" to "authenticated";

grant select on table "public"."student_fee_assignments" to "authenticated";

grant trigger on table "public"."student_fee_assignments" to "authenticated";

grant truncate on table "public"."student_fee_assignments" to "authenticated";

grant update on table "public"."student_fee_assignments" to "authenticated";

grant delete on table "public"."student_fee_assignments" to "service_role";

grant insert on table "public"."student_fee_assignments" to "service_role";

grant references on table "public"."student_fee_assignments" to "service_role";

grant select on table "public"."student_fee_assignments" to "service_role";

grant trigger on table "public"."student_fee_assignments" to "service_role";

grant truncate on table "public"."student_fee_assignments" to "service_role";

grant update on table "public"."student_fee_assignments" to "service_role";

grant delete on table "public"."student_groups" to "anon";

grant insert on table "public"."student_groups" to "anon";

grant references on table "public"."student_groups" to "anon";

grant select on table "public"."student_groups" to "anon";

grant trigger on table "public"."student_groups" to "anon";

grant truncate on table "public"."student_groups" to "anon";

grant update on table "public"."student_groups" to "anon";

grant delete on table "public"."student_groups" to "authenticated";

grant insert on table "public"."student_groups" to "authenticated";

grant references on table "public"."student_groups" to "authenticated";

grant select on table "public"."student_groups" to "authenticated";

grant trigger on table "public"."student_groups" to "authenticated";

grant truncate on table "public"."student_groups" to "authenticated";

grant update on table "public"."student_groups" to "authenticated";

grant delete on table "public"."student_groups" to "service_role";

grant insert on table "public"."student_groups" to "service_role";

grant references on table "public"."student_groups" to "service_role";

grant select on table "public"."student_groups" to "service_role";

grant trigger on table "public"."student_groups" to "service_role";

grant truncate on table "public"."student_groups" to "service_role";

grant update on table "public"."student_groups" to "service_role";

grant delete on table "public"."student_parent_relationships" to "anon";

grant insert on table "public"."student_parent_relationships" to "anon";

grant references on table "public"."student_parent_relationships" to "anon";

grant select on table "public"."student_parent_relationships" to "anon";

grant trigger on table "public"."student_parent_relationships" to "anon";

grant truncate on table "public"."student_parent_relationships" to "anon";

grant update on table "public"."student_parent_relationships" to "anon";

grant delete on table "public"."student_parent_relationships" to "authenticated";

grant insert on table "public"."student_parent_relationships" to "authenticated";

grant references on table "public"."student_parent_relationships" to "authenticated";

grant select on table "public"."student_parent_relationships" to "authenticated";

grant trigger on table "public"."student_parent_relationships" to "authenticated";

grant truncate on table "public"."student_parent_relationships" to "authenticated";

grant update on table "public"."student_parent_relationships" to "authenticated";

grant delete on table "public"."student_parent_relationships" to "service_role";

grant insert on table "public"."student_parent_relationships" to "service_role";

grant references on table "public"."student_parent_relationships" to "service_role";

grant select on table "public"."student_parent_relationships" to "service_role";

grant trigger on table "public"."student_parent_relationships" to "service_role";

grant truncate on table "public"."student_parent_relationships" to "service_role";

grant update on table "public"."student_parent_relationships" to "service_role";

grant delete on table "public"."student_progress" to "anon";

grant insert on table "public"."student_progress" to "anon";

grant references on table "public"."student_progress" to "anon";

grant select on table "public"."student_progress" to "anon";

grant trigger on table "public"."student_progress" to "anon";

grant truncate on table "public"."student_progress" to "anon";

grant update on table "public"."student_progress" to "anon";

grant delete on table "public"."student_progress" to "authenticated";

grant insert on table "public"."student_progress" to "authenticated";

grant references on table "public"."student_progress" to "authenticated";

grant select on table "public"."student_progress" to "authenticated";

grant trigger on table "public"."student_progress" to "authenticated";

grant truncate on table "public"."student_progress" to "authenticated";

grant update on table "public"."student_progress" to "authenticated";

grant delete on table "public"."student_progress" to "service_role";

grant insert on table "public"."student_progress" to "service_role";

grant references on table "public"."student_progress" to "service_role";

grant select on table "public"."student_progress" to "service_role";

grant trigger on table "public"."student_progress" to "service_role";

grant truncate on table "public"."student_progress" to "service_role";

grant update on table "public"."student_progress" to "service_role";

grant delete on table "public"."student_streaks" to "anon";

grant insert on table "public"."student_streaks" to "anon";

grant references on table "public"."student_streaks" to "anon";

grant select on table "public"."student_streaks" to "anon";

grant trigger on table "public"."student_streaks" to "anon";

grant truncate on table "public"."student_streaks" to "anon";

grant update on table "public"."student_streaks" to "anon";

grant delete on table "public"."student_streaks" to "authenticated";

grant insert on table "public"."student_streaks" to "authenticated";

grant references on table "public"."student_streaks" to "authenticated";

grant select on table "public"."student_streaks" to "authenticated";

grant trigger on table "public"."student_streaks" to "authenticated";

grant truncate on table "public"."student_streaks" to "authenticated";

grant update on table "public"."student_streaks" to "authenticated";

grant delete on table "public"."student_streaks" to "service_role";

grant insert on table "public"."student_streaks" to "service_role";

grant references on table "public"."student_streaks" to "service_role";

grant select on table "public"."student_streaks" to "service_role";

grant trigger on table "public"."student_streaks" to "service_role";

grant truncate on table "public"."student_streaks" to "service_role";

grant update on table "public"."student_streaks" to "service_role";

grant delete on table "public"."study_groups" to "anon";

grant insert on table "public"."study_groups" to "anon";

grant references on table "public"."study_groups" to "anon";

grant select on table "public"."study_groups" to "anon";

grant trigger on table "public"."study_groups" to "anon";

grant truncate on table "public"."study_groups" to "anon";

grant update on table "public"."study_groups" to "anon";

grant delete on table "public"."study_groups" to "authenticated";

grant insert on table "public"."study_groups" to "authenticated";

grant references on table "public"."study_groups" to "authenticated";

grant select on table "public"."study_groups" to "authenticated";

grant trigger on table "public"."study_groups" to "authenticated";

grant truncate on table "public"."study_groups" to "authenticated";

grant update on table "public"."study_groups" to "authenticated";

grant delete on table "public"."study_groups" to "service_role";

grant insert on table "public"."study_groups" to "service_role";

grant references on table "public"."study_groups" to "service_role";

grant select on table "public"."study_groups" to "service_role";

grant trigger on table "public"."study_groups" to "service_role";

grant truncate on table "public"."study_groups" to "service_role";

grant update on table "public"."study_groups" to "service_role";

grant delete on table "public"."submissions" to "anon";

grant insert on table "public"."submissions" to "anon";

grant references on table "public"."submissions" to "anon";

grant select on table "public"."submissions" to "anon";

grant trigger on table "public"."submissions" to "anon";

grant truncate on table "public"."submissions" to "anon";

grant update on table "public"."submissions" to "anon";

grant delete on table "public"."submissions" to "authenticated";

grant insert on table "public"."submissions" to "authenticated";

grant references on table "public"."submissions" to "authenticated";

grant select on table "public"."submissions" to "authenticated";

grant trigger on table "public"."submissions" to "authenticated";

grant truncate on table "public"."submissions" to "authenticated";

grant update on table "public"."submissions" to "authenticated";

grant delete on table "public"."submissions" to "service_role";

grant insert on table "public"."submissions" to "service_role";

grant references on table "public"."submissions" to "service_role";

grant select on table "public"."submissions" to "service_role";

grant trigger on table "public"."submissions" to "service_role";

grant truncate on table "public"."submissions" to "service_role";

grant update on table "public"."submissions" to "service_role";

grant delete on table "public"."subscription_plans" to "anon";

grant insert on table "public"."subscription_plans" to "anon";

grant references on table "public"."subscription_plans" to "anon";

grant select on table "public"."subscription_plans" to "anon";

grant trigger on table "public"."subscription_plans" to "anon";

grant truncate on table "public"."subscription_plans" to "anon";

grant update on table "public"."subscription_plans" to "anon";

grant delete on table "public"."subscription_plans" to "authenticated";

grant insert on table "public"."subscription_plans" to "authenticated";

grant references on table "public"."subscription_plans" to "authenticated";

grant select on table "public"."subscription_plans" to "authenticated";

grant trigger on table "public"."subscription_plans" to "authenticated";

grant truncate on table "public"."subscription_plans" to "authenticated";

grant update on table "public"."subscription_plans" to "authenticated";

grant delete on table "public"."subscription_plans" to "service_role";

grant insert on table "public"."subscription_plans" to "service_role";

grant references on table "public"."subscription_plans" to "service_role";

grant select on table "public"."subscription_plans" to "service_role";

grant trigger on table "public"."subscription_plans" to "service_role";

grant truncate on table "public"."subscription_plans" to "service_role";

grant update on table "public"."subscription_plans" to "service_role";

grant delete on table "public"."subscription_seats" to "anon";

grant insert on table "public"."subscription_seats" to "anon";

grant references on table "public"."subscription_seats" to "anon";

grant select on table "public"."subscription_seats" to "anon";

grant trigger on table "public"."subscription_seats" to "anon";

grant truncate on table "public"."subscription_seats" to "anon";

grant update on table "public"."subscription_seats" to "anon";

grant delete on table "public"."subscription_seats" to "authenticated";

grant insert on table "public"."subscription_seats" to "authenticated";

grant references on table "public"."subscription_seats" to "authenticated";

grant select on table "public"."subscription_seats" to "authenticated";

grant trigger on table "public"."subscription_seats" to "authenticated";

grant truncate on table "public"."subscription_seats" to "authenticated";

grant update on table "public"."subscription_seats" to "authenticated";

grant delete on table "public"."subscription_seats" to "service_role";

grant insert on table "public"."subscription_seats" to "service_role";

grant references on table "public"."subscription_seats" to "service_role";

grant select on table "public"."subscription_seats" to "service_role";

grant trigger on table "public"."subscription_seats" to "service_role";

grant truncate on table "public"."subscription_seats" to "service_role";

grant update on table "public"."subscription_seats" to "service_role";

grant delete on table "public"."subscription_usage" to "anon";

grant insert on table "public"."subscription_usage" to "anon";

grant references on table "public"."subscription_usage" to "anon";

grant select on table "public"."subscription_usage" to "anon";

grant trigger on table "public"."subscription_usage" to "anon";

grant truncate on table "public"."subscription_usage" to "anon";

grant update on table "public"."subscription_usage" to "anon";

grant delete on table "public"."subscription_usage" to "authenticated";

grant insert on table "public"."subscription_usage" to "authenticated";

grant references on table "public"."subscription_usage" to "authenticated";

grant select on table "public"."subscription_usage" to "authenticated";

grant trigger on table "public"."subscription_usage" to "authenticated";

grant truncate on table "public"."subscription_usage" to "authenticated";

grant update on table "public"."subscription_usage" to "authenticated";

grant delete on table "public"."subscription_usage" to "service_role";

grant insert on table "public"."subscription_usage" to "service_role";

grant references on table "public"."subscription_usage" to "service_role";

grant select on table "public"."subscription_usage" to "service_role";

grant trigger on table "public"."subscription_usage" to "service_role";

grant truncate on table "public"."subscription_usage" to "service_role";

grant update on table "public"."subscription_usage" to "service_role";

grant delete on table "public"."subscriptions" to "anon";

grant insert on table "public"."subscriptions" to "anon";

grant references on table "public"."subscriptions" to "anon";

grant select on table "public"."subscriptions" to "anon";

grant trigger on table "public"."subscriptions" to "anon";

grant truncate on table "public"."subscriptions" to "anon";

grant update on table "public"."subscriptions" to "anon";

grant delete on table "public"."subscriptions" to "authenticated";

grant insert on table "public"."subscriptions" to "authenticated";

grant references on table "public"."subscriptions" to "authenticated";

grant select on table "public"."subscriptions" to "authenticated";

grant trigger on table "public"."subscriptions" to "authenticated";

grant truncate on table "public"."subscriptions" to "authenticated";

grant update on table "public"."subscriptions" to "authenticated";

grant delete on table "public"."subscriptions" to "service_role";

grant insert on table "public"."subscriptions" to "service_role";

grant references on table "public"."subscriptions" to "service_role";

grant select on table "public"."subscriptions" to "service_role";

grant trigger on table "public"."subscriptions" to "service_role";

grant truncate on table "public"."subscriptions" to "service_role";

grant update on table "public"."subscriptions" to "service_role";

grant delete on table "public"."superadmin_agent_executions" to "anon";

grant insert on table "public"."superadmin_agent_executions" to "anon";

grant references on table "public"."superadmin_agent_executions" to "anon";

grant select on table "public"."superadmin_agent_executions" to "anon";

grant trigger on table "public"."superadmin_agent_executions" to "anon";

grant truncate on table "public"."superadmin_agent_executions" to "anon";

grant update on table "public"."superadmin_agent_executions" to "anon";

grant delete on table "public"."superadmin_agent_executions" to "authenticated";

grant insert on table "public"."superadmin_agent_executions" to "authenticated";

grant references on table "public"."superadmin_agent_executions" to "authenticated";

grant select on table "public"."superadmin_agent_executions" to "authenticated";

grant trigger on table "public"."superadmin_agent_executions" to "authenticated";

grant truncate on table "public"."superadmin_agent_executions" to "authenticated";

grant update on table "public"."superadmin_agent_executions" to "authenticated";

grant delete on table "public"."superadmin_agent_executions" to "service_role";

grant insert on table "public"."superadmin_agent_executions" to "service_role";

grant references on table "public"."superadmin_agent_executions" to "service_role";

grant select on table "public"."superadmin_agent_executions" to "service_role";

grant trigger on table "public"."superadmin_agent_executions" to "service_role";

grant truncate on table "public"."superadmin_agent_executions" to "service_role";

grant update on table "public"."superadmin_agent_executions" to "service_role";

grant delete on table "public"."superadmin_ai_agents" to "anon";

grant insert on table "public"."superadmin_ai_agents" to "anon";

grant references on table "public"."superadmin_ai_agents" to "anon";

grant select on table "public"."superadmin_ai_agents" to "anon";

grant trigger on table "public"."superadmin_ai_agents" to "anon";

grant truncate on table "public"."superadmin_ai_agents" to "anon";

grant update on table "public"."superadmin_ai_agents" to "anon";

grant delete on table "public"."superadmin_ai_agents" to "authenticated";

grant insert on table "public"."superadmin_ai_agents" to "authenticated";

grant references on table "public"."superadmin_ai_agents" to "authenticated";

grant select on table "public"."superadmin_ai_agents" to "authenticated";

grant trigger on table "public"."superadmin_ai_agents" to "authenticated";

grant truncate on table "public"."superadmin_ai_agents" to "authenticated";

grant update on table "public"."superadmin_ai_agents" to "authenticated";

grant delete on table "public"."superadmin_ai_agents" to "service_role";

grant insert on table "public"."superadmin_ai_agents" to "service_role";

grant references on table "public"."superadmin_ai_agents" to "service_role";

grant select on table "public"."superadmin_ai_agents" to "service_role";

grant trigger on table "public"."superadmin_ai_agents" to "service_role";

grant truncate on table "public"."superadmin_ai_agents" to "service_role";

grant update on table "public"."superadmin_ai_agents" to "service_role";

grant delete on table "public"."superadmin_audit_log" to "anon";

grant insert on table "public"."superadmin_audit_log" to "anon";

grant references on table "public"."superadmin_audit_log" to "anon";

grant select on table "public"."superadmin_audit_log" to "anon";

grant trigger on table "public"."superadmin_audit_log" to "anon";

grant truncate on table "public"."superadmin_audit_log" to "anon";

grant update on table "public"."superadmin_audit_log" to "anon";

grant delete on table "public"."superadmin_audit_log" to "authenticated";

grant insert on table "public"."superadmin_audit_log" to "authenticated";

grant references on table "public"."superadmin_audit_log" to "authenticated";

grant select on table "public"."superadmin_audit_log" to "authenticated";

grant trigger on table "public"."superadmin_audit_log" to "authenticated";

grant truncate on table "public"."superadmin_audit_log" to "authenticated";

grant update on table "public"."superadmin_audit_log" to "authenticated";

grant delete on table "public"."superadmin_audit_log" to "service_role";

grant insert on table "public"."superadmin_audit_log" to "service_role";

grant references on table "public"."superadmin_audit_log" to "service_role";

grant select on table "public"."superadmin_audit_log" to "service_role";

grant trigger on table "public"."superadmin_audit_log" to "service_role";

grant truncate on table "public"."superadmin_audit_log" to "service_role";

grant update on table "public"."superadmin_audit_log" to "service_role";

grant delete on table "public"."superadmin_autonomous_tasks" to "anon";

grant insert on table "public"."superadmin_autonomous_tasks" to "anon";

grant references on table "public"."superadmin_autonomous_tasks" to "anon";

grant select on table "public"."superadmin_autonomous_tasks" to "anon";

grant trigger on table "public"."superadmin_autonomous_tasks" to "anon";

grant truncate on table "public"."superadmin_autonomous_tasks" to "anon";

grant update on table "public"."superadmin_autonomous_tasks" to "anon";

grant delete on table "public"."superadmin_autonomous_tasks" to "authenticated";

grant insert on table "public"."superadmin_autonomous_tasks" to "authenticated";

grant references on table "public"."superadmin_autonomous_tasks" to "authenticated";

grant select on table "public"."superadmin_autonomous_tasks" to "authenticated";

grant trigger on table "public"."superadmin_autonomous_tasks" to "authenticated";

grant truncate on table "public"."superadmin_autonomous_tasks" to "authenticated";

grant update on table "public"."superadmin_autonomous_tasks" to "authenticated";

grant delete on table "public"."superadmin_autonomous_tasks" to "service_role";

grant insert on table "public"."superadmin_autonomous_tasks" to "service_role";

grant references on table "public"."superadmin_autonomous_tasks" to "service_role";

grant select on table "public"."superadmin_autonomous_tasks" to "service_role";

grant trigger on table "public"."superadmin_autonomous_tasks" to "service_role";

grant truncate on table "public"."superadmin_autonomous_tasks" to "service_role";

grant update on table "public"."superadmin_autonomous_tasks" to "service_role";

grant delete on table "public"."superadmin_command_log" to "anon";

grant insert on table "public"."superadmin_command_log" to "anon";

grant references on table "public"."superadmin_command_log" to "anon";

grant select on table "public"."superadmin_command_log" to "anon";

grant trigger on table "public"."superadmin_command_log" to "anon";

grant truncate on table "public"."superadmin_command_log" to "anon";

grant update on table "public"."superadmin_command_log" to "anon";

grant delete on table "public"."superadmin_command_log" to "authenticated";

grant insert on table "public"."superadmin_command_log" to "authenticated";

grant references on table "public"."superadmin_command_log" to "authenticated";

grant select on table "public"."superadmin_command_log" to "authenticated";

grant trigger on table "public"."superadmin_command_log" to "authenticated";

grant truncate on table "public"."superadmin_command_log" to "authenticated";

grant update on table "public"."superadmin_command_log" to "authenticated";

grant delete on table "public"."superadmin_command_log" to "service_role";

grant insert on table "public"."superadmin_command_log" to "service_role";

grant references on table "public"."superadmin_command_log" to "service_role";

grant select on table "public"."superadmin_command_log" to "service_role";

grant trigger on table "public"."superadmin_command_log" to "service_role";

grant truncate on table "public"."superadmin_command_log" to "service_role";

grant update on table "public"."superadmin_command_log" to "service_role";

grant delete on table "public"."superadmin_compliance_reports" to "anon";

grant insert on table "public"."superadmin_compliance_reports" to "anon";

grant references on table "public"."superadmin_compliance_reports" to "anon";

grant select on table "public"."superadmin_compliance_reports" to "anon";

grant trigger on table "public"."superadmin_compliance_reports" to "anon";

grant truncate on table "public"."superadmin_compliance_reports" to "anon";

grant update on table "public"."superadmin_compliance_reports" to "anon";

grant delete on table "public"."superadmin_compliance_reports" to "authenticated";

grant insert on table "public"."superadmin_compliance_reports" to "authenticated";

grant references on table "public"."superadmin_compliance_reports" to "authenticated";

grant select on table "public"."superadmin_compliance_reports" to "authenticated";

grant trigger on table "public"."superadmin_compliance_reports" to "authenticated";

grant truncate on table "public"."superadmin_compliance_reports" to "authenticated";

grant update on table "public"."superadmin_compliance_reports" to "authenticated";

grant delete on table "public"."superadmin_compliance_reports" to "service_role";

grant insert on table "public"."superadmin_compliance_reports" to "service_role";

grant references on table "public"."superadmin_compliance_reports" to "service_role";

grant select on table "public"."superadmin_compliance_reports" to "service_role";

grant trigger on table "public"."superadmin_compliance_reports" to "service_role";

grant truncate on table "public"."superadmin_compliance_reports" to "service_role";

grant update on table "public"."superadmin_compliance_reports" to "service_role";

grant delete on table "public"."superadmin_integrations" to "anon";

grant insert on table "public"."superadmin_integrations" to "anon";

grant references on table "public"."superadmin_integrations" to "anon";

grant select on table "public"."superadmin_integrations" to "anon";

grant trigger on table "public"."superadmin_integrations" to "anon";

grant truncate on table "public"."superadmin_integrations" to "anon";

grant update on table "public"."superadmin_integrations" to "anon";

grant delete on table "public"."superadmin_integrations" to "authenticated";

grant insert on table "public"."superadmin_integrations" to "authenticated";

grant references on table "public"."superadmin_integrations" to "authenticated";

grant select on table "public"."superadmin_integrations" to "authenticated";

grant trigger on table "public"."superadmin_integrations" to "authenticated";

grant truncate on table "public"."superadmin_integrations" to "authenticated";

grant update on table "public"."superadmin_integrations" to "authenticated";

grant delete on table "public"."superadmin_integrations" to "service_role";

grant insert on table "public"."superadmin_integrations" to "service_role";

grant references on table "public"."superadmin_integrations" to "service_role";

grant select on table "public"."superadmin_integrations" to "service_role";

grant trigger on table "public"."superadmin_integrations" to "service_role";

grant truncate on table "public"."superadmin_integrations" to "service_role";

grant update on table "public"."superadmin_integrations" to "service_role";

grant delete on table "public"."superadmin_notification_deliveries" to "anon";

grant insert on table "public"."superadmin_notification_deliveries" to "anon";

grant references on table "public"."superadmin_notification_deliveries" to "anon";

grant select on table "public"."superadmin_notification_deliveries" to "anon";

grant trigger on table "public"."superadmin_notification_deliveries" to "anon";

grant truncate on table "public"."superadmin_notification_deliveries" to "anon";

grant update on table "public"."superadmin_notification_deliveries" to "anon";

grant delete on table "public"."superadmin_notification_deliveries" to "authenticated";

grant insert on table "public"."superadmin_notification_deliveries" to "authenticated";

grant references on table "public"."superadmin_notification_deliveries" to "authenticated";

grant select on table "public"."superadmin_notification_deliveries" to "authenticated";

grant trigger on table "public"."superadmin_notification_deliveries" to "authenticated";

grant truncate on table "public"."superadmin_notification_deliveries" to "authenticated";

grant update on table "public"."superadmin_notification_deliveries" to "authenticated";

grant delete on table "public"."superadmin_notification_deliveries" to "service_role";

grant insert on table "public"."superadmin_notification_deliveries" to "service_role";

grant references on table "public"."superadmin_notification_deliveries" to "service_role";

grant select on table "public"."superadmin_notification_deliveries" to "service_role";

grant trigger on table "public"."superadmin_notification_deliveries" to "service_role";

grant truncate on table "public"."superadmin_notification_deliveries" to "service_role";

grant update on table "public"."superadmin_notification_deliveries" to "service_role";

grant delete on table "public"."superadmin_notification_rules" to "anon";

grant insert on table "public"."superadmin_notification_rules" to "anon";

grant references on table "public"."superadmin_notification_rules" to "anon";

grant select on table "public"."superadmin_notification_rules" to "anon";

grant trigger on table "public"."superadmin_notification_rules" to "anon";

grant truncate on table "public"."superadmin_notification_rules" to "anon";

grant update on table "public"."superadmin_notification_rules" to "anon";

grant delete on table "public"."superadmin_notification_rules" to "authenticated";

grant insert on table "public"."superadmin_notification_rules" to "authenticated";

grant references on table "public"."superadmin_notification_rules" to "authenticated";

grant select on table "public"."superadmin_notification_rules" to "authenticated";

grant trigger on table "public"."superadmin_notification_rules" to "authenticated";

grant truncate on table "public"."superadmin_notification_rules" to "authenticated";

grant update on table "public"."superadmin_notification_rules" to "authenticated";

grant delete on table "public"."superadmin_notification_rules" to "service_role";

grant insert on table "public"."superadmin_notification_rules" to "service_role";

grant references on table "public"."superadmin_notification_rules" to "service_role";

grant select on table "public"."superadmin_notification_rules" to "service_role";

grant trigger on table "public"."superadmin_notification_rules" to "service_role";

grant truncate on table "public"."superadmin_notification_rules" to "service_role";

grant update on table "public"."superadmin_notification_rules" to "service_role";

grant delete on table "public"."superadmin_notifications" to "anon";

grant insert on table "public"."superadmin_notifications" to "anon";

grant references on table "public"."superadmin_notifications" to "anon";

grant select on table "public"."superadmin_notifications" to "anon";

grant trigger on table "public"."superadmin_notifications" to "anon";

grant truncate on table "public"."superadmin_notifications" to "anon";

grant update on table "public"."superadmin_notifications" to "anon";

grant delete on table "public"."superadmin_notifications" to "authenticated";

grant insert on table "public"."superadmin_notifications" to "authenticated";

grant references on table "public"."superadmin_notifications" to "authenticated";

grant select on table "public"."superadmin_notifications" to "authenticated";

grant trigger on table "public"."superadmin_notifications" to "authenticated";

grant truncate on table "public"."superadmin_notifications" to "authenticated";

grant update on table "public"."superadmin_notifications" to "authenticated";

grant delete on table "public"."superadmin_notifications" to "service_role";

grant insert on table "public"."superadmin_notifications" to "service_role";

grant references on table "public"."superadmin_notifications" to "service_role";

grant select on table "public"."superadmin_notifications" to "service_role";

grant trigger on table "public"."superadmin_notifications" to "service_role";

grant truncate on table "public"."superadmin_notifications" to "service_role";

grant update on table "public"."superadmin_notifications" to "service_role";

grant delete on table "public"."superadmin_platform_insights" to "anon";

grant insert on table "public"."superadmin_platform_insights" to "anon";

grant references on table "public"."superadmin_platform_insights" to "anon";

grant select on table "public"."superadmin_platform_insights" to "anon";

grant trigger on table "public"."superadmin_platform_insights" to "anon";

grant truncate on table "public"."superadmin_platform_insights" to "anon";

grant update on table "public"."superadmin_platform_insights" to "anon";

grant delete on table "public"."superadmin_platform_insights" to "authenticated";

grant insert on table "public"."superadmin_platform_insights" to "authenticated";

grant references on table "public"."superadmin_platform_insights" to "authenticated";

grant select on table "public"."superadmin_platform_insights" to "authenticated";

grant trigger on table "public"."superadmin_platform_insights" to "authenticated";

grant truncate on table "public"."superadmin_platform_insights" to "authenticated";

grant update on table "public"."superadmin_platform_insights" to "authenticated";

grant delete on table "public"."superadmin_platform_insights" to "service_role";

grant insert on table "public"."superadmin_platform_insights" to "service_role";

grant references on table "public"."superadmin_platform_insights" to "service_role";

grant select on table "public"."superadmin_platform_insights" to "service_role";

grant trigger on table "public"."superadmin_platform_insights" to "service_role";

grant truncate on table "public"."superadmin_platform_insights" to "service_role";

grant update on table "public"."superadmin_platform_insights" to "service_role";

grant delete on table "public"."superadmin_role_assignments" to "anon";

grant insert on table "public"."superadmin_role_assignments" to "anon";

grant references on table "public"."superadmin_role_assignments" to "anon";

grant select on table "public"."superadmin_role_assignments" to "anon";

grant trigger on table "public"."superadmin_role_assignments" to "anon";

grant truncate on table "public"."superadmin_role_assignments" to "anon";

grant update on table "public"."superadmin_role_assignments" to "anon";

grant delete on table "public"."superadmin_role_assignments" to "authenticated";

grant insert on table "public"."superadmin_role_assignments" to "authenticated";

grant references on table "public"."superadmin_role_assignments" to "authenticated";

grant select on table "public"."superadmin_role_assignments" to "authenticated";

grant trigger on table "public"."superadmin_role_assignments" to "authenticated";

grant truncate on table "public"."superadmin_role_assignments" to "authenticated";

grant update on table "public"."superadmin_role_assignments" to "authenticated";

grant delete on table "public"."superadmin_role_assignments" to "service_role";

grant insert on table "public"."superadmin_role_assignments" to "service_role";

grant references on table "public"."superadmin_role_assignments" to "service_role";

grant select on table "public"."superadmin_role_assignments" to "service_role";

grant trigger on table "public"."superadmin_role_assignments" to "service_role";

grant truncate on table "public"."superadmin_role_assignments" to "service_role";

grant update on table "public"."superadmin_role_assignments" to "service_role";

grant delete on table "public"."superadmin_session_management" to "anon";

grant insert on table "public"."superadmin_session_management" to "anon";

grant references on table "public"."superadmin_session_management" to "anon";

grant select on table "public"."superadmin_session_management" to "anon";

grant trigger on table "public"."superadmin_session_management" to "anon";

grant truncate on table "public"."superadmin_session_management" to "anon";

grant update on table "public"."superadmin_session_management" to "anon";

grant delete on table "public"."superadmin_session_management" to "authenticated";

grant insert on table "public"."superadmin_session_management" to "authenticated";

grant references on table "public"."superadmin_session_management" to "authenticated";

grant select on table "public"."superadmin_session_management" to "authenticated";

grant trigger on table "public"."superadmin_session_management" to "authenticated";

grant truncate on table "public"."superadmin_session_management" to "authenticated";

grant update on table "public"."superadmin_session_management" to "authenticated";

grant delete on table "public"."superadmin_session_management" to "service_role";

grant insert on table "public"."superadmin_session_management" to "service_role";

grant references on table "public"."superadmin_session_management" to "service_role";

grant select on table "public"."superadmin_session_management" to "service_role";

grant trigger on table "public"."superadmin_session_management" to "service_role";

grant truncate on table "public"."superadmin_session_management" to "service_role";

grant update on table "public"."superadmin_session_management" to "service_role";

grant delete on table "public"."superadmin_user_actions" to "anon";

grant insert on table "public"."superadmin_user_actions" to "anon";

grant references on table "public"."superadmin_user_actions" to "anon";

grant select on table "public"."superadmin_user_actions" to "anon";

grant trigger on table "public"."superadmin_user_actions" to "anon";

grant truncate on table "public"."superadmin_user_actions" to "anon";

grant update on table "public"."superadmin_user_actions" to "anon";

grant delete on table "public"."superadmin_user_actions" to "authenticated";

grant insert on table "public"."superadmin_user_actions" to "authenticated";

grant references on table "public"."superadmin_user_actions" to "authenticated";

grant select on table "public"."superadmin_user_actions" to "authenticated";

grant trigger on table "public"."superadmin_user_actions" to "authenticated";

grant truncate on table "public"."superadmin_user_actions" to "authenticated";

grant update on table "public"."superadmin_user_actions" to "authenticated";

grant delete on table "public"."superadmin_user_actions" to "service_role";

grant insert on table "public"."superadmin_user_actions" to "service_role";

grant references on table "public"."superadmin_user_actions" to "service_role";

grant select on table "public"."superadmin_user_actions" to "service_role";

grant trigger on table "public"."superadmin_user_actions" to "service_role";

grant truncate on table "public"."superadmin_user_actions" to "service_role";

grant update on table "public"."superadmin_user_actions" to "service_role";

grant delete on table "public"."superadmin_user_deletion_requests" to "anon";

grant insert on table "public"."superadmin_user_deletion_requests" to "anon";

grant references on table "public"."superadmin_user_deletion_requests" to "anon";

grant select on table "public"."superadmin_user_deletion_requests" to "anon";

grant trigger on table "public"."superadmin_user_deletion_requests" to "anon";

grant truncate on table "public"."superadmin_user_deletion_requests" to "anon";

grant update on table "public"."superadmin_user_deletion_requests" to "anon";

grant delete on table "public"."superadmin_user_deletion_requests" to "authenticated";

grant insert on table "public"."superadmin_user_deletion_requests" to "authenticated";

grant references on table "public"."superadmin_user_deletion_requests" to "authenticated";

grant select on table "public"."superadmin_user_deletion_requests" to "authenticated";

grant trigger on table "public"."superadmin_user_deletion_requests" to "authenticated";

grant truncate on table "public"."superadmin_user_deletion_requests" to "authenticated";

grant update on table "public"."superadmin_user_deletion_requests" to "authenticated";

grant delete on table "public"."superadmin_user_deletion_requests" to "service_role";

grant insert on table "public"."superadmin_user_deletion_requests" to "service_role";

grant references on table "public"."superadmin_user_deletion_requests" to "service_role";

grant select on table "public"."superadmin_user_deletion_requests" to "service_role";

grant trigger on table "public"."superadmin_user_deletion_requests" to "service_role";

grant truncate on table "public"."superadmin_user_deletion_requests" to "service_role";

grant update on table "public"."superadmin_user_deletion_requests" to "service_role";

grant delete on table "public"."superadmin_user_risk_assessments" to "anon";

grant insert on table "public"."superadmin_user_risk_assessments" to "anon";

grant references on table "public"."superadmin_user_risk_assessments" to "anon";

grant select on table "public"."superadmin_user_risk_assessments" to "anon";

grant trigger on table "public"."superadmin_user_risk_assessments" to "anon";

grant truncate on table "public"."superadmin_user_risk_assessments" to "anon";

grant update on table "public"."superadmin_user_risk_assessments" to "anon";

grant delete on table "public"."superadmin_user_risk_assessments" to "authenticated";

grant insert on table "public"."superadmin_user_risk_assessments" to "authenticated";

grant references on table "public"."superadmin_user_risk_assessments" to "authenticated";

grant select on table "public"."superadmin_user_risk_assessments" to "authenticated";

grant trigger on table "public"."superadmin_user_risk_assessments" to "authenticated";

grant truncate on table "public"."superadmin_user_risk_assessments" to "authenticated";

grant update on table "public"."superadmin_user_risk_assessments" to "authenticated";

grant delete on table "public"."superadmin_user_risk_assessments" to "service_role";

grant insert on table "public"."superadmin_user_risk_assessments" to "service_role";

grant references on table "public"."superadmin_user_risk_assessments" to "service_role";

grant select on table "public"."superadmin_user_risk_assessments" to "service_role";

grant trigger on table "public"."superadmin_user_risk_assessments" to "service_role";

grant truncate on table "public"."superadmin_user_risk_assessments" to "service_role";

grant update on table "public"."superadmin_user_risk_assessments" to "service_role";

grant delete on table "public"."support_tickets" to "anon";

grant insert on table "public"."support_tickets" to "anon";

grant references on table "public"."support_tickets" to "anon";

grant select on table "public"."support_tickets" to "anon";

grant trigger on table "public"."support_tickets" to "anon";

grant truncate on table "public"."support_tickets" to "anon";

grant update on table "public"."support_tickets" to "anon";

grant delete on table "public"."support_tickets" to "authenticated";

grant insert on table "public"."support_tickets" to "authenticated";

grant references on table "public"."support_tickets" to "authenticated";

grant select on table "public"."support_tickets" to "authenticated";

grant trigger on table "public"."support_tickets" to "authenticated";

grant truncate on table "public"."support_tickets" to "authenticated";

grant update on table "public"."support_tickets" to "authenticated";

grant delete on table "public"."support_tickets" to "service_role";

grant insert on table "public"."support_tickets" to "service_role";

grant references on table "public"."support_tickets" to "service_role";

grant select on table "public"."support_tickets" to "service_role";

grant trigger on table "public"."support_tickets" to "service_role";

grant truncate on table "public"."support_tickets" to "service_role";

grant update on table "public"."support_tickets" to "service_role";

grant delete on table "public"."sync_logs" to "anon";

grant insert on table "public"."sync_logs" to "anon";

grant references on table "public"."sync_logs" to "anon";

grant select on table "public"."sync_logs" to "anon";

grant trigger on table "public"."sync_logs" to "anon";

grant truncate on table "public"."sync_logs" to "anon";

grant update on table "public"."sync_logs" to "anon";

grant delete on table "public"."sync_logs" to "authenticated";

grant insert on table "public"."sync_logs" to "authenticated";

grant references on table "public"."sync_logs" to "authenticated";

grant select on table "public"."sync_logs" to "authenticated";

grant trigger on table "public"."sync_logs" to "authenticated";

grant truncate on table "public"."sync_logs" to "authenticated";

grant update on table "public"."sync_logs" to "authenticated";

grant delete on table "public"."sync_logs" to "service_role";

grant insert on table "public"."sync_logs" to "service_role";

grant references on table "public"."sync_logs" to "service_role";

grant select on table "public"."sync_logs" to "service_role";

grant trigger on table "public"."sync_logs" to "service_role";

grant truncate on table "public"."sync_logs" to "service_role";

grant update on table "public"."sync_logs" to "service_role";

grant delete on table "public"."system_config" to "anon";

grant insert on table "public"."system_config" to "anon";

grant references on table "public"."system_config" to "anon";

grant select on table "public"."system_config" to "anon";

grant trigger on table "public"."system_config" to "anon";

grant truncate on table "public"."system_config" to "anon";

grant update on table "public"."system_config" to "anon";

grant delete on table "public"."system_config" to "authenticated";

grant insert on table "public"."system_config" to "authenticated";

grant references on table "public"."system_config" to "authenticated";

grant select on table "public"."system_config" to "authenticated";

grant trigger on table "public"."system_config" to "authenticated";

grant truncate on table "public"."system_config" to "authenticated";

grant update on table "public"."system_config" to "authenticated";

grant delete on table "public"."system_config" to "service_role";

grant insert on table "public"."system_config" to "service_role";

grant references on table "public"."system_config" to "service_role";

grant select on table "public"."system_config" to "service_role";

grant trigger on table "public"."system_config" to "service_role";

grant truncate on table "public"."system_config" to "service_role";

grant update on table "public"."system_config" to "service_role";

grant delete on table "public"."system_settings" to "anon";

grant insert on table "public"."system_settings" to "anon";

grant references on table "public"."system_settings" to "anon";

grant select on table "public"."system_settings" to "anon";

grant trigger on table "public"."system_settings" to "anon";

grant truncate on table "public"."system_settings" to "anon";

grant update on table "public"."system_settings" to "anon";

grant delete on table "public"."system_settings" to "authenticated";

grant insert on table "public"."system_settings" to "authenticated";

grant references on table "public"."system_settings" to "authenticated";

grant select on table "public"."system_settings" to "authenticated";

grant trigger on table "public"."system_settings" to "authenticated";

grant truncate on table "public"."system_settings" to "authenticated";

grant update on table "public"."system_settings" to "authenticated";

grant delete on table "public"."system_settings" to "service_role";

grant insert on table "public"."system_settings" to "service_role";

grant references on table "public"."system_settings" to "service_role";

grant select on table "public"."system_settings" to "service_role";

grant trigger on table "public"."system_settings" to "service_role";

grant truncate on table "public"."system_settings" to "service_role";

grant update on table "public"."system_settings" to "service_role";

grant delete on table "public"."teacher_ai_allocations" to "anon";

grant insert on table "public"."teacher_ai_allocations" to "anon";

grant references on table "public"."teacher_ai_allocations" to "anon";

grant select on table "public"."teacher_ai_allocations" to "anon";

grant trigger on table "public"."teacher_ai_allocations" to "anon";

grant truncate on table "public"."teacher_ai_allocations" to "anon";

grant update on table "public"."teacher_ai_allocations" to "anon";

grant delete on table "public"."teacher_ai_allocations" to "authenticated";

grant insert on table "public"."teacher_ai_allocations" to "authenticated";

grant references on table "public"."teacher_ai_allocations" to "authenticated";

grant select on table "public"."teacher_ai_allocations" to "authenticated";

grant trigger on table "public"."teacher_ai_allocations" to "authenticated";

grant truncate on table "public"."teacher_ai_allocations" to "authenticated";

grant update on table "public"."teacher_ai_allocations" to "authenticated";

grant delete on table "public"."teacher_ai_allocations" to "service_role";

grant insert on table "public"."teacher_ai_allocations" to "service_role";

grant references on table "public"."teacher_ai_allocations" to "service_role";

grant select on table "public"."teacher_ai_allocations" to "service_role";

grant trigger on table "public"."teacher_ai_allocations" to "service_role";

grant truncate on table "public"."teacher_ai_allocations" to "service_role";

grant update on table "public"."teacher_ai_allocations" to "service_role";

grant delete on table "public"."teacher_class_codes" to "anon";

grant insert on table "public"."teacher_class_codes" to "anon";

grant references on table "public"."teacher_class_codes" to "anon";

grant select on table "public"."teacher_class_codes" to "anon";

grant trigger on table "public"."teacher_class_codes" to "anon";

grant truncate on table "public"."teacher_class_codes" to "anon";

grant update on table "public"."teacher_class_codes" to "anon";

grant delete on table "public"."teacher_class_codes" to "authenticated";

grant insert on table "public"."teacher_class_codes" to "authenticated";

grant references on table "public"."teacher_class_codes" to "authenticated";

grant select on table "public"."teacher_class_codes" to "authenticated";

grant trigger on table "public"."teacher_class_codes" to "authenticated";

grant truncate on table "public"."teacher_class_codes" to "authenticated";

grant update on table "public"."teacher_class_codes" to "authenticated";

grant delete on table "public"."teacher_class_codes" to "service_role";

grant insert on table "public"."teacher_class_codes" to "service_role";

grant references on table "public"."teacher_class_codes" to "service_role";

grant select on table "public"."teacher_class_codes" to "service_role";

grant trigger on table "public"."teacher_class_codes" to "service_role";

grant truncate on table "public"."teacher_class_codes" to "service_role";

grant update on table "public"."teacher_class_codes" to "service_role";

grant delete on table "public"."teacher_invitations" to "anon";

grant insert on table "public"."teacher_invitations" to "anon";

grant references on table "public"."teacher_invitations" to "anon";

grant select on table "public"."teacher_invitations" to "anon";

grant trigger on table "public"."teacher_invitations" to "anon";

grant truncate on table "public"."teacher_invitations" to "anon";

grant update on table "public"."teacher_invitations" to "anon";

grant delete on table "public"."teacher_invitations" to "authenticated";

grant insert on table "public"."teacher_invitations" to "authenticated";

grant references on table "public"."teacher_invitations" to "authenticated";

grant select on table "public"."teacher_invitations" to "authenticated";

grant trigger on table "public"."teacher_invitations" to "authenticated";

grant truncate on table "public"."teacher_invitations" to "authenticated";

grant update on table "public"."teacher_invitations" to "authenticated";

grant delete on table "public"."teacher_invitations" to "service_role";

grant insert on table "public"."teacher_invitations" to "service_role";

grant references on table "public"."teacher_invitations" to "service_role";

grant select on table "public"."teacher_invitations" to "service_role";

grant trigger on table "public"."teacher_invitations" to "service_role";

grant truncate on table "public"."teacher_invitations" to "service_role";

grant update on table "public"."teacher_invitations" to "service_role";

grant delete on table "public"."teacher_performance_metrics" to "anon";

grant insert on table "public"."teacher_performance_metrics" to "anon";

grant references on table "public"."teacher_performance_metrics" to "anon";

grant select on table "public"."teacher_performance_metrics" to "anon";

grant trigger on table "public"."teacher_performance_metrics" to "anon";

grant truncate on table "public"."teacher_performance_metrics" to "anon";

grant update on table "public"."teacher_performance_metrics" to "anon";

grant delete on table "public"."teacher_performance_metrics" to "authenticated";

grant insert on table "public"."teacher_performance_metrics" to "authenticated";

grant references on table "public"."teacher_performance_metrics" to "authenticated";

grant select on table "public"."teacher_performance_metrics" to "authenticated";

grant trigger on table "public"."teacher_performance_metrics" to "authenticated";

grant truncate on table "public"."teacher_performance_metrics" to "authenticated";

grant update on table "public"."teacher_performance_metrics" to "authenticated";

grant delete on table "public"."teacher_performance_metrics" to "service_role";

grant insert on table "public"."teacher_performance_metrics" to "service_role";

grant references on table "public"."teacher_performance_metrics" to "service_role";

grant select on table "public"."teacher_performance_metrics" to "service_role";

grant trigger on table "public"."teacher_performance_metrics" to "service_role";

grant truncate on table "public"."teacher_performance_metrics" to "service_role";

grant update on table "public"."teacher_performance_metrics" to "service_role";

grant delete on table "public"."teacher_student_notes" to "anon";

grant insert on table "public"."teacher_student_notes" to "anon";

grant references on table "public"."teacher_student_notes" to "anon";

grant select on table "public"."teacher_student_notes" to "anon";

grant trigger on table "public"."teacher_student_notes" to "anon";

grant truncate on table "public"."teacher_student_notes" to "anon";

grant update on table "public"."teacher_student_notes" to "anon";

grant delete on table "public"."teacher_student_notes" to "authenticated";

grant insert on table "public"."teacher_student_notes" to "authenticated";

grant references on table "public"."teacher_student_notes" to "authenticated";

grant select on table "public"."teacher_student_notes" to "authenticated";

grant trigger on table "public"."teacher_student_notes" to "authenticated";

grant truncate on table "public"."teacher_student_notes" to "authenticated";

grant update on table "public"."teacher_student_notes" to "authenticated";

grant delete on table "public"."teacher_student_notes" to "service_role";

grant insert on table "public"."teacher_student_notes" to "service_role";

grant references on table "public"."teacher_student_notes" to "service_role";

grant select on table "public"."teacher_student_notes" to "service_role";

grant trigger on table "public"."teacher_student_notes" to "service_role";

grant truncate on table "public"."teacher_student_notes" to "service_role";

grant update on table "public"."teacher_student_notes" to "service_role";

grant delete on table "public"."teachers" to "anon";

grant insert on table "public"."teachers" to "anon";

grant references on table "public"."teachers" to "anon";

grant select on table "public"."teachers" to "anon";

grant trigger on table "public"."teachers" to "anon";

grant truncate on table "public"."teachers" to "anon";

grant update on table "public"."teachers" to "anon";

grant delete on table "public"."teachers" to "authenticated";

grant insert on table "public"."teachers" to "authenticated";

grant references on table "public"."teachers" to "authenticated";

grant select on table "public"."teachers" to "authenticated";

grant trigger on table "public"."teachers" to "authenticated";

grant truncate on table "public"."teachers" to "authenticated";

grant update on table "public"."teachers" to "authenticated";

grant delete on table "public"."teachers" to "service_role";

grant insert on table "public"."teachers" to "service_role";

grant references on table "public"."teachers" to "service_role";

grant select on table "public"."teachers" to "service_role";

grant trigger on table "public"."teachers" to "service_role";

grant truncate on table "public"."teachers" to "service_role";

grant update on table "public"."teachers" to "service_role";

grant delete on table "public"."template_approvals" to "anon";

grant insert on table "public"."template_approvals" to "anon";

grant references on table "public"."template_approvals" to "anon";

grant select on table "public"."template_approvals" to "anon";

grant trigger on table "public"."template_approvals" to "anon";

grant truncate on table "public"."template_approvals" to "anon";

grant update on table "public"."template_approvals" to "anon";

grant delete on table "public"."template_approvals" to "authenticated";

grant insert on table "public"."template_approvals" to "authenticated";

grant references on table "public"."template_approvals" to "authenticated";

grant select on table "public"."template_approvals" to "authenticated";

grant trigger on table "public"."template_approvals" to "authenticated";

grant truncate on table "public"."template_approvals" to "authenticated";

grant update on table "public"."template_approvals" to "authenticated";

grant delete on table "public"."template_approvals" to "service_role";

grant insert on table "public"."template_approvals" to "service_role";

grant references on table "public"."template_approvals" to "service_role";

grant select on table "public"."template_approvals" to "service_role";

grant trigger on table "public"."template_approvals" to "service_role";

grant truncate on table "public"."template_approvals" to "service_role";

grant update on table "public"."template_approvals" to "service_role";

grant delete on table "public"."template_usage_logs" to "anon";

grant insert on table "public"."template_usage_logs" to "anon";

grant references on table "public"."template_usage_logs" to "anon";

grant select on table "public"."template_usage_logs" to "anon";

grant trigger on table "public"."template_usage_logs" to "anon";

grant truncate on table "public"."template_usage_logs" to "anon";

grant update on table "public"."template_usage_logs" to "anon";

grant delete on table "public"."template_usage_logs" to "authenticated";

grant insert on table "public"."template_usage_logs" to "authenticated";

grant references on table "public"."template_usage_logs" to "authenticated";

grant select on table "public"."template_usage_logs" to "authenticated";

grant trigger on table "public"."template_usage_logs" to "authenticated";

grant truncate on table "public"."template_usage_logs" to "authenticated";

grant update on table "public"."template_usage_logs" to "authenticated";

grant delete on table "public"."template_usage_logs" to "service_role";

grant insert on table "public"."template_usage_logs" to "service_role";

grant references on table "public"."template_usage_logs" to "service_role";

grant select on table "public"."template_usage_logs" to "service_role";

grant trigger on table "public"."template_usage_logs" to "service_role";

grant truncate on table "public"."template_usage_logs" to "service_role";

grant update on table "public"."template_usage_logs" to "service_role";

grant delete on table "public"."template_variables" to "anon";

grant insert on table "public"."template_variables" to "anon";

grant references on table "public"."template_variables" to "anon";

grant select on table "public"."template_variables" to "anon";

grant trigger on table "public"."template_variables" to "anon";

grant truncate on table "public"."template_variables" to "anon";

grant update on table "public"."template_variables" to "anon";

grant delete on table "public"."template_variables" to "authenticated";

grant insert on table "public"."template_variables" to "authenticated";

grant references on table "public"."template_variables" to "authenticated";

grant select on table "public"."template_variables" to "authenticated";

grant trigger on table "public"."template_variables" to "authenticated";

grant truncate on table "public"."template_variables" to "authenticated";

grant update on table "public"."template_variables" to "authenticated";

grant delete on table "public"."template_variables" to "service_role";

grant insert on table "public"."template_variables" to "service_role";

grant references on table "public"."template_variables" to "service_role";

grant select on table "public"."template_variables" to "service_role";

grant trigger on table "public"."template_variables" to "service_role";

grant truncate on table "public"."template_variables" to "service_role";

grant update on table "public"."template_variables" to "service_role";

grant delete on table "public"."tenants" to "anon";

grant insert on table "public"."tenants" to "anon";

grant references on table "public"."tenants" to "anon";

grant select on table "public"."tenants" to "anon";

grant trigger on table "public"."tenants" to "anon";

grant truncate on table "public"."tenants" to "anon";

grant update on table "public"."tenants" to "anon";

grant delete on table "public"."tenants" to "authenticated";

grant insert on table "public"."tenants" to "authenticated";

grant references on table "public"."tenants" to "authenticated";

grant select on table "public"."tenants" to "authenticated";

grant trigger on table "public"."tenants" to "authenticated";

grant truncate on table "public"."tenants" to "authenticated";

grant update on table "public"."tenants" to "authenticated";

grant delete on table "public"."tenants" to "service_role";

grant insert on table "public"."tenants" to "service_role";

grant references on table "public"."tenants" to "service_role";

grant select on table "public"."tenants" to "service_role";

grant trigger on table "public"."tenants" to "service_role";

grant truncate on table "public"."tenants" to "service_role";

grant update on table "public"."tenants" to "service_role";

grant delete on table "public"."tester_feedback" to "anon";

grant insert on table "public"."tester_feedback" to "anon";

grant references on table "public"."tester_feedback" to "anon";

grant select on table "public"."tester_feedback" to "anon";

grant trigger on table "public"."tester_feedback" to "anon";

grant truncate on table "public"."tester_feedback" to "anon";

grant update on table "public"."tester_feedback" to "anon";

grant delete on table "public"."tester_feedback" to "authenticated";

grant insert on table "public"."tester_feedback" to "authenticated";

grant references on table "public"."tester_feedback" to "authenticated";

grant select on table "public"."tester_feedback" to "authenticated";

grant trigger on table "public"."tester_feedback" to "authenticated";

grant truncate on table "public"."tester_feedback" to "authenticated";

grant update on table "public"."tester_feedback" to "authenticated";

grant delete on table "public"."tester_feedback" to "service_role";

grant insert on table "public"."tester_feedback" to "service_role";

grant references on table "public"."tester_feedback" to "service_role";

grant select on table "public"."tester_feedback" to "service_role";

grant trigger on table "public"."tester_feedback" to "service_role";

grant truncate on table "public"."tester_feedback" to "service_role";

grant update on table "public"."tester_feedback" to "service_role";

grant delete on table "public"."textbook_chapters" to "anon";

grant insert on table "public"."textbook_chapters" to "anon";

grant references on table "public"."textbook_chapters" to "anon";

grant select on table "public"."textbook_chapters" to "anon";

grant trigger on table "public"."textbook_chapters" to "anon";

grant truncate on table "public"."textbook_chapters" to "anon";

grant update on table "public"."textbook_chapters" to "anon";

grant delete on table "public"."textbook_chapters" to "authenticated";

grant insert on table "public"."textbook_chapters" to "authenticated";

grant references on table "public"."textbook_chapters" to "authenticated";

grant select on table "public"."textbook_chapters" to "authenticated";

grant trigger on table "public"."textbook_chapters" to "authenticated";

grant truncate on table "public"."textbook_chapters" to "authenticated";

grant update on table "public"."textbook_chapters" to "authenticated";

grant delete on table "public"."textbook_chapters" to "service_role";

grant insert on table "public"."textbook_chapters" to "service_role";

grant references on table "public"."textbook_chapters" to "service_role";

grant select on table "public"."textbook_chapters" to "service_role";

grant trigger on table "public"."textbook_chapters" to "service_role";

grant truncate on table "public"."textbook_chapters" to "service_role";

grant update on table "public"."textbook_chapters" to "service_role";

grant delete on table "public"."textbook_content" to "anon";

grant insert on table "public"."textbook_content" to "anon";

grant references on table "public"."textbook_content" to "anon";

grant select on table "public"."textbook_content" to "anon";

grant trigger on table "public"."textbook_content" to "anon";

grant truncate on table "public"."textbook_content" to "anon";

grant update on table "public"."textbook_content" to "anon";

grant delete on table "public"."textbook_content" to "authenticated";

grant insert on table "public"."textbook_content" to "authenticated";

grant references on table "public"."textbook_content" to "authenticated";

grant select on table "public"."textbook_content" to "authenticated";

grant trigger on table "public"."textbook_content" to "authenticated";

grant truncate on table "public"."textbook_content" to "authenticated";

grant update on table "public"."textbook_content" to "authenticated";

grant delete on table "public"."textbook_content" to "service_role";

grant insert on table "public"."textbook_content" to "service_role";

grant references on table "public"."textbook_content" to "service_role";

grant select on table "public"."textbook_content" to "service_role";

grant trigger on table "public"."textbook_content" to "service_role";

grant truncate on table "public"."textbook_content" to "service_role";

grant update on table "public"."textbook_content" to "service_role";

grant delete on table "public"."textbook_pages" to "anon";

grant insert on table "public"."textbook_pages" to "anon";

grant references on table "public"."textbook_pages" to "anon";

grant select on table "public"."textbook_pages" to "anon";

grant trigger on table "public"."textbook_pages" to "anon";

grant truncate on table "public"."textbook_pages" to "anon";

grant update on table "public"."textbook_pages" to "anon";

grant delete on table "public"."textbook_pages" to "authenticated";

grant insert on table "public"."textbook_pages" to "authenticated";

grant references on table "public"."textbook_pages" to "authenticated";

grant select on table "public"."textbook_pages" to "authenticated";

grant trigger on table "public"."textbook_pages" to "authenticated";

grant truncate on table "public"."textbook_pages" to "authenticated";

grant update on table "public"."textbook_pages" to "authenticated";

grant delete on table "public"."textbook_pages" to "service_role";

grant insert on table "public"."textbook_pages" to "service_role";

grant references on table "public"."textbook_pages" to "service_role";

grant select on table "public"."textbook_pages" to "service_role";

grant trigger on table "public"."textbook_pages" to "service_role";

grant truncate on table "public"."textbook_pages" to "service_role";

grant update on table "public"."textbook_pages" to "service_role";

grant delete on table "public"."textbooks" to "anon";

grant insert on table "public"."textbooks" to "anon";

grant references on table "public"."textbooks" to "anon";

grant select on table "public"."textbooks" to "anon";

grant trigger on table "public"."textbooks" to "anon";

grant truncate on table "public"."textbooks" to "anon";

grant update on table "public"."textbooks" to "anon";

grant delete on table "public"."textbooks" to "authenticated";

grant insert on table "public"."textbooks" to "authenticated";

grant references on table "public"."textbooks" to "authenticated";

grant select on table "public"."textbooks" to "authenticated";

grant trigger on table "public"."textbooks" to "authenticated";

grant truncate on table "public"."textbooks" to "authenticated";

grant update on table "public"."textbooks" to "authenticated";

grant delete on table "public"."textbooks" to "service_role";

grant insert on table "public"."textbooks" to "service_role";

grant references on table "public"."textbooks" to "service_role";

grant select on table "public"."textbooks" to "service_role";

grant trigger on table "public"."textbooks" to "service_role";

grant truncate on table "public"."textbooks" to "service_role";

grant update on table "public"."textbooks" to "service_role";

grant delete on table "public"."trial_usage_log" to "anon";

grant insert on table "public"."trial_usage_log" to "anon";

grant references on table "public"."trial_usage_log" to "anon";

grant select on table "public"."trial_usage_log" to "anon";

grant trigger on table "public"."trial_usage_log" to "anon";

grant truncate on table "public"."trial_usage_log" to "anon";

grant update on table "public"."trial_usage_log" to "anon";

grant delete on table "public"."trial_usage_log" to "authenticated";

grant insert on table "public"."trial_usage_log" to "authenticated";

grant references on table "public"."trial_usage_log" to "authenticated";

grant select on table "public"."trial_usage_log" to "authenticated";

grant trigger on table "public"."trial_usage_log" to "authenticated";

grant truncate on table "public"."trial_usage_log" to "authenticated";

grant update on table "public"."trial_usage_log" to "authenticated";

grant delete on table "public"."trial_usage_log" to "service_role";

grant insert on table "public"."trial_usage_log" to "service_role";

grant references on table "public"."trial_usage_log" to "service_role";

grant select on table "public"."trial_usage_log" to "service_role";

grant trigger on table "public"."trial_usage_log" to "service_role";

grant truncate on table "public"."trial_usage_log" to "service_role";

grant update on table "public"."trial_usage_log" to "service_role";

grant delete on table "public"."tts_audio_cache" to "anon";

grant insert on table "public"."tts_audio_cache" to "anon";

grant references on table "public"."tts_audio_cache" to "anon";

grant select on table "public"."tts_audio_cache" to "anon";

grant trigger on table "public"."tts_audio_cache" to "anon";

grant truncate on table "public"."tts_audio_cache" to "anon";

grant update on table "public"."tts_audio_cache" to "anon";

grant delete on table "public"."tts_audio_cache" to "authenticated";

grant insert on table "public"."tts_audio_cache" to "authenticated";

grant references on table "public"."tts_audio_cache" to "authenticated";

grant select on table "public"."tts_audio_cache" to "authenticated";

grant trigger on table "public"."tts_audio_cache" to "authenticated";

grant truncate on table "public"."tts_audio_cache" to "authenticated";

grant update on table "public"."tts_audio_cache" to "authenticated";

grant delete on table "public"."tts_audio_cache" to "service_role";

grant insert on table "public"."tts_audio_cache" to "service_role";

grant references on table "public"."tts_audio_cache" to "service_role";

grant select on table "public"."tts_audio_cache" to "service_role";

grant trigger on table "public"."tts_audio_cache" to "service_role";

grant truncate on table "public"."tts_audio_cache" to "service_role";

grant update on table "public"."tts_audio_cache" to "service_role";

grant delete on table "public"."typing_indicators" to "anon";

grant insert on table "public"."typing_indicators" to "anon";

grant references on table "public"."typing_indicators" to "anon";

grant select on table "public"."typing_indicators" to "anon";

grant trigger on table "public"."typing_indicators" to "anon";

grant truncate on table "public"."typing_indicators" to "anon";

grant update on table "public"."typing_indicators" to "anon";

grant delete on table "public"."typing_indicators" to "authenticated";

grant insert on table "public"."typing_indicators" to "authenticated";

grant references on table "public"."typing_indicators" to "authenticated";

grant select on table "public"."typing_indicators" to "authenticated";

grant trigger on table "public"."typing_indicators" to "authenticated";

grant truncate on table "public"."typing_indicators" to "authenticated";

grant update on table "public"."typing_indicators" to "authenticated";

grant delete on table "public"."typing_indicators" to "service_role";

grant insert on table "public"."typing_indicators" to "service_role";

grant references on table "public"."typing_indicators" to "service_role";

grant select on table "public"."typing_indicators" to "service_role";

grant trigger on table "public"."typing_indicators" to "service_role";

grant truncate on table "public"."typing_indicators" to "service_role";

grant update on table "public"."typing_indicators" to "service_role";

grant delete on table "public"."user_ai_tiers" to "anon";

grant insert on table "public"."user_ai_tiers" to "anon";

grant references on table "public"."user_ai_tiers" to "anon";

grant select on table "public"."user_ai_tiers" to "anon";

grant trigger on table "public"."user_ai_tiers" to "anon";

grant truncate on table "public"."user_ai_tiers" to "anon";

grant update on table "public"."user_ai_tiers" to "anon";

grant delete on table "public"."user_ai_tiers" to "authenticated";

grant insert on table "public"."user_ai_tiers" to "authenticated";

grant references on table "public"."user_ai_tiers" to "authenticated";

grant select on table "public"."user_ai_tiers" to "authenticated";

grant trigger on table "public"."user_ai_tiers" to "authenticated";

grant truncate on table "public"."user_ai_tiers" to "authenticated";

grant update on table "public"."user_ai_tiers" to "authenticated";

grant delete on table "public"."user_ai_tiers" to "service_role";

grant insert on table "public"."user_ai_tiers" to "service_role";

grant references on table "public"."user_ai_tiers" to "service_role";

grant select on table "public"."user_ai_tiers" to "service_role";

grant trigger on table "public"."user_ai_tiers" to "service_role";

grant truncate on table "public"."user_ai_tiers" to "service_role";

grant update on table "public"."user_ai_tiers" to "service_role";

grant delete on table "public"."user_ai_usage" to "anon";

grant insert on table "public"."user_ai_usage" to "anon";

grant references on table "public"."user_ai_usage" to "anon";

grant select on table "public"."user_ai_usage" to "anon";

grant trigger on table "public"."user_ai_usage" to "anon";

grant truncate on table "public"."user_ai_usage" to "anon";

grant update on table "public"."user_ai_usage" to "anon";

grant delete on table "public"."user_ai_usage" to "authenticated";

grant insert on table "public"."user_ai_usage" to "authenticated";

grant references on table "public"."user_ai_usage" to "authenticated";

grant select on table "public"."user_ai_usage" to "authenticated";

grant trigger on table "public"."user_ai_usage" to "authenticated";

grant truncate on table "public"."user_ai_usage" to "authenticated";

grant update on table "public"."user_ai_usage" to "authenticated";

grant delete on table "public"."user_ai_usage" to "service_role";

grant insert on table "public"."user_ai_usage" to "service_role";

grant references on table "public"."user_ai_usage" to "service_role";

grant select on table "public"."user_ai_usage" to "service_role";

grant trigger on table "public"."user_ai_usage" to "service_role";

grant truncate on table "public"."user_ai_usage" to "service_role";

grant update on table "public"."user_ai_usage" to "service_role";

grant delete on table "public"."user_blocks" to "anon";

grant insert on table "public"."user_blocks" to "anon";

grant references on table "public"."user_blocks" to "anon";

grant select on table "public"."user_blocks" to "anon";

grant trigger on table "public"."user_blocks" to "anon";

grant truncate on table "public"."user_blocks" to "anon";

grant update on table "public"."user_blocks" to "anon";

grant delete on table "public"."user_blocks" to "authenticated";

grant insert on table "public"."user_blocks" to "authenticated";

grant references on table "public"."user_blocks" to "authenticated";

grant select on table "public"."user_blocks" to "authenticated";

grant trigger on table "public"."user_blocks" to "authenticated";

grant truncate on table "public"."user_blocks" to "authenticated";

grant update on table "public"."user_blocks" to "authenticated";

grant delete on table "public"."user_blocks" to "service_role";

grant insert on table "public"."user_blocks" to "service_role";

grant references on table "public"."user_blocks" to "service_role";

grant select on table "public"."user_blocks" to "service_role";

grant trigger on table "public"."user_blocks" to "service_role";

grant truncate on table "public"."user_blocks" to "service_role";

grant update on table "public"."user_blocks" to "service_role";

grant delete on table "public"."user_bookmarks" to "anon";

grant insert on table "public"."user_bookmarks" to "anon";

grant references on table "public"."user_bookmarks" to "anon";

grant select on table "public"."user_bookmarks" to "anon";

grant trigger on table "public"."user_bookmarks" to "anon";

grant truncate on table "public"."user_bookmarks" to "anon";

grant update on table "public"."user_bookmarks" to "anon";

grant delete on table "public"."user_bookmarks" to "authenticated";

grant insert on table "public"."user_bookmarks" to "authenticated";

grant references on table "public"."user_bookmarks" to "authenticated";

grant select on table "public"."user_bookmarks" to "authenticated";

grant trigger on table "public"."user_bookmarks" to "authenticated";

grant truncate on table "public"."user_bookmarks" to "authenticated";

grant update on table "public"."user_bookmarks" to "authenticated";

grant delete on table "public"."user_bookmarks" to "service_role";

grant insert on table "public"."user_bookmarks" to "service_role";

grant references on table "public"."user_bookmarks" to "service_role";

grant select on table "public"."user_bookmarks" to "service_role";

grant trigger on table "public"."user_bookmarks" to "service_role";

grant truncate on table "public"."user_bookmarks" to "service_role";

grant update on table "public"."user_bookmarks" to "service_role";

grant delete on table "public"."user_connections" to "anon";

grant insert on table "public"."user_connections" to "anon";

grant references on table "public"."user_connections" to "anon";

grant select on table "public"."user_connections" to "anon";

grant trigger on table "public"."user_connections" to "anon";

grant truncate on table "public"."user_connections" to "anon";

grant update on table "public"."user_connections" to "anon";

grant delete on table "public"."user_connections" to "authenticated";

grant insert on table "public"."user_connections" to "authenticated";

grant references on table "public"."user_connections" to "authenticated";

grant select on table "public"."user_connections" to "authenticated";

grant trigger on table "public"."user_connections" to "authenticated";

grant truncate on table "public"."user_connections" to "authenticated";

grant update on table "public"."user_connections" to "authenticated";

grant delete on table "public"."user_connections" to "service_role";

grant insert on table "public"."user_connections" to "service_role";

grant references on table "public"."user_connections" to "service_role";

grant select on table "public"."user_connections" to "service_role";

grant trigger on table "public"."user_connections" to "service_role";

grant truncate on table "public"."user_connections" to "service_role";

grant update on table "public"."user_connections" to "service_role";

grant delete on table "public"."user_contacts" to "anon";

grant insert on table "public"."user_contacts" to "anon";

grant references on table "public"."user_contacts" to "anon";

grant select on table "public"."user_contacts" to "anon";

grant trigger on table "public"."user_contacts" to "anon";

grant truncate on table "public"."user_contacts" to "anon";

grant update on table "public"."user_contacts" to "anon";

grant delete on table "public"."user_contacts" to "authenticated";

grant insert on table "public"."user_contacts" to "authenticated";

grant references on table "public"."user_contacts" to "authenticated";

grant select on table "public"."user_contacts" to "authenticated";

grant trigger on table "public"."user_contacts" to "authenticated";

grant truncate on table "public"."user_contacts" to "authenticated";

grant update on table "public"."user_contacts" to "authenticated";

grant delete on table "public"."user_contacts" to "service_role";

grant insert on table "public"."user_contacts" to "service_role";

grant references on table "public"."user_contacts" to "service_role";

grant select on table "public"."user_contacts" to "service_role";

grant trigger on table "public"."user_contacts" to "service_role";

grant truncate on table "public"."user_contacts" to "service_role";

grant update on table "public"."user_contacts" to "service_role";

grant delete on table "public"."user_invitations" to "anon";

grant insert on table "public"."user_invitations" to "anon";

grant references on table "public"."user_invitations" to "anon";

grant select on table "public"."user_invitations" to "anon";

grant trigger on table "public"."user_invitations" to "anon";

grant truncate on table "public"."user_invitations" to "anon";

grant update on table "public"."user_invitations" to "anon";

grant delete on table "public"."user_invitations" to "authenticated";

grant insert on table "public"."user_invitations" to "authenticated";

grant references on table "public"."user_invitations" to "authenticated";

grant select on table "public"."user_invitations" to "authenticated";

grant trigger on table "public"."user_invitations" to "authenticated";

grant truncate on table "public"."user_invitations" to "authenticated";

grant update on table "public"."user_invitations" to "authenticated";

grant delete on table "public"."user_invitations" to "service_role";

grant insert on table "public"."user_invitations" to "service_role";

grant references on table "public"."user_invitations" to "service_role";

grant select on table "public"."user_invitations" to "service_role";

grant trigger on table "public"."user_invitations" to "service_role";

grant truncate on table "public"."user_invitations" to "service_role";

grant update on table "public"."user_invitations" to "service_role";

grant delete on table "public"."user_phone_numbers" to "anon";

grant insert on table "public"."user_phone_numbers" to "anon";

grant references on table "public"."user_phone_numbers" to "anon";

grant select on table "public"."user_phone_numbers" to "anon";

grant trigger on table "public"."user_phone_numbers" to "anon";

grant truncate on table "public"."user_phone_numbers" to "anon";

grant update on table "public"."user_phone_numbers" to "anon";

grant delete on table "public"."user_phone_numbers" to "authenticated";

grant insert on table "public"."user_phone_numbers" to "authenticated";

grant references on table "public"."user_phone_numbers" to "authenticated";

grant select on table "public"."user_phone_numbers" to "authenticated";

grant trigger on table "public"."user_phone_numbers" to "authenticated";

grant truncate on table "public"."user_phone_numbers" to "authenticated";

grant update on table "public"."user_phone_numbers" to "authenticated";

grant delete on table "public"."user_phone_numbers" to "service_role";

grant insert on table "public"."user_phone_numbers" to "service_role";

grant references on table "public"."user_phone_numbers" to "service_role";

grant select on table "public"."user_phone_numbers" to "service_role";

grant trigger on table "public"."user_phone_numbers" to "service_role";

grant truncate on table "public"."user_phone_numbers" to "service_role";

grant update on table "public"."user_phone_numbers" to "service_role";

grant delete on table "public"."user_preferences" to "anon";

grant insert on table "public"."user_preferences" to "anon";

grant references on table "public"."user_preferences" to "anon";

grant select on table "public"."user_preferences" to "anon";

grant trigger on table "public"."user_preferences" to "anon";

grant truncate on table "public"."user_preferences" to "anon";

grant update on table "public"."user_preferences" to "anon";

grant delete on table "public"."user_preferences" to "authenticated";

grant insert on table "public"."user_preferences" to "authenticated";

grant references on table "public"."user_preferences" to "authenticated";

grant select on table "public"."user_preferences" to "authenticated";

grant trigger on table "public"."user_preferences" to "authenticated";

grant truncate on table "public"."user_preferences" to "authenticated";

grant update on table "public"."user_preferences" to "authenticated";

grant delete on table "public"."user_preferences" to "service_role";

grant insert on table "public"."user_preferences" to "service_role";

grant references on table "public"."user_preferences" to "service_role";

grant select on table "public"."user_preferences" to "service_role";

grant trigger on table "public"."user_preferences" to "service_role";

grant truncate on table "public"."user_preferences" to "service_role";

grant update on table "public"."user_preferences" to "service_role";

grant delete on table "public"."user_presence" to "anon";

grant insert on table "public"."user_presence" to "anon";

grant references on table "public"."user_presence" to "anon";

grant select on table "public"."user_presence" to "anon";

grant trigger on table "public"."user_presence" to "anon";

grant truncate on table "public"."user_presence" to "anon";

grant update on table "public"."user_presence" to "anon";

grant delete on table "public"."user_presence" to "authenticated";

grant insert on table "public"."user_presence" to "authenticated";

grant references on table "public"."user_presence" to "authenticated";

grant select on table "public"."user_presence" to "authenticated";

grant trigger on table "public"."user_presence" to "authenticated";

grant truncate on table "public"."user_presence" to "authenticated";

grant update on table "public"."user_presence" to "authenticated";

grant delete on table "public"."user_presence" to "service_role";

grant insert on table "public"."user_presence" to "service_role";

grant references on table "public"."user_presence" to "service_role";

grant select on table "public"."user_presence" to "service_role";

grant trigger on table "public"."user_presence" to "service_role";

grant truncate on table "public"."user_presence" to "service_role";

grant update on table "public"."user_presence" to "service_role";

grant delete on table "public"."user_profiles" to "anon";

grant insert on table "public"."user_profiles" to "anon";

grant references on table "public"."user_profiles" to "anon";

grant select on table "public"."user_profiles" to "anon";

grant trigger on table "public"."user_profiles" to "anon";

grant truncate on table "public"."user_profiles" to "anon";

grant update on table "public"."user_profiles" to "anon";

grant delete on table "public"."user_profiles" to "authenticated";

grant insert on table "public"."user_profiles" to "authenticated";

grant references on table "public"."user_profiles" to "authenticated";

grant select on table "public"."user_profiles" to "authenticated";

grant trigger on table "public"."user_profiles" to "authenticated";

grant truncate on table "public"."user_profiles" to "authenticated";

grant update on table "public"."user_profiles" to "authenticated";

grant delete on table "public"."user_profiles" to "service_role";

grant insert on table "public"."user_profiles" to "service_role";

grant references on table "public"."user_profiles" to "service_role";

grant select on table "public"."user_profiles" to "service_role";

grant trigger on table "public"."user_profiles" to "service_role";

grant truncate on table "public"."user_profiles" to "service_role";

grant update on table "public"."user_profiles" to "service_role";

grant delete on table "public"."user_promotional_subscriptions" to "anon";

grant insert on table "public"."user_promotional_subscriptions" to "anon";

grant references on table "public"."user_promotional_subscriptions" to "anon";

grant select on table "public"."user_promotional_subscriptions" to "anon";

grant trigger on table "public"."user_promotional_subscriptions" to "anon";

grant truncate on table "public"."user_promotional_subscriptions" to "anon";

grant update on table "public"."user_promotional_subscriptions" to "anon";

grant delete on table "public"."user_promotional_subscriptions" to "authenticated";

grant insert on table "public"."user_promotional_subscriptions" to "authenticated";

grant references on table "public"."user_promotional_subscriptions" to "authenticated";

grant select on table "public"."user_promotional_subscriptions" to "authenticated";

grant trigger on table "public"."user_promotional_subscriptions" to "authenticated";

grant truncate on table "public"."user_promotional_subscriptions" to "authenticated";

grant update on table "public"."user_promotional_subscriptions" to "authenticated";

grant delete on table "public"."user_promotional_subscriptions" to "service_role";

grant insert on table "public"."user_promotional_subscriptions" to "service_role";

grant references on table "public"."user_promotional_subscriptions" to "service_role";

grant select on table "public"."user_promotional_subscriptions" to "service_role";

grant trigger on table "public"."user_promotional_subscriptions" to "service_role";

grant truncate on table "public"."user_promotional_subscriptions" to "service_role";

grant update on table "public"."user_promotional_subscriptions" to "service_role";

grant delete on table "public"."user_usage_tracking" to "anon";

grant insert on table "public"."user_usage_tracking" to "anon";

grant references on table "public"."user_usage_tracking" to "anon";

grant select on table "public"."user_usage_tracking" to "anon";

grant trigger on table "public"."user_usage_tracking" to "anon";

grant truncate on table "public"."user_usage_tracking" to "anon";

grant update on table "public"."user_usage_tracking" to "anon";

grant delete on table "public"."user_usage_tracking" to "authenticated";

grant insert on table "public"."user_usage_tracking" to "authenticated";

grant references on table "public"."user_usage_tracking" to "authenticated";

grant select on table "public"."user_usage_tracking" to "authenticated";

grant trigger on table "public"."user_usage_tracking" to "authenticated";

grant truncate on table "public"."user_usage_tracking" to "authenticated";

grant update on table "public"."user_usage_tracking" to "authenticated";

grant delete on table "public"."user_usage_tracking" to "service_role";

grant insert on table "public"."user_usage_tracking" to "service_role";

grant references on table "public"."user_usage_tracking" to "service_role";

grant select on table "public"."user_usage_tracking" to "service_role";

grant trigger on table "public"."user_usage_tracking" to "service_role";

grant truncate on table "public"."user_usage_tracking" to "service_role";

grant update on table "public"."user_usage_tracking" to "service_role";

grant delete on table "public"."user_voice_usage" to "anon";

grant insert on table "public"."user_voice_usage" to "anon";

grant references on table "public"."user_voice_usage" to "anon";

grant select on table "public"."user_voice_usage" to "anon";

grant trigger on table "public"."user_voice_usage" to "anon";

grant truncate on table "public"."user_voice_usage" to "anon";

grant update on table "public"."user_voice_usage" to "anon";

grant delete on table "public"."user_voice_usage" to "authenticated";

grant insert on table "public"."user_voice_usage" to "authenticated";

grant references on table "public"."user_voice_usage" to "authenticated";

grant select on table "public"."user_voice_usage" to "authenticated";

grant trigger on table "public"."user_voice_usage" to "authenticated";

grant truncate on table "public"."user_voice_usage" to "authenticated";

grant update on table "public"."user_voice_usage" to "authenticated";

grant delete on table "public"."user_voice_usage" to "service_role";

grant insert on table "public"."user_voice_usage" to "service_role";

grant references on table "public"."user_voice_usage" to "service_role";

grant select on table "public"."user_voice_usage" to "service_role";

grant trigger on table "public"."user_voice_usage" to "service_role";

grant truncate on table "public"."user_voice_usage" to "service_role";

grant update on table "public"."user_voice_usage" to "service_role";

grant delete on table "public"."users" to "authenticated";

grant insert on table "public"."users" to "authenticated";

grant references on table "public"."users" to "authenticated";

grant select on table "public"."users" to "authenticated";

grant trigger on table "public"."users" to "authenticated";

grant truncate on table "public"."users" to "authenticated";

grant update on table "public"."users" to "authenticated";

grant delete on table "public"."users" to "service_role";

grant insert on table "public"."users" to "service_role";

grant references on table "public"."users" to "service_role";

grant select on table "public"."users" to "service_role";

grant trigger on table "public"."users" to "service_role";

grant truncate on table "public"."users" to "service_role";

grant update on table "public"."users" to "service_role";

grant delete on table "public"."voice_notes" to "anon";

grant insert on table "public"."voice_notes" to "anon";

grant references on table "public"."voice_notes" to "anon";

grant select on table "public"."voice_notes" to "anon";

grant trigger on table "public"."voice_notes" to "anon";

grant truncate on table "public"."voice_notes" to "anon";

grant update on table "public"."voice_notes" to "anon";

grant delete on table "public"."voice_notes" to "authenticated";

grant insert on table "public"."voice_notes" to "authenticated";

grant references on table "public"."voice_notes" to "authenticated";

grant select on table "public"."voice_notes" to "authenticated";

grant trigger on table "public"."voice_notes" to "authenticated";

grant truncate on table "public"."voice_notes" to "authenticated";

grant update on table "public"."voice_notes" to "authenticated";

grant delete on table "public"."voice_notes" to "service_role";

grant insert on table "public"."voice_notes" to "service_role";

grant references on table "public"."voice_notes" to "service_role";

grant select on table "public"."voice_notes" to "service_role";

grant trigger on table "public"."voice_notes" to "service_role";

grant truncate on table "public"."voice_notes" to "service_role";

grant update on table "public"."voice_notes" to "service_role";

grant delete on table "public"."voice_preferences" to "anon";

grant insert on table "public"."voice_preferences" to "anon";

grant references on table "public"."voice_preferences" to "anon";

grant select on table "public"."voice_preferences" to "anon";

grant trigger on table "public"."voice_preferences" to "anon";

grant truncate on table "public"."voice_preferences" to "anon";

grant update on table "public"."voice_preferences" to "anon";

grant delete on table "public"."voice_preferences" to "authenticated";

grant insert on table "public"."voice_preferences" to "authenticated";

grant references on table "public"."voice_preferences" to "authenticated";

grant select on table "public"."voice_preferences" to "authenticated";

grant trigger on table "public"."voice_preferences" to "authenticated";

grant truncate on table "public"."voice_preferences" to "authenticated";

grant update on table "public"."voice_preferences" to "authenticated";

grant delete on table "public"."voice_preferences" to "service_role";

grant insert on table "public"."voice_preferences" to "service_role";

grant references on table "public"."voice_preferences" to "service_role";

grant select on table "public"."voice_preferences" to "service_role";

grant trigger on table "public"."voice_preferences" to "service_role";

grant truncate on table "public"."voice_preferences" to "service_role";

grant update on table "public"."voice_preferences" to "service_role";

grant delete on table "public"."voice_usage_logs" to "anon";

grant insert on table "public"."voice_usage_logs" to "anon";

grant references on table "public"."voice_usage_logs" to "anon";

grant select on table "public"."voice_usage_logs" to "anon";

grant trigger on table "public"."voice_usage_logs" to "anon";

grant truncate on table "public"."voice_usage_logs" to "anon";

grant update on table "public"."voice_usage_logs" to "anon";

grant delete on table "public"."voice_usage_logs" to "authenticated";

grant insert on table "public"."voice_usage_logs" to "authenticated";

grant references on table "public"."voice_usage_logs" to "authenticated";

grant select on table "public"."voice_usage_logs" to "authenticated";

grant trigger on table "public"."voice_usage_logs" to "authenticated";

grant truncate on table "public"."voice_usage_logs" to "authenticated";

grant update on table "public"."voice_usage_logs" to "authenticated";

grant delete on table "public"."voice_usage_logs" to "service_role";

grant insert on table "public"."voice_usage_logs" to "service_role";

grant references on table "public"."voice_usage_logs" to "service_role";

grant select on table "public"."voice_usage_logs" to "service_role";

grant trigger on table "public"."voice_usage_logs" to "service_role";

grant truncate on table "public"."voice_usage_logs" to "service_role";

grant update on table "public"."voice_usage_logs" to "service_role";

grant delete on table "public"."voice_usage_quotas" to "anon";

grant insert on table "public"."voice_usage_quotas" to "anon";

grant references on table "public"."voice_usage_quotas" to "anon";

grant select on table "public"."voice_usage_quotas" to "anon";

grant trigger on table "public"."voice_usage_quotas" to "anon";

grant truncate on table "public"."voice_usage_quotas" to "anon";

grant update on table "public"."voice_usage_quotas" to "anon";

grant delete on table "public"."voice_usage_quotas" to "authenticated";

grant insert on table "public"."voice_usage_quotas" to "authenticated";

grant references on table "public"."voice_usage_quotas" to "authenticated";

grant select on table "public"."voice_usage_quotas" to "authenticated";

grant trigger on table "public"."voice_usage_quotas" to "authenticated";

grant truncate on table "public"."voice_usage_quotas" to "authenticated";

grant update on table "public"."voice_usage_quotas" to "authenticated";

grant delete on table "public"."voice_usage_quotas" to "service_role";

grant insert on table "public"."voice_usage_quotas" to "service_role";

grant references on table "public"."voice_usage_quotas" to "service_role";

grant select on table "public"."voice_usage_quotas" to "service_role";

grant trigger on table "public"."voice_usage_quotas" to "service_role";

grant truncate on table "public"."voice_usage_quotas" to "service_role";

grant update on table "public"."voice_usage_quotas" to "service_role";

grant delete on table "public"."webhook_logs" to "anon";

grant insert on table "public"."webhook_logs" to "anon";

grant references on table "public"."webhook_logs" to "anon";

grant select on table "public"."webhook_logs" to "anon";

grant trigger on table "public"."webhook_logs" to "anon";

grant truncate on table "public"."webhook_logs" to "anon";

grant update on table "public"."webhook_logs" to "anon";

grant delete on table "public"."webhook_logs" to "authenticated";

grant insert on table "public"."webhook_logs" to "authenticated";

grant references on table "public"."webhook_logs" to "authenticated";

grant select on table "public"."webhook_logs" to "authenticated";

grant trigger on table "public"."webhook_logs" to "authenticated";

grant truncate on table "public"."webhook_logs" to "authenticated";

grant update on table "public"."webhook_logs" to "authenticated";

grant delete on table "public"."webhook_logs" to "service_role";

grant insert on table "public"."webhook_logs" to "service_role";

grant references on table "public"."webhook_logs" to "service_role";

grant select on table "public"."webhook_logs" to "service_role";

grant trigger on table "public"."webhook_logs" to "service_role";

grant truncate on table "public"."webhook_logs" to "service_role";

grant update on table "public"."webhook_logs" to "service_role";

grant delete on table "public"."whatsapp_contacts" to "anon";

grant insert on table "public"."whatsapp_contacts" to "anon";

grant references on table "public"."whatsapp_contacts" to "anon";

grant select on table "public"."whatsapp_contacts" to "anon";

grant trigger on table "public"."whatsapp_contacts" to "anon";

grant truncate on table "public"."whatsapp_contacts" to "anon";

grant update on table "public"."whatsapp_contacts" to "anon";

grant delete on table "public"."whatsapp_contacts" to "authenticated";

grant insert on table "public"."whatsapp_contacts" to "authenticated";

grant references on table "public"."whatsapp_contacts" to "authenticated";

grant select on table "public"."whatsapp_contacts" to "authenticated";

grant trigger on table "public"."whatsapp_contacts" to "authenticated";

grant truncate on table "public"."whatsapp_contacts" to "authenticated";

grant update on table "public"."whatsapp_contacts" to "authenticated";

grant delete on table "public"."whatsapp_contacts" to "service_role";

grant insert on table "public"."whatsapp_contacts" to "service_role";

grant references on table "public"."whatsapp_contacts" to "service_role";

grant select on table "public"."whatsapp_contacts" to "service_role";

grant trigger on table "public"."whatsapp_contacts" to "service_role";

grant truncate on table "public"."whatsapp_contacts" to "service_role";

grant update on table "public"."whatsapp_contacts" to "service_role";

grant delete on table "public"."wing_regional_coordinators" to "anon";

grant insert on table "public"."wing_regional_coordinators" to "anon";

grant references on table "public"."wing_regional_coordinators" to "anon";

grant select on table "public"."wing_regional_coordinators" to "anon";

grant trigger on table "public"."wing_regional_coordinators" to "anon";

grant truncate on table "public"."wing_regional_coordinators" to "anon";

grant update on table "public"."wing_regional_coordinators" to "anon";

grant delete on table "public"."wing_regional_coordinators" to "authenticated";

grant insert on table "public"."wing_regional_coordinators" to "authenticated";

grant references on table "public"."wing_regional_coordinators" to "authenticated";

grant select on table "public"."wing_regional_coordinators" to "authenticated";

grant trigger on table "public"."wing_regional_coordinators" to "authenticated";

grant truncate on table "public"."wing_regional_coordinators" to "authenticated";

grant update on table "public"."wing_regional_coordinators" to "authenticated";

grant delete on table "public"."wing_regional_coordinators" to "service_role";

grant insert on table "public"."wing_regional_coordinators" to "service_role";

grant references on table "public"."wing_regional_coordinators" to "service_role";

grant select on table "public"."wing_regional_coordinators" to "service_role";

grant trigger on table "public"."wing_regional_coordinators" to "service_role";

grant truncate on table "public"."wing_regional_coordinators" to "service_role";

grant update on table "public"."wing_regional_coordinators" to "service_role";


  create policy "Users can create calls"
  on "public"."active_calls"
  as permissive
  for insert
  to public
with check ((auth.uid() = caller_id));



  create policy "Users can delete their calls"
  on "public"."active_calls"
  as permissive
  for delete
  to public
using (((auth.uid() = caller_id) OR (auth.uid() = callee_id)));



  create policy "Users can update their calls"
  on "public"."active_calls"
  as permissive
  for update
  to public
using (((auth.uid() = caller_id) OR (auth.uid() = callee_id)));



  create policy "Users can view their calls"
  on "public"."active_calls"
  as permissive
  for select
  to public
using (((auth.uid() = caller_id) OR (auth.uid() = callee_id)));



  create policy "activities_admin_delete"
  on "public"."activities"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "activities_admin_modify"
  on "public"."activities"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "activities_admin_update"
  on "public"."activities"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "activities_public_read"
  on "public"."activities"
  as permissive
  for select
  to authenticated
using (true);



  create policy "activity_attempts_insert"
  on "public"."activity_attempts"
  as permissive
  for insert
  to public
with check (((EXISTS ( SELECT 1
   FROM public.students s
  WHERE ((s.id = activity_attempts.student_id) AND ((s.parent_id = auth.uid()) OR (s.guardian_id = auth.uid()))))) OR (EXISTS ( SELECT 1
   FROM (public.interactive_activities ia
     JOIN public.profiles p ON ((p.preschool_id = ia.preschool_id)))
  WHERE ((ia.id = activity_attempts.activity_id) AND (p.id = auth.uid()) AND (p.role = ANY (ARRAY['teacher'::text, 'principal'::text])))))));



  create policy "activity_attempts_parent_child"
  on "public"."activity_attempts"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "activity_attempts_select"
  on "public"."activity_attempts"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "activity_attempts_staff_org"
  on "public"."activity_attempts"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM (public.profiles staff
     JOIN public.profiles student ON ((student.id = activity_attempts.student_id)))
  WHERE ((staff.id = auth.uid()) AND (staff.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text, 'superadmin'::text])) AND ((staff.role = 'superadmin'::text) OR (staff.organization_id = student.organization_id))))));



  create policy "activity_attempts_student_own"
  on "public"."activity_attempts"
  as permissive
  for all
  to authenticated
using ((student_id = auth.uid()))
with check ((student_id = auth.uid()));



  create policy "activity_attempts_update"
  on "public"."activity_attempts"
  as permissive
  for update
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "activity_feed_tenant_modify"
  on "public"."activity_feed"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "activity_feed_tenant_select"
  on "public"."activity_feed"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "activity_logs_authenticated_insert"
  on "public"."activity_logs"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "activity_logs_org_scoped_select"
  on "public"."activity_logs"
  as permissive
  for select
  to authenticated
using ((public.is_super_admin() OR ((organization_id IS NOT NULL) AND (organization_id = public.get_user_organization_id()))));



  create policy "activity_logs_simple_insert"
  on "public"."activity_logs"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.organization_id = activity_logs.organization_id)))));



  create policy "service_role_full_access"
  on "public"."activity_logs"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "activity_progress_staff_org"
  on "public"."activity_progress"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM (public.profiles staff
     JOIN public.profiles student ON ((student.id = activity_progress.student_id)))
  WHERE ((staff.id = auth.uid()) AND (staff.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text, 'superadmin'::text])) AND ((staff.role = 'superadmin'::text) OR (staff.organization_id = student.organization_id))))));



  create policy "activity_progress_student_own"
  on "public"."activity_progress"
  as permissive
  for all
  to authenticated
using ((student_id = auth.uid()))
with check ((student_id = auth.uid()));



  create policy "activity_submissions_insert_own"
  on "public"."activity_submissions"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "activity_submissions_select_own"
  on "public"."activity_submissions"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "activity_submissions_select_teacher"
  on "public"."activity_submissions"
  as permissive
  for select
  to public
using ((assigned_teacher_id = auth.uid()));



  create policy "activity_submissions_update_teacher"
  on "public"."activity_submissions"
  as permissive
  for update
  to public
using ((assigned_teacher_id = auth.uid()))
with check ((assigned_teacher_id = auth.uid()));



  create policy "ad_impressions_tenant_modify"
  on "public"."ad_impressions"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "ad_impressions_tenant_select"
  on "public"."ad_impressions"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "addresses_admin_org"
  on "public"."addresses"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles admin
  WHERE ((admin.id = auth.uid()) AND (admin.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text])) AND ((admin.role = 'superadmin'::text) OR (admin.organization_id IN ( SELECT target.organization_id
           FROM public.profiles target
          WHERE (target.id = addresses.user_id))))))));



  create policy "addresses_user_own"
  on "public"."addresses"
  as permissive
  for all
  to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "Admins can view admin users in organization"
  on "public"."admin_users"
  as permissive
  for select
  to authenticated
using ((organization_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "Superadmins can manage admin users"
  on "public"."admin_users"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'superadmin'::text)))));



  create policy "age_groups_tenant_modify"
  on "public"."age_groups"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "age_groups_tenant_select"
  on "public"."age_groups"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "ai_admin_actions_admin_delete"
  on "public"."ai_admin_actions"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "ai_admin_actions_admin_modify"
  on "public"."ai_admin_actions"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "ai_admin_actions_admin_update"
  on "public"."ai_admin_actions"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "ai_admin_actions_public_read"
  on "public"."ai_admin_actions"
  as permissive
  for select
  to authenticated
using (true);



  create policy "ai_allocation_history_tenant_modify"
  on "public"."ai_allocation_history"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "ai_allocation_history_tenant_select"
  on "public"."ai_allocation_history"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "ai_allocation_requests_tenant_modify"
  on "public"."ai_allocation_requests"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "ai_allocation_requests_tenant_select"
  on "public"."ai_allocation_requests"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "ai_attachments_delete_owner"
  on "public"."ai_attachments"
  as permissive
  for delete
  to public
using ((user_id = auth.uid()));



  create policy "ai_attachments_insert_owner"
  on "public"."ai_attachments"
  as permissive
  for insert
  to public
with check ((user_id = auth.uid()));



  create policy "ai_attachments_select_owner"
  on "public"."ai_attachments"
  as permissive
  for select
  to public
using ((user_id = auth.uid()));



  create policy "ai_attachments_update_owner"
  on "public"."ai_attachments"
  as permissive
  for update
  to public
using ((user_id = auth.uid()));



  create policy "Users can insert their own autonomy settings"
  on "public"."ai_autonomy_settings"
  as permissive
  for insert
  to public
with check (((user_id = auth.uid()) AND (preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid())))));



  create policy "Users can update their own autonomy settings"
  on "public"."ai_autonomy_settings"
  as permissive
  for update
  to public
using ((user_id = auth.uid()));



  create policy "Users can view their own autonomy settings"
  on "public"."ai_autonomy_settings"
  as permissive
  for select
  to public
using ((user_id = auth.uid()));



  create policy "Users can insert context snapshots for their preschool"
  on "public"."ai_context_snapshots"
  as permissive
  for insert
  to public
with check (((preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))) AND (user_id = auth.uid())));



  create policy "Users can view their preschool's context snapshots"
  on "public"."ai_context_snapshots"
  as permissive
  for select
  to public
using ((preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "Superadmin can view all conversations"
  on "public"."ai_conversations"
  as permissive
  for select
  to authenticated
using ((auth.uid() IN ( SELECT profiles.id
   FROM public.profiles
  WHERE (profiles.role = 'superadmin'::text))));



  create policy "Users can delete their own conversations"
  on "public"."ai_conversations"
  as permissive
  for delete
  to public
using ((user_id = auth.uid()));



  create policy "Users can insert their own conversations"
  on "public"."ai_conversations"
  as permissive
  for insert
  to public
with check ((user_id = auth.uid()));



  create policy "Users can update their own conversations"
  on "public"."ai_conversations"
  as permissive
  for update
  to public
using ((user_id = auth.uid()));



  create policy "Users can view their own conversations"
  on "public"."ai_conversations"
  as permissive
  for select
  to public
using ((user_id = auth.uid()));



  create policy "Users can insert AI events for their preschool"
  on "public"."ai_events"
  as permissive
  for insert
  to public
with check (((preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))) AND (user_id = auth.uid())));



  create policy "Users can view their preschool's AI events"
  on "public"."ai_events"
  as permissive
  for select
  to public
using ((preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "Users can submit feedback for their preschool"
  on "public"."ai_feedback"
  as permissive
  for insert
  to public
with check (((preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))) AND (user_id = auth.uid())));



  create policy "Users can view feedback for their preschool"
  on "public"."ai_feedback"
  as permissive
  for select
  to public
using ((preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "Creators can update their AI content"
  on "public"."ai_generated_content"
  as permissive
  for update
  to public
using (((auth.uid() = created_by) OR (created_by IS NULL)));



  create policy "Organization members can view AI content"
  on "public"."ai_generated_content"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.organization_id = ai_generated_content.organization_id)))));



  create policy "Users can create AI content for their org"
  on "public"."ai_generated_content"
  as permissive
  for insert
  to public
with check (((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.organization_id = ai_generated_content.organization_id)))) AND ((auth.uid() = created_by) OR (created_by IS NULL))));



  create policy "ai_generations_tenant_isolation"
  on "public"."ai_generations"
  as permissive
  for all
  to public
using (((user_id = auth.uid()) OR public.is_super_admin()));



  create policy "Superadmins can update AI global settings"
  on "public"."ai_global_settings"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'superadmin'::text)))))
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'superadmin'::text)))));



  create policy "Superadmins can view AI global settings"
  on "public"."ai_global_settings"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'superadmin'::text)))));



  create policy "Users can insert AI insights for their preschool"
  on "public"."ai_insights"
  as permissive
  for insert
  to public
with check (((preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))) AND (user_id = auth.uid())));



  create policy "Users can update their own AI insights"
  on "public"."ai_insights"
  as permissive
  for update
  to public
using (((preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))) AND (user_id = auth.uid())));



  create policy "Users can view their preschool's AI insights"
  on "public"."ai_insights"
  as permissive
  for select
  to public
using ((preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "Users can delete their own AI memories"
  on "public"."ai_memories"
  as permissive
  for delete
  to public
using (((preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))) AND (user_id = auth.uid())));



  create policy "Users can insert AI memories for their preschool"
  on "public"."ai_memories"
  as permissive
  for insert
  to public
with check (((preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))) AND (user_id = auth.uid())));



  create policy "Users can update their own AI memories"
  on "public"."ai_memories"
  as permissive
  for update
  to public
using (((preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))) AND (user_id = auth.uid())));



  create policy "Users can view their preschool's AI memories"
  on "public"."ai_memories"
  as permissive
  for select
  to public
using ((preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "Users can insert their messages"
  on "public"."ai_messages"
  as permissive
  for insert
  to authenticated
with check ((auth.uid() = user_id));



  create policy "Users can update their messages"
  on "public"."ai_messages"
  as permissive
  for update
  to authenticated
using ((auth.uid() = user_id))
with check ((auth.uid() = user_id));



  create policy "Users can view their messages"
  on "public"."ai_messages"
  as permissive
  for select
  to authenticated
using ((auth.uid() = user_id));



  create policy "Anyone can view active AI model tiers"
  on "public"."ai_model_tiers"
  as permissive
  for select
  to public
using ((is_active = true));



  create policy "Super admins can manage AI model tiers"
  on "public"."ai_model_tiers"
  as permissive
  for all
  to public
using (public.is_super_admin());



  create policy "ai_overage_logs_admin_org"
  on "public"."ai_overage_logs"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles admin
  WHERE ((admin.id = auth.uid()) AND (admin.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text])) AND ((admin.role = 'superadmin'::text) OR (admin.organization_id IN ( SELECT target.organization_id
           FROM public.profiles target
          WHERE (target.id = ai_overage_logs.user_id))))))));



  create policy "ai_overage_logs_user_own"
  on "public"."ai_overage_logs"
  as permissive
  for all
  to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "Superadmins can insert AI provider config"
  on "public"."ai_provider_config"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'superadmin'::text)))));



  create policy "Superadmins can update AI provider config"
  on "public"."ai_provider_config"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'superadmin'::text)))))
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'superadmin'::text)))));



  create policy "Superadmins can view AI provider config"
  on "public"."ai_provider_config"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'superadmin'::text)))));



  create policy "Learners can update their recommendations"
  on "public"."ai_recommendations"
  as permissive
  for update
  to public
using ((auth.uid() = learner_id));



  create policy "Learners can view their own recommendations"
  on "public"."ai_recommendations"
  as permissive
  for select
  to public
using ((auth.uid() = learner_id));



  create policy "System can create recommendations"
  on "public"."ai_recommendations"
  as permissive
  for insert
  to public
with check (true);



  create policy "Service role full access to ai_request_log"
  on "public"."ai_request_log"
  as permissive
  for all
  to public
using (((auth.jwt() ->> 'role'::text) = 'service_role'::text));



  create policy "Users can view own request logs"
  on "public"."ai_request_log"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "ai_services_admin_delete"
  on "public"."ai_services"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "ai_services_admin_modify"
  on "public"."ai_services"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "ai_services_admin_update"
  on "public"."ai_services"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "ai_services_public_read"
  on "public"."ai_services"
  as permissive
  for select
  to authenticated
using (true);



  create policy "ai_services_read_policy"
  on "public"."ai_services"
  as permissive
  for select
  to authenticated
using (((is_active = true) AND (is_available = true)));



  create policy "ai_services_write_policy"
  on "public"."ai_services"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Users can insert task runs for their preschool"
  on "public"."ai_task_runs"
  as permissive
  for insert
  to public
with check (((preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))) AND (user_id = auth.uid())));



  create policy "Users can update their task runs"
  on "public"."ai_task_runs"
  as permissive
  for update
  to public
using (((preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))) AND (user_id = auth.uid())));



  create policy "Users can view task runs for their preschool"
  on "public"."ai_task_runs"
  as permissive
  for select
  to public
using ((preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "Organization admins can view their organization's AI usage"
  on "public"."ai_usage"
  as permissive
  for select
  to public
using ((public.is_admin_level() AND public.can_access_organization(organization_id)));



  create policy "Super admins can view all AI usage"
  on "public"."ai_usage"
  as permissive
  for select
  to public
using (public.is_super_admin());



  create policy "Users can view their own AI usage"
  on "public"."ai_usage"
  as permissive
  for select
  to public
using ((user_id = auth.uid()));



  create policy "ai_usage_insert"
  on "public"."ai_usage_logs"
  as permissive
  for insert
  to authenticated
with check ((user_id = auth.uid()));



  create policy "ai_usage_select"
  on "public"."ai_usage_logs"
  as permissive
  for select
  to authenticated
using ((user_id = auth.uid()));



  create policy "ai_usage_service_role"
  on "public"."ai_usage_logs"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "ai_usage_resets_admin_delete"
  on "public"."ai_usage_resets"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "ai_usage_resets_admin_modify"
  on "public"."ai_usage_resets"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "ai_usage_resets_admin_update"
  on "public"."ai_usage_resets"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "ai_usage_resets_public_read"
  on "public"."ai_usage_resets"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Anyone can view tier limits"
  on "public"."ai_usage_tiers"
  as permissive
  for select
  to public
using (true);



  create policy "announcement_views_insert_policy"
  on "public"."announcement_views"
  as permissive
  for insert
  to public
with check ((user_id = auth.uid()));



  create policy "announcement_views_select_policy"
  on "public"."announcement_views"
  as permissive
  for select
  to public
using ((user_id = auth.uid()));



  create policy "announcements_delete_policy"
  on "public"."announcements"
  as permissive
  for delete
  to public
using (((author_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.organization_id = announcements.preschool_id) AND (p.role = ANY (ARRAY['principal'::text, 'admin'::text, 'super_admin'::text])))))));



  create policy "announcements_insert_policy"
  on "public"."announcements"
  as permissive
  for insert
  to public
with check (((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.organization_id = announcements.preschool_id) AND (p.role = ANY (ARRAY['principal'::text, 'admin'::text, 'super_admin'::text]))))) AND (author_id = auth.uid())));



  create policy "announcements_select_policy"
  on "public"."announcements"
  as permissive
  for select
  to public
using (((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.organization_id = announcements.preschool_id)))) OR (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = 'super_admin'::text))))));



  create policy "announcements_superadmin_manage"
  on "public"."announcements"
  as permissive
  for all
  to authenticated
using (public.is_superadmin_safe())
with check (public.is_superadmin_safe());



  create policy "announcements_superadmin_read"
  on "public"."announcements"
  as permissive
  for select
  to authenticated
using (public.is_superadmin_safe());



  create policy "announcements_tenant_isolation"
  on "public"."announcements"
  as permissive
  for all
  to public
using ((preschool_id = public.current_preschool_id()));



  create policy "announcements_update_policy"
  on "public"."announcements"
  as permissive
  for update
  to public
using (((author_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.organization_id = announcements.preschool_id) AND (p.role = ANY (ARRAY['principal'::text, 'admin'::text, 'super_admin'::text])))))));



  create policy "assessment_rubrics_tenant_modify"
  on "public"."assessment_rubrics"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "assessment_rubrics_tenant_select"
  on "public"."assessment_rubrics"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "assessments_staff_org"
  on "public"."assessments"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM (public.profiles staff
     JOIN public.profiles student ON ((student.id = assessments.student_id)))
  WHERE ((staff.id = auth.uid()) AND (staff.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text, 'superadmin'::text])) AND ((staff.role = 'superadmin'::text) OR (staff.organization_id = student.organization_id))))));



  create policy "assessments_student_own"
  on "public"."assessments"
  as permissive
  for all
  to authenticated
using ((student_id = auth.uid()))
with check ((student_id = auth.uid()));



  create policy "Instructors can manage assignment access for their courses"
  on "public"."assignment_access"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM ((public.assignments a
     JOIN public.courses c ON ((a.course_id = c.id)))
     JOIN public.profiles p ON ((p.id = auth.uid())))
  WHERE ((a.id = assignment_access.assignment_id) AND ((c.instructor_id = auth.uid()) OR (p.role = 'admin'::text)) AND (p.organization_id = c.organization_id)))));



  create policy "Students can view their assignment access"
  on "public"."assignment_access"
  as permissive
  for select
  to authenticated
using (((student_id = auth.uid()) OR (student_id IN ( SELECT profiles.id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'student'::text) AND (profiles.organization_id IN ( SELECT profiles_1.organization_id
           FROM public.profiles profiles_1
          WHERE (profiles_1.id = ( SELECT assignment_access_1.student_id
                   FROM public.assignment_access assignment_access_1
                  WHERE (assignment_access_1.id = assignment_access_1.id))))))))));



  create policy "assignment_categories_org_modify"
  on "public"."assignment_categories"
  as permissive
  for all
  to authenticated
using ((organization_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((organization_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "assignment_categories_org_select"
  on "public"."assignment_categories"
  as permissive
  for select
  to authenticated
using ((organization_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "assignment_grades_admin_teacher"
  on "public"."assignment_grades"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM (public.profiles admin
     JOIN public.profiles teacher ON ((teacher.id = assignment_grades.teacher_id)))
  WHERE ((admin.id = auth.uid()) AND (admin.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text])) AND ((admin.role = 'superadmin'::text) OR (admin.organization_id = teacher.organization_id))))));



  create policy "assignment_grades_teacher_own"
  on "public"."assignment_grades"
  as permissive
  for all
  to authenticated
using ((teacher_id = auth.uid()))
with check ((teacher_id = auth.uid()));



  create policy "assignment_rubrics_admin_delete"
  on "public"."assignment_rubrics"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "assignment_rubrics_admin_modify"
  on "public"."assignment_rubrics"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "assignment_rubrics_admin_update"
  on "public"."assignment_rubrics"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "assignment_rubrics_public_read"
  on "public"."assignment_rubrics"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Learners can create their own submissions"
  on "public"."assignment_submissions"
  as permissive
  for insert
  to public
with check ((auth.uid() = learner_id));



  create policy "Learners can update their own submissions"
  on "public"."assignment_submissions"
  as permissive
  for update
  to public
using ((auth.uid() = learner_id));



  create policy "Learners can view their own submissions"
  on "public"."assignment_submissions"
  as permissive
  for select
  to public
using ((auth.uid() = learner_id));



  create policy "assignment_submissions_parent_child"
  on "public"."assignment_submissions"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "assignment_submissions_staff_org"
  on "public"."assignment_submissions"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM (public.profiles staff
     JOIN public.profiles student ON ((student.id = assignment_submissions.student_id)))
  WHERE ((staff.id = auth.uid()) AND (staff.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text, 'superadmin'::text])) AND ((staff.role = 'superadmin'::text) OR (staff.organization_id = student.organization_id))))));



  create policy "assignment_submissions_student_own"
  on "public"."assignment_submissions"
  as permissive
  for all
  to authenticated
using ((student_id = auth.uid()))
with check ((student_id = auth.uid()));



  create policy "assignments_admin_manage"
  on "public"."assignments"
  as permissive
  for all
  to public
using ((public.is_admin_level() AND (EXISTS ( SELECT 1
   FROM public.courses c
  WHERE ((c.id = assignments.course_id) AND public.can_access_organization(c.organization_id))))));



  create policy "assignments_admin_read"
  on "public"."assignments"
  as permissive
  for select
  to public
using ((public.is_admin_level() AND (EXISTS ( SELECT 1
   FROM public.courses c
  WHERE ((c.id = assignments.course_id) AND public.can_access_organization(c.organization_id)))) AND (deleted_at IS NULL)));



  create policy "assignments_enrolled_student_read"
  on "public"."assignments"
  as permissive
  for select
  to public
using ((public.user_enrolled_in_course(course_id) AND public.assignment_available_to_student(id) AND (deleted_at IS NULL)));



  create policy "assignments_instructor_manage"
  on "public"."assignments"
  as permissive
  for all
  to public
using ((public.is_instructor_level() AND public.user_owns_course(course_id) AND ((deleted_at IS NULL) OR (current_setting('request.method'::text) = 'DELETE'::text))));



  create policy "assignments_instructor_read"
  on "public"."assignments"
  as permissive
  for select
  to public
using ((public.is_instructor_level() AND public.user_can_access_assignment(id) AND (deleted_at IS NULL)));



  create policy "assignments_super_admin_read"
  on "public"."assignments"
  as permissive
  for select
  to public
using (public.is_super_admin());



  create policy "attendance_parent_child"
  on "public"."attendance"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "attendance_staff_org"
  on "public"."attendance"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM (public.profiles staff
     JOIN public.students student ON ((student.id = attendance.student_id)))
  WHERE ((staff.id = auth.uid()) AND (staff.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text, 'principal_admin'::text, 'superadmin'::text])) AND ((staff.role = 'superadmin'::text) OR (staff.organization_id = student.organization_id) OR (staff.preschool_id = student.preschool_id) OR (staff.organization_id = student.preschool_id) OR (staff.preschool_id = student.organization_id))))))
with check ((EXISTS ( SELECT 1
   FROM (public.profiles staff
     JOIN public.students student ON ((student.id = attendance.student_id)))
  WHERE ((staff.id = auth.uid()) AND (staff.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text, 'principal_admin'::text, 'superadmin'::text])) AND ((staff.role = 'superadmin'::text) OR (staff.organization_id = student.organization_id) OR (staff.preschool_id = student.preschool_id) OR (staff.organization_id = student.preschool_id) OR (staff.preschool_id = student.organization_id))))));



  create policy "attendance_student_own"
  on "public"."attendance"
  as permissive
  for all
  to authenticated
using ((student_id = auth.uid()))
with check ((student_id = auth.uid()));



  create policy "attendance_records_access"
  on "public"."attendance_records"
  as permissive
  for all
  to public
using (((preschool_id = public.get_user_org_id()) OR public.is_super_admin()));



  create policy "attendance_records_parent_access"
  on "public"."attendance_records"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "attendance_records_superadmin_access"
  on "public"."attendance_records"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "attendance_records_teacher_access"
  on "public"."attendance_records"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.users u
  WHERE ((u.id = auth.uid()) AND (u.role = 'teacher'::text) AND (u.preschool_id = attendance_records.preschool_id) AND (EXISTS ( SELECT 1
           FROM public.classes c
          WHERE ((c.teacher_id = u.id) AND (c.id = attendance_records.class_id))))))))
with check ((EXISTS ( SELECT 1
   FROM public.users u
  WHERE ((u.id = auth.uid()) AND (u.role = 'teacher'::text) AND (u.preschool_id = attendance_records.preschool_id) AND (EXISTS ( SELECT 1
           FROM public.classes c
          WHERE ((c.teacher_id = u.id) AND (c.id = attendance_records.class_id))))))));



  create policy "attendance_records_tenant_access"
  on "public"."attendance_records"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = ANY (ARRAY['principal'::text, 'preschool_admin'::text]))))))
with check ((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = ANY (ARRAY['principal'::text, 'preschool_admin'::text]))))));



  create policy "Organization admins can view their organization's audit logs"
  on "public"."audit_logs"
  as permissive
  for select
  to public
using ((public.is_admin_level() AND (public.is_super_admin() OR public.can_access_organization(actor_organization_id))));



  create policy "beta_feedback_admin_org"
  on "public"."beta_feedback"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles admin
  WHERE ((admin.id = auth.uid()) AND (admin.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text])) AND ((admin.role = 'superadmin'::text) OR (admin.organization_id IN ( SELECT target.organization_id
           FROM public.profiles target
          WHERE (target.id = beta_feedback.user_id))))))));



  create policy "beta_feedback_user_own"
  on "public"."beta_feedback"
  as permissive
  for all
  to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "beta_feedback_attachments_admin_delete"
  on "public"."beta_feedback_attachments"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "beta_feedback_attachments_admin_modify"
  on "public"."beta_feedback_attachments"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "beta_feedback_attachments_admin_update"
  on "public"."beta_feedback_attachments"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "beta_feedback_attachments_public_read"
  on "public"."beta_feedback_attachments"
  as permissive
  for select
  to authenticated
using (true);



  create policy "billing_cycles_tenant_modify"
  on "public"."billing_cycles"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "billing_cycles_tenant_select"
  on "public"."billing_cycles"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "billing_invoices_school_modify"
  on "public"."billing_invoices"
  as permissive
  for all
  to authenticated
using ((school_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((school_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "billing_invoices_school_select"
  on "public"."billing_invoices"
  as permissive
  for select
  to authenticated
using ((school_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "billing_plans_deprecated_superadmin_only"
  on "public"."billing_plans"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'superadmin'::text)))));



  create policy "billing_preferences_admin_org"
  on "public"."billing_preferences"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles admin
  WHERE ((admin.id = auth.uid()) AND (admin.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text])) AND ((admin.role = 'superadmin'::text) OR (admin.organization_id IN ( SELECT target.organization_id
           FROM public.profiles target
          WHERE (target.id = billing_preferences.user_id))))))));



  create policy "billing_preferences_user_own"
  on "public"."billing_preferences"
  as permissive
  for all
  to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "Superadmins can manage blocked content"
  on "public"."blocked_content"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = 'superadmin'::text)))));



  create policy "Users can block content"
  on "public"."blocked_content"
  as permissive
  for insert
  to authenticated
with check ((blocker_id = auth.uid()));



  create policy "Users can update their blocked content"
  on "public"."blocked_content"
  as permissive
  for update
  to authenticated
using ((blocker_id = auth.uid()));



  create policy "Users can view their blocked content"
  on "public"."blocked_content"
  as permissive
  for select
  to authenticated
using ((blocker_id = auth.uid()));



  create policy "Public read access"
  on "public"."books"
  as permissive
  for select
  to public
using (true);



  create policy "Service role delete"
  on "public"."books"
  as permissive
  for delete
  to public
using (true);



  create policy "Service role insert"
  on "public"."books"
  as permissive
  for insert
  to public
with check (true);



  create policy "Service role update"
  on "public"."books"
  as permissive
  for update
  to public
using (true);



  create policy "calendar_mappings_insert_preschool"
  on "public"."calendar_event_mappings"
  as permissive
  for insert
  to public
with check ((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE (users.id = auth.uid()))));



  create policy "calendar_mappings_select_preschool"
  on "public"."calendar_event_mappings"
  as permissive
  for select
  to public
using ((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE (users.id = auth.uid()))));



  create policy "calendar_mappings_service_role_all"
  on "public"."calendar_event_mappings"
  as permissive
  for all
  to public
using (((auth.jwt() ->> 'role'::text) = 'service_role'::text));



  create policy "Users can delete their signals"
  on "public"."call_signals"
  as permissive
  for delete
  to public
using (((auth.uid() = from_user_id) OR (auth.uid() = to_user_id)));



  create policy "Users can receive signals"
  on "public"."call_signals"
  as permissive
  for select
  to public
using (((auth.uid() = to_user_id) OR (auth.uid() = from_user_id)));



  create policy "Users can send signals"
  on "public"."call_signals"
  as permissive
  for insert
  to public
with check ((auth.uid() = from_user_id));



  create policy "Users view own redemptions"
  on "public"."campaign_redemptions"
  as permissive
  for select
  to public
using (((redeemed_by_email)::text = (( SELECT users.email
   FROM auth.users
  WHERE (users.id = auth.uid())))::text));



  create policy "candidates_update_own_profile"
  on "public"."candidate_profiles"
  as permissive
  for update
  to public
using ((email = (( SELECT users.email
   FROM auth.users
  WHERE (users.id = auth.uid())))::text));



  create policy "candidates_view_own_profile"
  on "public"."candidate_profiles"
  as permissive
  for select
  to public
using ((email = (( SELECT users.email
   FROM auth.users
  WHERE (users.id = auth.uid())))::text));



  create policy "public_create_candidate_profile"
  on "public"."candidate_profiles"
  as permissive
  for insert
  to public
with check (true);



  create policy "caps_chunks_select_auth"
  on "public"."caps_chunks"
  as permissive
  for select
  to authenticated
using (true);



  create policy "CAPS chunks are publicly readable"
  on "public"."caps_content_chunks"
  as permissive
  for select
  to public
using (true);



  create policy "CAPS documents are publicly readable"
  on "public"."caps_documents"
  as permissive
  for select
  to public
using (true);



  create policy "caps_documents_select_auth"
  on "public"."caps_documents"
  as permissive
  for select
  to authenticated
using (true);



  create policy "CAPS patterns are publicly readable"
  on "public"."caps_exam_patterns"
  as permissive
  for select
  to public
using (true);



  create policy "CAPS questions are publicly readable"
  on "public"."caps_exam_questions"
  as permissive
  for select
  to public
using (true);



  create policy "Allow insert for admins on mapping"
  on "public"."caps_textbook_mapping"
  as permissive
  for insert
  to public
with check (((auth.role() = 'authenticated'::text) AND (( SELECT profiles.role
   FROM public.profiles
  WHERE (profiles.id = auth.uid())) = ANY (ARRAY['teacher'::text, 'principal'::text, 'superadmin'::text]))));



  create policy "Allow public read on verified mappings"
  on "public"."caps_textbook_mapping"
  as permissive
  for select
  to public
using (((status)::text = ANY ((ARRAY['verified'::character varying, 'approved'::character varying])::text[])));



  create policy "Allow insert for teachers and admins"
  on "public"."caps_topics"
  as permissive
  for insert
  to public
with check (((auth.role() = 'authenticated'::text) AND (( SELECT profiles.role
   FROM public.profiles
  WHERE (profiles.id = auth.uid())) = ANY (ARRAY['teacher'::text, 'principal'::text, 'superadmin'::text]))));



  create policy "Allow public read on caps_topics"
  on "public"."caps_topics"
  as permissive
  for select
  to public
using (true);



  create policy "Allow update for teachers and admins"
  on "public"."caps_topics"
  as permissive
  for update
  to public
using (((auth.role() = 'authenticated'::text) AND (( SELECT profiles.role
   FROM public.profiles
  WHERE (profiles.id = auth.uid())) = ANY (ARRAY['teacher'::text, 'principal'::text, 'superadmin'::text]))));



  create policy "Images are publicly readable"
  on "public"."chat_images"
  as permissive
  for select
  to anon
using (true);



  create policy "Users can upload images"
  on "public"."chat_images"
  as permissive
  for insert
  to authenticated
with check ((auth.uid() = uploaded_by));



  create policy "Users can view their images"
  on "public"."chat_images"
  as permissive
  for select
  to authenticated
using ((auth.uid() = uploaded_by));



  create policy "child_registration_requests_admin_manage"
  on "public"."child_registration_requests"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.preschool_id = child_registration_requests.preschool_id) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text]))))))
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.preschool_id = child_registration_requests.preschool_id) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text]))))));



  create policy "child_registration_requests_admin_view"
  on "public"."child_registration_requests"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.preschool_id = child_registration_requests.preschool_id) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'teacher'::text]))))));



  create policy "child_registration_requests_parent_insert"
  on "public"."child_registration_requests"
  as permissive
  for insert
  to authenticated
with check ((parent_id = auth.uid()));



  create policy "class_assignments_parent_child"
  on "public"."class_assignments"
  as permissive
  for select
  to authenticated
using ((class_id IN ( SELECT public.get_my_children_class_ids() AS get_my_children_class_ids)));



  create policy "class_assignments_staff_org"
  on "public"."class_assignments"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM (public.profiles staff
     JOIN public.profiles student ON ((student.id = class_assignments.student_id)))
  WHERE ((staff.id = auth.uid()) AND (staff.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text, 'superadmin'::text])) AND ((staff.role = 'superadmin'::text) OR (staff.organization_id = student.organization_id))))));



  create policy "class_assignments_student_own"
  on "public"."class_assignments"
  as permissive
  for all
  to authenticated
using ((student_id = auth.uid()))
with check ((student_id = auth.uid()));



  create policy "class_events_tenant_modify"
  on "public"."class_events"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "class_events_tenant_select"
  on "public"."class_events"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "classroom_reports_tenant_modify"
  on "public"."classroom_reports"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "classroom_reports_tenant_select"
  on "public"."classroom_reports"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "config_kv_public_read"
  on "public"."config_kv"
  as permissive
  for select
  to public
using (((is_public = true) AND (preschool_id IS NULL)));



  create policy "config_kv_tenant_isolation"
  on "public"."config_kv"
  as permissive
  for all
  to public
using (((preschool_id = public.current_preschool_id()) OR (preschool_id IS NULL) OR (is_public = true)));



  create policy "contact_discovery_settings_insert_own"
  on "public"."contact_discovery_settings"
  as permissive
  for insert
  to public
with check ((user_id = auth.uid()));



  create policy "contact_discovery_settings_select_own"
  on "public"."contact_discovery_settings"
  as permissive
  for select
  to public
using ((user_id = auth.uid()));



  create policy "contact_discovery_settings_update_own"
  on "public"."contact_discovery_settings"
  as permissive
  for update
  to public
using ((user_id = auth.uid()));



  create policy "contact_suggestions_select_own"
  on "public"."contact_suggestions"
  as permissive
  for select
  to public
using ((user_id = auth.uid()));



  create policy "contact_suggestions_update_own"
  on "public"."contact_suggestions"
  as permissive
  for update
  to public
using ((user_id = auth.uid()));



  create policy "Superadmins can view all reports"
  on "public"."content_reports"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = 'superadmin'::text)))));



  create policy "Users can create reports"
  on "public"."content_reports"
  as permissive
  for insert
  to authenticated
with check ((reporter_id = auth.uid()));



  create policy "conversation_members_admin_org"
  on "public"."conversation_members"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles admin
  WHERE ((admin.id = auth.uid()) AND (admin.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text])) AND ((admin.role = 'superadmin'::text) OR (admin.organization_id IN ( SELECT target.organization_id
           FROM public.profiles target
          WHERE (target.id = conversation_members.user_id))))))));



  create policy "conversation_members_user_own"
  on "public"."conversation_members"
  as permissive
  for all
  to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "conversations_tenant_modify"
  on "public"."conversations"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "conversations_tenant_select"
  on "public"."conversations"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "Instructors can manage course grades for their courses"
  on "public"."course_grades"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM (public.courses c
     JOIN public.profiles p ON ((p.id = auth.uid())))
  WHERE ((c.id = course_grades.course_id) AND ((c.instructor_id = auth.uid()) OR (p.role = 'admin'::text)) AND (p.organization_id = c.organization_id)))));



  create policy "Students can view their own course grades"
  on "public"."course_grades"
  as permissive
  for select
  to authenticated
using (((student_id = auth.uid()) AND (is_published = true)));



  create policy "parents_view_children_course_grades"
  on "public"."course_grades"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "Instructors can process join requests for their courses"
  on "public"."course_join_requests"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM (public.courses c
     JOIN public.profiles p ON ((p.id = auth.uid())))
  WHERE ((c.id = course_join_requests.course_id) AND ((c.instructor_id = auth.uid()) OR (p.role = 'admin'::text)) AND (p.organization_id = c.organization_id)))));



  create policy "Students can manage their own join requests"
  on "public"."course_join_requests"
  as permissive
  for all
  to authenticated
using ((student_id = auth.uid()));



  create policy "courses_authenticated_select"
  on "public"."courses"
  as permissive
  for select
  to authenticated
using ((((is_active = true) AND (deleted_at IS NULL)) OR (instructor_id = auth.uid())));



  create policy "courses_organization_delete"
  on "public"."courses"
  as permissive
  for delete
  to authenticated
using (((instructor_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND (om.organization_id = courses.organization_id) AND ((om.membership_status)::text = 'active'::text) AND ((om.member_type)::text = ANY ((ARRAY['youth_president'::character varying, 'youth_deputy'::character varying, 'youth_secretary'::character varying, 'youth_treasurer'::character varying, 'president'::character varying, 'deputy_president'::character varying, 'secretary_general'::character varying, 'treasurer'::character varying, 'ceo'::character varying, 'national_admin'::character varying])::text[])))))));



  create policy "courses_organization_insert"
  on "public"."courses"
  as permissive
  for insert
  to authenticated
with check (((EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND (om.organization_id = courses.organization_id) AND ((om.membership_status)::text = 'active'::text) AND ((om.member_type)::text = ANY ((ARRAY['youth_president'::character varying, 'youth_deputy'::character varying, 'youth_secretary'::character varying, 'youth_treasurer'::character varying, 'president'::character varying, 'deputy_president'::character varying, 'secretary_general'::character varying, 'treasurer'::character varying, 'ceo'::character varying, 'national_admin'::character varying, 'regional_manager'::character varying, 'regional_coordinator'::character varying, 'women_president'::character varying, 'women_secretary'::character varying, 'veterans_president'::character varying, 'veterans_coordinator'::character varying])::text[]))))) OR (instructor_id = auth.uid())));



  create policy "courses_organization_update"
  on "public"."courses"
  as permissive
  for update
  to authenticated
using (((instructor_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND (om.organization_id = courses.organization_id) AND ((om.membership_status)::text = 'active'::text) AND ((om.member_type)::text = ANY ((ARRAY['youth_president'::character varying, 'youth_deputy'::character varying, 'youth_secretary'::character varying, 'youth_treasurer'::character varying, 'president'::character varying, 'deputy_president'::character varying, 'secretary_general'::character varying, 'treasurer'::character varying, 'ceo'::character varying, 'national_admin'::character varying])::text[])))))))
with check (((instructor_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND (om.organization_id = courses.organization_id) AND ((om.membership_status)::text = 'active'::text) AND ((om.member_type)::text = ANY ((ARRAY['youth_president'::character varying, 'youth_deputy'::character varying, 'youth_secretary'::character varying, 'youth_treasurer'::character varying, 'president'::character varying, 'deputy_president'::character varying, 'secretary_general'::character varying, 'treasurer'::character varying, 'ceo'::character varying, 'national_admin'::character varying])::text[])))))));



  create policy "courses_service_role"
  on "public"."courses"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "Organization admins can manage CV templates"
  on "public"."cv_templates"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.organization_id = cv_templates.organization_id) AND (profiles.role = ANY (ARRAY['admin'::text, 'super_admin'::text]))))));



  create policy "Organization members can view CV templates"
  on "public"."cv_templates"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.organization_id = cv_templates.organization_id)))));



  create policy "cv_uploads_insert_org_admins"
  on "public"."cv_uploads"
  as permissive
  for insert
  to authenticated
with check (((uploaded_by = auth.uid()) AND (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.organization_id = cv_uploads.organization_id) AND (p.role = ANY (ARRAY['admin'::text, 'super_admin'::text, 'principal'::text, 'principal_admin'::text])))))));



  create policy "cv_uploads_select_org_members"
  on "public"."cv_uploads"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.organization_id = cv_uploads.organization_id)))));



  create policy "cv_uploads_update_org_admins"
  on "public"."cv_uploads"
  as permissive
  for update
  to authenticated
using (((uploaded_by = auth.uid()) AND (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.organization_id = cv_uploads.organization_id) AND (p.role = ANY (ARRAY['admin'::text, 'super_admin'::text, 'principal'::text, 'principal_admin'::text])))))))
with check ((uploaded_by = auth.uid()));



  create policy "daily_activities_admin_delete"
  on "public"."daily_activities"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "daily_activities_admin_modify"
  on "public"."daily_activities"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "daily_activities_admin_update"
  on "public"."daily_activities"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "daily_activities_public_read"
  on "public"."daily_activities"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Users can insert their agent instances"
  on "public"."dash_agent_instances"
  as permissive
  for insert
  to public
with check (((user_id = auth.uid()) AND (preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid())))));



  create policy "Users can update their agent instances"
  on "public"."dash_agent_instances"
  as permissive
  for update
  to public
using ((user_id = auth.uid()));



  create policy "Users can view their agent instances"
  on "public"."dash_agent_instances"
  as permissive
  for select
  to public
using ((user_id = auth.uid()));



  create policy "Users can insert their conversation facts"
  on "public"."dash_conversation_facts"
  as permissive
  for insert
  to public
with check (((user_id = auth.uid()) AND (preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid())))));



  create policy "Users can view their conversation facts"
  on "public"."dash_conversation_facts"
  as permissive
  for select
  to public
using ((user_id = auth.uid()));



  create policy "Dash memory is publicly readable"
  on "public"."dash_curriculum_memory"
  as permissive
  for select
  to public
using (true);



  create policy "Users can insert their reminders"
  on "public"."dash_reminders"
  as permissive
  for insert
  to public
with check (((user_id = auth.uid()) AND (preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid())))));



  create policy "Users can update their reminders"
  on "public"."dash_reminders"
  as permissive
  for update
  to public
using ((user_id = auth.uid()));



  create policy "Users can view their reminders"
  on "public"."dash_reminders"
  as permissive
  for select
  to public
using ((user_id = auth.uid()));



  create policy "Superadmin can access all dash storage"
  on "public"."dash_storage"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((dash_storage.user_id = auth.uid()) AND (profiles.role = 'superadmin'::text)))))
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((dash_storage.user_id = auth.uid()) AND (profiles.role = 'superadmin'::text)))));



  create policy "Users can delete own dash storage"
  on "public"."dash_storage"
  as permissive
  for delete
  to public
using (((auth.uid() = user_id) AND (preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (dash_storage.user_id = auth.uid())))));



  create policy "Users can insert own dash storage"
  on "public"."dash_storage"
  as permissive
  for insert
  to public
with check (((auth.uid() = user_id) AND (preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (dash_storage.user_id = auth.uid())))));



  create policy "Users can read own dash storage"
  on "public"."dash_storage"
  as permissive
  for select
  to public
using (((auth.uid() = user_id) AND (preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (dash_storage.user_id = auth.uid())))));



  create policy "Users can update own dash storage"
  on "public"."dash_storage"
  as permissive
  for update
  to public
using (((auth.uid() = user_id) AND (preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (dash_storage.user_id = auth.uid())))))
with check (((auth.uid() = user_id) AND (preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (dash_storage.user_id = auth.uid())))));



  create policy "Users can update their own context"
  on "public"."dash_user_contexts"
  as permissive
  for update
  to public
using ((user_id = auth.uid()));



  create policy "Users can upsert their own context"
  on "public"."dash_user_contexts"
  as permissive
  for insert
  to public
with check (((user_id = auth.uid()) AND (preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid())))));



  create policy "Users can view their own context"
  on "public"."dash_user_contexts"
  as permissive
  for select
  to public
using ((user_id = auth.uid()));



  create policy "Users can delete their own voice notes"
  on "public"."dashboard_voice_notes"
  as permissive
  for delete
  to public
using ((auth.uid() = user_id));



  create policy "Users can insert their own voice notes"
  on "public"."dashboard_voice_notes"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "Users can update their own voice notes"
  on "public"."dashboard_voice_notes"
  as permissive
  for update
  to public
using ((auth.uid() = user_id))
with check ((auth.uid() = user_id));



  create policy "Users can view their own voice notes"
  on "public"."dashboard_voice_notes"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "Anyone can submit deletion request"
  on "public"."deletion_requests"
  as permissive
  for insert
  to public
with check (true);



  create policy "Super admin can delete deletion requests"
  on "public"."deletion_requests"
  as permissive
  for delete
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'super_admin'::text)))));



  create policy "Super admin can update deletion requests"
  on "public"."deletion_requests"
  as permissive
  for update
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'super_admin'::text)))));



  create policy "Users can view own deletion requests"
  on "public"."deletion_requests"
  as permissive
  for select
  to public
using (((email = (auth.jwt() ->> 'email'::text)) OR (user_id = auth.uid())));



  create policy "delivery_providers_admin_delete"
  on "public"."delivery_providers"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "delivery_providers_admin_modify"
  on "public"."delivery_providers"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "delivery_providers_admin_update"
  on "public"."delivery_providers"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "delivery_providers_public_read"
  on "public"."delivery_providers"
  as permissive
  for select
  to authenticated
using (true);



  create policy "delivery_retry_queue_admin_delete"
  on "public"."delivery_retry_queue"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "delivery_retry_queue_admin_modify"
  on "public"."delivery_retry_queue"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "delivery_retry_queue_admin_update"
  on "public"."delivery_retry_queue"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "delivery_retry_queue_public_read"
  on "public"."delivery_retry_queue"
  as permissive
  for select
  to authenticated
using (true);



  create policy "delivery_webhooks_admin_delete"
  on "public"."delivery_webhooks"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "delivery_webhooks_admin_modify"
  on "public"."delivery_webhooks"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "delivery_webhooks_admin_update"
  on "public"."delivery_webhooks"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "delivery_webhooks_public_read"
  on "public"."delivery_webhooks"
  as permissive
  for select
  to authenticated
using (true);



  create policy "dm_settings_admin_org"
  on "public"."dm_settings"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles admin
  WHERE ((admin.id = auth.uid()) AND (admin.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text])) AND ((admin.role = 'superadmin'::text) OR (admin.organization_id IN ( SELECT target.organization_id
           FROM public.profiles target
          WHERE (target.id = dm_settings.user_id))))))));



  create policy "dm_settings_user_own"
  on "public"."dm_settings"
  as permissive
  for all
  to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "Admins can view signups"
  on "public"."early_access_signups"
  as permissive
  for select
  to public
using (true);



  create policy "Anyone can signup for early access"
  on "public"."early_access_signups"
  as permissive
  for insert
  to public
with check (true);



  create policy "Service role can insert email logs"
  on "public"."email_logs"
  as permissive
  for insert
  to public
with check (true);



  create policy "Teachers can view their own email logs"
  on "public"."email_logs"
  as permissive
  for select
  to public
using (((user_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'superadmin'::text])))))));



  create policy "Users can view their organization's email logs"
  on "public"."email_logs"
  as permissive
  for select
  to public
using ((organization_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid())
UNION
 SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "Users can manage their own preferences"
  on "public"."email_preferences"
  as permissive
  for all
  to public
using ((user_id IN ( SELECT users.id
   FROM public.users
  WHERE (users.auth_user_id = auth.uid()))));



  create policy "Principals and admins can manage templates"
  on "public"."email_templates"
  as permissive
  for all
  to public
using ((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE ((users.auth_user_id = auth.uid()) AND (users.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'superadmin'::text]))))));



  create policy "Users can view their preschool templates"
  on "public"."email_templates"
  as permissive
  for select
  to public
using (((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE (users.auth_user_id = auth.uid()))) OR (is_system_template = true)));



  create policy "emergency_contacts_parent_child"
  on "public"."emergency_contacts"
  as permissive
  for all
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "emergency_contacts_staff_org"
  on "public"."emergency_contacts"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM (public.profiles staff
     JOIN public.profiles student ON ((student.id = emergency_contacts.student_id)))
  WHERE ((staff.id = auth.uid()) AND (staff.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text, 'superadmin'::text])) AND ((staff.role = 'superadmin'::text) OR (staff.organization_id = student.organization_id))))));



  create policy "emergency_contacts_student_own"
  on "public"."emergency_contacts"
  as permissive
  for all
  to authenticated
using ((student_id = auth.uid()))
with check ((student_id = auth.uid()));



  create policy "enrollment_applications_service_full"
  on "public"."enrollment_applications"
  as permissive
  for all
  to service_role
using (true);



  create policy "enrollment_applications_tenant_modify"
  on "public"."enrollment_applications"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT COALESCE(users.organization_id, users.preschool_id) AS "coalesce"
   FROM public.users
  WHERE ((users.id = auth.uid()) OR (users.auth_user_id = auth.uid())))));



  create policy "enrollment_applications_tenant_read"
  on "public"."enrollment_applications"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT COALESCE(users.organization_id, users.preschool_id) AS "coalesce"
   FROM public.users
  WHERE ((users.id = auth.uid()) OR (users.auth_user_id = auth.uid())))));



  create policy "enrollments_admin_manage"
  on "public"."enrollments"
  as permissive
  for all
  to public
using ((public.is_admin_level() AND (EXISTS ( SELECT 1
   FROM public.courses c
  WHERE ((c.id = enrollments.course_id) AND public.can_access_organization(c.organization_id))))));



  create policy "enrollments_admin_read"
  on "public"."enrollments"
  as permissive
  for select
  to public
using ((public.is_admin_level() AND (EXISTS ( SELECT 1
   FROM public.courses c
  WHERE ((c.id = enrollments.course_id) AND public.can_access_organization(c.organization_id))))));



  create policy "enrollments_instructor_manage"
  on "public"."enrollments"
  as permissive
  for all
  to public
using ((public.is_instructor_level() AND public.user_owns_course(course_id)));



  create policy "enrollments_instructor_read"
  on "public"."enrollments"
  as permissive
  for select
  to public
using ((public.is_instructor_level() AND public.user_owns_course(course_id)));



  create policy "enrollments_student_read_own"
  on "public"."enrollments"
  as permissive
  for select
  to public
using ((student_id = auth.uid()));



  create policy "enrollments_student_self_enroll"
  on "public"."enrollments"
  as permissive
  for insert
  to authenticated
with check (((student_id = auth.uid()) AND (EXISTS ( SELECT 1
   FROM public.courses c
  WHERE ((c.id = enrollments.course_id) AND (c.is_active = true) AND (c.deleted_at IS NULL) AND ((enrollments.enrollment_method = 'join_code'::text) OR public.can_access_organization(c.organization_id) OR (NOT (EXISTS ( SELECT 1
           FROM public.profiles
          WHERE (profiles.id = auth.uid())))) OR (( SELECT profiles.organization_id
           FROM public.profiles
          WHERE (profiles.id = auth.uid())) IS NULL)))))));



  create policy "enrollments_student_self_update"
  on "public"."enrollments"
  as permissive
  for update
  to public
using (((student_id = auth.uid()) AND (EXISTS ( SELECT 1
   FROM public.courses c
  WHERE ((c.id = enrollments.course_id) AND (c.is_active = true) AND (c.deleted_at IS NULL))))));



  create policy "enrollments_super_admin_read"
  on "public"."enrollments"
  as permissive
  for select
  to public
using (public.is_super_admin());



  create policy "enterprise_leads_admin_delete"
  on "public"."enterprise_leads"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "enterprise_leads_admin_modify"
  on "public"."enterprise_leads"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "enterprise_leads_admin_update"
  on "public"."enterprise_leads"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "enterprise_leads_public_read"
  on "public"."enterprise_leads"
  as permissive
  for select
  to authenticated
using (true);



  create policy "error_logs_own"
  on "public"."error_logs"
  as permissive
  for all
  to public
using (((user_id = auth.uid()) OR (user_id IS NULL)));



  create policy "Members can register for events"
  on "public"."event_attendees"
  as permissive
  for insert
  to public
with check ((member_id IN ( SELECT organization_members.id
   FROM public.organization_members
  WHERE (organization_members.user_id = auth.uid()))));



  create policy "Members can view own attendance"
  on "public"."event_attendees"
  as permissive
  for select
  to public
using ((member_id IN ( SELECT organization_members.id
   FROM public.organization_members
  WHERE (organization_members.user_id = auth.uid()))));



  create policy "Org admins can manage attendance"
  on "public"."event_attendees"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM (public.member_events e
     JOIN public.profiles p ON ((p.organization_id = e.organization_id)))
  WHERE ((e.id = event_attendees.event_id) AND (p.id = auth.uid()) AND (p.role = ANY (ARRAY['admin'::text, 'principal'::text, 'super_admin'::text]))))));



  create policy "event_audiences_admin_delete"
  on "public"."event_audiences"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "event_audiences_admin_modify"
  on "public"."event_audiences"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "event_audiences_admin_update"
  on "public"."event_audiences"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "event_audiences_public_read"
  on "public"."event_audiences"
  as permissive
  for select
  to authenticated
using (true);



  create policy "event_invitations_admin_delete"
  on "public"."event_invitations"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "event_invitations_admin_modify"
  on "public"."event_invitations"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "event_invitations_admin_update"
  on "public"."event_invitations"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "event_invitations_public_read"
  on "public"."event_invitations"
  as permissive
  for select
  to authenticated
using (true);



  create policy "event_media_admin_delete"
  on "public"."event_media"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "event_media_admin_modify"
  on "public"."event_media"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "event_media_admin_update"
  on "public"."event_media"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "event_media_public_read"
  on "public"."event_media"
  as permissive
  for select
  to authenticated
using (true);



  create policy "event_notifications_admin_delete"
  on "public"."event_notifications"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "event_notifications_admin_modify"
  on "public"."event_notifications"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "event_notifications_admin_update"
  on "public"."event_notifications"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "event_notifications_public_read"
  on "public"."event_notifications"
  as permissive
  for select
  to authenticated
using (true);



  create policy "event_participants_admin_org"
  on "public"."event_participants"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles admin
  WHERE ((admin.id = auth.uid()) AND (admin.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text])) AND ((admin.role = 'superadmin'::text) OR (admin.organization_id IN ( SELECT target.organization_id
           FROM public.profiles target
          WHERE (target.id = event_participants.user_id))))))));



  create policy "event_participants_user_own"
  on "public"."event_participants"
  as permissive
  for all
  to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "event_reactions_admin_org"
  on "public"."event_reactions"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles admin
  WHERE ((admin.id = auth.uid()) AND (admin.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text])) AND ((admin.role = 'superadmin'::text) OR (admin.organization_id IN ( SELECT target.organization_id
           FROM public.profiles target
          WHERE (target.id = event_reactions.user_id))))))));



  create policy "event_reactions_user_own"
  on "public"."event_reactions"
  as permissive
  for all
  to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "event_rsvps_insert_policy"
  on "public"."event_rsvps"
  as permissive
  for insert
  to public
with check (((user_id = auth.uid()) AND (EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.preschool_id = event_rsvps.preschool_id))))));



  create policy "event_rsvps_select_policy"
  on "public"."event_rsvps"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.preschool_id = event_rsvps.preschool_id)))));



  create policy "event_rsvps_update_policy"
  on "public"."event_rsvps"
  as permissive
  for update
  to public
using ((user_id = auth.uid()));



  create policy "event_updates_admin_delete"
  on "public"."event_updates"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "event_updates_admin_modify"
  on "public"."event_updates"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "event_updates_admin_update"
  on "public"."event_updates"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "event_updates_public_read"
  on "public"."event_updates"
  as permissive
  for select
  to authenticated
using (true);



  create policy "events_tenant_modify"
  on "public"."events"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "events_tenant_select"
  on "public"."events"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "Teachers can create assignments"
  on "public"."exam_assignments"
  as permissive
  for insert
  to authenticated
with check ((auth.uid() = teacher_id));



  create policy "Teachers can delete their assignments"
  on "public"."exam_assignments"
  as permissive
  for delete
  to authenticated
using ((auth.uid() = teacher_id));



  create policy "Teachers can update their assignments"
  on "public"."exam_assignments"
  as permissive
  for update
  to authenticated
using ((auth.uid() = teacher_id))
with check ((auth.uid() = teacher_id));



  create policy "Teachers can view their assignments"
  on "public"."exam_assignments"
  as permissive
  for select
  to authenticated
using (((auth.uid() = teacher_id) OR (auth.uid() = ANY (student_ids))));



  create policy "Parents can view children attempts"
  on "public"."exam_attempts"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.students
  WHERE ((students.id = exam_attempts.student_id) AND (students.parent_id = ( SELECT profiles.id
           FROM public.profiles
          WHERE (profiles.auth_user_id = auth.uid())))))));



  create policy "Users can create own attempts"
  on "public"."exam_attempts"
  as permissive
  for insert
  to authenticated
with check ((user_id = auth.uid()));



  create policy "Users can update own attempts"
  on "public"."exam_attempts"
  as permissive
  for update
  to authenticated
using ((user_id = auth.uid()));



  create policy "Users can view own attempts"
  on "public"."exam_attempts"
  as permissive
  for select
  to authenticated
using ((user_id = auth.uid()));



  create policy "Users can delete their own exam generations"
  on "public"."exam_generations"
  as permissive
  for delete
  to public
using ((auth.uid() = user_id));



  create policy "Users can insert their own exam generations"
  on "public"."exam_generations"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "Users can update their own exam generations"
  on "public"."exam_generations"
  as permissive
  for update
  to public
using ((auth.uid() = user_id));



  create policy "Users can view their own exam generations"
  on "public"."exam_generations"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "Anyone can view exam papers"
  on "public"."exam_papers"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Only admins can manage exam papers"
  on "public"."exam_papers"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['super_admin'::text, 'admin'::text, 'principal'::text]))))));



  create policy "Students can create submissions"
  on "public"."exam_submissions"
  as permissive
  for insert
  to authenticated
with check ((auth.uid() = student_id));



  create policy "Students can update their own submissions"
  on "public"."exam_submissions"
  as permissive
  for update
  to authenticated
using (((auth.uid() = student_id) OR (auth.uid() IN ( SELECT exam_assignments.teacher_id
   FROM public.exam_assignments
  WHERE (exam_assignments.id = exam_submissions.assignment_id)))))
with check (((auth.uid() = student_id) OR (auth.uid() IN ( SELECT exam_assignments.teacher_id
   FROM public.exam_assignments
  WHERE (exam_assignments.id = exam_submissions.assignment_id)))));



  create policy "Students can view their submissions"
  on "public"."exam_submissions"
  as permissive
  for select
  to authenticated
using (((auth.uid() = student_id) OR (auth.uid() IN ( SELECT exam_assignments.teacher_id
   FROM public.exam_assignments
  WHERE (exam_assignments.id = exam_submissions.assignment_id)))));



  create policy "Users can insert their own progress"
  on "public"."exam_user_progress"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "Users can update their own progress"
  on "public"."exam_user_progress"
  as permissive
  for update
  to public
using ((auth.uid() = user_id));



  create policy "Users can view their own progress"
  on "public"."exam_user_progress"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "expense_categories_tenant_modify"
  on "public"."expense_categories"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "expense_categories_tenant_select"
  on "public"."expense_categories"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "Anyone can read feature flags"
  on "public"."feature_flags"
  as permissive
  for select
  to public
using (true);



  create policy "School staff can manage payments"
  on "public"."fee_payments"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['principal'::text, 'superadmin'::text]))))));



  create policy "parents_view_their_payments"
  on "public"."fee_payments"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "fee_structures_delete"
  on "public"."fee_structures"
  as permissive
  for delete
  to public
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['principal'::text, 'admin'::text, 'super_admin'::text]))))));



  create policy "fee_structures_insert"
  on "public"."fee_structures"
  as permissive
  for insert
  to public
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['principal'::text, 'admin'::text, 'super_admin'::text]))))));



  create policy "fee_structures_tenant_select"
  on "public"."fee_structures"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "fee_structures_update"
  on "public"."fee_structures"
  as permissive
  for update
  to public
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['principal'::text, 'admin'::text, 'super_admin'::text]))))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['principal'::text, 'admin'::text, 'super_admin'::text]))))));



  create policy "financial_transactions_access"
  on "public"."financial_transactions"
  as permissive
  for all
  to public
using (((preschool_id = public.get_user_org_id()) OR public.is_super_admin()));



  create policy "financial_transactions_creator_access"
  on "public"."financial_transactions"
  as permissive
  for all
  to authenticated
using (((created_by = auth.uid()) AND (EXISTS ( SELECT 1
   FROM public.users u
  WHERE ((u.id = auth.uid()) AND (u.preschool_id = financial_transactions.preschool_id))))))
with check (((created_by = auth.uid()) AND (EXISTS ( SELECT 1
   FROM public.users u
  WHERE ((u.id = auth.uid()) AND (u.preschool_id = financial_transactions.preschool_id))))));



  create policy "financial_transactions_superadmin_access"
  on "public"."financial_transactions"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "financial_transactions_tenant_access"
  on "public"."financial_transactions"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = ANY (ARRAY['principal'::text, 'preschool_admin'::text]))))))
with check ((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = ANY (ARRAY['principal'::text, 'preschool_admin'::text]))))));



  create policy "financial_transactions_tenant_isolation"
  on "public"."financial_transactions"
  as permissive
  for all
  to public
using ((preschool_id = public.current_preschool_id()));



  create policy "Instructors can manage gradebook entries for their courses"
  on "public"."gradebook_entries"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM (public.courses c
     JOIN public.profiles p ON ((p.id = auth.uid())))
  WHERE ((c.id = gradebook_entries.course_id) AND ((c.instructor_id = auth.uid()) OR (p.role = 'admin'::text)) AND (p.organization_id = c.organization_id)))));



  create policy "Students can view their own gradebook entries"
  on "public"."gradebook_entries"
  as permissive
  for select
  to authenticated
using ((student_id = auth.uid()));



  create policy "parents_view_children_gradebook_entries"
  on "public"."gradebook_entries"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "grades_admin_manage"
  on "public"."grades"
  as permissive
  for all
  to public
using ((public.is_admin_level() AND (EXISTS ( SELECT 1
   FROM ((public.submissions s
     JOIN public.assignments a ON ((a.id = s.assignment_id)))
     JOIN public.courses c ON ((c.id = a.course_id)))
  WHERE ((s.id = grades.submission_id) AND public.can_access_organization(c.organization_id) AND (a.deleted_at IS NULL) AND (c.deleted_at IS NULL))))));



  create policy "grades_admin_read"
  on "public"."grades"
  as permissive
  for select
  to public
using ((public.is_admin_level() AND (EXISTS ( SELECT 1
   FROM ((public.submissions s
     JOIN public.assignments a ON ((a.id = s.assignment_id)))
     JOIN public.courses c ON ((c.id = a.course_id)))
  WHERE ((s.id = grades.submission_id) AND public.can_access_organization(c.organization_id) AND (a.deleted_at IS NULL) AND (c.deleted_at IS NULL))))));



  create policy "grades_instructor_manage"
  on "public"."grades"
  as permissive
  for all
  to public
using ((public.is_instructor_level() AND (EXISTS ( SELECT 1
   FROM ((public.submissions s
     JOIN public.assignments a ON ((a.id = s.assignment_id)))
     JOIN public.courses c ON ((c.id = a.course_id)))
  WHERE ((s.id = grades.submission_id) AND ((c.instructor_id = auth.uid()) OR public.can_access_organization(c.organization_id)) AND (a.deleted_at IS NULL) AND (c.deleted_at IS NULL))))));



  create policy "grades_instructor_read"
  on "public"."grades"
  as permissive
  for select
  to public
using ((public.is_instructor_level() AND (EXISTS ( SELECT 1
   FROM ((public.submissions s
     JOIN public.assignments a ON ((a.id = s.assignment_id)))
     JOIN public.courses c ON ((c.id = a.course_id)))
  WHERE ((s.id = grades.submission_id) AND ((c.instructor_id = auth.uid()) OR public.can_access_organization(c.organization_id)) AND (a.deleted_at IS NULL) AND (c.deleted_at IS NULL))))));



  create policy "grades_student_read_published"
  on "public"."grades"
  as permissive
  for select
  to public
using (((is_published = true) AND (EXISTS ( SELECT 1
   FROM public.submissions s
  WHERE ((s.id = grades.submission_id) AND (s.student_id = auth.uid()))))));



  create policy "grades_super_admin_read"
  on "public"."grades"
  as permissive
  for select
  to public
using (public.is_super_admin());



  create policy "group_invitations_admin_delete"
  on "public"."group_invitations"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "group_invitations_admin_modify"
  on "public"."group_invitations"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "group_invitations_admin_update"
  on "public"."group_invitations"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "group_invitations_public_read"
  on "public"."group_invitations"
  as permissive
  for select
  to authenticated
using (true);



  create policy "group_members_admin_org"
  on "public"."group_members"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles admin
  WHERE ((admin.id = auth.uid()) AND (admin.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text])) AND ((admin.role = 'superadmin'::text) OR (admin.organization_id IN ( SELECT target.organization_id
           FROM public.profiles target
          WHERE (target.id = group_members.user_id))))))));



  create policy "group_members_user_own"
  on "public"."group_members"
  as permissive
  for all
  to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "Organization members can view groups"
  on "public"."groups"
  as permissive
  for select
  to authenticated
using ((organization_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "Teachers can manage groups in their organization"
  on "public"."groups"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.organization_id = groups.organization_id) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "guardian_requests_parent_insert"
  on "public"."guardian_requests"
  as permissive
  for insert
  to public
with check (((parent_auth_id = auth.uid()) AND (status = 'pending'::text) AND ((school_id IS NULL) OR (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.auth_user_id = auth.uid()) AND (p.role = 'parent'::text) AND (p.preschool_id = guardian_requests.school_id)))))));



  create policy "guardian_requests_parent_select_own"
  on "public"."guardian_requests"
  as permissive
  for select
  to authenticated
using ((parent_auth_id = auth.uid()));



  create policy "guardian_requests_school_modify"
  on "public"."guardian_requests"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.auth_user_id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'principal'::text, 'superadmin'::text])) AND ((profiles.organization_id = guardian_requests.school_id) OR (profiles.preschool_id = guardian_requests.school_id))))));



  create policy "guardian_requests_school_select"
  on "public"."guardian_requests"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.auth_user_id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'principal'::text, 'superadmin'::text])) AND ((profiles.organization_id = guardian_requests.school_id) OR (profiles.preschool_id = guardian_requests.school_id))))));



  create policy "Anyone can log guest usage"
  on "public"."guest_usage_log"
  as permissive
  for insert
  to public
with check (true);



  create policy "Superadmin can view guest usage"
  on "public"."guest_usage_log"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'superadmin'::text)))));



  create policy "homework_activity_log_tenant_isolation"
  on "public"."homework_activity_log"
  as permissive
  for all
  to public
using ((preschool_id = public.current_preschool_id()))
with check ((preschool_id = public.current_preschool_id()));



  create policy "homework_assignment_targets_tenant_isolation"
  on "public"."homework_assignment_targets"
  as permissive
  for all
  to public
using ((preschool_id = public.current_preschool_id()))
with check ((preschool_id = public.current_preschool_id()));



  create policy "anon_debug_access"
  on "public"."homework_assignments"
  as permissive
  for select
  to anon
using (true);



  create policy "authenticated_access"
  on "public"."homework_assignments"
  as permissive
  for all
  to authenticated
using (true)
with check (true);



  create policy "homework_assignments_access"
  on "public"."homework_assignments"
  as permissive
  for all
  to public
using (((preschool_id = public.get_user_org_id()) OR public.is_super_admin()));



  create policy "homework_assignments_parent_read_access"
  on "public"."homework_assignments"
  as permissive
  for select
  to authenticated
using (((class_id IN ( SELECT public.get_my_children_class_ids() AS get_my_children_class_ids)) OR (preschool_id IN ( SELECT public.get_my_children_preschool_ids() AS get_my_children_preschool_ids))));



  create policy "homework_assignments_superadmin_access"
  on "public"."homework_assignments"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "homework_assignments_teacher_full_access"
  on "public"."homework_assignments"
  as permissive
  for all
  to authenticated
using (((teacher_id = auth.uid()) AND (EXISTS ( SELECT 1
   FROM public.users u
  WHERE ((u.id = auth.uid()) AND (u.role = 'teacher'::text) AND (u.preschool_id = homework_assignments.preschool_id))))))
with check (((teacher_id = auth.uid()) AND (EXISTS ( SELECT 1
   FROM public.users u
  WHERE ((u.id = auth.uid()) AND (u.role = 'teacher'::text) AND (u.preschool_id = homework_assignments.preschool_id))))));



  create policy "homework_assignments_tenant_isolation"
  on "public"."homework_assignments"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = ANY (ARRAY['principal'::text, 'preschool_admin'::text]))))))
with check ((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = ANY (ARRAY['principal'::text, 'preschool_admin'::text]))))));



  create policy "service_role_access"
  on "public"."homework_assignments"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "homework_notifications_tenant_isolation"
  on "public"."homework_notifications"
  as permissive
  for all
  to public
using ((preschool_id = public.current_preschool_id()))
with check ((preschool_id = public.current_preschool_id()));



  create policy "homework_submissions_parent_child"
  on "public"."homework_submissions"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "homework_submissions_staff_org"
  on "public"."homework_submissions"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM (public.profiles staff
     JOIN public.profiles student ON ((student.id = homework_submissions.student_id)))
  WHERE ((staff.id = auth.uid()) AND (staff.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text, 'superadmin'::text])) AND ((staff.role = 'superadmin'::text) OR (staff.organization_id = student.organization_id))))));



  create policy "homework_submissions_student_own"
  on "public"."homework_submissions"
  as permissive
  for all
  to authenticated
using ((student_id = auth.uid()))
with check ((student_id = auth.uid()));



  create policy "in_app_notifications_delete"
  on "public"."in_app_notifications"
  as permissive
  for delete
  to public
using ((user_id = auth.uid()));



  create policy "in_app_notifications_insert"
  on "public"."in_app_notifications"
  as permissive
  for insert
  to public
with check (true);



  create policy "in_app_notifications_select"
  on "public"."in_app_notifications"
  as permissive
  for select
  to public
using ((user_id = auth.uid()));



  create policy "in_app_notifications_update"
  on "public"."in_app_notifications"
  as permissive
  for update
  to public
using ((user_id = auth.uid()));



  create policy "independent_children_admin_delete"
  on "public"."independent_children"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "independent_children_admin_modify"
  on "public"."independent_children"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "independent_children_admin_update"
  on "public"."independent_children"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "independent_children_public_read"
  on "public"."independent_children"
  as permissive
  for select
  to authenticated
using (true);



  create policy "independent_content_library_admin_delete"
  on "public"."independent_content_library"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "independent_content_library_admin_modify"
  on "public"."independent_content_library"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "independent_content_library_admin_update"
  on "public"."independent_content_library"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "independent_content_library_public_read"
  on "public"."independent_content_library"
  as permissive
  for select
  to authenticated
using (true);



  create policy "integration_audit_insert_staff"
  on "public"."integration_audit_log"
  as permissive
  for insert
  to public
with check ((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = ANY (ARRAY['principal'::text, 'teacher'::text, 'superadmin'::text]))))));



  create policy "integration_audit_select_admin"
  on "public"."integration_audit_log"
  as permissive
  for select
  to public
using ((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = ANY (ARRAY['principal'::text, 'superadmin'::text]))))));



  create policy "integration_audit_service_role_all"
  on "public"."integration_audit_log"
  as permissive
  for all
  to public
using (((auth.jwt() ->> 'role'::text) = 'service_role'::text));



  create policy "interactive_activities_insert"
  on "public"."interactive_activities"
  as permissive
  for insert
  to public
with check (((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.preschool_id = interactive_activities.preschool_id) AND (p.role = ANY (ARRAY['teacher'::text, 'principal'::text]))))) OR (EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'super_admin'::text))))));



  create policy "interactive_activities_select"
  on "public"."interactive_activities"
  as permissive
  for select
  to authenticated
using (((preschool_id IN ( SELECT public.get_my_children_preschool_ids() AS get_my_children_preschool_ids)) OR (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.auth_user_id = auth.uid()) AND (COALESCE(p.organization_id, p.preschool_id) = interactive_activities.preschool_id))))));



  create policy "parents_view_interactive_activities"
  on "public"."interactive_activities"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT public.get_my_children_preschool_ids() AS get_my_children_preschool_ids)));



  create policy "teachers_manage_interactive_activities"
  on "public"."interactive_activities"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['teacher'::text, 'principal'::text, 'principal_admin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = interactive_activities.preschool_id)))));



  create policy "principals_create_interviews"
  on "public"."interview_schedules"
  as permissive
  for insert
  to public
with check ((application_id IN ( SELECT ja.id
   FROM (public.job_applications ja
     JOIN public.job_postings jp ON ((ja.job_posting_id = jp.id)))
  WHERE ((jp.preschool_id IN ( SELECT users.preschool_id
           FROM public.users
          WHERE (users.auth_user_id = auth.uid()))) OR (jp.preschool_id IN ( SELECT profiles.organization_id
           FROM public.profiles
          WHERE (profiles.id = auth.uid())))))));



  create policy "principals_update_interviews"
  on "public"."interview_schedules"
  as permissive
  for update
  to public
using ((application_id IN ( SELECT ja.id
   FROM (public.job_applications ja
     JOIN public.job_postings jp ON ((ja.job_posting_id = jp.id)))
  WHERE ((jp.preschool_id IN ( SELECT users.preschool_id
           FROM public.users
          WHERE (users.auth_user_id = auth.uid()))) OR (jp.preschool_id IN ( SELECT profiles.organization_id
           FROM public.profiles
          WHERE (profiles.id = auth.uid())))))));



  create policy "principals_view_interviews"
  on "public"."interview_schedules"
  as permissive
  for select
  to public
using ((application_id IN ( SELECT ja.id
   FROM (public.job_applications ja
     JOIN public.job_postings jp ON ((ja.job_posting_id = jp.id)))
  WHERE ((jp.preschool_id IN ( SELECT users.preschool_id
           FROM public.users
          WHERE (users.auth_user_id = auth.uid()))) OR (jp.preschool_id IN ( SELECT profiles.organization_id
           FROM public.profiles
          WHERE (profiles.id = auth.uid())))))));



  create policy "invitation_codes_tenant_modify"
  on "public"."invitation_codes"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "invitation_codes_tenant_select"
  on "public"."invitation_codes"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "Principals can create invitations"
  on "public"."invitations"
  as permissive
  for insert
  to authenticated
with check ((organization_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['principal'::text, 'admin'::text]))))));



  create policy "Principals can update organization invitations"
  on "public"."invitations"
  as permissive
  for update
  to authenticated
using ((organization_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['principal'::text, 'admin'::text]))))))
with check ((organization_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['principal'::text, 'admin'::text]))))));



  create policy "Principals can view organization invitations"
  on "public"."invitations"
  as permissive
  for select
  to authenticated
using ((organization_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['principal'::text, 'admin'::text, 'teacher'::text]))))));



  create policy "Service role has full access to invitations"
  on "public"."invitations"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "invite_logs_insert_own"
  on "public"."invite_logs"
  as permissive
  for insert
  to public
with check ((sender_id = auth.uid()));



  create policy "invite_logs_select_own"
  on "public"."invite_logs"
  as permissive
  for select
  to public
using ((sender_id = auth.uid()));



  create policy "invite_logs_select_preschool"
  on "public"."invite_logs"
  as permissive
  for select
  to public
using ((preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['principal'::text, 'teacher'::text]))))));



  create policy "invite_logs_service_role"
  on "public"."invite_logs"
  as permissive
  for all
  to public
using (((auth.jwt() ->> 'role'::text) = 'service_role'::text));



  create policy "invoice_audit_log_admin_org"
  on "public"."invoice_audit_log"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles admin
  WHERE ((admin.id = auth.uid()) AND (admin.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text])) AND ((admin.role = 'superadmin'::text) OR (admin.organization_id IN ( SELECT target.organization_id
           FROM public.profiles target
          WHERE (target.id = invoice_audit_log.user_id))))))));



  create policy "invoice_audit_log_user_own"
  on "public"."invoice_audit_log"
  as permissive
  for all
  to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "invoice_items_admin_delete"
  on "public"."invoice_items"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "invoice_items_admin_modify"
  on "public"."invoice_items"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "invoice_items_admin_update"
  on "public"."invoice_items"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "invoice_items_public_read"
  on "public"."invoice_items"
  as permissive
  for select
  to authenticated
using (true);



  create policy "invoice_payments_admin_delete"
  on "public"."invoice_payments"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "invoice_payments_admin_modify"
  on "public"."invoice_payments"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "invoice_payments_admin_update"
  on "public"."invoice_payments"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "invoice_payments_public_read"
  on "public"."invoice_payments"
  as permissive
  for select
  to authenticated
using (true);



  create policy "invoice_templates_tenant_modify"
  on "public"."invoice_templates"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "invoice_templates_tenant_select"
  on "public"."invoice_templates"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "invoices_access"
  on "public"."invoices"
  as permissive
  for all
  to public
using (((preschool_id = public.get_user_org_id()) OR public.is_super_admin()));



  create policy "invoices_creator_access"
  on "public"."invoices"
  as permissive
  for all
  to authenticated
using (((created_by = auth.uid()) AND (EXISTS ( SELECT 1
   FROM public.users u
  WHERE ((u.id = auth.uid()) AND (u.preschool_id = invoices.preschool_id))))))
with check (((created_by = auth.uid()) AND (EXISTS ( SELECT 1
   FROM public.users u
  WHERE ((u.id = auth.uid()) AND (u.preschool_id = invoices.preschool_id))))));



  create policy "invoices_parent_access"
  on "public"."invoices"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "invoices_superadmin_access"
  on "public"."invoices"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "invoices_tenant_access"
  on "public"."invoices"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = ANY (ARRAY['principal'::text, 'preschool_admin'::text]))))))
with check ((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = ANY (ARRAY['principal'::text, 'preschool_admin'::text]))))));



  create policy "candidates_manage_own_alerts"
  on "public"."job_alerts"
  as permissive
  for all
  to public
using ((candidate_profile_id IN ( SELECT candidate_profiles.id
   FROM public.candidate_profiles
  WHERE (candidate_profiles.email = (( SELECT users.email
           FROM auth.users
          WHERE (users.id = auth.uid())))::text))));



  create policy "candidates_view_own_applications"
  on "public"."job_applications"
  as permissive
  for select
  to public
using ((candidate_profile_id IN ( SELECT candidate_profiles.id
   FROM public.candidate_profiles
  WHERE (candidate_profiles.email = (( SELECT users.email
           FROM auth.users
          WHERE (users.id = auth.uid())))::text))));



  create policy "principals_update_applications"
  on "public"."job_applications"
  as permissive
  for update
  to public
using ((job_posting_id IN ( SELECT job_postings.id
   FROM public.job_postings
  WHERE ((job_postings.preschool_id IN ( SELECT users.preschool_id
           FROM public.users
          WHERE (users.auth_user_id = auth.uid()))) OR (job_postings.preschool_id IN ( SELECT profiles.organization_id
           FROM public.profiles
          WHERE (profiles.id = auth.uid())))))));



  create policy "principals_view_applications"
  on "public"."job_applications"
  as permissive
  for select
  to public
using ((job_posting_id IN ( SELECT job_postings.id
   FROM public.job_postings
  WHERE ((job_postings.preschool_id IN ( SELECT users.preschool_id
           FROM public.users
          WHERE (users.auth_user_id = auth.uid()))) OR (job_postings.preschool_id IN ( SELECT profiles.organization_id
           FROM public.profiles
          WHERE (profiles.id = auth.uid())))))));



  create policy "public_create_applications"
  on "public"."job_applications"
  as permissive
  for insert
  to public
with check (true);



  create policy "principals_create_job_distributions"
  on "public"."job_distributions"
  as permissive
  for insert
  to public
with check ((job_posting_id IN ( SELECT job_postings.id
   FROM public.job_postings
  WHERE ((job_postings.preschool_id IN ( SELECT users.preschool_id
           FROM public.users
          WHERE (users.auth_user_id = auth.uid()))) OR (job_postings.preschool_id IN ( SELECT profiles.organization_id
           FROM public.profiles
          WHERE (profiles.id = auth.uid())))))));



  create policy "principals_view_job_distributions"
  on "public"."job_distributions"
  as permissive
  for select
  to public
using ((job_posting_id IN ( SELECT job_postings.id
   FROM public.job_postings
  WHERE ((job_postings.preschool_id IN ( SELECT users.preschool_id
           FROM public.users
          WHERE (users.auth_user_id = auth.uid()))) OR (job_postings.preschool_id IN ( SELECT profiles.organization_id
           FROM public.profiles
          WHERE (profiles.id = auth.uid())))))));



  create policy "principals_create_job_postings"
  on "public"."job_postings"
  as permissive
  for insert
  to public
with check (((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE (users.auth_user_id = auth.uid()))) OR (preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid())))));



  create policy "principals_delete_job_postings"
  on "public"."job_postings"
  as permissive
  for delete
  to public
using (((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE (users.auth_user_id = auth.uid()))) OR (preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid())))));



  create policy "principals_update_job_postings"
  on "public"."job_postings"
  as permissive
  for update
  to public
using (((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE (users.auth_user_id = auth.uid()))) OR (preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid())))));



  create policy "principals_view_own_school_job_postings"
  on "public"."job_postings"
  as permissive
  for select
  to public
using (((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE (users.auth_user_id = auth.uid()))) OR (preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid())))));



  create policy "public_view_active_job_postings"
  on "public"."job_postings"
  as permissive
  for select
  to public
using (((status = 'active'::text) AND ((expires_at IS NULL) OR (expires_at > now()))));



  create policy "Admins can create invites"
  on "public"."join_requests"
  as permissive
  for insert
  to authenticated
with check (((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['super_admin'::text, 'national_admin'::text]))))) OR (organization_id IN ( SELECT p.organization_id
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'admin'::text, 'regional_admin'::text, 'youth_president'::text])) AND (p.organization_id IS NOT NULL)))) OR (preschool_id IN ( SELECT p.preschool_id
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'admin'::text])) AND (p.preschool_id IS NOT NULL))))));



  create policy "Admins can delete invite codes"
  on "public"."join_requests"
  as permissive
  for delete
  to authenticated
using (((invited_by = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND (om.organization_id = join_requests.organization_id) AND ((om.member_type)::text = ANY ((ARRAY['president'::character varying, 'secretary'::character varying, 'ceo'::character varying, 'board_member'::character varying, 'executive'::character varying, 'staff'::character varying])::text[])))))));



  create policy "Admins can process requests"
  on "public"."join_requests"
  as permissive
  for update
  to authenticated
using (((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['super_admin'::text, 'national_admin'::text]))))) OR (organization_id IN ( SELECT p.organization_id
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'admin'::text, 'regional_admin'::text, 'youth_president'::text])) AND (p.organization_id IS NOT NULL)))) OR (preschool_id IN ( SELECT p.preschool_id
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'admin'::text])) AND (p.preschool_id IS NOT NULL))))))
with check ((status = ANY (ARRAY['approved'::public.join_request_status, 'rejected'::public.join_request_status, 'cancelled'::public.join_request_status, 'expired'::public.join_request_status, 'revoked'::public.join_request_status])));



  create policy "Admins can view all org join requests"
  on "public"."join_requests"
  as permissive
  for select
  to authenticated
using (((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['super_admin'::text, 'national_admin'::text]))))) OR (organization_id IN ( SELECT p.organization_id
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'admin'::text, 'regional_admin'::text, 'youth_president'::text])) AND (p.organization_id IS NOT NULL)))) OR (preschool_id IN ( SELECT p.preschool_id
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'admin'::text])) AND (p.preschool_id IS NOT NULL))))));



  create policy "Anyone can validate invite codes"
  on "public"."join_requests"
  as permissive
  for select
  to authenticated, anon
using (((invite_code IS NOT NULL) AND (status = 'pending'::public.join_request_status)));



  create policy "Org members can view their org invite codes"
  on "public"."join_requests"
  as permissive
  for select
  to authenticated
using (((invite_code IS NOT NULL) AND (EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND (om.organization_id = join_requests.organization_id))))));



  create policy "Service role full access to join_requests"
  on "public"."join_requests"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "Users can cancel own pending requests"
  on "public"."join_requests"
  as permissive
  for update
  to public
using (((requester_id = auth.uid()) AND (status = 'pending'::public.join_request_status)))
with check ((status = 'cancelled'::public.join_request_status));



  create policy "Users can create own join requests"
  on "public"."join_requests"
  as permissive
  for insert
  to public
with check ((requester_id = auth.uid()));



  create policy "Users can view own join requests"
  on "public"."join_requests"
  as permissive
  for select
  to public
using ((requester_id = auth.uid()));



  create policy "anon_select_join_requests_by_invite_code"
  on "public"."join_requests"
  as permissive
  for select
  to anon
using (((invite_code IS NOT NULL) AND (status = 'pending'::public.join_request_status)));



  create policy "Users can create their own connections"
  on "public"."learner_connections"
  as permissive
  for insert
  to public
with check ((auth.uid() = learner_id));



  create policy "Users can update their own connections"
  on "public"."learner_connections"
  as permissive
  for update
  to public
using (((auth.uid() = learner_id) OR (auth.uid() = connection_id)));



  create policy "Users can view their own connections"
  on "public"."learner_connections"
  as permissive
  for select
  to public
using (((auth.uid() = learner_id) OR (auth.uid() = connection_id)));



  create policy "Users can create their own CVs"
  on "public"."learner_cvs"
  as permissive
  for insert
  to public
with check ((auth.uid() = learner_id));



  create policy "Users can update their own CVs"
  on "public"."learner_cvs"
  as permissive
  for update
  to public
using ((auth.uid() = learner_id));



  create policy "Users can view their own CVs"
  on "public"."learner_cvs"
  as permissive
  for select
  to public
using ((auth.uid() = learner_id));



  create policy "learning_activities_admin_delete"
  on "public"."learning_activities"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "learning_activities_admin_modify"
  on "public"."learning_activities"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "learning_activities_admin_update"
  on "public"."learning_activities"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "learning_activities_public_read"
  on "public"."learning_activities"
  as permissive
  for select
  to authenticated
using (true);



  create policy "lesson_activities_admin_delete"
  on "public"."lesson_activities"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "lesson_activities_admin_modify"
  on "public"."lesson_activities"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "lesson_activities_admin_update"
  on "public"."lesson_activities"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "lesson_activities_public_read"
  on "public"."lesson_activities"
  as permissive
  for select
  to authenticated
using (true);



  create policy "principals_manage_lesson_approvals"
  on "public"."lesson_approvals"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'principal_admin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = lesson_approvals.preschool_id)))));



  create policy "teachers_insert_lesson_approvals"
  on "public"."lesson_approvals"
  as permissive
  for insert
  to public
with check ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['teacher'::text, 'principal'::text, 'principal_admin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = lesson_approvals.preschool_id)))));



  create policy "teachers_view_submit_lesson_approvals"
  on "public"."lesson_approvals"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['teacher'::text, 'principal'::text, 'principal_admin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = lesson_approvals.preschool_id)))));



  create policy "lesson_categories_admin_delete"
  on "public"."lesson_categories"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "lesson_categories_admin_modify"
  on "public"."lesson_categories"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "lesson_categories_admin_update"
  on "public"."lesson_categories"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "lesson_categories_public_read"
  on "public"."lesson_categories"
  as permissive
  for select
  to authenticated
using (true);



  create policy "lesson_progress_delete_own"
  on "public"."lesson_progress"
  as permissive
  for delete
  to public
using ((auth.uid() = user_id));



  create policy "lesson_progress_insert_own"
  on "public"."lesson_progress"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "lesson_progress_select_own"
  on "public"."lesson_progress"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "lesson_progress_teacher_view"
  on "public"."lesson_progress"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.lessons l
  WHERE ((l.id = lesson_progress.lesson_id) AND (l.teacher_id = auth.uid())))));



  create policy "lesson_progress_update_own"
  on "public"."lesson_progress"
  as permissive
  for update
  to public
using ((auth.uid() = user_id))
with check ((auth.uid() = user_id));



  create policy "anon_debug_access"
  on "public"."lessons"
  as permissive
  for select
  to anon
using (true);



  create policy "authenticated_access"
  on "public"."lessons"
  as permissive
  for all
  to authenticated
using (true)
with check (true);



  create policy "lessons_principal_access"
  on "public"."lessons"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'admin'::text, 'preschool_admin'::text])) AND (p.preschool_id = lessons.preschool_id)))))
with check ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'admin'::text, 'preschool_admin'::text])) AND (p.preschool_id = lessons.preschool_id)))));



  create policy "lessons_public_read"
  on "public"."lessons"
  as permissive
  for select
  to authenticated
using ((is_public = true));



  create policy "lessons_superadmin_access"
  on "public"."lessons"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "lessons_superadmin_full_access"
  on "public"."lessons"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'super_admin'::text)))));



  create policy "lessons_teacher_delete"
  on "public"."lessons"
  as permissive
  for delete
  to authenticated
using (((teacher_id = auth.uid()) AND (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = 'teacher'::text) AND (p.preschool_id = lessons.preschool_id))))));



  create policy "lessons_teacher_insert"
  on "public"."lessons"
  as permissive
  for insert
  to authenticated
with check (((teacher_id = auth.uid()) AND (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = 'teacher'::text) AND (p.preschool_id = lessons.preschool_id))))));



  create policy "lessons_teacher_select"
  on "public"."lessons"
  as permissive
  for select
  to authenticated
using (((teacher_id = auth.uid()) OR (preschool_id IN ( SELECT p.preschool_id
   FROM public.profiles p
  WHERE (p.id = auth.uid()))) OR (is_public = true)));



  create policy "lessons_teacher_update"
  on "public"."lessons"
  as permissive
  for update
  to authenticated
using (((teacher_id = auth.uid()) AND (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = 'teacher'::text) AND (p.preschool_id = lessons.preschool_id))))))
with check (((teacher_id = auth.uid()) AND (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = 'teacher'::text) AND (p.preschool_id = lessons.preschool_id))))));



  create policy "lessons_tenant_isolation"
  on "public"."lessons"
  as permissive
  for all
  to public
using (((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))) OR (is_public = true)));



  create policy "service_role_access"
  on "public"."lessons"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "Anyone can view active campaigns"
  on "public"."marketing_campaigns"
  as permissive
  for select
  to public
using (((active = true) AND (start_date <= now()) AND (end_date >= now())));



  create policy "Preschool staff manage campaigns"
  on "public"."marketing_campaigns"
  as permissive
  for all
  to public
using ((organization_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['principal'::text, 'teacher'::text]))))));



  create policy "media_uploads_tenant_modify"
  on "public"."media_uploads"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "media_uploads_tenant_select"
  on "public"."media_uploads"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "meeting_action_items_admin_delete"
  on "public"."meeting_action_items"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "meeting_action_items_admin_modify"
  on "public"."meeting_action_items"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "meeting_action_items_admin_update"
  on "public"."meeting_action_items"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "meeting_action_items_public_read"
  on "public"."meeting_action_items"
  as permissive
  for select
  to authenticated
using (true);



  create policy "meeting_participants_admin_org"
  on "public"."meeting_participants"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles admin
  WHERE ((admin.id = auth.uid()) AND (admin.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text])) AND ((admin.role = 'superadmin'::text) OR (admin.organization_id IN ( SELECT target.organization_id
           FROM public.profiles target
          WHERE (target.id = meeting_participants.user_id))))))));



  create policy "meeting_participants_user_own"
  on "public"."meeting_participants"
  as permissive
  for all
  to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "meeting_rooms_org_modify"
  on "public"."meeting_rooms"
  as permissive
  for all
  to authenticated
using ((organization_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((organization_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "meeting_rooms_org_select"
  on "public"."meeting_rooms"
  as permissive
  for select
  to authenticated
using ((organization_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "meeting_sessions_admin_delete"
  on "public"."meeting_sessions"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "meeting_sessions_admin_modify"
  on "public"."meeting_sessions"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "meeting_sessions_admin_update"
  on "public"."meeting_sessions"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "meeting_sessions_public_read"
  on "public"."meeting_sessions"
  as permissive
  for select
  to authenticated
using (true);



  create policy "meeting_shared_resources_admin_delete"
  on "public"."meeting_shared_resources"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "meeting_shared_resources_admin_modify"
  on "public"."meeting_shared_resources"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "meeting_shared_resources_admin_update"
  on "public"."meeting_shared_resources"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "meeting_shared_resources_public_read"
  on "public"."meeting_shared_resources"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Org admins can manage events"
  on "public"."member_events"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.organization_id = member_events.organization_id) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'super_admin'::text]))))));



  create policy "Org members can view events"
  on "public"."member_events"
  as permissive
  for select
  to public
using (((organization_id IN ( SELECT organization_members.organization_id
   FROM public.organization_members
  WHERE (organization_members.user_id = auth.uid()))) OR (EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.organization_id = member_events.organization_id))))));



  create policy "member_fees_select"
  on "public"."member_fees"
  as permissive
  for select
  to authenticated
using (((EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND (om.id = member_fees.member_id)))) OR (EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND (om.organization_id = member_fees.organization_id) AND ((om.member_type)::text = ANY ((ARRAY['national_admin'::character varying, 'admin'::character varying, 'regional_manager'::character varying, 'youth_president'::character varying, 'youth_treasurer'::character varying, 'women_president'::character varying, 'women_treasurer'::character varying])::text[])))))));



  create policy "Members can view own ID cards"
  on "public"."member_id_cards"
  as permissive
  for select
  to public
using ((member_id IN ( SELECT organization_members.id
   FROM public.organization_members
  WHERE (organization_members.user_id = auth.uid()))));



  create policy "Org admins can manage ID cards"
  on "public"."member_id_cards"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.organization_id = member_id_cards.organization_id) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'super_admin'::text]))))));



  create policy "Members can view own invoices"
  on "public"."member_invoices"
  as permissive
  for select
  to public
using ((member_id IN ( SELECT organization_members.id
   FROM public.organization_members
  WHERE (organization_members.user_id = auth.uid()))));



  create policy "Org admins can manage invoices"
  on "public"."member_invoices"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.organization_id = member_invoices.organization_id) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'super_admin'::text]))))));



  create policy "membership_pop_insert"
  on "public"."membership_pop_uploads"
  as permissive
  for insert
  to public
with check (((EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.id = membership_pop_uploads.member_id) AND (om.user_id = auth.uid())))) OR (EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.organization_id = membership_pop_uploads.organization_id) AND (om.user_id = auth.uid()) AND ((om.member_type)::text = ANY ((ARRAY['admin'::character varying, 'national_admin'::character varying, 'regional_manager'::character varying, 'staff'::character varying])::text[]))))) OR (EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'super_admin'::text))))));



  create policy "membership_pop_select"
  on "public"."membership_pop_uploads"
  as permissive
  for select
  to public
using (((EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.id = membership_pop_uploads.member_id) AND (om.user_id = auth.uid())))) OR (EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.organization_id = membership_pop_uploads.organization_id) AND (om.user_id = auth.uid()) AND ((om.member_type)::text = ANY ((ARRAY['admin'::character varying, 'national_admin'::character varying, 'regional_manager'::character varying, 'staff'::character varying, 'youth_treasurer'::character varying, 'women_treasurer'::character varying])::text[]))))) OR (EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'super_admin'::text))))));



  create policy "membership_pop_update"
  on "public"."membership_pop_uploads"
  as permissive
  for update
  to public
using (((EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.organization_id = membership_pop_uploads.organization_id) AND (om.user_id = auth.uid()) AND ((om.member_type)::text = ANY ((ARRAY['admin'::character varying, 'national_admin'::character varying, 'regional_manager'::character varying, 'staff'::character varying, 'youth_treasurer'::character varying, 'women_treasurer'::character varying])::text[]))))) OR (EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'super_admin'::text))))));



  create policy "message_drafts_admin_delete"
  on "public"."message_drafts"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "message_drafts_admin_modify"
  on "public"."message_drafts"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "message_drafts_admin_update"
  on "public"."message_drafts"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "message_drafts_public_read"
  on "public"."message_drafts"
  as permissive
  for select
  to authenticated
using (true);



  create policy "message_participants_delete_policy"
  on "public"."message_participants"
  as permissive
  for delete
  to public
using (((user_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.message_threads mt
  WHERE ((mt.id = message_participants.thread_id) AND (mt.created_by = auth.uid()))))));



  create policy "message_participants_insert_policy"
  on "public"."message_participants"
  as permissive
  for insert
  to public
with check (((EXISTS ( SELECT 1
   FROM public.message_participants mp
  WHERE ((mp.thread_id = message_participants.thread_id) AND (mp.user_id = auth.uid())))) OR (EXISTS ( SELECT 1
   FROM public.message_threads mt
  WHERE ((mt.id = message_participants.thread_id) AND (mt.created_by = auth.uid()))))));



  create policy "message_participants_select_policy"
  on "public"."message_participants"
  as permissive
  for select
  to public
using (((user_id = auth.uid()) OR public.user_is_thread_participant(thread_id)));



  create policy "Users can add reactions to messages in their threads"
  on "public"."message_reactions"
  as permissive
  for insert
  to public
with check (((user_id = auth.uid()) AND (EXISTS ( SELECT 1
   FROM public.message_participants mp
  WHERE ((mp.thread_id = ( SELECT messages.thread_id
           FROM public.messages
          WHERE (messages.id = message_reactions.message_id))) AND (mp.user_id = auth.uid()))))));



  create policy "Users can remove their own reactions"
  on "public"."message_reactions"
  as permissive
  for delete
  to public
using ((user_id = auth.uid()));



  create policy "Users can view reactions on messages in their threads"
  on "public"."message_reactions"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.message_participants mp
  WHERE ((mp.thread_id = ( SELECT messages.thread_id
           FROM public.messages
          WHERE (messages.id = message_reactions.message_id))) AND (mp.user_id = auth.uid())))));



  create policy "message_recipients_admin_delete"
  on "public"."message_recipients"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "message_recipients_admin_modify"
  on "public"."message_recipients"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "message_recipients_admin_update"
  on "public"."message_recipients"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "message_recipients_public_read"
  on "public"."message_recipients"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Group admins can update thread details"
  on "public"."message_threads"
  as permissive
  for update
  to public
using (((EXISTS ( SELECT 1
   FROM public.message_participants
  WHERE ((message_participants.thread_id = message_threads.id) AND (message_participants.user_id = auth.uid()) AND (message_participants.is_admin = true)))) OR (created_by = auth.uid())));



  create policy "Users can view threads they participate in"
  on "public"."message_threads"
  as permissive
  for select
  to public
using (((EXISTS ( SELECT 1
   FROM public.message_participants
  WHERE ((message_participants.thread_id = message_threads.id) AND (message_participants.user_id = auth.uid())))) OR (created_by = auth.uid())));



  create policy "message_threads_delete_policy"
  on "public"."message_threads"
  as permissive
  for delete
  to public
using (((created_by = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.message_participants mp
  WHERE ((mp.thread_id = message_threads.id) AND (mp.user_id = auth.uid()))))));



  create policy "message_threads_insert_policy"
  on "public"."message_threads"
  as permissive
  for insert
  to public
with check ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.preschool_id = message_threads.preschool_id) AND (p.role = ANY (ARRAY['parent'::text, 'teacher'::text, 'principal'::text, 'admin'::text]))))));



  create policy "message_threads_select_policy"
  on "public"."message_threads"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.message_participants mp
  WHERE ((mp.thread_id = message_threads.id) AND (mp.user_id = auth.uid())))));



  create policy "message_threads_update_policy"
  on "public"."message_threads"
  as permissive
  for update
  to public
using ((EXISTS ( SELECT 1
   FROM public.message_participants mp
  WHERE ((mp.thread_id = message_threads.id) AND (mp.user_id = auth.uid())))));



  create policy "Participants can send messages if allowed"
  on "public"."messages"
  as permissive
  for insert
  to public
with check (((EXISTS ( SELECT 1
   FROM (public.message_participants mp
     JOIN public.message_threads mt ON ((mp.thread_id = mt.id)))
  WHERE ((mp.thread_id = messages.thread_id) AND (mp.user_id = auth.uid()) AND ((mp.can_send_messages = true) OR (mp.is_admin = true))))) OR (EXISTS ( SELECT 1
   FROM public.message_threads mt
  WHERE ((mt.id = messages.thread_id) AND (mt.is_group = false) AND (EXISTS ( SELECT 1
           FROM public.message_participants
          WHERE ((message_participants.thread_id = mt.id) AND (message_participants.user_id = auth.uid())))))))));



  create policy "messages_delete_policy"
  on "public"."messages"
  as permissive
  for delete
  to public
using (((sender_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.message_threads mt
  WHERE ((mt.id = messages.thread_id) AND (mt.created_by = auth.uid())))) OR (EXISTS ( SELECT 1
   FROM public.message_participants mp
  WHERE ((mp.thread_id = messages.thread_id) AND (mp.user_id = auth.uid()))))));



  create policy "messages_insert_policy"
  on "public"."messages"
  as permissive
  for insert
  to public
with check (((sender_id = auth.uid()) AND (EXISTS ( SELECT 1
   FROM public.message_participants mp
  WHERE ((mp.thread_id = messages.thread_id) AND (mp.user_id = auth.uid()))))));



  create policy "messages_select_policy"
  on "public"."messages"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.message_participants mp
  WHERE ((mp.thread_id = messages.thread_id) AND (mp.user_id = auth.uid())))));



  create policy "messages_update_policy"
  on "public"."messages"
  as permissive
  for update
  to public
using (((sender_id = auth.uid()) AND (deleted_at IS NULL)));



  create policy "migration_logs_service_only"
  on "public"."migration_logs"
  as permissive
  for select
  to public
using (true);



  create policy "Superadmins can create moderation actions"
  on "public"."moderation_actions"
  as permissive
  for insert
  to authenticated
with check (((moderator_id = auth.uid()) AND (EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = 'superadmin'::text))))));



  create policy "Superadmins can view moderation actions"
  on "public"."moderation_actions"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = 'superadmin'::text)))));



  create policy "Superadmins can manage moderation queue"
  on "public"."moderation_queue"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = 'superadmin'::text)))));



  create policy "newsletter_recipients_own"
  on "public"."newsletter_recipients"
  as permissive
  for all
  to public
using ((user_id = auth.uid()));



  create policy "Principals can manage newsletters"
  on "public"."newsletters"
  as permissive
  for all
  to public
using ((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE ((users.auth_user_id = auth.uid()) AND (users.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'superadmin'::text]))))));



  create policy "Users can view their preschool newsletters"
  on "public"."newsletters"
  as permissive
  for select
  to public
using ((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE (users.auth_user_id = auth.uid()))));



  create policy "notification_deliveries_admin_delete"
  on "public"."notification_deliveries"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "notification_deliveries_admin_modify"
  on "public"."notification_deliveries"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "notification_deliveries_admin_update"
  on "public"."notification_deliveries"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "notification_deliveries_public_read"
  on "public"."notification_deliveries"
  as permissive
  for select
  to authenticated
using (true);



  create policy "notification_history_admin_delete"
  on "public"."notification_history"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "notification_history_admin_modify"
  on "public"."notification_history"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "notification_history_admin_update"
  on "public"."notification_history"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "notification_history_public_read"
  on "public"."notification_history"
  as permissive
  for select
  to authenticated
using (true);



  create policy "service_role_access"
  on "public"."notification_logs"
  as permissive
  for all
  to public
using ((auth.role() = 'service_role'::text));



  create policy "notification_templates_admin_delete"
  on "public"."notification_templates"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "notification_templates_admin_modify"
  on "public"."notification_templates"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "notification_templates_admin_update"
  on "public"."notification_templates"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "notification_templates_public_read"
  on "public"."notification_templates"
  as permissive
  for select
  to authenticated
using (true);



  create policy "System can create notifications"
  on "public"."notifications"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Users can update their notifications"
  on "public"."notifications"
  as permissive
  for update
  to authenticated
using ((user_id = auth.uid()));



  create policy "Users can view their notifications"
  on "public"."notifications"
  as permissive
  for select
  to authenticated
using ((user_id = auth.uid()));



  create policy "oauth_tokens_delete_own"
  on "public"."oauth_tokens"
  as permissive
  for delete
  to public
using ((auth.uid() = user_id));



  create policy "oauth_tokens_insert_own"
  on "public"."oauth_tokens"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "oauth_tokens_select_own"
  on "public"."oauth_tokens"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "oauth_tokens_service_role_all"
  on "public"."oauth_tokens"
  as permissive
  for all
  to public
using (((auth.jwt() ->> 'role'::text) = 'service_role'::text));



  create policy "oauth_tokens_update_own"
  on "public"."oauth_tokens"
  as permissive
  for update
  to public
using ((auth.uid() = user_id));



  create policy "candidates_manage_own_offers"
  on "public"."offer_letters"
  as permissive
  for all
  to public
using ((application_id IN ( SELECT ja.id
   FROM (public.job_applications ja
     JOIN public.candidate_profiles cp ON ((ja.candidate_profile_id = cp.id)))
  WHERE (cp.email = (( SELECT users.email
           FROM auth.users
          WHERE (users.id = auth.uid())))::text))));



  create policy "principals_create_offers"
  on "public"."offer_letters"
  as permissive
  for insert
  to public
with check ((application_id IN ( SELECT ja.id
   FROM (public.job_applications ja
     JOIN public.job_postings jp ON ((ja.job_posting_id = jp.id)))
  WHERE ((jp.preschool_id IN ( SELECT users.preschool_id
           FROM public.users
          WHERE (users.auth_user_id = auth.uid()))) OR (jp.preschool_id IN ( SELECT profiles.organization_id
           FROM public.profiles
          WHERE (profiles.id = auth.uid())))))));



  create policy "principals_update_offers"
  on "public"."offer_letters"
  as permissive
  for update
  to public
using ((application_id IN ( SELECT ja.id
   FROM (public.job_applications ja
     JOIN public.job_postings jp ON ((ja.job_posting_id = jp.id)))
  WHERE ((jp.preschool_id IN ( SELECT users.preschool_id
           FROM public.users
          WHERE (users.auth_user_id = auth.uid()))) OR (jp.preschool_id IN ( SELECT profiles.organization_id
           FROM public.profiles
          WHERE (profiles.id = auth.uid())))))));



  create policy "principals_view_offers"
  on "public"."offer_letters"
  as permissive
  for select
  to public
using ((application_id IN ( SELECT ja.id
   FROM (public.job_applications ja
     JOIN public.job_postings jp ON ((ja.job_posting_id = jp.id)))
  WHERE ((jp.preschool_id IN ( SELECT users.preschool_id
           FROM public.users
          WHERE (users.auth_user_id = auth.uid()))) OR (jp.preschool_id IN ( SELECT profiles.organization_id
           FROM public.profiles
          WHERE (profiles.id = auth.uid())))))));



  create policy "onboarding_progress_school_access"
  on "public"."onboarding_progress"
  as permissive
  for all
  to authenticated
using ((school_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = ANY (ARRAY['principal'::text, 'preschool_admin'::text]))))))
with check ((school_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = ANY (ARRAY['principal'::text, 'preschool_admin'::text]))))));



  create policy "onboarding_progress_superadmin_access"
  on "public"."onboarding_progress"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "onboarding_requests_admin_delete"
  on "public"."onboarding_requests"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "onboarding_requests_admin_modify"
  on "public"."onboarding_requests"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "onboarding_requests_admin_update"
  on "public"."onboarding_requests"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "onboarding_requests_public_read"
  on "public"."onboarding_requests"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Feature flags are readable by all authenticated users"
  on "public"."org_dashboard_features"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Only superadmins can manage feature flags"
  on "public"."org_dashboard_features"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'superadmin'::text)))));



  create policy "org_invites_tenant_modify"
  on "public"."org_invites"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "org_invites_tenant_select"
  on "public"."org_invites"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "admins_view_recipients"
  on "public"."organization_announcement_recipients"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM (public.organization_announcements oa
     JOIN public.organization_members om ON ((om.organization_id = oa.organization_id)))
  WHERE ((oa.id = organization_announcement_recipients.announcement_id) AND (om.user_id = auth.uid()) AND (om.role = ANY (ARRAY['admin'::text, 'national_admin'::text, 'president'::text, 'ceo'::text])) AND ((om.membership_status)::text = 'active'::text)))));



  create policy "recipients_update_own"
  on "public"."organization_announcement_recipients"
  as permissive
  for update
  to authenticated
using ((recipient_id = auth.uid()))
with check ((recipient_id = auth.uid()));



  create policy "recipients_view_own"
  on "public"."organization_announcement_recipients"
  as permissive
  for select
  to authenticated
using ((recipient_id = auth.uid()));



  create policy "system_insert_recipients"
  on "public"."organization_announcement_recipients"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM (public.organization_announcements oa
     JOIN public.organization_members om ON ((om.organization_id = oa.organization_id)))
  WHERE ((oa.id = organization_announcement_recipients.announcement_id) AND (om.user_id = auth.uid()) AND (om.role = ANY (ARRAY['admin'::text, 'national_admin'::text, 'president'::text, 'ceo'::text])) AND ((om.membership_status)::text = 'active'::text)))));



  create policy "members_view_announcements"
  on "public"."organization_announcements"
  as permissive
  for select
  to authenticated
using (((is_published = true) AND ((expires_at IS NULL) OR (expires_at > now())) AND (EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND (om.organization_id = organization_announcements.organization_id) AND ((om.membership_status)::text = 'active'::text) AND ((organization_announcements.target_audience = 'all'::text) OR ((organization_announcements.target_audience = 'regional_managers'::text) AND (om.role = ANY (ARRAY['admin'::text, 'national_admin'::text, 'regional_manager'::text]))) OR ((organization_announcements.target_audience = 'branch_managers'::text) AND (om.role = ANY (ARRAY['admin'::text, 'national_admin'::text, 'regional_manager'::text, 'branch_manager'::text]))) OR ((organization_announcements.target_region_id IS NOT NULL) AND (om.region_id = organization_announcements.target_region_id))))))));



  create policy "org_admins_create_announcements"
  on "public"."organization_announcements"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND (om.organization_id = organization_announcements.organization_id) AND (om.role = ANY (ARRAY['admin'::text, 'national_admin'::text, 'president'::text, 'ceo'::text])) AND ((om.membership_status)::text = 'active'::text)))));



  create policy "org_admins_delete_announcements"
  on "public"."organization_announcements"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND (om.organization_id = organization_announcements.organization_id) AND (om.role = ANY (ARRAY['admin'::text, 'national_admin'::text, 'president'::text, 'ceo'::text])) AND ((om.membership_status)::text = 'active'::text)))));



  create policy "org_admins_update_announcements"
  on "public"."organization_announcements"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND (om.organization_id = organization_announcements.organization_id) AND (om.role = ANY (ARRAY['admin'::text, 'national_admin'::text, 'president'::text, 'ceo'::text])) AND ((om.membership_status)::text = 'active'::text)))));



  create policy "bank_accounts_delete"
  on "public"."organization_bank_accounts"
  as permissive
  for delete
  to authenticated
using (((EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND (om.organization_id = organization_bank_accounts.organization_id) AND ((om.member_type)::text = 'national_admin'::text)))) OR (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.preschool_id = organization_bank_accounts.organization_id) AND (p.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'super_admin'::text])))))));



  create policy "bank_accounts_insert"
  on "public"."organization_bank_accounts"
  as permissive
  for insert
  to authenticated
with check (((EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND (om.organization_id = organization_bank_accounts.organization_id) AND ((om.member_type)::text = ANY ((ARRAY['national_admin'::character varying, 'admin'::character varying])::text[]))))) OR (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.preschool_id = organization_bank_accounts.organization_id) AND (p.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'super_admin'::text])))))));



  create policy "bank_accounts_select"
  on "public"."organization_bank_accounts"
  as permissive
  for select
  to authenticated
using (((EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND (om.organization_id = organization_bank_accounts.organization_id)))) OR (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.preschool_id = organization_bank_accounts.organization_id))))));



  create policy "bank_accounts_update"
  on "public"."organization_bank_accounts"
  as permissive
  for update
  to authenticated
using (((EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND (om.organization_id = organization_bank_accounts.organization_id) AND ((om.member_type)::text = ANY ((ARRAY['national_admin'::character varying, 'admin'::character varying])::text[]))))) OR (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.preschool_id = organization_bank_accounts.organization_id) AND (p.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'super_admin'::text])))))))
with check (((EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND (om.organization_id = organization_bank_accounts.organization_id) AND ((om.member_type)::text = ANY ((ARRAY['national_admin'::character varying, 'admin'::character varying])::text[]))))) OR (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.preschool_id = organization_bank_accounts.organization_id) AND (p.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'super_admin'::text])))))));



  create policy "organization_board_positions_delete_policy"
  on "public"."organization_board_positions"
  as permissive
  for delete
  to public
using ((EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.organization_id = organization_board_positions.organization_id) AND (om.user_id = auth.uid()) AND (((om.member_type)::text = 'national_admin'::text) OR (om.role = ANY (ARRAY['admin'::text, 'national_admin'::text, 'president'::text, 'ceo'::text])))))));



  create policy "organization_board_positions_insert_policy"
  on "public"."organization_board_positions"
  as permissive
  for insert
  to public
with check ((EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.organization_id = organization_board_positions.organization_id) AND (om.user_id = auth.uid()) AND (((om.member_type)::text = 'national_admin'::text) OR (om.role = ANY (ARRAY['admin'::text, 'national_admin'::text, 'president'::text, 'ceo'::text])))))));



  create policy "organization_board_positions_select_policy"
  on "public"."organization_board_positions"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.organization_id = organization_board_positions.organization_id) AND (om.user_id = auth.uid())))));



  create policy "organization_board_positions_update_policy"
  on "public"."organization_board_positions"
  as permissive
  for update
  to public
using ((EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.organization_id = organization_board_positions.organization_id) AND (om.user_id = auth.uid()) AND (((om.member_type)::text = 'national_admin'::text) OR (om.role = ANY (ARRAY['admin'::text, 'national_admin'::text, 'president'::text, 'ceo'::text])))))));



  create policy "admins_manage_access"
  on "public"."organization_document_access"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM (public.organization_documents od
     JOIN public.organization_members om ON ((om.organization_id = od.organization_id)))
  WHERE ((od.id = organization_document_access.document_id) AND (om.user_id = auth.uid()) AND (om.role = ANY (ARRAY['admin'::text, 'national_admin'::text])) AND ((om.membership_status)::text = 'active'::text)))));



  create policy "users_view_own_access"
  on "public"."organization_document_access"
  as permissive
  for select
  to authenticated
using ((grantee_user_id = auth.uid()));



  create policy "admins_review_requests"
  on "public"."organization_document_access_requests"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM (public.organization_documents od
     JOIN public.organization_members om ON ((om.organization_id = od.organization_id)))
  WHERE ((od.id = organization_document_access_requests.document_id) AND (om.user_id = auth.uid()) AND (om.role = ANY (ARRAY['admin'::text, 'national_admin'::text])) AND ((om.membership_status)::text = 'active'::text)))));



  create policy "users_manage_own_requests"
  on "public"."organization_document_access_requests"
  as permissive
  for all
  to authenticated
using ((requester_id = auth.uid()))
with check ((requester_id = auth.uid()));



  create policy "admins_view_audit"
  on "public"."organization_document_audit_log"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM (public.organization_documents od
     JOIN public.organization_members om ON ((om.organization_id = od.organization_id)))
  WHERE ((od.id = organization_document_audit_log.document_id) AND (om.user_id = auth.uid()) AND (om.role = ANY (ARRAY['admin'::text, 'national_admin'::text])) AND ((om.membership_status)::text = 'active'::text)))));



  create policy "insert_audit"
  on "public"."organization_document_audit_log"
  as permissive
  for insert
  to authenticated
with check ((user_id = auth.uid()));



  create policy "users_view_own_audit"
  on "public"."organization_document_audit_log"
  as permissive
  for select
  to authenticated
using ((user_id = auth.uid()));



  create policy "Allow anon select for upsert"
  on "public"."organization_members"
  as permissive
  for select
  to anon
using (((membership_status)::text = 'pending_verification'::text));



  create policy "Allow pending verification inserts"
  on "public"."organization_members"
  as permissive
  for insert
  to anon
with check (((membership_status)::text = 'pending_verification'::text));



  create policy "Anyone can count members for region display"
  on "public"."organization_members"
  as permissive
  for select
  to authenticated, anon
using (((membership_status)::text = 'active'::text));



  create policy "Users can join organizations via invite"
  on "public"."organization_members"
  as permissive
  for insert
  to authenticated
with check (((user_id = auth.uid()) AND (joined_via IS NOT NULL)));



  create policy "Users can update own membership"
  on "public"."organization_members"
  as permissive
  for update
  to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "organization_members_select_own"
  on "public"."organization_members"
  as permissive
  for select
  to authenticated
using ((user_id = auth.uid()));



  create policy "Parents can view payment methods"
  on "public"."organization_payment_methods"
  as permissive
  for select
  to authenticated
using ((active = true));



  create policy "Anyone can view active regions for registration"
  on "public"."organization_regions"
  as permissive
  for select
  to authenticated, anon
using ((is_active = true));



  create policy "Org admins can manage regions"
  on "public"."organization_regions"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.organization_id = organization_regions.organization_id) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'super_admin'::text]))))));



  create policy "Org members can view regions"
  on "public"."organization_regions"
  as permissive
  for select
  to public
using (((organization_id IN ( SELECT organization_members.organization_id
   FROM public.organization_members
  WHERE (organization_members.user_id = auth.uid()))) OR (EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.organization_id = organization_regions.organization_id))))));



  create policy "anon_select_organization_regions_public"
  on "public"."organization_regions"
  as permissive
  for select
  to anon
using (true);



  create policy "admins_can_manage_organization_roles"
  on "public"."organization_roles"
  as permissive
  for all
  to public
using ((organization_id IN ( SELECT users.organization_id
   FROM public.users
  WHERE ((users.auth_user_id = auth.uid()) AND (users.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "users_can_view_organization_roles"
  on "public"."organization_roles"
  as permissive
  for select
  to public
using ((organization_id IN ( SELECT users.organization_id
   FROM public.users
  WHERE (users.auth_user_id = auth.uid()))));



  create policy "org_transactions_insert"
  on "public"."organization_transactions"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND (om.organization_id = organization_transactions.organization_id) AND ((om.member_type)::text = ANY ((ARRAY['national_admin'::character varying, 'admin'::character varying, 'staff'::character varying, 'regional_manager'::character varying, 'youth_president'::character varying, 'youth_deputy'::character varying, 'youth_treasurer'::character varying, 'youth_coordinator'::character varying, 'women_president'::character varying, 'women_deputy'::character varying, 'women_treasurer'::character varying, 'women_coordinator'::character varying])::text[]))))));



  create policy "org_transactions_select"
  on "public"."organization_transactions"
  as permissive
  for select
  to authenticated
using (((EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND (om.organization_id = organization_transactions.organization_id) AND ((om.member_type)::text = ANY ((ARRAY['national_admin'::character varying, 'admin'::character varying, 'regional_manager'::character varying, 'youth_president'::character varying, 'youth_treasurer'::character varying, 'women_president'::character varying, 'women_treasurer'::character varying])::text[]))))) OR (submitted_by = auth.uid())));



  create policy "org_wings_manage"
  on "public"."organization_wings"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND (om.organization_id = organization_wings.organization_id) AND ((om.member_type)::text = 'national_admin'::text)))));



  create policy "org_wings_select"
  on "public"."organization_wings"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND (om.organization_id = organization_wings.organization_id)))));



  create policy "admins_can_update_organizations"
  on "public"."organizations"
  as permissive
  for update
  to public
using ((id IN ( SELECT users.organization_id
   FROM public.users
  WHERE ((users.auth_user_id = auth.uid()) AND (users.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "anon_can_view_public_organizations"
  on "public"."organizations"
  as permissive
  for select
  to anon
using (((is_public = true) AND (accepting_registrations = true) AND (is_active = true)));



  create policy "anon_select_organizations_public"
  on "public"."organizations"
  as permissive
  for select
  to anon
using (true);



  create policy "authenticated_can_view_public_organizations"
  on "public"."organizations"
  as permissive
  for select
  to authenticated
using (((is_public = true) AND (accepting_registrations = true) AND (is_active = true)));



  create policy "organizations_delete"
  on "public"."organizations"
  as permissive
  for delete
  to public
using (public.is_super_admin());



  create policy "organizations_insert_own"
  on "public"."organizations"
  as permissive
  for insert
  to authenticated
with check ((created_by = auth.uid()));



  create policy "organizations_insert_principal"
  on "public"."organizations"
  as permissive
  for insert
  to authenticated
with check ((app_auth.is_superadmin() OR app_auth.is_principal()));



  create policy "organizations_own_access"
  on "public"."organizations"
  as permissive
  for select
  to authenticated
using ((id IN ( SELECT users.organization_id
   FROM public.users
  WHERE (users.auth_user_id = auth.uid()))));



  create policy "organizations_select"
  on "public"."organizations"
  as permissive
  for select
  to public
using (((id = public.get_user_org_id()) OR public.is_super_admin()));



  create policy "organizations_service_role_full"
  on "public"."organizations"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "organizations_superadmin_delete"
  on "public"."organizations"
  as permissive
  for delete
  to authenticated
using (public.is_superadmin_safe());



  create policy "organizations_superadmin_read_all"
  on "public"."organizations"
  as permissive
  for select
  to authenticated
using (public.is_superadmin_safe());



  create policy "organizations_superadmin_update"
  on "public"."organizations"
  as permissive
  for update
  to authenticated
using (public.is_superadmin_safe())
with check (public.is_superadmin_safe());



  create policy "organizations_view_active"
  on "public"."organizations"
  as permissive
  for select
  to authenticated
using ((is_active = true));



  create policy "superadmins_can_create_organizations"
  on "public"."organizations"
  as permissive
  for insert
  to public
with check ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.auth_user_id = auth.uid()) AND (users.role = 'superadmin'::text)))));



  create policy "overage_billing_records_admin_org"
  on "public"."overage_billing_records"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles admin
  WHERE ((admin.id = auth.uid()) AND (admin.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text])) AND ((admin.role = 'superadmin'::text) OR (admin.organization_id IN ( SELECT target.organization_id
           FROM public.profiles target
          WHERE (target.id = overage_billing_records.user_id))))))));



  create policy "overage_billing_records_user_own"
  on "public"."overage_billing_records"
  as permissive
  for all
  to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "overage_notifications_admin_org"
  on "public"."overage_notifications"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles admin
  WHERE ((admin.id = auth.uid()) AND (admin.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text])) AND ((admin.role = 'superadmin'::text) OR (admin.organization_id IN ( SELECT target.organization_id
           FROM public.profiles target
          WHERE (target.id = overage_notifications.user_id))))))));



  create policy "overage_notifications_user_own"
  on "public"."overage_notifications"
  as permissive
  for all
  to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "parent_access_codes_tenant_modify"
  on "public"."parent_access_codes"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "parent_access_codes_tenant_select"
  on "public"."parent_access_codes"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "parent_child_links_access"
  on "public"."parent_child_links"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.auth_user_id = auth.uid()) AND ((parent_child_links.parent_id = p.id) OR (parent_child_links.child_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)))))));



  create policy "Anyone can create join requests during signup"
  on "public"."parent_join_requests"
  as permissive
  for insert
  to authenticated, anon
with check (true);



  create policy "Parents can create join requests"
  on "public"."parent_join_requests"
  as permissive
  for insert
  to authenticated
with check ((auth.uid() = parent_id));



  create policy "Parents can update own pending requests"
  on "public"."parent_join_requests"
  as permissive
  for update
  to authenticated
using (((auth.uid() = parent_id) AND (status = 'pending'::text)))
with check (((auth.uid() = parent_id) AND (status = 'pending'::text)));



  create policy "Parents can view own join requests"
  on "public"."parent_join_requests"
  as permissive
  for select
  to authenticated
using ((auth.uid() = parent_id));



  create policy "Principals can update requests for their organization"
  on "public"."parent_join_requests"
  as permissive
  for update
  to authenticated
using ((organization_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['principal'::text, 'admin'::text]))))))
with check ((organization_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['principal'::text, 'admin'::text]))))));



  create policy "Principals can view requests for their organization"
  on "public"."parent_join_requests"
  as permissive
  for select
  to authenticated
using ((organization_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['principal'::text, 'admin'::text]))))));



  create policy "Service role has full access to join requests"
  on "public"."parent_join_requests"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "parent_payments_tenant_modify"
  on "public"."parent_payments"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "parent_payments_tenant_select"
  on "public"."parent_payments"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "Authenticated users can view all papers"
  on "public"."past_papers"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Public papers are viewable by everyone"
  on "public"."past_papers"
  as permissive
  for select
  to public
using ((is_public = true));



  create policy "Only superadmins can access PayFast logs"
  on "public"."payfast_itn_logs"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.users u
  WHERE ((u.auth_user_id = auth.uid()) AND (u.role = 'superadmin'::text)))));



  create policy "payment_reminders_tenant_modify"
  on "public"."payment_reminders"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "payment_reminders_tenant_select"
  on "public"."payment_reminders"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "payment_transactions_school_modify"
  on "public"."payment_transactions"
  as permissive
  for all
  to authenticated
using ((school_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((school_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "payment_transactions_school_select"
  on "public"."payment_transactions"
  as permissive
  for select
  to authenticated
using ((school_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "payment_transactions_user_select"
  on "public"."payment_transactions"
  as permissive
  for select
  to authenticated
using ((user_id = auth.uid()));



  create policy "payments_tenant_modify"
  on "public"."payments"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "payments_tenant_select"
  on "public"."payments"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "pdf_custom_templates_owner_policy"
  on "public"."pdf_custom_templates"
  as permissive
  for all
  to public
using ((auth.uid() = owner_user_id));



  create policy "pdf_documents_policy"
  on "public"."pdf_documents"
  as permissive
  for all
  to public
using ((auth.uid() = user_id));



  create policy "pdf_user_preferences_policy"
  on "public"."pdf_user_preferences"
  as permissive
  for all
  to public
using ((auth.uid() = user_id));



  create policy "Principals and admins can delete petty cash accounts"
  on "public"."petty_cash_accounts"
  as permissive
  for delete
  to public
using ((EXISTS ( SELECT 1
   FROM public.users u
  WHERE ((u.auth_user_id = auth.uid()) AND (u.preschool_id = petty_cash_accounts.school_id) AND (u.role = ANY (ARRAY['principal'::text, 'admin'::text, 'superadmin'::text]))))));



  create policy "Principals and admins can insert petty cash accounts"
  on "public"."petty_cash_accounts"
  as permissive
  for insert
  to public
with check ((EXISTS ( SELECT 1
   FROM public.users u
  WHERE ((u.auth_user_id = auth.uid()) AND (u.preschool_id = petty_cash_accounts.school_id) AND (u.role = ANY (ARRAY['principal'::text, 'admin'::text, 'superadmin'::text]))))));



  create policy "Principals and admins can update petty cash accounts"
  on "public"."petty_cash_accounts"
  as permissive
  for update
  to public
using ((EXISTS ( SELECT 1
   FROM public.users u
  WHERE ((u.auth_user_id = auth.uid()) AND (u.preschool_id = petty_cash_accounts.school_id) AND (u.role = ANY (ARRAY['principal'::text, 'admin'::text, 'superadmin'::text]))))));



  create policy "Users can view petty cash accounts in their preschool"
  on "public"."petty_cash_accounts"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.users u
  WHERE ((u.auth_user_id = auth.uid()) AND (u.preschool_id = petty_cash_accounts.school_id)))));



  create policy "petty_cash_accounts_debug_anon"
  on "public"."petty_cash_accounts"
  as permissive
  for select
  to anon
using (true);



  create policy "petty_cash_accounts_service_full"
  on "public"."petty_cash_accounts"
  as permissive
  for all
  to service_role
using (true);



  create policy "petty_cash_accounts_tenant_modify"
  on "public"."petty_cash_accounts"
  as permissive
  for all
  to authenticated
using ((school_id IN ( SELECT COALESCE(users.organization_id, users.preschool_id) AS "coalesce"
   FROM public.users
  WHERE ((users.id = auth.uid()) OR (users.auth_user_id = auth.uid())))));



  create policy "petty_cash_accounts_tenant_read"
  on "public"."petty_cash_accounts"
  as permissive
  for select
  to authenticated
using ((school_id IN ( SELECT COALESCE(users.organization_id, users.preschool_id) AS "coalesce"
   FROM public.users
  WHERE ((users.id = auth.uid()) OR (users.auth_user_id = auth.uid())))));



  create policy "petty_cash_authenticated_access"
  on "public"."petty_cash_accounts"
  as permissive
  for select
  to authenticated
using (true);



  create policy "petty_cash_debug_anon"
  on "public"."petty_cash_accounts"
  as permissive
  for select
  to anon
using (true);



  create policy "petty_cash_service_access"
  on "public"."petty_cash_accounts"
  as permissive
  for all
  to service_role
using (true);



  create policy "petty_cash_reconciliations_rls_read"
  on "public"."petty_cash_reconciliations"
  as permissive
  for select
  to public
using (((preschool_id = public.get_user_org_id()) OR public.is_super_admin()));



  create policy "petty_cash_reconciliations_rls_write"
  on "public"."petty_cash_reconciliations"
  as permissive
  for all
  to public
using (((preschool_id = public.get_user_org_id()) OR public.is_super_admin()));



  create policy "Principals and admins can delete petty cash transactions"
  on "public"."petty_cash_transactions"
  as permissive
  for delete
  to public
using ((EXISTS ( SELECT 1
   FROM public.users u
  WHERE ((u.auth_user_id = auth.uid()) AND (u.preschool_id = petty_cash_transactions.school_id) AND (u.role = ANY (ARRAY['principal'::text, 'admin'::text, 'superadmin'::text]))))));



  create policy "Principals and admins can insert petty cash transactions"
  on "public"."petty_cash_transactions"
  as permissive
  for insert
  to public
with check ((EXISTS ( SELECT 1
   FROM public.users u
  WHERE ((u.auth_user_id = auth.uid()) AND (u.preschool_id = petty_cash_transactions.school_id) AND (u.role = ANY (ARRAY['principal'::text, 'admin'::text, 'superadmin'::text]))))));



  create policy "Principals and admins can update petty cash transactions"
  on "public"."petty_cash_transactions"
  as permissive
  for update
  to public
using ((EXISTS ( SELECT 1
   FROM public.users u
  WHERE ((u.auth_user_id = auth.uid()) AND (u.preschool_id = petty_cash_transactions.school_id) AND (u.role = ANY (ARRAY['principal'::text, 'admin'::text, 'superadmin'::text]))))));



  create policy "Users can view petty cash transactions in their preschool"
  on "public"."petty_cash_transactions"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.users u
  WHERE ((u.auth_user_id = auth.uid()) AND (u.preschool_id = petty_cash_transactions.school_id)))));



  create policy "petty_cash_transactions_staff_access"
  on "public"."petty_cash_transactions"
  as permissive
  for all
  to authenticated
using ((((created_by = auth.uid()) OR (approved_by = auth.uid())) AND (EXISTS ( SELECT 1
   FROM public.users u
  WHERE ((u.id = auth.uid()) AND (u.preschool_id = petty_cash_transactions.school_id) AND (u.role = ANY (ARRAY['teacher'::text, 'preschool_admin'::text])))))))
with check (((created_by = auth.uid()) AND (EXISTS ( SELECT 1
   FROM public.users u
  WHERE ((u.id = auth.uid()) AND (u.preschool_id = petty_cash_transactions.school_id) AND (u.role = ANY (ARRAY['teacher'::text, 'preschool_admin'::text])))))));



  create policy "petty_cash_transactions_superadmin_access"
  on "public"."petty_cash_transactions"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "petty_cash_transactions_tenant_access"
  on "public"."petty_cash_transactions"
  as permissive
  for all
  to authenticated
using ((school_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = ANY (ARRAY['principal'::text, 'preschool_admin'::text]))))))
with check ((school_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = ANY (ARRAY['principal'::text, 'preschool_admin'::text]))))));



  create policy "phone_verification_service"
  on "public"."phone_verification_logs"
  as permissive
  for all
  to public
using (false);



  create policy "plan_quotas_admin_delete"
  on "public"."plan_quotas"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "plan_quotas_admin_modify"
  on "public"."plan_quotas"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "plan_quotas_admin_update"
  on "public"."plan_quotas"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "plan_quotas_public_read"
  on "public"."plan_quotas"
  as permissive
  for select
  to authenticated
using (true);



  create policy "platform_analytics_admin_delete"
  on "public"."platform_analytics"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "platform_analytics_admin_modify"
  on "public"."platform_analytics"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "platform_analytics_admin_update"
  on "public"."platform_analytics"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "platform_analytics_public_read"
  on "public"."platform_analytics"
  as permissive
  for select
  to authenticated
using (true);



  create policy "platform_payments_insert"
  on "public"."platform_collected_payments"
  as permissive
  for insert
  to public
with check (((payer_user_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'super_admin'::text))))));



  create policy "platform_payments_select"
  on "public"."platform_collected_payments"
  as permissive
  for select
  to public
using (((payer_user_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.organization_id = platform_collected_payments.destination_organization_id) AND (om.user_id = auth.uid()) AND ((om.member_type)::text = ANY ((ARRAY['admin'::character varying, 'national_admin'::character varying, 'regional_manager'::character varying, 'treasurer'::character varying])::text[]))))) OR (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.preschool_id = platform_collected_payments.destination_organization_id) AND (p.role = 'principal'::text)))) OR (EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'super_admin'::text))))));



  create policy "disbursements_select"
  on "public"."platform_disbursements"
  as permissive
  for select
  to public
using (((EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.organization_id = platform_disbursements.organization_id) AND (om.user_id = auth.uid()) AND ((om.member_type)::text = ANY ((ARRAY['admin'::character varying, 'national_admin'::character varying, 'treasurer'::character varying])::text[]))))) OR (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.preschool_id = platform_disbursements.organization_id) AND (p.role = 'principal'::text)))) OR (EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'super_admin'::text))))));



  create policy "platform_subscriptions_admin_org"
  on "public"."platform_subscriptions"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles admin
  WHERE ((admin.id = auth.uid()) AND (admin.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text])) AND ((admin.role = 'superadmin'::text) OR (admin.organization_id IN ( SELECT target.organization_id
           FROM public.profiles target
          WHERE (target.id = platform_subscriptions.user_id))))))));



  create policy "platform_subscriptions_user_own"
  on "public"."platform_subscriptions"
  as permissive
  for all
  to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "pop_uploads_parent_insert"
  on "public"."pop_uploads"
  as permissive
  for insert
  to public
with check (((uploaded_by = auth.uid()) AND ((EXISTS ( SELECT 1
   FROM public.students s
  WHERE ((s.id = pop_uploads.student_id) AND ((s.parent_id = auth.uid()) OR (s.guardian_id = auth.uid())) AND (s.is_active = true)))) OR (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text])) AND (p.organization_id = pop_uploads.preschool_id)))))));



  create policy "pop_uploads_parent_update"
  on "public"."pop_uploads"
  as permissive
  for update
  to authenticated
using (((uploaded_by = auth.uid()) AND ((status)::text = 'pending'::text)))
with check (((uploaded_by = auth.uid()) AND ((status)::text = 'pending'::text)));



  create policy "pop_uploads_staff_delete"
  on "public"."pop_uploads"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['admin'::text, 'principal'::text])) AND (p.organization_id = pop_uploads.preschool_id)))));



  create policy "pop_uploads_staff_update"
  on "public"."pop_uploads"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text])) AND (p.organization_id = pop_uploads.preschool_id)))))
with check ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text])) AND (p.organization_id = pop_uploads.preschool_id)))));



  create policy "pop_uploads_tenant_select"
  on "public"."pop_uploads"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "Users can create their own portfolio items"
  on "public"."portfolio_items"
  as permissive
  for insert
  to public
with check ((auth.uid() = learner_id));



  create policy "Users can update their own portfolio items"
  on "public"."portfolio_items"
  as permissive
  for update
  to public
using ((auth.uid() = learner_id));



  create policy "Users can view their own portfolio items"
  on "public"."portfolio_items"
  as permissive
  for select
  to public
using (((auth.uid() = learner_id) OR (is_public = true)));



  create policy "preschool_onboarding_requests_admin_delete"
  on "public"."preschool_onboarding_requests"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "preschool_onboarding_requests_admin_modify"
  on "public"."preschool_onboarding_requests"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "preschool_onboarding_requests_admin_update"
  on "public"."preschool_onboarding_requests"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "preschool_onboarding_requests_public_read"
  on "public"."preschool_onboarding_requests"
  as permissive
  for select
  to authenticated
using (true);



  create policy "principals_manage_preschool_settings"
  on "public"."preschool_settings"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'principal_admin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = preschool_settings.preschool_id)))));



  create policy "teachers_view_preschool_settings"
  on "public"."preschool_settings"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['teacher'::text, 'principal'::text, 'principal_admin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = preschool_settings.preschool_id)))));



  create policy "Preschool admins can view preschool usage"
  on "public"."preschool_voice_usage"
  as permissive
  for select
  to public
using ((preschool_id = ((auth.jwt() ->> 'preschool_id'::text))::uuid));



  create policy "Allow insert during sign-up"
  on "public"."preschools"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Parents can view approved preschools"
  on "public"."preschools"
  as permissive
  for select
  to authenticated
using (((approved = true) AND (verified = true) AND (is_active = true)));



  create policy "Service role full access"
  on "public"."preschools"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "preschools_service_role"
  on "public"."preschools"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "preschools_superadmin_delete"
  on "public"."preschools"
  as permissive
  for delete
  to authenticated
using (public.is_superadmin_safe());



  create policy "preschools_superadmin_read_all"
  on "public"."preschools"
  as permissive
  for select
  to authenticated
using (public.is_superadmin_safe());



  create policy "preschools_superadmin_update"
  on "public"."preschools"
  as permissive
  for update
  to authenticated
using (public.is_superadmin_safe())
with check (public.is_superadmin_safe());



  create policy "preschools_tenant_write"
  on "public"."preschools"
  as permissive
  for insert
  to authenticated
with check ((id = public.current_organization_id()));



  create policy "preschools_user_access"
  on "public"."preschools"
  as permissive
  for select
  to authenticated
using (((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'superadmin'::text)))) OR (EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.organization_id = preschools.id))))));



  create policy "preschools_user_join_access"
  on "public"."preschools"
  as permissive
  for select
  to authenticated
using ((id IN ( SELECT COALESCE(u.organization_id, u.preschool_id) AS "coalesce"
   FROM public.users u
  WHERE ((u.id = auth.uid()) OR (u.auth_user_id = auth.uid())))));



  create policy "preschools_user_read_own"
  on "public"."preschools"
  as permissive
  for select
  to authenticated
using ((id = public.get_user_preschool_id()));



  create policy "preschools_view_active"
  on "public"."preschools"
  as permissive
  for select
  to authenticated
using ((is_active = true));



  create policy "principal_groups_tenant_modify"
  on "public"."principal_groups"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "principal_groups_tenant_select"
  on "public"."principal_groups"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "profiles_principal_view_parents"
  on "public"."profiles"
  as permissive
  for select
  to authenticated
using ((id IN ( SELECT public.get_viewable_parent_ids_for_principal() AS get_viewable_parent_ids_for_principal)));



  create policy "profiles_superadmin_read_all"
  on "public"."profiles"
  as permissive
  for select
  to authenticated
using (public.is_superadmin_safe());



  create policy "profiles_superadmin_update"
  on "public"."profiles"
  as permissive
  for update
  to authenticated
using (public.is_superadmin_safe())
with check (public.is_superadmin_safe());



  create policy "service_role_all_access"
  on "public"."profiles"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "users_insert_own_profile"
  on "public"."profiles"
  as permissive
  for insert
  to authenticated
with check ((id = auth.uid()));



  create policy "Parents can view sent reports for their students"
  on "public"."progress_reports"
  as permissive
  for select
  to public
using (((status = 'sent'::text) AND (student_id IN ( SELECT students.id
   FROM public.students
  WHERE (students.parent_id IN ( SELECT users.id
           FROM public.users
          WHERE (users.auth_user_id = auth.uid())))))));



  create policy "Principals can delete non-sent reports"
  on "public"."progress_reports"
  as permissive
  for delete
  to public
using (((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE ((users.auth_user_id = auth.uid()) AND (users.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'superadmin'::text]))))) AND (status <> 'sent'::text)));



  create policy "Principals can review pending reports"
  on "public"."progress_reports"
  as permissive
  for update
  to public
using (((status = 'pending_review'::text) AND (preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE ((users.auth_user_id = auth.uid()) AND (users.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'superadmin'::text])))))))
with check (((status = ANY (ARRAY['pending_review'::text, 'approved'::text, 'rejected'::text])) AND (preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE ((users.auth_user_id = auth.uid()) AND (users.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'superadmin'::text])))))));



  create policy "Principals can view all preschool reports"
  on "public"."progress_reports"
  as permissive
  for select
  to public
using ((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE ((users.auth_user_id = auth.uid()) AND (users.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'superadmin'::text]))))));



  create policy "Teachers can create reports for their students"
  on "public"."progress_reports"
  as permissive
  for insert
  to public
with check (((teacher_id IN ( SELECT users.id
   FROM public.users
  WHERE (users.auth_user_id = auth.uid()))) AND (preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE (users.auth_user_id = auth.uid()))) AND (status = 'draft'::text)));



  create policy "Teachers can delete only draft reports"
  on "public"."progress_reports"
  as permissive
  for delete
  to public
using (((teacher_id IN ( SELECT users.id
   FROM public.users
  WHERE (users.auth_user_id = auth.uid()))) AND (status = 'draft'::text) AND (preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE (users.auth_user_id = auth.uid())))));



  create policy "Teachers can mark approved reports as sent"
  on "public"."progress_reports"
  as permissive
  for update
  to public
using (((teacher_id IN ( SELECT users.id
   FROM public.users
  WHERE (users.auth_user_id = auth.uid()))) AND (status = 'approved'::text) AND (preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE (users.auth_user_id = auth.uid())))))
with check (((status = 'sent'::text) AND (preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE (users.auth_user_id = auth.uid())))));



  create policy "Teachers can update draft or rejected reports"
  on "public"."progress_reports"
  as permissive
  for update
  to public
using (((teacher_id IN ( SELECT users.id
   FROM public.users
  WHERE (users.auth_user_id = auth.uid()))) AND (status = ANY (ARRAY['draft'::text, 'rejected'::text])) AND (preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE (users.auth_user_id = auth.uid())))))
with check (((teacher_id IN ( SELECT users.id
   FROM public.users
  WHERE (users.auth_user_id = auth.uid()))) AND (status = ANY (ARRAY['draft'::text, 'rejected'::text, 'pending_review'::text])) AND (preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE (users.auth_user_id = auth.uid())))));



  create policy "Teachers can view their own reports"
  on "public"."progress_reports"
  as permissive
  for select
  to public
using ((teacher_id IN ( SELECT users.id
   FROM public.users
  WHERE (users.auth_user_id = auth.uid()))));



  create policy "Admins can manage campaigns"
  on "public"."promotional_campaigns"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['super_admin'::text, 'superadmin'::text]))))));



  create policy "Anyone can view active campaigns"
  on "public"."promotional_campaigns"
  as permissive
  for select
  to anon, authenticated
using (((is_active = true) AND ((now() >= start_date) AND (now() <= end_date))));



  create policy "push_device_tokens_admin_org"
  on "public"."push_device_tokens"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles admin
  WHERE ((admin.id = auth.uid()) AND (admin.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text])) AND ((admin.role = 'superadmin'::text) OR (admin.organization_id IN ( SELECT target.organization_id
           FROM public.profiles target
          WHERE (target.id = push_device_tokens.user_id))))))));



  create policy "push_device_tokens_user_own"
  on "public"."push_device_tokens"
  as permissive
  for all
  to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "Authenticated users can register push devices"
  on "public"."push_devices"
  as permissive
  for insert
  to authenticated
with check ((user_id = auth.uid()));



  create policy "Service role can manage all push devices"
  on "public"."push_devices"
  as permissive
  for all
  to public
using (((current_setting('role'::text, true) = 'service_role'::text) OR ((auth.jwt() ->> 'role'::text) = 'service_role'::text)));



  create policy "Users can delete their own push devices"
  on "public"."push_devices"
  as permissive
  for delete
  to public
using ((user_id = auth.uid()));



  create policy "Users can update their push devices"
  on "public"."push_devices"
  as permissive
  for update
  to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "Users can view their own push devices"
  on "public"."push_devices"
  as permissive
  for select
  to public
using ((user_id = auth.uid()));



  create policy "push_queue_service_role"
  on "public"."push_notification_queue"
  as permissive
  for all
  to public
using ((auth.role() = 'service_role'::text));



  create policy "push_notifications_recipient_access"
  on "public"."push_notifications"
  as permissive
  for select
  to authenticated
using ((recipient_user_id = auth.uid()));



  create policy "push_notifications_superadmin_access"
  on "public"."push_notifications"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "push_notifications_tenant_isolation"
  on "public"."push_notifications"
  as permissive
  for insert
  to authenticated
with check ((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE (users.id = auth.uid()))));



  create policy "Service role full access"
  on "public"."push_subscriptions"
  as permissive
  for all
  to public
using ((auth.role() = 'service_role'::text));



  create policy "Users can delete their own subscriptions"
  on "public"."push_subscriptions"
  as permissive
  for delete
  to public
using (((auth.uid() = user_id) OR (user_id IS NULL)));



  create policy "Users can insert their own subscriptions"
  on "public"."push_subscriptions"
  as permissive
  for insert
  to public
with check (((auth.uid() = user_id) OR (user_id IS NULL)));



  create policy "Users can manage own subscriptions"
  on "public"."push_subscriptions"
  as permissive
  for all
  to public
using ((auth.uid() = user_id));



  create policy "Users can update their own subscriptions"
  on "public"."push_subscriptions"
  as permissive
  for update
  to public
using (((auth.uid() = user_id) OR (user_id IS NULL)))
with check (((auth.uid() = user_id) OR (user_id IS NULL)));



  create policy "Users can view their own subscriptions"
  on "public"."push_subscriptions"
  as permissive
  for select
  to public
using (((auth.uid() = user_id) OR (user_id IS NULL)));



  create policy "push_subscriptions_delete_policy"
  on "public"."push_subscriptions"
  as permissive
  for delete
  to public
using ((user_id = auth.uid()));



  create policy "push_subscriptions_insert_policy"
  on "public"."push_subscriptions"
  as permissive
  for insert
  to public
with check ((user_id = auth.uid()));



  create policy "push_subscriptions_select_policy"
  on "public"."push_subscriptions"
  as permissive
  for select
  to public
using ((user_id = auth.uid()));



  create policy "push_subscriptions_service_role_policy"
  on "public"."push_subscriptions"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "push_subscriptions_update_policy"
  on "public"."push_subscriptions"
  as permissive
  for update
  to public
using ((user_id = auth.uid()));



  create policy "rag_chunks_delete_owner"
  on "public"."rag_chunks"
  as permissive
  for delete
  to public
using ((user_id = auth.uid()));



  create policy "rag_chunks_insert_owner"
  on "public"."rag_chunks"
  as permissive
  for insert
  to public
with check ((user_id = auth.uid()));



  create policy "rag_chunks_select_owner"
  on "public"."rag_chunks"
  as permissive
  for select
  to public
using ((user_id = auth.uid()));



  create policy "rag_chunks_update_owner"
  on "public"."rag_chunks"
  as permissive
  for update
  to public
using ((user_id = auth.uid()));



  create policy "rag_documents_delete_owner"
  on "public"."rag_documents"
  as permissive
  for delete
  to public
using ((user_id = auth.uid()));



  create policy "rag_documents_insert_owner"
  on "public"."rag_documents"
  as permissive
  for insert
  to public
with check ((user_id = auth.uid()));



  create policy "rag_documents_select_owner"
  on "public"."rag_documents"
  as permissive
  for select
  to public
using ((user_id = auth.uid()));



  create policy "rag_documents_update_owner"
  on "public"."rag_documents"
  as permissive
  for update
  to public
using ((user_id = auth.uid()));



  create policy "rag_ingestion_logs_select_owner"
  on "public"."rag_ingestion_logs"
  as permissive
  for select
  to public
using ((attachment_id IN ( SELECT ai_attachments.id
   FROM public.ai_attachments
  WHERE (ai_attachments.user_id = auth.uid()))));



  create policy "Users can manage own reading progress"
  on "public"."reading_progress"
  as permissive
  for all
  to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "anon_select_region_invite_codes"
  on "public"."region_invite_codes"
  as permissive
  for select
  to anon
using ((is_active = true));



  create policy "regional_managers_delete_codes"
  on "public"."region_invite_codes"
  as permissive
  for delete
  to public
using ((EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND (om.organization_id = region_invite_codes.organization_id) AND ((om.role = ANY (ARRAY['national_admin'::text, 'regional_manager'::text, 'ceo'::text, 'president'::text, 'youth_president'::text])) OR ((om.member_type)::text = ANY ((ARRAY['national_admin'::character varying, 'regional_manager'::character varying, 'ceo'::character varying, 'president'::character varying, 'youth_president'::character varying])::text[]))) AND ((om.role = ANY (ARRAY['national_admin'::text, 'ceo'::text, 'president'::text, 'youth_president'::text])) OR ((om.member_type)::text = ANY ((ARRAY['national_admin'::character varying, 'ceo'::character varying, 'president'::character varying, 'youth_president'::character varying])::text[])) OR (om.region_id = region_invite_codes.region_id))))));



  create policy "regional_managers_insert_codes"
  on "public"."region_invite_codes"
  as permissive
  for insert
  to public
with check (((EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND (om.organization_id = region_invite_codes.organization_id) AND ((om.role = ANY (ARRAY['national_admin'::text, 'regional_manager'::text, 'ceo'::text, 'president'::text, 'youth_president'::text])) OR ((om.member_type)::text = ANY ((ARRAY['national_admin'::character varying, 'regional_manager'::character varying, 'ceo'::character varying, 'president'::character varying, 'youth_president'::character varying])::text[]))) AND ((om.role = ANY (ARRAY['national_admin'::text, 'ceo'::text, 'president'::text, 'youth_president'::text])) OR ((om.member_type)::text = ANY ((ARRAY['national_admin'::character varying, 'ceo'::character varying, 'president'::character varying, 'youth_president'::character varying])::text[])) OR (om.region_id = region_invite_codes.region_id))))) AND (created_by = auth.uid())));



  create policy "regional_managers_select_codes"
  on "public"."region_invite_codes"
  as permissive
  for select
  to public
using (((is_active = true) OR (EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND (om.organization_id = region_invite_codes.organization_id) AND ((om.role = ANY (ARRAY['national_admin'::text, 'regional_manager'::text, 'ceo'::text, 'president'::text, 'youth_president'::text])) OR ((om.member_type)::text = ANY ((ARRAY['national_admin'::character varying, 'regional_manager'::character varying, 'ceo'::character varying, 'president'::character varying, 'youth_president'::character varying])::text[]))))))));



  create policy "regional_managers_update_codes"
  on "public"."region_invite_codes"
  as permissive
  for update
  to public
using ((EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND (om.organization_id = region_invite_codes.organization_id) AND ((om.role = ANY (ARRAY['national_admin'::text, 'regional_manager'::text, 'ceo'::text, 'president'::text, 'youth_president'::text])) OR ((om.member_type)::text = ANY ((ARRAY['national_admin'::character varying, 'regional_manager'::character varying, 'ceo'::character varying, 'president'::character varying, 'youth_president'::character varying])::text[]))) AND ((om.role = ANY (ARRAY['national_admin'::text, 'ceo'::text, 'president'::text, 'youth_president'::text])) OR ((om.member_type)::text = ANY ((ARRAY['national_admin'::character varying, 'ceo'::character varying, 'president'::character varying, 'youth_president'::character varying])::text[])) OR (om.region_id = region_invite_codes.region_id))))));



  create policy "Principals manage own school registrations"
  on "public"."registration_requests"
  as permissive
  for update
  to public
using ((organization_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'principal'::text)))));



  create policy "Principals see own school registrations"
  on "public"."registration_requests"
  as permissive
  for select
  to public
using ((organization_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'principal'::text)))));



  create policy "SuperAdmins see all registrations"
  on "public"."registration_requests"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'superadmin'::text)))));



  create policy "resource_categories_org_modify"
  on "public"."resource_categories"
  as permissive
  for all
  to authenticated
using ((organization_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((organization_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "resource_categories_org_select"
  on "public"."resource_categories"
  as permissive
  for select
  to authenticated
using ((organization_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "resource_permissions_admin_org"
  on "public"."resource_permissions"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles admin
  WHERE ((admin.id = auth.uid()) AND (admin.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text])) AND ((admin.role = 'superadmin'::text) OR (admin.organization_id IN ( SELECT target.organization_id
           FROM public.profiles target
          WHERE (target.id = resource_permissions.user_id))))))));



  create policy "resource_permissions_user_own"
  on "public"."resource_permissions"
  as permissive
  for all
  to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "resource_reviews_admin_org"
  on "public"."resource_reviews"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles admin
  WHERE ((admin.id = auth.uid()) AND (admin.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text])) AND ((admin.role = 'superadmin'::text) OR (admin.organization_id IN ( SELECT target.organization_id
           FROM public.profiles target
          WHERE (target.id = resource_reviews.user_id))))))));



  create policy "resource_reviews_user_own"
  on "public"."resource_reviews"
  as permissive
  for all
  to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "resources_org_modify"
  on "public"."resources"
  as permissive
  for all
  to authenticated
using ((organization_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((organization_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "resources_org_select"
  on "public"."resources"
  as permissive
  for select
  to authenticated
using ((organization_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "service_role_revenuecat_webhook_events"
  on "public"."revenuecat_webhook_events"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "rubric_grades_admin_delete"
  on "public"."rubric_grades"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "rubric_grades_admin_modify"
  on "public"."rubric_grades"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "rubric_grades_admin_update"
  on "public"."rubric_grades"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "rubric_grades_public_read"
  on "public"."rubric_grades"
  as permissive
  for select
  to authenticated
using (true);



  create policy "scheduled_lessons_parent_select"
  on "public"."scheduled_lessons"
  as permissive
  for select
  to authenticated
using ((class_id IN ( SELECT public.get_my_children_class_ids() AS get_my_children_class_ids)));



  create policy "scheduled_lessons_teacher_all"
  on "public"."scheduled_lessons"
  as permissive
  for all
  to public
using ((auth.uid() = teacher_id));



  create policy "Admins can manage scheduled tasks in their organization"
  on "public"."scheduled_tasks"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['admin'::text, 'principal'::text])) AND ((p.organization_id = p.organization_id) OR (p.organization_id IS NULL))))));



  create policy "Instructors can view scheduled tasks in their organization"
  on "public"."scheduled_tasks"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['instructor'::text, 'admin'::text, 'principal'::text])) AND (p.organization_id = scheduled_tasks.organization_id)))));



  create policy "school_branding_tenant_modify"
  on "public"."school_branding"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "school_branding_tenant_select"
  on "public"."school_branding"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "school_events_delete_policy"
  on "public"."school_events"
  as permissive
  for delete
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.preschool_id = school_events.preschool_id) AND (profiles.role = 'principal'::text)))));



  create policy "school_events_insert_policy"
  on "public"."school_events"
  as permissive
  for insert
  to public
with check (((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.preschool_id = school_events.preschool_id) AND (profiles.role = 'principal'::text)))) AND (created_by = auth.uid())));



  create policy "school_events_select_policy"
  on "public"."school_events"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.preschool_id = school_events.preschool_id)))));



  create policy "school_events_update_policy"
  on "public"."school_events"
  as permissive
  for update
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.preschool_id = school_events.preschool_id) AND (profiles.role = 'principal'::text)))));



  create policy "Principals can manage fee structures"
  on "public"."school_fee_structures"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['principal'::text, 'superadmin'::text]))))));



  create policy "parents_view_fee_structures"
  on "public"."school_fee_structures"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT public.get_my_children_preschool_ids() AS get_my_children_preschool_ids)));



  create policy "school_invitation_codes_select"
  on "public"."school_invitation_codes"
  as permissive
  for select
  to public
using (((school_id = public.get_user_org_id()) OR public.is_super_admin()));



  create policy "school_invitation_codes_tenant_modify"
  on "public"."school_invitation_codes"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "school_invitation_codes_tenant_select"
  on "public"."school_invitation_codes"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "school_invitation_codes_update"
  on "public"."school_invitation_codes"
  as permissive
  for update
  to public
using (((school_id = public.get_user_org_id()) AND (EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['principal'::text, 'admin'::text])))))));



  create policy "school_invite_codes_insert_by_principal"
  on "public"."school_invitation_codes"
  as permissive
  for insert
  to authenticated
with check ((app_auth.is_superadmin() OR ((preschool_id = COALESCE(public.current_preschool_id(), ( SELECT p.preschool_id
   FROM public.profiles p
  WHERE (p.id = auth.uid())))) AND (public.current_user_role() = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'admin'::text])))));



  create policy "school_settings_select_policy"
  on "public"."school_settings"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.preschool_id = school_settings.preschool_id)))));



  create policy "school_settings_tenant_modify"
  on "public"."school_settings"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "school_settings_tenant_select"
  on "public"."school_settings"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "school_settings_update_policy"
  on "public"."school_settings"
  as permissive
  for update
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.preschool_id = school_settings.preschool_id) AND (profiles.role = 'principal'::text)))));



  create policy "school_verifications_school_access"
  on "public"."school_verifications"
  as permissive
  for all
  to authenticated
using ((school_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = ANY (ARRAY['principal'::text, 'preschool_admin'::text]))))))
with check ((school_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = ANY (ARRAY['principal'::text, 'preschool_admin'::text]))))));



  create policy "school_verifications_superadmin_access"
  on "public"."school_verifications"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "schools_admin_delete"
  on "public"."schools"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "schools_admin_modify"
  on "public"."schools"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "schools_admin_update"
  on "public"."schools"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "schools_public_read"
  on "public"."schools"
  as permissive
  for select
  to authenticated
using (true);



  create policy "schools_superadmin_delete"
  on "public"."schools"
  as permissive
  for delete
  to authenticated
using (public.is_superadmin_safe());



  create policy "schools_superadmin_read_all"
  on "public"."schools"
  as permissive
  for select
  to authenticated
using (public.is_superadmin_safe());



  create policy "schools_superadmin_update"
  on "public"."schools"
  as permissive
  for update
  to authenticated
using (public.is_superadmin_safe())
with check (public.is_superadmin_safe());



  create policy "seats_own_or_org"
  on "public"."seats"
  as permissive
  for all
  to public
using (((user_id = auth.uid()) OR (preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid())))));



  create policy "Superadmins can view all security events"
  on "public"."security_events"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'superadmin'::text)))));



  create policy "System can insert security events"
  on "public"."security_events"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "service_alert_config_access"
  on "public"."service_alert_config"
  as permissive
  for all
  to public
using (public.is_super_admin());



  create policy "service_alerts_access"
  on "public"."service_alerts"
  as permissive
  for all
  to public
using (public.is_super_admin());



  create policy "service_api_keys_access"
  on "public"."service_api_keys"
  as permissive
  for all
  to public
using (public.is_super_admin());



  create policy "service_cost_tracking_access"
  on "public"."service_cost_tracking"
  as permissive
  for all
  to public
using (public.is_super_admin());



  create policy "service_health_status_access"
  on "public"."service_health_status"
  as permissive
  for all
  to public
using (public.is_super_admin());



  create policy "service_incidents_access"
  on "public"."service_incidents"
  as permissive
  for all
  to public
using (public.is_super_admin());



  create policy "service_usage_limits_access"
  on "public"."service_usage_limits"
  as permissive
  for all
  to public
using (public.is_super_admin());



  create policy "sms_messages_insert_staff"
  on "public"."sms_messages"
  as permissive
  for insert
  to public
with check ((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = ANY (ARRAY['principal'::text, 'teacher'::text, 'superadmin'::text]))))));



  create policy "sms_messages_select_preschool"
  on "public"."sms_messages"
  as permissive
  for select
  to public
using ((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE (users.id = auth.uid()))));



  create policy "sms_messages_service_role_all"
  on "public"."sms_messages"
  as permissive
  for all
  to public
using (((auth.jwt() ->> 'role'::text) = 'service_role'::text));



  create policy "sms_opt_outs_insert_staff"
  on "public"."sms_opt_outs"
  as permissive
  for insert
  to public
with check ((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = ANY (ARRAY['principal'::text, 'teacher'::text, 'superadmin'::text]))))));



  create policy "sms_opt_outs_select_preschool"
  on "public"."sms_opt_outs"
  as permissive
  for select
  to public
using ((preschool_id IN ( SELECT users.preschool_id
   FROM public.users
  WHERE (users.id = auth.uid()))));



  create policy "sms_opt_outs_service_role_all"
  on "public"."sms_opt_outs"
  as permissive
  for all
  to public
using (((auth.jwt() ->> 'role'::text) = 'service_role'::text));



  create policy "sound_alert_settings_user_access"
  on "public"."sound_alert_settings"
  as permissive
  for all
  to public
using ((auth.uid() = user_id))
with check ((auth.uid() = user_id));



  create policy "standalone_users_select_own"
  on "public"."standalone_users"
  as permissive
  for select
  to authenticated
using ((user_id = auth.uid()));



  create policy "standalone_users_update_own"
  on "public"."standalone_users"
  as permissive
  for update
  to authenticated
using ((user_id = auth.uid()));



  create policy "parents_view_child_stem_progress"
  on "public"."stem_progress"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "teachers_manage_stem_progress"
  on "public"."stem_progress"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['teacher'::text, 'principal'::text, 'principal_admin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = stem_progress.preschool_id)))));



  create policy "achievements_insert"
  on "public"."student_achievements"
  as permissive
  for insert
  to public
with check (((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.preschool_id = student_achievements.preschool_id) AND (p.role = ANY (ARRAY['teacher'::text, 'principal'::text]))))) OR (EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'super_admin'::text))))));



  create policy "achievements_select"
  on "public"."student_achievements"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "activity_feed_manage"
  on "public"."student_activity_feed"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.preschool_id = student_activity_feed.preschool_id) AND (p.role = ANY (ARRAY['teacher'::text, 'principal'::text]))))));



  create policy "student_enrollments_parent_child"
  on "public"."student_enrollments"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "student_enrollments_staff_org"
  on "public"."student_enrollments"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM (public.profiles staff
     JOIN public.profiles student ON ((student.id = student_enrollments.student_id)))
  WHERE ((staff.id = auth.uid()) AND (staff.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text, 'superadmin'::text])) AND ((staff.role = 'superadmin'::text) OR (staff.organization_id = student.organization_id))))));



  create policy "student_enrollments_student_own"
  on "public"."student_enrollments"
  as permissive
  for all
  to authenticated
using ((student_id = auth.uid()))
with check ((student_id = auth.uid()));



  create policy "School staff can manage fee assignments"
  on "public"."student_fee_assignments"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['principal'::text, 'superadmin'::text]))))));



  create policy "parents_view_children_fees"
  on "public"."student_fee_assignments"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "student_fees_student_own"
  on "public"."student_fees"
  as permissive
  for all
  to authenticated
using ((student_id = auth.uid()))
with check ((student_id = auth.uid()));



  create policy "Organization members can view student groups"
  on "public"."student_groups"
  as permissive
  for select
  to authenticated
using ((group_id IN ( SELECT g.id
   FROM (public.groups g
     JOIN public.profiles p ON ((p.organization_id = g.organization_id)))
  WHERE (p.id = auth.uid()))));



  create policy "Teachers can manage student groups"
  on "public"."student_groups"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM (public.groups g
     JOIN public.profiles p ON ((p.id = auth.uid())))
  WHERE ((g.id = student_groups.group_id) AND (p.organization_id = g.organization_id) AND (p.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "Admins can manage parent relationships"
  on "public"."student_parent_relationships"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['admin'::text, 'principal'::text])) AND (p.organization_id IN ( SELECT profiles.organization_id
           FROM public.profiles
          WHERE (profiles.id = student_parent_relationships.student_id)))))));



  create policy "Students can view their parent relationships"
  on "public"."student_parent_relationships"
  as permissive
  for select
  to authenticated
using ((student_id = auth.uid()));



  create policy "parents_view_their_relationships"
  on "public"."student_parent_relationships"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "Admins can view all student progress in their organization"
  on "public"."student_progress"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM (public.profiles p
     JOIN public.courses c ON ((c.id = student_progress.course_id)))
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['admin'::text, 'principal'::text])) AND (p.organization_id = c.organization_id)))));



  create policy "Instructors can manage student progress for their courses"
  on "public"."student_progress"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM (public.courses c
     JOIN public.profiles p ON ((p.id = auth.uid())))
  WHERE ((c.id = student_progress.course_id) AND ((c.instructor_id = auth.uid()) OR (p.role = 'admin'::text)) AND (p.organization_id = c.organization_id)))));



  create policy "Students can view their own progress"
  on "public"."student_progress"
  as permissive
  for select
  to authenticated
using ((student_id = auth.uid()));



  create policy "parents_view_children_progress"
  on "public"."student_progress"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "streaks_select"
  on "public"."student_streaks"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "streaks_upsert"
  on "public"."student_streaks"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.preschool_id = student_streaks.preschool_id) AND (p.role = ANY (ARRAY['teacher'::text, 'principal'::text]))))));



  create policy "students_parent_insert_own_children"
  on "public"."students"
  as permissive
  for insert
  to authenticated
with check (((parent_id = auth.uid()) AND (preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid())))));



  create policy "students_superadmin_all"
  on "public"."students"
  as permissive
  for all
  to public
using (public.is_superadmin_safe());



  create policy "Organization members can create study groups"
  on "public"."study_groups"
  as permissive
  for insert
  to public
with check (((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.organization_id = study_groups.organization_id)))) AND (auth.uid() = created_by)));



  create policy "Organization members can view study groups"
  on "public"."study_groups"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.organization_id = study_groups.organization_id)))));



  create policy "submissions_instructor_manage"
  on "public"."submissions"
  as permissive
  for all
  to public
using ((public.is_instructor_level() AND (EXISTS ( SELECT 1
   FROM (public.assignments a
     JOIN public.courses c ON ((c.id = a.course_id)))
  WHERE ((a.id = submissions.assignment_id) AND (c.instructor_id = auth.uid()) AND (a.deleted_at IS NULL) AND (c.deleted_at IS NULL))))));



  create policy "submissions_instructor_read"
  on "public"."submissions"
  as permissive
  for select
  to public
using ((public.is_instructor_level() AND (EXISTS ( SELECT 1
   FROM (public.assignments a
     JOIN public.courses c ON ((c.id = a.course_id)))
  WHERE ((a.id = submissions.assignment_id) AND ((c.instructor_id = auth.uid()) OR public.can_access_organization(c.organization_id)) AND (a.deleted_at IS NULL) AND (c.deleted_at IS NULL))))));



  create policy "submissions_student_manage_own"
  on "public"."submissions"
  as permissive
  for all
  to public
using (((student_id = auth.uid()) AND (EXISTS ( SELECT 1
   FROM ((public.assignments a
     JOIN public.courses c ON ((c.id = a.course_id)))
     JOIN public.enrollments e ON ((e.course_id = c.id)))
  WHERE ((a.id = submissions.assignment_id) AND (e.student_id = auth.uid()) AND (e.is_active = true) AND (a.deleted_at IS NULL) AND (c.deleted_at IS NULL) AND (c.is_active = true) AND ((current_setting('request.method'::text) = 'SELECT'::text) OR ((a.available_until IS NULL) OR (a.available_until > now()))))))));



  create policy "submissions_student_read_own"
  on "public"."submissions"
  as permissive
  for select
  to public
using ((student_id = auth.uid()));



  create policy "submissions_super_admin_read"
  on "public"."submissions"
  as permissive
  for select
  to public
using (public.is_super_admin());



  create policy "Anyone can view active subscription plans"
  on "public"."subscription_plans"
  as permissive
  for select
  to public
using ((is_active = true));



  create policy "Only superadmins can manage subscription plans"
  on "public"."subscription_plans"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'superadmin'::text)))));



  create policy "Admins can manage subscription seats"
  on "public"."subscription_seats"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.organization_id = subscription_seats.preschool_id) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text]))))));



  create policy "Organization members can view subscription seats"
  on "public"."subscription_seats"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "subscription_seats_block_writes"
  on "public"."subscription_seats"
  as permissive
  for all
  to public
using (false)
with check (false);



  create policy "subscription_seats_tenant_select"
  on "public"."subscription_seats"
  as permissive
  for select
  to public
using (((EXISTS ( SELECT 1
   FROM (public.profiles p
     JOIN public.subscriptions s ON ((s.school_id = p.preschool_id)))
  WHERE ((p.id = auth.uid()) AND (p.role = 'principal'::text) AND (s.id = subscription_seats.subscription_id)))) OR (user_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = 'superadmin'::text))))));



  create policy "System can manage usage tracking"
  on "public"."subscription_usage"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'superadmin'::text)))));



  create policy "Users can view their school's usage"
  on "public"."subscription_usage"
  as permissive
  for select
  to public
using ((school_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "Principals and superadmins can manage subscriptions"
  on "public"."subscriptions"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND ((profiles.role = 'superadmin'::text) OR ((profiles.role = 'principal'::text) AND (profiles.preschool_id = subscriptions.school_id)))))));



  create policy "Service role full access to subscriptions"
  on "public"."subscriptions"
  as permissive
  for all
  to public
using (((auth.jwt() ->> 'role'::text) = 'service_role'::text));



  create policy "Users can view own subscriptions"
  on "public"."subscriptions"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "Users can view their school's subscription"
  on "public"."subscriptions"
  as permissive
  for select
  to public
using ((school_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "anon_debug_access"
  on "public"."subscriptions"
  as permissive
  for select
  to anon
using (true);



  create policy "authenticated_access"
  on "public"."subscriptions"
  as permissive
  for all
  to authenticated
using (true)
with check (true);



  create policy "service_role_access"
  on "public"."subscriptions"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "subscriptions_superadmin_read"
  on "public"."subscriptions"
  as permissive
  for select
  to authenticated
using (public.is_superadmin_safe());



  create policy "superadmin_agent_executions_super_admin"
  on "public"."superadmin_agent_executions"
  as permissive
  for all
  to authenticated
using (public.is_super_admin())
with check (public.is_super_admin());



  create policy "superadmin_ai_agents_super_admin"
  on "public"."superadmin_ai_agents"
  as permissive
  for all
  to authenticated
using (public.is_super_admin())
with check (public.is_super_admin());



  create policy "Superadmins can view all audit logs"
  on "public"."superadmin_audit_log"
  as permissive
  for select
  to authenticated
using ((( SELECT profiles.role
   FROM public.profiles
  WHERE (profiles.id = auth.uid())) = 'superadmin'::text));



  create policy "superadmin_audit_access"
  on "public"."superadmin_audit_log"
  as permissive
  for all
  to public
using (public.is_super_admin());



  create policy "superadmin_autonomous_tasks_super_admin"
  on "public"."superadmin_autonomous_tasks"
  as permissive
  for all
  to authenticated
using (public.is_super_admin())
with check (public.is_super_admin());



  create policy "superadmin_command_log_super_admin"
  on "public"."superadmin_command_log"
  as permissive
  for all
  to authenticated
using (public.is_super_admin())
with check (public.is_super_admin());



  create policy "superadmin_compliance_reports_admin_delete"
  on "public"."superadmin_compliance_reports"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "superadmin_compliance_reports_admin_modify"
  on "public"."superadmin_compliance_reports"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "superadmin_compliance_reports_admin_update"
  on "public"."superadmin_compliance_reports"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "superadmin_compliance_reports_public_read"
  on "public"."superadmin_compliance_reports"
  as permissive
  for select
  to authenticated
using (true);



  create policy "superadmin_integrations_super_admin"
  on "public"."superadmin_integrations"
  as permissive
  for all
  to authenticated
using (public.is_super_admin())
with check (public.is_super_admin());



  create policy "superadmin_notification_deliveries_admin_delete"
  on "public"."superadmin_notification_deliveries"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "superadmin_notification_deliveries_admin_modify"
  on "public"."superadmin_notification_deliveries"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "superadmin_notification_deliveries_admin_update"
  on "public"."superadmin_notification_deliveries"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "superadmin_notification_deliveries_public_read"
  on "public"."superadmin_notification_deliveries"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Only superadmins can access notification rules"
  on "public"."superadmin_notification_rules"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'superadmin'::text)))));



  create policy "superadmin_notifications_admin_delete"
  on "public"."superadmin_notifications"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "superadmin_notifications_admin_modify"
  on "public"."superadmin_notifications"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "superadmin_notifications_admin_update"
  on "public"."superadmin_notifications"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "superadmin_notifications_public_read"
  on "public"."superadmin_notifications"
  as permissive
  for select
  to authenticated
using (true);



  create policy "superadmin_platform_insights_super_admin"
  on "public"."superadmin_platform_insights"
  as permissive
  for all
  to authenticated
using (public.is_super_admin())
with check (public.is_super_admin());



  create policy "superadmin_role_assignments_admin_delete"
  on "public"."superadmin_role_assignments"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "superadmin_role_assignments_admin_modify"
  on "public"."superadmin_role_assignments"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "superadmin_role_assignments_admin_update"
  on "public"."superadmin_role_assignments"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "superadmin_role_assignments_public_read"
  on "public"."superadmin_role_assignments"
  as permissive
  for select
  to authenticated
using (true);



  create policy "superadmin_session_management_admin_delete"
  on "public"."superadmin_session_management"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "superadmin_session_management_admin_modify"
  on "public"."superadmin_session_management"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "superadmin_session_management_admin_update"
  on "public"."superadmin_session_management"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "superadmin_session_management_public_read"
  on "public"."superadmin_session_management"
  as permissive
  for select
  to authenticated
using (true);



  create policy "superadmin_user_actions_admin_delete"
  on "public"."superadmin_user_actions"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "superadmin_user_actions_admin_modify"
  on "public"."superadmin_user_actions"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "superadmin_user_actions_admin_update"
  on "public"."superadmin_user_actions"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "superadmin_user_actions_public_read"
  on "public"."superadmin_user_actions"
  as permissive
  for select
  to authenticated
using (true);



  create policy "superadmin_user_deletion_requests_admin_org"
  on "public"."superadmin_user_deletion_requests"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles admin
  WHERE ((admin.id = auth.uid()) AND (admin.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text])) AND ((admin.role = 'superadmin'::text) OR (admin.organization_id IN ( SELECT target.organization_id
           FROM public.profiles target
          WHERE (target.id = superadmin_user_deletion_requests.user_id))))))));



  create policy "superadmin_user_deletion_requests_user_own"
  on "public"."superadmin_user_deletion_requests"
  as permissive
  for all
  to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "superadmin_user_risk_assessments_admin_org"
  on "public"."superadmin_user_risk_assessments"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles admin
  WHERE ((admin.id = auth.uid()) AND (admin.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text])) AND ((admin.role = 'superadmin'::text) OR (admin.organization_id IN ( SELECT target.organization_id
           FROM public.profiles target
          WHERE (target.id = superadmin_user_risk_assessments.user_id))))))));



  create policy "superadmin_user_risk_assessments_user_own"
  on "public"."superadmin_user_risk_assessments"
  as permissive
  for all
  to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "support_tickets_tenant_modify"
  on "public"."support_tickets"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "support_tickets_tenant_select"
  on "public"."support_tickets"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "Admins can view sync logs"
  on "public"."sync_logs"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['super_admin'::text, 'principal'::text, 'admin'::text]))))));



  create policy "Service role can log syncs"
  on "public"."sync_logs"
  as permissive
  for insert
  to public
with check (true);



  create policy "system_config_read"
  on "public"."system_config"
  as permissive
  for select
  to public
using (true);



  create policy "system_settings_admin_delete"
  on "public"."system_settings"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "system_settings_admin_modify"
  on "public"."system_settings"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "system_settings_admin_update"
  on "public"."system_settings"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "system_settings_public_read"
  on "public"."system_settings"
  as permissive
  for select
  to authenticated
using (true);



  create policy "teacher_ai_allocations_tenant_modify"
  on "public"."teacher_ai_allocations"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "teacher_ai_allocations_tenant_select"
  on "public"."teacher_ai_allocations"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "teacher_class_codes_delete_own"
  on "public"."teacher_class_codes"
  as permissive
  for delete
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.id = teacher_class_codes.teacher_id)))));



  create policy "teacher_class_codes_insert_own"
  on "public"."teacher_class_codes"
  as permissive
  for insert
  to public
with check ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.id = teacher_class_codes.teacher_id)))));



  create policy "teacher_class_codes_select_active"
  on "public"."teacher_class_codes"
  as permissive
  for select
  to authenticated
using ((active = true));



  create policy "teacher_class_codes_select_own"
  on "public"."teacher_class_codes"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.id = teacher_class_codes.teacher_id)))));



  create policy "teacher_class_codes_update_own"
  on "public"."teacher_class_codes"
  as permissive
  for update
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.id = teacher_class_codes.teacher_id)))))
with check ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.id = teacher_class_codes.teacher_id)))));



  create policy "teacher_invitations_tenant_modify"
  on "public"."teacher_invitations"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "teacher_invitations_tenant_select"
  on "public"."teacher_invitations"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "teacher_invites_school_modify"
  on "public"."teacher_invites"
  as permissive
  for all
  to authenticated
using ((school_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((school_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "teacher_invites_school_select"
  on "public"."teacher_invites"
  as permissive
  for select
  to authenticated
using ((school_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "teacher_performance_metrics_tenant_modify"
  on "public"."teacher_performance_metrics"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "teacher_performance_metrics_tenant_select"
  on "public"."teacher_performance_metrics"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "parents_acknowledge_notes"
  on "public"."teacher_student_notes"
  as permissive
  for update
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "parents_view_child_notes"
  on "public"."teacher_student_notes"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "principals_view_school_notes"
  on "public"."teacher_student_notes"
  as permissive
  for select
  to authenticated
using (((preschool_id IN ( SELECT preschools.id
   FROM public.preschools
  WHERE (preschools.principal_id = auth.uid()))) OR (preschool_id IN ( SELECT organizations.id
   FROM public.organizations
  WHERE (organizations.principal_id = auth.uid())))));



  create policy "teachers_manage_own_notes"
  on "public"."teacher_student_notes"
  as permissive
  for all
  to authenticated
using ((teacher_id = auth.uid()))
with check ((teacher_id = auth.uid()));



  create policy "teachers_service_full"
  on "public"."teachers"
  as permissive
  for all
  to service_role
using (true);



  create policy "teachers_simple_read"
  on "public"."teachers"
  as permissive
  for select
  to authenticated
using (((user_id = auth.uid()) OR (auth_user_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.users u
  WHERE (((u.id = auth.uid()) OR (u.auth_user_id = auth.uid())) AND ((u.preschool_id = teachers.preschool_id) OR (u.organization_id = teachers.preschool_id)))))));



  create policy "teachers_tenant_isolation_select"
  on "public"."teachers"
  as permissive
  for select
  to public
using ((preschool_id = public.current_preschool_id()));



  create policy "teachers_tenant_modify_disabled"
  on "public"."teachers"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT COALESCE(users.organization_id, users.preschool_id) AS "coalesce"
   FROM public.users
  WHERE ((users.id = auth.uid()) OR (users.auth_user_id = auth.uid())))));



  create policy "teachers_tenant_read_disabled"
  on "public"."teachers"
  as permissive
  for select
  to authenticated
using (((preschool_id IN ( SELECT COALESCE(users.organization_id, users.preschool_id) AS "coalesce"
   FROM public.users
  WHERE ((users.id = auth.uid()) OR (users.auth_user_id = auth.uid())))) OR (user_id = auth.uid())));



  create policy "template_approvals_admin_delete"
  on "public"."template_approvals"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "template_approvals_admin_modify"
  on "public"."template_approvals"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "template_approvals_admin_update"
  on "public"."template_approvals"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "template_approvals_public_read"
  on "public"."template_approvals"
  as permissive
  for select
  to authenticated
using (true);



  create policy "template_usage_logs_admin_delete"
  on "public"."template_usage_logs"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "template_usage_logs_admin_modify"
  on "public"."template_usage_logs"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "template_usage_logs_admin_update"
  on "public"."template_usage_logs"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "template_usage_logs_public_read"
  on "public"."template_usage_logs"
  as permissive
  for select
  to authenticated
using (true);



  create policy "template_variables_admin_delete"
  on "public"."template_variables"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "template_variables_admin_modify"
  on "public"."template_variables"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "template_variables_admin_update"
  on "public"."template_variables"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "template_variables_public_read"
  on "public"."template_variables"
  as permissive
  for select
  to authenticated
using (true);



  create policy "tenants_admin_delete"
  on "public"."tenants"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "tenants_admin_modify"
  on "public"."tenants"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "tenants_admin_update"
  on "public"."tenants"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "tenants_public_read"
  on "public"."tenants"
  as permissive
  for select
  to authenticated
using (true);



  create policy "owner_insert_own_preschool"
  on "public"."tester_feedback"
  as permissive
  for insert
  to authenticated
with check (((auth.uid() = user_id) AND (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.preschool_id = tester_feedback.preschool_id))))));



  create policy "owner_update_while_new"
  on "public"."tester_feedback"
  as permissive
  for update
  to authenticated
using (((user_id = auth.uid()) AND (status = 'new'::public.feedback_status)))
with check ((user_id = auth.uid()));



  create policy "superadmin_all_access"
  on "public"."tester_feedback"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = 'superadmin'::text)))))
with check ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = 'superadmin'::text)))));



  create policy "tenant_users_select_own_preschool"
  on "public"."tester_feedback"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.preschool_id = tester_feedback.preschool_id)))));



  create policy "Anyone can read chapters"
  on "public"."textbook_chapters"
  as permissive
  for select
  to authenticated, anon
using ((EXISTS ( SELECT 1
   FROM public.textbooks
  WHERE ((textbooks.id = textbook_chapters.textbook_id) AND (textbooks.is_active = true)))));



  create policy "Service role full access to chapters"
  on "public"."textbook_chapters"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "Allow public read on textbook_content"
  on "public"."textbook_content"
  as permissive
  for select
  to public
using (true);



  create policy "Anyone can read pages"
  on "public"."textbook_pages"
  as permissive
  for select
  to authenticated, anon
using ((EXISTS ( SELECT 1
   FROM public.textbooks
  WHERE ((textbooks.id = textbook_pages.textbook_id) AND (textbooks.is_active = true)))));



  create policy "Service role full access to pages"
  on "public"."textbook_pages"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "Allow insert for admins on textbooks"
  on "public"."textbooks"
  as permissive
  for insert
  to public
with check (((auth.role() = 'authenticated'::text) AND (( SELECT profiles.role
   FROM public.profiles
  WHERE (profiles.id = auth.uid())) = ANY (ARRAY['principal'::text, 'superadmin'::text]))));



  create policy "Allow public read on textbooks"
  on "public"."textbooks"
  as permissive
  for select
  to public
using ((is_active = true));



  create policy "Anyone can read active textbooks"
  on "public"."textbooks"
  as permissive
  for select
  to authenticated, anon
using ((is_active = true));



  create policy "Service role full access to textbooks"
  on "public"."textbooks"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "Service role full access"
  on "public"."trial_usage_log"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "Preschool can insert TTS cache"
  on "public"."tts_audio_cache"
  as permissive
  for insert
  to public
with check ((preschool_id = ((auth.jwt() ->> 'preschool_id'::text))::uuid));



  create policy "Preschool can view their TTS cache"
  on "public"."tts_audio_cache"
  as permissive
  for select
  to public
using ((preschool_id = ((auth.jwt() ->> 'preschool_id'::text))::uuid));



  create policy "Thread participants can view typing indicators"
  on "public"."typing_indicators"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.message_participants
  WHERE ((message_participants.thread_id = typing_indicators.thread_id) AND (message_participants.user_id = auth.uid())))));



  create policy "Users can delete their own typing status"
  on "public"."typing_indicators"
  as permissive
  for delete
  to authenticated
using ((auth.uid() = user_id));



  create policy "Users can insert their own typing status"
  on "public"."typing_indicators"
  as permissive
  for insert
  to authenticated
with check (((auth.uid() = user_id) AND (EXISTS ( SELECT 1
   FROM public.message_participants
  WHERE ((message_participants.thread_id = typing_indicators.thread_id) AND (message_participants.user_id = auth.uid()))))));



  create policy "Users can update their own typing status"
  on "public"."typing_indicators"
  as permissive
  for update
  to authenticated
using ((auth.uid() = user_id))
with check ((auth.uid() = user_id));



  create policy "Admins can manage user AI tiers"
  on "public"."user_ai_tiers"
  as permissive
  for all
  to public
using (public.is_admin_level());



  create policy "Users can view their own AI tier"
  on "public"."user_ai_tiers"
  as permissive
  for select
  to public
using (((user_id = auth.uid()) OR public.is_admin_level()));



  create policy "Service role full access to ai_usage"
  on "public"."user_ai_usage"
  as permissive
  for all
  to public
using (((auth.jwt() ->> 'role'::text) = 'service_role'::text));



  create policy "Users can view own AI usage"
  on "public"."user_ai_usage"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "Superadmins can manage all blocks"
  on "public"."user_blocks"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = 'superadmin'::text)))));



  create policy "Users can create blocks"
  on "public"."user_blocks"
  as permissive
  for insert
  to authenticated
with check ((blocker_id = auth.uid()));



  create policy "Users can update their blocks"
  on "public"."user_blocks"
  as permissive
  for update
  to authenticated
using ((blocker_id = auth.uid()));



  create policy "Users can view blocks against them"
  on "public"."user_blocks"
  as permissive
  for select
  to authenticated
using ((blocked_id = auth.uid()));



  create policy "Users can view blocks they created"
  on "public"."user_blocks"
  as permissive
  for select
  to authenticated
using ((blocker_id = auth.uid()));



  create policy "Users can create own bookmarks"
  on "public"."user_bookmarks"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "Users can delete own bookmarks"
  on "public"."user_bookmarks"
  as permissive
  for delete
  to public
using ((auth.uid() = user_id));



  create policy "Users can manage own bookmarks"
  on "public"."user_bookmarks"
  as permissive
  for all
  to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "Users can view own bookmarks"
  on "public"."user_bookmarks"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "user_connections_insert_own"
  on "public"."user_connections"
  as permissive
  for insert
  to public
with check ((requester_id = auth.uid()));



  create policy "user_connections_select_own"
  on "public"."user_connections"
  as permissive
  for select
  to public
using (((requester_id = auth.uid()) OR (addressee_id = auth.uid())));



  create policy "user_connections_update_own"
  on "public"."user_connections"
  as permissive
  for update
  to public
using (((requester_id = auth.uid()) OR (addressee_id = auth.uid())));



  create policy "user_contacts_delete_own"
  on "public"."user_contacts"
  as permissive
  for delete
  to public
using ((user_id = auth.uid()));



  create policy "user_contacts_insert_own"
  on "public"."user_contacts"
  as permissive
  for insert
  to public
with check ((user_id = auth.uid()));



  create policy "user_contacts_select_own"
  on "public"."user_contacts"
  as permissive
  for select
  to public
using ((user_id = auth.uid()));



  create policy "Superadmins can insert invitations"
  on "public"."user_invitations"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'superadmin'::text)))));



  create policy "Superadmins can update invitations"
  on "public"."user_invitations"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'superadmin'::text)))));



  create policy "Superadmins can view all invitations"
  on "public"."user_invitations"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'superadmin'::text)))));



  create policy "user_phone_numbers_delete_own"
  on "public"."user_phone_numbers"
  as permissive
  for delete
  to public
using ((user_id = auth.uid()));



  create policy "user_phone_numbers_insert_own"
  on "public"."user_phone_numbers"
  as permissive
  for insert
  to public
with check ((user_id = auth.uid()));



  create policy "user_phone_numbers_select_own"
  on "public"."user_phone_numbers"
  as permissive
  for select
  to public
using ((user_id = auth.uid()));



  create policy "user_phone_numbers_update_own"
  on "public"."user_phone_numbers"
  as permissive
  for update
  to public
using ((user_id = auth.uid()));



  create policy "user_preferences_own_data"
  on "public"."user_preferences"
  as permissive
  for all
  to public
using ((user_id = auth.uid()));



  create policy "Anyone can view presence"
  on "public"."user_presence"
  as permissive
  for select
  to public
using (true);



  create policy "Users can insert own presence"
  on "public"."user_presence"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "Users can update own presence"
  on "public"."user_presence"
  as permissive
  for update
  to public
using ((auth.uid() = user_id));



  create policy "Enable all for authenticated users"
  on "public"."user_profiles"
  as permissive
  for all
  to authenticated
using (true)
with check (true);



  create policy "Enable all for service role"
  on "public"."user_profiles"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "Users can view own promotional subscriptions"
  on "public"."user_promotional_subscriptions"
  as permissive
  for select
  to authenticated
using ((user_id = auth.uid()));



  create policy "user_usage_tracking_admin_org"
  on "public"."user_usage_tracking"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles admin
  WHERE ((admin.id = auth.uid()) AND (admin.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text])) AND ((admin.role = 'superadmin'::text) OR (admin.organization_id IN ( SELECT target.organization_id
           FROM public.profiles target
          WHERE (target.id = user_usage_tracking.user_id))))))));



  create policy "user_usage_tracking_user_own"
  on "public"."user_usage_tracking"
  as permissive
  for all
  to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "Service role can manage usage"
  on "public"."user_voice_usage"
  as permissive
  for all
  to public
using (((auth.jwt() ->> 'role'::text) = 'service_role'::text));



  create policy "Users can view own usage"
  on "public"."user_voice_usage"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "Users can read own profile"
  on "public"."users"
  as permissive
  for select
  to authenticated
using ((auth_user_id = auth.uid()));



  create policy "users_admin_insert_preschool"
  on "public"."users"
  as permissive
  for insert
  to authenticated
with check (((preschool_id = ( SELECT get_my_user_context.user_preschool_id
   FROM public.get_my_user_context() get_my_user_context(user_id, user_auth_user_id, user_role, user_preschool_id, is_superadmin))) AND (( SELECT get_my_user_context.user_role
   FROM public.get_my_user_context() get_my_user_context(user_id, user_auth_user_id, user_role, user_preschool_id, is_superadmin)) = ANY (ARRAY['principal_admin'::text, 'admin'::text, 'principal'::text])) AND (role <> 'superadmin'::text)));



  create policy "users_admin_select_preschool"
  on "public"."users"
  as permissive
  for select
  to authenticated
using (((preschool_id = ( SELECT get_my_user_context.user_preschool_id
   FROM public.get_my_user_context() get_my_user_context(user_id, user_auth_user_id, user_role, user_preschool_id, is_superadmin))) AND (( SELECT get_my_user_context.user_role
   FROM public.get_my_user_context() get_my_user_context(user_id, user_auth_user_id, user_role, user_preschool_id, is_superadmin)) = ANY (ARRAY['principal_admin'::text, 'admin'::text, 'principal'::text]))));



  create policy "users_admin_update_preschool"
  on "public"."users"
  as permissive
  for update
  to authenticated
using (((preschool_id = ( SELECT get_my_user_context.user_preschool_id
   FROM public.get_my_user_context() get_my_user_context(user_id, user_auth_user_id, user_role, user_preschool_id, is_superadmin))) AND (( SELECT get_my_user_context.user_role
   FROM public.get_my_user_context() get_my_user_context(user_id, user_auth_user_id, user_role, user_preschool_id, is_superadmin)) = ANY (ARRAY['principal_admin'::text, 'admin'::text, 'principal'::text])) AND (role <> 'superadmin'::text)))
with check (((preschool_id = ( SELECT get_my_user_context.user_preschool_id
   FROM public.get_my_user_context() get_my_user_context(user_id, user_auth_user_id, user_role, user_preschool_id, is_superadmin))) AND (( SELECT get_my_user_context.user_role
   FROM public.get_my_user_context() get_my_user_context(user_id, user_auth_user_id, user_role, user_preschool_id, is_superadmin)) = ANY (ARRAY['principal_admin'::text, 'admin'::text, 'principal'::text])) AND (role <> 'superadmin'::text)));



  create policy "users_insert_self"
  on "public"."users"
  as permissive
  for insert
  to authenticated
with check ((auth_user_id = auth.uid()));



  create policy "users_select_own"
  on "public"."users"
  as permissive
  for select
  to authenticated
using ((auth_user_id = auth.uid()));



  create policy "users_service_role"
  on "public"."users"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "users_service_role_all"
  on "public"."users"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "users_superadmin_delete"
  on "public"."users"
  as permissive
  for delete
  to authenticated
using ((( SELECT get_my_user_context.is_superadmin
   FROM public.get_my_user_context() get_my_user_context(user_id, user_auth_user_id, user_role, user_preschool_id, is_superadmin)) = true));



  create policy "users_superadmin_insert"
  on "public"."users"
  as permissive
  for insert
  to authenticated
with check ((( SELECT get_my_user_context.is_superadmin
   FROM public.get_my_user_context() get_my_user_context(user_id, user_auth_user_id, user_role, user_preschool_id, is_superadmin)) = true));



  create policy "users_superadmin_select"
  on "public"."users"
  as permissive
  for select
  to authenticated
using ((( SELECT get_my_user_context.is_superadmin
   FROM public.get_my_user_context() get_my_user_context(user_id, user_auth_user_id, user_role, user_preschool_id, is_superadmin)) = true));



  create policy "users_superadmin_update"
  on "public"."users"
  as permissive
  for update
  to authenticated
using ((( SELECT get_my_user_context.is_superadmin
   FROM public.get_my_user_context() get_my_user_context(user_id, user_auth_user_id, user_role, user_preschool_id, is_superadmin)) = true))
with check ((( SELECT get_my_user_context.is_superadmin
   FROM public.get_my_user_context() get_my_user_context(user_id, user_auth_user_id, user_role, user_preschool_id, is_superadmin)) = true));



  create policy "users_teacher_view_staff"
  on "public"."users"
  as permissive
  for select
  to authenticated
using (((preschool_id = ( SELECT get_my_user_context.user_preschool_id
   FROM public.get_my_user_context() get_my_user_context(user_id, user_auth_user_id, user_role, user_preschool_id, is_superadmin))) AND (( SELECT get_my_user_context.user_role
   FROM public.get_my_user_context() get_my_user_context(user_id, user_auth_user_id, user_role, user_preschool_id, is_superadmin)) = 'teacher'::text) AND (role = ANY (ARRAY['teacher'::text, 'principal_admin'::text, 'admin'::text, 'principal'::text]))));



  create policy "users_tenant_isolation_select"
  on "public"."users"
  as permissive
  for select
  to public
using ((preschool_id = public.current_preschool_id()));



  create policy "users_update_own"
  on "public"."users"
  as permissive
  for update
  to authenticated
using ((auth_user_id = auth.uid()))
with check (((auth_user_id = auth.uid()) AND (role = ( SELECT get_my_user_context.user_role
   FROM public.get_my_user_context() get_my_user_context(user_id, user_auth_user_id, user_role, user_preschool_id, is_superadmin)))));



  create policy "video_call_participants_admin_org"
  on "public"."video_call_participants"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles admin
  WHERE ((admin.id = auth.uid()) AND (admin.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text])) AND ((admin.role = 'superadmin'::text) OR (admin.organization_id IN ( SELECT target.organization_id
           FROM public.profiles target
          WHERE (target.id = video_call_participants.user_id))))))));



  create policy "video_call_participants_user_own"
  on "public"."video_call_participants"
  as permissive
  for all
  to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "video_calls_insert"
  on "public"."video_calls"
  as permissive
  for insert
  to public
with check (((teacher_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['principal'::text, 'superadmin'::text])))))));



  create policy "video_calls_select"
  on "public"."video_calls"
  as permissive
  for select
  to public
using (((preschool_id IN ( SELECT profiles.preschool_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))) OR (teacher_id = auth.uid())));



  create policy "video_calls_teacher_all"
  on "public"."video_calls"
  as permissive
  for all
  to public
using (((auth.uid() = teacher_id) OR (EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['principal'::text, 'superadmin'::text])))))));



  create policy "video_calls_tenant_modify"
  on "public"."video_calls"
  as permissive
  for all
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))))
with check ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text]))))));



  create policy "video_calls_tenant_select"
  on "public"."video_calls"
  as permissive
  for select
  to authenticated
using ((preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE (profiles.id = auth.uid()))));



  create policy "video_calls_update"
  on "public"."video_calls"
  as permissive
  for update
  to public
using (((teacher_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['principal'::text, 'superadmin'::text])))))));



  create policy "voice_notes_delete_own"
  on "public"."voice_notes"
  as permissive
  for delete
  to authenticated
using ((auth.uid() = created_by));



  create policy "voice_notes_insert_own"
  on "public"."voice_notes"
  as permissive
  for insert
  to authenticated
with check ((auth.uid() = created_by));



  create policy "voice_notes_select_own"
  on "public"."voice_notes"
  as permissive
  for select
  to authenticated
using ((auth.uid() = created_by));



  create policy "voice_notes_update_own"
  on "public"."voice_notes"
  as permissive
  for update
  to authenticated
using ((auth.uid() = created_by))
with check ((auth.uid() = created_by));



  create policy "Users can insert their own voice preferences"
  on "public"."voice_preferences"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "Users can update their own voice preferences"
  on "public"."voice_preferences"
  as permissive
  for update
  to public
using ((auth.uid() = user_id));



  create policy "Users can view their own voice preferences"
  on "public"."voice_preferences"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "Service role can insert voice usage"
  on "public"."voice_usage_logs"
  as permissive
  for insert
  to public
with check (true);



  create policy "Users can insert their own usage logs"
  on "public"."voice_usage_logs"
  as permissive
  for insert
  to public
with check (true);



  create policy "Users can view own voice usage"
  on "public"."voice_usage_logs"
  as permissive
  for select
  to public
using ((user_id = auth.uid()));



  create policy "Anyone can view quotas"
  on "public"."voice_usage_quotas"
  as permissive
  for select
  to public
using (true);



  create policy "webhook_logs_admin_delete"
  on "public"."webhook_logs"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "webhook_logs_admin_modify"
  on "public"."webhook_logs"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "webhook_logs_admin_update"
  on "public"."webhook_logs"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'principal'::text, 'superadmin'::text]))))));



  create policy "webhook_logs_public_read"
  on "public"."webhook_logs"
  as permissive
  for select
  to authenticated
using (true);



  create policy "whatsapp_contacts_access"
  on "public"."whatsapp_contacts"
  as permissive
  for all
  to authenticated
using (((user_id = auth.uid()) OR (preschool_id IN ( SELECT profiles.organization_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.organization_id IS NOT NULL))))));



  create policy "principals_manage_academic_terms"
  on "public"."academic_terms"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'principal_admin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = academic_terms.preschool_id)))));



  create policy "teachers_view_academic_terms"
  on "public"."academic_terms"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['teacher'::text, 'principal'::text, 'principal_admin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = academic_terms.preschool_id)))));



  create policy "activity_comments_parent_select"
  on "public"."activity_comments"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.student_activity_feed saf
  WHERE ((saf.id = activity_comments.activity_id) AND (saf.student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids))))));



  create policy "activity_progress_parent_child"
  on "public"."activity_progress"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "parents_view_child_activity_progress"
  on "public"."activity_progress"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "activity_reactions_parent_select"
  on "public"."activity_reactions"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.student_activity_feed saf
  WHERE ((saf.id = activity_reactions.activity_id) AND (saf.student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids))))));



  create policy "school_manage_own_templates"
  on "public"."activity_templates"
  as permissive
  for all
  to public
using (((preschool_id IS NOT NULL) AND (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['teacher'::text, 'principal'::text, 'principal_admin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = activity_templates.preschool_id))))));



  create policy "authenticated_select_aftercare"
  on "public"."aftercare_registrations"
  as permissive
  for select
  to authenticated
using (((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'super_admin'::text])) AND (p.preschool_id = COALESCE(p.organization_id, p.preschool_id))))) OR ((parent_user_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.email = aftercare_registrations.parent_email)))))));



  create policy "authenticated_update_aftercare"
  on "public"."aftercare_registrations"
  as permissive
  for update
  to authenticated
using (((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'super_admin'::text])) AND (p.preschool_id IN ( SELECT COALESCE(profiles.organization_id, profiles.preschool_id) AS "coalesce"
           FROM public.profiles
          WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'super_admin'::text])))))))) OR (((parent_user_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.email = aftercare_registrations.parent_email))))) AND (status = ANY (ARRAY['pending_payment'::text, 'paid'::text])))))
with check (((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'super_admin'::text])) AND (p.preschool_id IN ( SELECT COALESCE(profiles.organization_id, profiles.preschool_id) AS "coalesce"
           FROM public.profiles
          WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'super_admin'::text])))))))) OR (((parent_user_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.email = aftercare_registrations.parent_email))))) AND (status = ANY (ARRAY['pending_payment'::text, 'paid'::text])))));



  create policy "birthday_donation_days_select"
  on "public"."birthday_donation_days"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.auth_user_id = auth.uid()) AND (COALESCE(p.organization_id, p.preschool_id) = birthday_donation_days.organization_id) AND (p.role = ANY (ARRAY['teacher'::text, 'principal'::text, 'principal_admin'::text, 'admin'::text, 'superadmin'::text, 'super_admin'::text, 'staff'::text]))))));



  create policy "birthday_donations_select"
  on "public"."birthday_donations"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.auth_user_id = auth.uid()) AND (COALESCE(p.organization_id, p.preschool_id) = birthday_donations.organization_id) AND (p.role = ANY (ARRAY['teacher'::text, 'principal'::text, 'principal_admin'::text, 'admin'::text, 'superadmin'::text, 'super_admin'::text, 'staff'::text]))))));



  create policy "Principals can view public teacher profiles"
  on "public"."candidate_profiles"
  as permissive
  for select
  to public
using (((is_public = true) AND (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'super_admin'::text, 'superadmin'::text])))))));



  create policy "child_registration_requests_parent_update"
  on "public"."child_registration_requests"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.auth_user_id = auth.uid()) AND (child_registration_requests.parent_id = p.id)))));



  create policy "child_registration_requests_parent_view"
  on "public"."child_registration_requests"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.auth_user_id = auth.uid()) AND (child_registration_requests.parent_id = p.id)))));



  create policy "classes_admin_all"
  on "public"."classes"
  as permissive
  for all
  to authenticated
using (public.user_can_manage_classes(preschool_id))
with check (public.user_can_manage_classes(preschool_id));



  create policy "classes_org_members_select"
  on "public"."classes"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.auth_user_id = auth.uid()) AND (COALESCE(p.organization_id, p.preschool_id) = classes.preschool_id)))));



  create policy "classes_teacher_select"
  on "public"."classes"
  as permissive
  for select
  to authenticated
using (public.user_can_view_classes(preschool_id, teacher_id));



  create policy "parents_view_child_classes"
  on "public"."classes"
  as permissive
  for select
  to authenticated
using (((EXISTS ( SELECT 1
   FROM (public.students s
     JOIN public.profiles p ON (((s.parent_id = p.id) OR (s.guardian_id = p.id))))
  WHERE ((p.auth_user_id = auth.uid()) AND (s.class_id = classes.id)))) OR public.user_can_view_classes(preschool_id, teacher_id)));



  create policy "principals_manage_curriculum_themes"
  on "public"."curriculum_themes"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'principal_admin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = curriculum_themes.preschool_id)))));



  create policy "teachers_view_curriculum_themes"
  on "public"."curriculum_themes"
  as permissive
  for select
  to public
using (((is_published = true) OR (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['teacher'::text, 'principal'::text, 'principal_admin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = curriculum_themes.preschool_id))))));



  create policy "tutor_attempts_insert"
  on "public"."dash_ai_tutor_attempts"
  as permissive
  for insert
  to public
with check (((auth.uid() = user_id) OR ((student_id IS NOT NULL) AND (EXISTS ( SELECT 1
   FROM public.students s
  WHERE ((s.id = dash_ai_tutor_attempts.student_id) AND (s.parent_id = auth.uid())))))));



  create policy "tutor_attempts_select"
  on "public"."dash_ai_tutor_attempts"
  as permissive
  for select
  to public
using (((auth.uid() = user_id) OR ((student_id IS NOT NULL) AND (EXISTS ( SELECT 1
   FROM public.students s
  WHERE ((s.id = dash_ai_tutor_attempts.student_id) AND (s.parent_id = auth.uid())))))));



  create policy "learner_documents_admin_all"
  on "public"."learner_documents"
  as permissive
  for all
  to authenticated
using (((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['super_admin'::text, 'admin'::text, 'principal'::text]))))) OR (EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND ((om.membership_status)::text = 'active'::text) AND ((om.member_type)::text = ANY ((ARRAY['youth_president'::character varying, 'youth_secretary'::character varying, 'president'::character varying, 'secretary_general'::character varying, 'ceo'::character varying, 'national_admin'::character varying])::text[])))))));



  create policy "learner_documents_select_own"
  on "public"."learner_documents"
  as permissive
  for select
  to authenticated
using ((learner_id = auth.uid()));



  create policy "parents_view_child_assignments"
  on "public"."lesson_assignments"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "teachers_manage_lesson_assignments"
  on "public"."lesson_assignments"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['teacher'::text, 'principal'::text, 'principal_admin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = lesson_assignments.preschool_id)))));



  create policy "parents_view_child_completions"
  on "public"."lesson_completions"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "teachers_manage_lesson_completions"
  on "public"."lesson_completions"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['teacher'::text, 'principal'::text, 'principal_admin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = lesson_completions.preschool_id)))));



  create policy "principals_manage_lesson_templates"
  on "public"."lesson_templates"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'principal_admin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = lesson_templates.preschool_id)))));



  create policy "teachers_use_lesson_templates"
  on "public"."lesson_templates"
  as permissive
  for select
  to public
using (((is_active = true) AND (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['teacher'::text, 'principal'::text, 'principal_admin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = lesson_templates.preschool_id))))));



  create policy "admins_manage_folders"
  on "public"."organization_document_folders"
  as permissive
  for all
  to public
using (public.user_can_manage_org_members(organization_id))
with check (public.user_can_manage_org_members(organization_id));



  create policy "members_view_folders"
  on "public"."organization_document_folders"
  as permissive
  for select
  to public
using (public.user_can_view_org_members(organization_id));



  create policy "admins_manage_documents"
  on "public"."organization_documents"
  as permissive
  for all
  to public
using (public.user_can_manage_org_members(organization_id))
with check (public.user_can_manage_org_members(organization_id));



  create policy "members_view_documents"
  on "public"."organization_documents"
  as permissive
  for select
  to public
using (public.user_can_view_org_document(id, access_level));



  create policy "Admins can manage organization members"
  on "public"."organization_members"
  as permissive
  for all
  to public
using (public.user_can_manage_org_members(organization_id))
with check (public.user_can_manage_org_members(organization_id));



  create policy "Members can view organization members"
  on "public"."organization_members"
  as permissive
  for select
  to public
using (public.user_can_view_org_members(organization_id));



  create policy "preschools_user_read_via_preschool_id"
  on "public"."preschools"
  as permissive
  for select
  to authenticated
using ((id IN ( SELECT p.preschool_id
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.preschool_id IS NOT NULL)))));



  create policy "profiles_preschool_access"
  on "public"."profiles"
  as permissive
  for select
  to public
using (((auth_user_id = auth.uid()) OR (preschool_id = public.get_current_user_preschool_id())));



  create policy "profiles_read_for_documents"
  on "public"."profiles"
  as permissive
  for select
  to public
using (public.user_can_read_profile(id));



  create policy "principals_manage_excursions"
  on "public"."school_excursions"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'super_admin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = school_excursions.preschool_id)))));



  create policy "teachers_view_excursions"
  on "public"."school_excursions"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['teacher'::text, 'principal'::text, 'principal_admin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = school_excursions.preschool_id)))));



  create policy "principals_manage_meetings"
  on "public"."school_meetings"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'super_admin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = school_meetings.preschool_id)))));



  create policy "staff_view_meetings"
  on "public"."school_meetings"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['teacher'::text, 'principal'::text, 'principal_admin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = school_meetings.preschool_id)))));



  create policy "activity_feed_select"
  on "public"."student_activity_feed"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "student_fees_parent_child"
  on "public"."student_fees"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "student_fees_staff_org"
  on "public"."student_fees"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM (public.profiles staff
     JOIN public.students student ON ((student.id = student_fees.student_id)))
  WHERE (((staff.auth_user_id = auth.uid()) OR (staff.id = auth.uid())) AND (staff.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text, 'principal_admin'::text, 'superadmin'::text, 'super_admin'::text])) AND ((staff.role = ANY (ARRAY['superadmin'::text, 'super_admin'::text])) OR (COALESCE(staff.organization_id, staff.preschool_id) = COALESCE(student.organization_id, student.preschool_id)))))))
with check ((EXISTS ( SELECT 1
   FROM (public.profiles staff
     JOIN public.students student ON ((student.id = student_fees.student_id)))
  WHERE (((staff.auth_user_id = auth.uid()) OR (staff.id = auth.uid())) AND (staff.role = ANY (ARRAY['teacher'::text, 'admin'::text, 'principal'::text, 'principal_admin'::text, 'superadmin'::text, 'super_admin'::text])) AND ((staff.role = ANY (ARRAY['superadmin'::text, 'super_admin'::text])) OR (COALESCE(staff.organization_id, staff.preschool_id) = COALESCE(student.organization_id, student.preschool_id)))))));



  create policy "parents_view_child_progress_summary"
  on "public"."student_progress_summary"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "teachers_manage_progress_summary"
  on "public"."student_progress_summary"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['teacher'::text, 'principal'::text, 'principal_admin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = student_progress_summary.preschool_id)))));



  create policy "students_parent_own_children"
  on "public"."students"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.auth_user_id = auth.uid()) AND ((students.parent_id = p.id) OR (students.guardian_id = p.id) OR (EXISTS ( SELECT 1
           FROM public.student_parent_relationships spr
          WHERE ((spr.student_id = students.id) AND (spr.parent_id = p.id)))))))));



  create policy "students_parent_update_own_children"
  on "public"."students"
  as permissive
  for update
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.auth_user_id = auth.uid()) AND ((students.parent_id = p.id) OR (students.guardian_id = p.id) OR (EXISTS ( SELECT 1
           FROM public.student_parent_relationships spr
          WHERE ((spr.student_id = students.id) AND (spr.parent_id = p.id)))))))))
with check ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.auth_user_id = auth.uid()) AND ((students.parent_id = p.id) OR (students.guardian_id = p.id) OR (EXISTS ( SELECT 1
           FROM public.student_parent_relationships spr
          WHERE ((spr.student_id = students.id) AND (spr.parent_id = p.id)))))))));



  create policy "students_school_admin_modify"
  on "public"."students"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.auth_user_id = auth.uid()) AND (COALESCE(p.organization_id, p.preschool_id) = students.preschool_id) AND (p.role = ANY (ARRAY['principal'::text, 'admin'::text, 'super_admin'::text, 'superadmin'::text, 'preschool_admin'::text]))))));



  create policy "students_school_staff_select"
  on "public"."students"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.auth_user_id = auth.uid()) AND (COALESCE(p.organization_id, p.preschool_id) = students.preschool_id)))));



  create policy "principals_manage_teacher_approvals"
  on "public"."teacher_approvals"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'principal_admin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = teacher_approvals.preschool_id)))));



  create policy "Principals manage employment history"
  on "public"."teacher_employment_history"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'super_admin'::text, 'superadmin'::text])) AND ((p.organization_id = p.organization_id) OR (p.preschool_id = p.organization_id))))))
with check ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'super_admin'::text, 'superadmin'::text])) AND ((p.organization_id = p.organization_id) OR (p.preschool_id = p.organization_id))))));



  create policy "Principals manage reference requests"
  on "public"."teacher_reference_requests"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'super_admin'::text, 'superadmin'::text])) AND ((p.organization_id = teacher_reference_requests.requester_org_id) OR (p.preschool_id = teacher_reference_requests.requester_org_id))))))
with check ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'super_admin'::text, 'superadmin'::text])) AND ((p.organization_id = teacher_reference_requests.requester_org_id) OR (p.preschool_id = teacher_reference_requests.requester_org_id))))));



  create policy "Principals can create references for former teachers"
  on "public"."teacher_references"
  as permissive
  for insert
  to public
with check (((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'super_admin'::text, 'superadmin'::text])) AND ((p.organization_id = p.organization_id) OR (p.preschool_id = p.organization_id))))) AND (EXISTS ( SELECT 1
   FROM (public.teacher_employment_history h
     JOIN public.candidate_profiles cp ON ((cp.user_id = h.teacher_user_id)))
  WHERE ((cp.id = teacher_references.candidate_profile_id) AND (h.organization_id = h.organization_id))))));



  create policy "Principals can view teacher references"
  on "public"."teacher_references"
  as permissive
  for select
  to public
using (((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'super_admin'::text, 'superadmin'::text]))))) OR (teacher_user_id = auth.uid()) OR (candidate_profile_id IN ( SELECT cp.id
   FROM public.candidate_profiles cp
  WHERE (cp.user_id = auth.uid())))));



  create policy "uniform_requests_parent_insert"
  on "public"."uniform_requests"
  as permissive
  for insert
  to authenticated
with check ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "uniform_requests_parent_select"
  on "public"."uniform_requests"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "uniform_requests_parent_update"
  on "public"."uniform_requests"
  as permissive
  for update
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)))
with check ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "uniform_requests_staff_select"
  on "public"."uniform_requests"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.auth_user_id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'admin'::text, 'superadmin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = uniform_requests.preschool_id)))));



  create policy "video_call_participants_insert"
  on "public"."video_call_participants"
  as permissive
  for insert
  to public
with check (((user_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.video_calls vc
  WHERE ((vc.id = video_call_participants.call_id) AND (vc.teacher_id = auth.uid()))))));



  create policy "video_call_participants_select"
  on "public"."video_call_participants"
  as permissive
  for select
  to public
using (((user_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.video_calls vc
  WHERE ((vc.id = video_call_participants.call_id) AND (vc.teacher_id = auth.uid()))))));



  create policy "video_calls_delete_policy"
  on "public"."video_calls"
  as permissive
  for delete
  to public
using (((teacher_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'super_admin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = video_calls.preschool_id))))));



  create policy "video_calls_insert_policy"
  on "public"."video_calls"
  as permissive
  for insert
  to public
with check ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['teacher'::text, 'principal'::text, 'principal_admin'::text, 'super_admin'::text])) AND ((video_calls.preschool_id IS NULL) OR (COALESCE(p.organization_id, p.preschool_id) = video_calls.preschool_id))))));



  create policy "video_calls_parent_select"
  on "public"."video_calls"
  as permissive
  for select
  to authenticated
using (((class_id IN ( SELECT public.get_my_children_class_ids() AS get_my_children_class_ids)) OR (preschool_id IN ( SELECT public.get_my_children_preschool_ids() AS get_my_children_preschool_ids))));



  create policy "video_calls_select_policy"
  on "public"."video_calls"
  as permissive
  for select
  to authenticated
using (((teacher_id IN ( SELECT profiles.id
   FROM public.profiles
  WHERE (profiles.auth_user_id = auth.uid()))) OR (class_id IN ( SELECT public.get_my_children_class_ids() AS get_my_children_class_ids)) OR (preschool_id IN ( SELECT public.get_my_children_preschool_ids() AS get_my_children_preschool_ids)) OR (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.auth_user_id = auth.uid()) AND (COALESCE(p.organization_id, p.preschool_id) = video_calls.preschool_id))))));



  create policy "video_calls_update_policy"
  on "public"."video_calls"
  as permissive
  for update
  to public
using (((teacher_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'principal_admin'::text, 'super_admin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = video_calls.preschool_id))))));



  create policy "weekly_reports_parent_select"
  on "public"."weekly_learning_reports"
  as permissive
  for select
  to authenticated
using ((student_id IN ( SELECT public.get_my_children_ids() AS get_my_children_ids)));



  create policy "weekly_reports_school_select"
  on "public"."weekly_learning_reports"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.preschool_id = weekly_learning_reports.preschool_id) AND (p.role = ANY (ARRAY['teacher'::text, 'principal'::text, 'principal_admin'::text]))))));



  create policy "principals_approve_weekly_plans"
  on "public"."weekly_plans"
  as permissive
  for update
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['principal'::text, 'principal_admin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = weekly_plans.preschool_id)))));



  create policy "teachers_manage_weekly_plans"
  on "public"."weekly_plans"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE ((p.id = auth.uid()) AND (p.role = ANY (ARRAY['teacher'::text, 'principal'::text, 'principal_admin'::text])) AND (COALESCE(p.organization_id, p.preschool_id) = weekly_plans.preschool_id)))));


CREATE TRIGGER trigger_queue_call_push AFTER INSERT ON public.active_calls FOR EACH ROW EXECUTE FUNCTION public.queue_call_push_notification();

CREATE TRIGGER trigger_aftercare_registrations_updated_at BEFORE UPDATE ON public.aftercare_registrations FOR EACH ROW EXECUTE FUNCTION public.update_aftercare_registrations_updated_at();

CREATE TRIGGER trg_ai_attachments_updated BEFORE UPDATE ON public.ai_attachments FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

CREATE TRIGGER trigger_ai_autonomy_settings_updated_at BEFORE UPDATE ON public.ai_autonomy_settings FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trg_ai_conversations_updated BEFORE UPDATE ON public.ai_conversations FOR EACH ROW EXECUTE FUNCTION public._touch_updated_at();

CREATE TRIGGER trigger_update_memory_recency BEFORE UPDATE ON public.ai_memories FOR EACH ROW WHEN ((old.accessed_count IS DISTINCT FROM new.accessed_count)) EXECUTE FUNCTION public.update_memory_recency_score();

CREATE TRIGGER ai_messages_updated_at BEFORE UPDATE ON public.ai_messages FOR EACH ROW EXECUTE FUNCTION public.update_ai_messages_updated_at();

CREATE TRIGGER ai_model_tiers_updated_at BEFORE UPDATE ON public.ai_model_tiers FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trg_increment_announcement_views AFTER INSERT ON public.announcement_views FOR EACH ROW EXECUTE FUNCTION public.increment_announcement_views();

CREATE TRIGGER announcements_updated_at_trigger BEFORE UPDATE ON public.announcements FOR EACH ROW EXECUTE FUNCTION public.update_announcements_updated_at();

CREATE TRIGGER update_assignment_submissions_updated_at BEFORE UPDATE ON public.assignment_submissions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER assignments_updated_at BEFORE UPDATE ON public.assignments FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER audit_assignments AFTER INSERT OR DELETE OR UPDATE ON public.assignments FOR EACH ROW EXECUTE FUNCTION public.log_educational_operations();

CREATE TRIGGER notify_assignment_changes AFTER INSERT OR UPDATE ON public.assignments FOR EACH ROW EXECUTE FUNCTION public.notify_assignment_changes();

CREATE TRIGGER validate_assignment_course_active BEFORE INSERT OR UPDATE ON public.assignments FOR EACH ROW EXECUTE FUNCTION public.validate_assignment_course_active();

CREATE TRIGGER update_caps_textbook_mapping_updated_at BEFORE UPDATE ON public.caps_textbook_mapping FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_caps_topics_updated_at BEFORE UPDATE ON public.caps_topics FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER chat_images_updated_at BEFORE UPDATE ON public.chat_images FOR EACH ROW EXECUTE FUNCTION public.update_chat_images_updated_at();

CREATE TRIGGER contact_discovery_settings_updated_at BEFORE UPDATE ON public.contact_discovery_settings FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

CREATE TRIGGER audit_courses AFTER INSERT OR DELETE OR UPDATE ON public.courses FOR EACH ROW EXECUTE FUNCTION public.log_educational_operations();

CREATE TRIGGER courses_updated_at BEFORE UPDATE ON public.courses FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_cv_templates_updated_at BEFORE UPDATE ON public.cv_templates FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_cv_uploads_updated_at BEFORE UPDATE ON public.cv_uploads FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER dash_storage_updated_at BEFORE UPDATE ON public.dash_storage FOR EACH ROW EXECUTE FUNCTION public.update_dash_storage_updated_at();

CREATE TRIGGER trg_dash_user_contexts_updated BEFORE UPDATE ON public.dash_user_contexts FOR EACH ROW EXECUTE FUNCTION public._touch_updated_at();

CREATE TRIGGER trigger_update_dashboard_voice_notes_updated_at BEFORE UPDATE ON public.dashboard_voice_notes FOR EACH ROW EXECUTE FUNCTION public.update_dashboard_voice_notes_updated_at();

CREATE TRIGGER trigger_update_deletion_requests_updated_at BEFORE UPDATE ON public.deletion_requests FOR EACH ROW EXECUTE FUNCTION public.update_deletion_requests_updated_at();

CREATE TRIGGER audit_enrollments AFTER INSERT OR DELETE OR UPDATE ON public.enrollments FOR EACH ROW EXECUTE FUNCTION public.log_educational_operations();

CREATE TRIGGER check_enrollment_capacity BEFORE INSERT OR UPDATE ON public.enrollments FOR EACH ROW EXECUTE FUNCTION public.check_enrollment_capacity();

CREATE TRIGGER enrollments_updated_at BEFORE UPDATE ON public.enrollments FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER notify_enrollment_change AFTER INSERT OR UPDATE ON public.enrollments FOR EACH ROW EXECUTE FUNCTION public.notify_enrollment_change();

CREATE TRIGGER validate_enrollment_course_active BEFORE INSERT OR UPDATE ON public.enrollments FOR EACH ROW EXECUTE FUNCTION public.validate_enrollment_course_active();

CREATE TRIGGER update_exam_assignments_updated_at BEFORE UPDATE ON public.exam_assignments FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER exam_papers_search_vector_update BEFORE INSERT OR UPDATE ON public.exam_papers FOR EACH ROW EXECUTE FUNCTION public.update_exam_papers_search_vector();

CREATE TRIGGER update_exam_submissions_updated_at BEFORE UPDATE ON public.exam_submissions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_assignment_on_payment AFTER INSERT OR UPDATE ON public.fee_payments FOR EACH ROW EXECUTE FUNCTION public.update_fee_assignment_on_payment();

CREATE TRIGGER update_fee_payments_updated_at BEFORE UPDATE ON public.fee_payments FOR EACH ROW EXECUTE FUNCTION public.update_fee_updated_at();

CREATE TRIGGER gradebook_entries_updated_at BEFORE UPDATE ON public.gradebook_entries FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER audit_grades AFTER INSERT OR DELETE OR UPDATE ON public.grades FOR EACH ROW EXECUTE FUNCTION public.log_educational_operations();

CREATE TRIGGER auto_apply_late_penalty BEFORE INSERT OR UPDATE ON public.grades FOR EACH ROW EXECUTE FUNCTION public.auto_apply_late_penalty();

CREATE TRIGGER auto_calculate_letter_grade BEFORE INSERT OR UPDATE ON public.grades FOR EACH ROW EXECUTE FUNCTION public.auto_calculate_letter_grade();

CREATE TRIGGER auto_update_grade_percentage BEFORE INSERT OR UPDATE ON public.grades FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER grades_updated_at BEFORE UPDATE ON public.grades FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER notify_grade_published AFTER UPDATE ON public.grades FOR EACH ROW EXECUTE FUNCTION public.notify_grade_published();

CREATE TRIGGER update_gradebook_on_grade_change AFTER INSERT OR DELETE OR UPDATE ON public.grades FOR EACH ROW EXECUTE FUNCTION public.trigger_gradebook_update();

CREATE TRIGGER groups_updated_at BEFORE UPDATE ON public.groups FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER auto_link_student_on_approval AFTER UPDATE OF status ON public.guardian_requests FOR EACH ROW WHEN ((new.status = 'approved'::text)) EXECUTE FUNCTION public.link_student_on_guardian_approval();

CREATE TRIGGER update_homework_assignment_targets_updated_at BEFORE UPDATE ON public.homework_assignment_targets FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_homework_notifications_updated_at BEFORE UPDATE ON public.homework_notifications FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_interactive_activities_updated_at BEFORE UPDATE ON public.interactive_activities FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER set_invite_logs_updated_at BEFORE UPDATE ON public.invite_logs FOR EACH ROW EXECUTE FUNCTION public.update_invite_logs_updated_at();

CREATE TRIGGER set_updated_at_job_alerts BEFORE UPDATE ON public.job_alerts FOR EACH ROW EXECUTE FUNCTION public.update_job_postings_updated_at();

CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.job_postings FOR EACH ROW EXECUTE FUNCTION public.update_job_postings_updated_at();

CREATE TRIGGER tr_auto_fill_requester_id BEFORE INSERT ON public.join_requests FOR EACH ROW EXECUTE FUNCTION public.auto_fill_requester_id();

CREATE TRIGGER tr_handle_join_request_approval BEFORE UPDATE ON public.join_requests FOR EACH ROW EXECUTE FUNCTION public.handle_join_request_approval();

CREATE TRIGGER tr_join_requests_updated_at BEFORE UPDATE ON public.join_requests FOR EACH ROW EXECUTE FUNCTION public.update_join_requests_updated_at();

CREATE TRIGGER tr_set_invite_tokens BEFORE INSERT ON public.join_requests FOR EACH ROW EXECUTE FUNCTION public.set_invite_tokens();

CREATE TRIGGER update_learner_connections_updated_at BEFORE UPDATE ON public.learner_connections FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_learner_cvs_updated_at BEFORE UPDATE ON public.learner_cvs FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_lesson_approvals_updated_at BEFORE UPDATE ON public.lesson_approvals FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_update_stem_progress_on_completion AFTER INSERT ON public.lesson_completions FOR EACH ROW WHEN ((new.status = 'completed'::text)) EXECUTE FUNCTION public.update_stem_progress_on_completion();

CREATE TRIGGER trigger_update_lesson_progress_updated_at BEFORE UPDATE ON public.lesson_progress FOR EACH ROW EXECUTE FUNCTION public.update_lesson_progress_updated_at();

CREATE TRIGGER lessons_updated_at_trigger BEFORE UPDATE ON public.lessons FOR EACH ROW EXECUTE FUNCTION public.update_lessons_updated_at();

CREATE TRIGGER trigger_sync_campaign_to_edusite AFTER INSERT OR DELETE OR UPDATE ON public.marketing_campaigns FOR EACH ROW EXECUTE FUNCTION public.sync_campaign_to_edusite();

CREATE TRIGGER update_member_events_updated_at BEFORE UPDATE ON public.member_events FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_member_id_cards_updated_at BEFORE UPDATE ON public.member_id_cards FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_member_invoices_updated_at BEFORE UPDATE ON public.member_invoices FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_notify_message_recipients AFTER INSERT ON public.messages FOR EACH ROW EXECUTE FUNCTION public.notify_message_recipients();

CREATE TRIGGER trigger_queue_message_push AFTER INSERT ON public.messages FOR EACH ROW EXECUTE FUNCTION public.queue_message_push_notification();

CREATE TRIGGER trigger_update_thread_last_message_at AFTER INSERT ON public.messages FOR EACH ROW EXECUTE FUNCTION public.update_thread_last_message_at();

CREATE TRIGGER trigger_org_announcement_updated_at BEFORE UPDATE ON public.organization_announcements FOR EACH ROW EXECUTE FUNCTION public.update_org_announcement_updated_at();

CREATE TRIGGER trigger_board_positions_updated_at BEFORE UPDATE ON public.organization_board_positions FOR EACH ROW EXECUTE FUNCTION public.update_board_positions_updated_at();

CREATE TRIGGER trigger_folder_updated_at BEFORE UPDATE ON public.organization_document_folders FOR EACH ROW EXECUTE FUNCTION public.update_document_updated_at();

CREATE TRIGGER trigger_document_updated_at BEFORE UPDATE ON public.organization_documents FOR EACH ROW EXECUTE FUNCTION public.update_document_updated_at();

CREATE TRIGGER update_organization_regions_updated_at BEFORE UPDATE ON public.organization_regions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_organization_roles_updated_at BEFORE UPDATE ON public.organization_roles FOR EACH ROW EXECUTE FUNCTION public.update_organizations_updated_at();

CREATE TRIGGER trg_update_budget_spent AFTER UPDATE ON public.organization_transactions FOR EACH ROW WHEN ((old.status IS DISTINCT FROM new.status)) EXECUTE FUNCTION public.update_budget_spent();

CREATE TRIGGER trigger_notify_superadmins_on_org_creation AFTER INSERT ON public.organizations FOR EACH ROW EXECUTE FUNCTION public.notify_superadmins_on_org_creation();

CREATE TRIGGER trigger_organizations_updated_at BEFORE UPDATE ON public.organizations FOR EACH ROW EXECUTE FUNCTION public.update_organizations_updated_at();

CREATE TRIGGER on_parent_join_request_approved BEFORE UPDATE ON public.parent_join_requests FOR EACH ROW WHEN (((new.status = 'approved'::text) AND (old.status = 'pending'::text))) EXECUTE FUNCTION public.handle_parent_join_request_approval();

CREATE TRIGGER trigger_auto_update_tier_on_payment AFTER UPDATE ON public.payment_transactions FOR EACH ROW EXECUTE FUNCTION public.auto_update_user_tier_on_payment();

CREATE TRIGGER update_portfolio_items_updated_at BEFORE UPDATE ON public.portfolio_items FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_preschool_settings_updated_at BEFORE UPDATE ON public.preschool_settings FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_preschool_voice_usage_updated_at BEFORE UPDATE ON public.preschool_voice_usage FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_create_trial_subscription AFTER INSERT ON public.preschools FOR EACH ROW EXECUTE FUNCTION public.create_trial_subscription_trigger();

CREATE TRIGGER trg_profiles_age_group BEFORE INSERT OR UPDATE OF date_of_birth ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.set_profile_age_group();

CREATE TRIGGER trigger_sync_profile_avatar AFTER UPDATE ON public.profiles FOR EACH ROW WHEN ((new.avatar_url IS DISTINCT FROM old.avatar_url)) EXECUTE FUNCTION public.sync_profile_avatar_to_org_members();

CREATE TRIGGER trigger_sync_subscription_tier AFTER INSERT OR UPDATE OF subscription_tier ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.sync_subscription_tier_to_ai_tables();

CREATE TRIGGER trigger_update_full_name BEFORE INSERT OR UPDATE OF first_name, last_name ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.update_full_name();

CREATE TRIGGER push_devices_updated_at_trigger BEFORE UPDATE ON public.push_devices FOR EACH ROW EXECUTE FUNCTION public.push_devices_set_updated_at();

CREATE TRIGGER trigger_process_push_queue AFTER INSERT ON public.push_notification_queue FOR EACH ROW EXECUTE FUNCTION public.process_push_queue_item();

CREATE TRIGGER push_subscriptions_updated_at BEFORE UPDATE ON public.push_subscriptions FOR EACH ROW EXECUTE FUNCTION public.update_push_subscriptions_updated_at();

CREATE TRIGGER trg_rag_documents_updated BEFORE UPDATE ON public.rag_documents FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

CREATE TRIGGER update_reading_progress_updated_at BEFORE UPDATE ON public.reading_progress FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_region_invite_codes_updated_at BEFORE UPDATE ON public.region_invite_codes FOR EACH ROW EXECUTE FUNCTION public.update_region_invite_codes_updated_at();

CREATE TRIGGER on_payment_unverify_sync_to_edusite AFTER UPDATE OF payment_verified ON public.registration_requests FOR EACH ROW EXECUTE FUNCTION public.trigger_sync_unverify_to_edusite();

CREATE TRIGGER on_payment_verification_sync_to_edusite AFTER UPDATE ON public.registration_requests FOR EACH ROW EXECUTE FUNCTION public.trigger_sync_payment_to_edusite();

CREATE TRIGGER on_registration_approval_sync_to_edusite AFTER UPDATE ON public.registration_requests FOR EACH ROW EXECUTE FUNCTION public.trigger_sync_approval_to_edusite();

CREATE TRIGGER on_registration_delete_sync_to_edusite BEFORE DELETE ON public.registration_requests FOR EACH ROW EXECUTE FUNCTION public.trigger_sync_delete_to_edusite();

CREATE TRIGGER trigger_update_registration_requests_timestamp BEFORE UPDATE ON public.registration_requests FOR EACH ROW EXECUTE FUNCTION public.update_registration_requests_updated_at();

CREATE TRIGGER scheduled_tasks_updated_at BEFORE UPDATE ON public.scheduled_tasks FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_school_fee_structures_updated_at BEFORE UPDATE ON public.school_fee_structures FOR EACH ROW EXECUTE FUNCTION public.update_fee_updated_at();

CREATE TRIGGER standalone_users_updated_at BEFORE UPDATE ON public.standalone_users FOR EACH ROW EXECUTE FUNCTION public.update_standalone_users_updated_at();

CREATE TRIGGER update_stem_progress_updated_at BEFORE UPDATE ON public.stem_progress FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_student_fee_assignments_updated_at BEFORE UPDATE ON public.student_fee_assignments FOR EACH ROW EXECUTE FUNCTION public.update_fee_updated_at();

CREATE TRIGGER auto_assign_student_class BEFORE INSERT OR UPDATE OF date_of_birth, preschool_id ON public.students FOR EACH ROW EXECUTE FUNCTION public.trigger_assign_student_class();

CREATE TRIGGER trg_notify_principal_on_student_registration AFTER INSERT ON public.students FOR EACH ROW EXECUTE FUNCTION public.notify_principal_on_student_registration();

CREATE TRIGGER trigger_update_class_enrollment AFTER INSERT OR DELETE OR UPDATE ON public.students FOR EACH ROW EXECUTE FUNCTION public.update_class_enrollment_on_student_change();

CREATE TRIGGER update_study_groups_updated_at BEFORE UPDATE ON public.study_groups FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER audit_submissions AFTER INSERT OR DELETE OR UPDATE ON public.submissions FOR EACH ROW EXECUTE FUNCTION public.log_educational_operations();

CREATE TRIGGER prevent_graded_submission_modification BEFORE UPDATE ON public.submissions FOR EACH ROW EXECUTE FUNCTION public.prevent_graded_submission_modification();

CREATE TRIGGER submissions_updated_at BEFORE UPDATE ON public.submissions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_subscription_plans_updated_at BEFORE UPDATE ON public.subscription_plans FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER sync_profile_seat_status_trigger AFTER INSERT OR DELETE OR UPDATE ON public.subscription_seats FOR EACH ROW EXECUTE FUNCTION public.sync_profile_seat_status();

CREATE TRIGGER update_subscription_usage_updated_at BEFORE UPDATE ON public.subscription_usage FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER sync_tier_on_subscription_change AFTER INSERT OR UPDATE OF status, plan_id ON public.subscriptions FOR EACH ROW EXECUTE FUNCTION public.trigger_sync_tier_on_subscription_change();

CREATE TRIGGER update_subscriptions_updated_at BEFORE UPDATE ON public.subscriptions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER superadmin_ai_agents_updated_at_trigger BEFORE UPDATE ON public.superadmin_ai_agents FOR EACH ROW EXECUTE FUNCTION public.update_superadmin_ai_agents_updated_at();

CREATE TRIGGER superadmin_autonomous_tasks_updated_at_trigger BEFORE UPDATE ON public.superadmin_autonomous_tasks FOR EACH ROW EXECUTE FUNCTION public.update_superadmin_ai_agents_updated_at();

CREATE TRIGGER superadmin_integrations_updated_at_trigger BEFORE UPDATE ON public.superadmin_integrations FOR EACH ROW EXECUTE FUNCTION public.update_superadmin_ai_agents_updated_at();

CREATE TRIGGER trigger_superadmin_notification_rules_updated_at BEFORE UPDATE ON public.superadmin_notification_rules FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_trigger();

CREATE TRIGGER trigger_superadmin_role_assignments_updated_at BEFORE UPDATE ON public.superadmin_role_assignments FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_trigger();

CREATE TRIGGER trigger_superadmin_deletion_requests_updated_at BEFORE UPDATE ON public.superadmin_user_deletion_requests FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_trigger();

CREATE TRIGGER trigger_superadmin_risk_assessments_updated_at BEFORE UPDATE ON public.superadmin_user_risk_assessments FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_trigger();

CREATE TRIGGER trigger_update_risk_level BEFORE INSERT OR UPDATE OF risk_score ON public.superadmin_user_risk_assessments FOR EACH ROW EXECUTE FUNCTION public.update_risk_level_trigger();

CREATE TRIGGER trg_teacher_notes_updated BEFORE UPDATE ON public.teacher_student_notes FOR EACH ROW EXECUTE FUNCTION public.update_teacher_notes_updated_at();

CREATE TRIGGER handle_updated_at_teachers BEFORE UPDATE ON public.teachers FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

CREATE TRIGGER set_tester_feedback_updated_at BEFORE UPDATE ON public.tester_feedback FOR EACH ROW EXECUTE FUNCTION public.set_current_timestamp_updated_at();

CREATE TRIGGER update_chapters_updated_at BEFORE UPDATE ON public.textbook_chapters FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_textbook_content_updated_at BEFORE UPDATE ON public.textbook_content FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_pages_updated_at BEFORE UPDATE ON public.textbook_pages FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_textbooks_updated_at BEFORE UPDATE ON public.textbooks FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_typing_indicator_timestamp BEFORE UPDATE ON public.typing_indicators FOR EACH ROW EXECUTE FUNCTION public.update_typing_indicator_timestamp();

CREATE TRIGGER user_ai_tiers_updated_at BEFORE UPDATE ON public.user_ai_tiers FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER user_connections_updated_at BEFORE UPDATE ON public.user_connections FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

CREATE TRIGGER update_user_invitations_updated_at BEFORE UPDATE ON public.user_invitations FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER user_phone_numbers_updated_at BEFORE UPDATE ON public.user_phone_numbers FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

CREATE TRIGGER update_user_voice_usage_updated_at BEFORE UPDATE ON public.user_voice_usage FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trg_sync_teacher_from_user_del AFTER DELETE ON public.users FOR EACH ROW EXECUTE FUNCTION public.sync_teacher_from_user();

CREATE TRIGGER trg_sync_teacher_from_user_ins AFTER INSERT ON public.users FOR EACH ROW EXECUTE FUNCTION public.sync_teacher_from_user();

CREATE TRIGGER trg_sync_teacher_from_user_upd AFTER UPDATE OF role, organization_id, preschool_id, is_active, email, name, first_name, last_name ON public.users FOR EACH ROW EXECUTE FUNCTION public.sync_teacher_from_user();

CREATE TRIGGER users_audit_trigger AFTER INSERT OR DELETE OR UPDATE ON public.users FOR EACH ROW EXECUTE FUNCTION public.audit_user_changes();

CREATE TRIGGER update_voice_preferences_updated_at BEFORE UPDATE ON public.voice_preferences FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_voice_quotas_updated_at BEFORE UPDATE ON public.voice_usage_quotas FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER whatsapp_contacts_updated_at BEFORE UPDATE ON public.whatsapp_contacts FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

CREATE TRIGGER update_academic_terms_updated_at BEFORE UPDATE ON public.academic_terms FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_activity_progress_updated_at BEFORE UPDATE ON public.activity_progress FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER aftercare_enrollment_trigger AFTER UPDATE OF status ON public.aftercare_registrations FOR EACH ROW WHEN ((new.status = ANY (ARRAY['enrolled'::text, 'paid'::text]))) EXECUTE FUNCTION public.trigger_aftercare_enrollment();

CREATE TRIGGER prevent_duplicate_aftercare_insert BEFORE INSERT ON public.aftercare_registrations FOR EACH ROW EXECUTE FUNCTION public.check_duplicate_aftercare_registration();

CREATE TRIGGER prevent_duplicate_aftercare_update BEFORE UPDATE ON public.aftercare_registrations FOR EACH ROW WHEN ((new.status <> 'cancelled'::text)) EXECUTE FUNCTION public.check_duplicate_aftercare_registration();

CREATE TRIGGER trg_birthday_donation_days_meta BEFORE INSERT OR UPDATE ON public.birthday_donation_days FOR EACH ROW EXECUTE FUNCTION public.set_birthday_donation_day_meta();

CREATE TRIGGER update_curriculum_themes_updated_at BEFORE UPDATE ON public.curriculum_themes FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER learner_documents_updated_at BEFORE UPDATE ON public.learner_documents FOR EACH ROW EXECUTE FUNCTION public.update_learner_documents_updated_at();

CREATE TRIGGER update_lesson_assignments_updated_at BEFORE UPDATE ON public.lesson_assignments FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_update_assignment_on_completion AFTER INSERT ON public.lesson_completions FOR EACH ROW WHEN ((new.status = 'completed'::text)) EXECUTE FUNCTION public.update_assignment_on_completion();

CREATE TRIGGER update_lesson_completions_updated_at BEFORE UPDATE ON public.lesson_completions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_lesson_templates_updated_at BEFORE UPDATE ON public.lesson_templates FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER prevent_duplicate_pop_insert BEFORE INSERT ON public.pop_uploads FOR EACH ROW EXECUTE FUNCTION public.check_duplicate_pop_upload();

CREATE TRIGGER prevent_duplicate_pop_update BEFORE UPDATE ON public.pop_uploads FOR EACH ROW EXECUTE FUNCTION public.check_duplicate_pop_upload();

CREATE TRIGGER update_student_progress_summary_updated_at BEFORE UPDATE ON public.student_progress_summary FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_teacher_approvals_updated_at BEFORE UPDATE ON public.teacher_approvals FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trg_uniform_requests_set_fields BEFORE INSERT OR UPDATE ON public.uniform_requests FOR EACH ROW EXECUTE FUNCTION public.set_uniform_request_fields();

CREATE TRIGGER update_weekly_plans_updated_at BEFORE UPDATE ON public.weekly_plans FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

CREATE TRIGGER on_auth_user_created_bulletproof AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION public.handle_auth_signup_bulletproof();

CREATE TRIGGER on_auth_user_created_profiles AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION public.create_profile_for_new_user();


  create policy "anon_select_buckets"
  on "storage"."buckets"
  as permissive
  for select
  to anon, authenticated
using (true);



  create policy "Authenticated users can upload homework files"
  on "storage"."objects"
  as permissive
  for insert
  to authenticated
with check ((bucket_id = 'homework-files'::text));



  create policy "Authenticated users can view homework files"
  on "storage"."objects"
  as permissive
  for select
  to authenticated
using ((bucket_id = 'homework-files'::text));



  create policy "Organization admins can upload documents"
  on "storage"."objects"
  as permissive
  for insert
  to authenticated
with check (((bucket_id = 'organization-documents'::text) AND (EXISTS ( SELECT 1
   FROM public.organization_members om
  WHERE ((om.user_id = auth.uid()) AND ((om.member_type)::text = ANY ((ARRAY['ceo'::character varying, 'president'::character varying, 'secretary_general'::character varying, 'treasurer'::character varying, 'admin'::character varying])::text[])) AND ((om.membership_status)::text = 'active'::text))))));



  create policy "Parents can upload homework files for their children"
  on "storage"."objects"
  as permissive
  for insert
  to authenticated
with check (((bucket_id = 'homework-files'::text) AND ((EXISTS ( SELECT 1
   FROM public.students
  WHERE (((students.id)::text = (string_to_array(objects.name, '/'::text))[4]) AND ((students.parent_id = auth.uid()) OR (students.guardian_id = auth.uid())) AND (students.is_active = true)))) OR ((auth.uid())::text = (string_to_array(name, '/'::text))[4]))));



  create policy "Principals can update school assets"
  on "storage"."objects"
  as permissive
  for update
  to authenticated
using (((bucket_id = 'school-assets'::text) AND ((storage.foldername(name))[1] IN ( SELECT (profiles.preschool_id)::text AS preschool_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['principal'::text, 'admin'::text])))))));



  create policy "Principals can upload school assets"
  on "storage"."objects"
  as permissive
  for insert
  to authenticated
with check (((bucket_id = 'school-assets'::text) AND ((storage.foldername(name))[1] IN ( SELECT (profiles.preschool_id)::text AS preschool_id
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['principal'::text, 'admin'::text])))))));



  create policy "Public can view school assets"
  on "storage"."objects"
  as permissive
  for select
  to public
using ((bucket_id = 'school-assets'::text));



  create policy "Teachers can view homework files in their preschool"
  on "storage"."objects"
  as permissive
  for select
  to authenticated
using (((bucket_id = 'homework-files'::text) AND ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'teacher'::text) AND ((profiles.preschool_id)::text = (string_to_array(objects.name, '/'::text))[2])))) OR (EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'principal'::text) AND ((profiles.preschool_id)::text = (string_to_array(objects.name, '/'::text))[2])))))));



  create policy "Users can delete their own uploaded homework files"
  on "storage"."objects"
  as permissive
  for delete
  to authenticated
using (((bucket_id = 'homework-files'::text) AND ((owner = auth.uid()) AND (created_at > (now() - '24:00:00'::interval)))));



  create policy "Users can delete their own voice recordings"
  on "storage"."objects"
  as permissive
  for delete
  to authenticated
using (((bucket_id = 'voice_recordings'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));



  create policy "Users can read their own voice recordings"
  on "storage"."objects"
  as permissive
  for select
  to authenticated
using (((bucket_id = 'voice_recordings'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));



  create policy "Users can update their own homework files"
  on "storage"."objects"
  as permissive
  for update
  to authenticated
using (((bucket_id = 'homework-files'::text) AND (owner = auth.uid()) AND (created_at > (now() - '24:00:00'::interval))));



  create policy "Users can upload their own voice recordings"
  on "storage"."objects"
  as permissive
  for insert
  to authenticated
with check (((bucket_id = 'voice_recordings'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));



  create policy "aftercare_payments_insert"
  on "storage"."objects"
  as permissive
  for insert
  to anon, authenticated
with check ((bucket_id = 'aftercare-payments'::text));



  create policy "aftercare_payments_select"
  on "storage"."objects"
  as permissive
  for select
  to authenticated
using ((bucket_id = 'aftercare-payments'::text));



  create policy "authenticated_users_can_delete_own"
  on "storage"."objects"
  as permissive
  for delete
  to authenticated
using ((owner = auth.uid()));



  create policy "authenticated_users_can_read"
  on "storage"."objects"
  as permissive
  for select
  to authenticated
using (true);



  create policy "authenticated_users_can_update_own"
  on "storage"."objects"
  as permissive
  for update
  to authenticated
using ((owner = auth.uid()))
with check ((owner = auth.uid()));



  create policy "authenticated_users_can_upload"
  on "storage"."objects"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "cv_uploads_insert_org_admins"
  on "storage"."objects"
  as permissive
  for insert
  to authenticated
with check (((bucket_id = 'cv-uploads'::text) AND ((storage.foldername(name))[1] IN ( SELECT COALESCE((profiles.organization_id)::text, (profiles.preschool_id)::text) AS "coalesce"
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'super_admin'::text, 'principal'::text, 'principal_admin'::text])))))));



  create policy "cv_uploads_select_org_members"
  on "storage"."objects"
  as permissive
  for select
  to authenticated
using (((bucket_id = 'cv-uploads'::text) AND ((storage.foldername(name))[1] IN ( SELECT COALESCE((profiles.organization_id)::text, (profiles.preschool_id)::text) AS "coalesce"
   FROM public.profiles
  WHERE (profiles.id = auth.uid())))));



  create policy "cv_uploads_update_org_admins"
  on "storage"."objects"
  as permissive
  for update
  to authenticated
using (((bucket_id = 'cv-uploads'::text) AND ((storage.foldername(name))[1] IN ( SELECT COALESCE((profiles.organization_id)::text, (profiles.preschool_id)::text) AS "coalesce"
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'super_admin'::text, 'principal'::text, 'principal_admin'::text])))))))
with check ((bucket_id = 'cv-uploads'::text));



  create policy "learner_documents_storage_delete"
  on "storage"."objects"
  as permissive
  for delete
  to authenticated
using (((bucket_id = 'learner-documents'::text) AND ((storage.foldername(name))[1] = (auth.uid())::text)));



  create policy "learner_documents_storage_insert"
  on "storage"."objects"
  as permissive
  for insert
  to authenticated
with check (((bucket_id = 'learner-documents'::text) AND ((storage.foldername(name))[1] = (auth.uid())::text)));



  create policy "learner_documents_storage_select"
  on "storage"."objects"
  as permissive
  for select
  to authenticated
using (((bucket_id = 'learner-documents'::text) AND ((storage.foldername(name))[1] = (auth.uid())::text)));



  create policy "learner_documents_storage_update"
  on "storage"."objects"
  as permissive
  for update
  to authenticated
using (((bucket_id = 'learner-documents'::text) AND ((storage.foldername(name))[1] = (auth.uid())::text)));



  create policy "organization_assets_delete_policy"
  on "storage"."objects"
  as permissive
  for delete
  to authenticated
using ((bucket_id = 'organization-assets'::text));



  create policy "organization_assets_public_read"
  on "storage"."objects"
  as permissive
  for select
  to public
using ((bucket_id = 'organization-assets'::text));



  create policy "organization_assets_update_policy"
  on "storage"."objects"
  as permissive
  for update
  to authenticated
using ((bucket_id = 'organization-assets'::text));



  create policy "organization_assets_upload_policy"
  on "storage"."objects"
  as permissive
  for insert
  to authenticated
with check ((bucket_id = 'organization-assets'::text));



  create policy "public_can_read"
  on "storage"."objects"
  as permissive
  for select
  to anon
using ((bucket_id IN ( SELECT buckets.id
   FROM storage.buckets
  WHERE (buckets.public = true))));



  create policy "school_assets_insert_org_admins"
  on "storage"."objects"
  as permissive
  for insert
  to authenticated
with check (((bucket_id = 'school-assets'::text) AND ((storage.foldername(name))[1] IN ( SELECT COALESCE((profiles.organization_id)::text, (profiles.preschool_id)::text) AS "coalesce"
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'super_admin'::text, 'principal'::text, 'principal_admin'::text])))))));



  create policy "school_assets_public_read"
  on "storage"."objects"
  as permissive
  for select
  to public
using ((bucket_id = 'school-assets'::text));



  create policy "school_assets_update_org_admins"
  on "storage"."objects"
  as permissive
  for update
  to authenticated
using (((bucket_id = 'school-assets'::text) AND ((storage.foldername(name))[1] IN ( SELECT COALESCE((profiles.organization_id)::text, (profiles.preschool_id)::text) AS "coalesce"
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = ANY (ARRAY['admin'::text, 'super_admin'::text, 'principal'::text, 'principal_admin'::text])))))))
with check ((bucket_id = 'school-assets'::text));



  create policy "service_role_full_storage_access"
  on "storage"."objects"
  as permissive
  for all
  to service_role
using (true)
with check (true);




