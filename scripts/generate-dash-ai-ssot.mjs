#!/usr/bin/env node
import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, '..');

const OCR_SOURCE_PATH = path.join(repoRoot, 'lib/dash-ai/ocrPrompts.ts');
const PHONICS_SOURCE_PATH = path.join(repoRoot, 'lib/dash-ai/phonicsPrompt.ts');

const EDGE_OCR_TARGET_PATH = path.join(repoRoot, 'supabase/functions/ai-proxy/generated/ocrPrompts.ts');
const EDGE_PHONICS_TARGET_PATH = path.join(repoRoot, 'supabase/functions/ai-proxy/generated/phonicsPrompt.ts');

const GENERATED_HEADER = [
  '/**',
  ' * AUTO-GENERATED FILE. DO NOT EDIT MANUALLY.',
  ' * Source of truth: lib/dash-ai/ocrPrompts.ts and lib/dash-ai/phonicsPrompt.ts',
  ' * Generated by: scripts/generate-dash-ai-ssot.mjs',
  ' */',
  '',
].join('\n');

function ensureDir(filePath) {
  fs.mkdirSync(path.dirname(filePath), { recursive: true });
}

function extractExportConstBlock(source, name) {
  const pattern = new RegExp(`export const ${name} = \\[[\\s\\S]*?\\]\\.join\\('\\\\n'\\);`);
  const match = source.match(pattern);
  if (!match) {
    throw new Error(`Failed to extract constant block: ${name}`);
  }
  return match[0];
}

function stripLeadingCommentBlock(source) {
  return source.replace(/^\/\*\*[\s\S]*?\*\/\s*/, '');
}

function buildWebOcrContent(ocrSource) {
  const withoutLocalHeader = stripLeadingCommentBlock(ocrSource).trimStart();
  return `${GENERATED_HEADER}${withoutLocalHeader.trimEnd()}\n`;
}

function buildEdgeOcrContent(ocrSource) {
  const homework = extractExportConstBlock(ocrSource, 'HOMEWORK_SCAN_PROMPT');
  const document = extractExportConstBlock(ocrSource, 'DOCUMENT_SCAN_PROMPT');
  const handwriting = extractExportConstBlock(ocrSource, 'HANDWRITING_ANALYSIS_PROMPT');

  return [
    GENERATED_HEADER.trimEnd(),
    '',
    homework,
    '',
    document,
    '',
    handwriting,
    '',
    'export const OCR_PROMPT_BY_TASK: Record<\'homework\' | \'document\' | \'handwriting\', string> = {',
    '  homework: HOMEWORK_SCAN_PROMPT,',
    '  document: DOCUMENT_SCAN_PROMPT,',
    '  handwriting: HANDWRITING_ANALYSIS_PROMPT,',
    '};',
    '',
  ].join('\n');
}

function buildEdgePhonicsContent(phonicsSource) {
  const phonics = extractExportConstBlock(phonicsSource, 'SHARED_PHONICS_PROMPT_BLOCK');
  return `${GENERATED_HEADER}${phonics}\n`;
}

function writeIfChanged(targetPath, nextContent) {
  const current = fs.existsSync(targetPath) ? fs.readFileSync(targetPath, 'utf8') : null;
  if (current === nextContent) {
    return false;
  }
  ensureDir(targetPath);
  fs.writeFileSync(targetPath, nextContent, 'utf8');
  return true;
}

function main() {
  const ocrSource = fs.readFileSync(OCR_SOURCE_PATH, 'utf8');
  const phonicsSource = fs.readFileSync(PHONICS_SOURCE_PATH, 'utf8');

  const outputs = [
    [EDGE_OCR_TARGET_PATH, buildEdgeOcrContent(ocrSource)],
    [EDGE_PHONICS_TARGET_PATH, buildEdgePhonicsContent(phonicsSource)],
  ];

  const changed = [];
  for (const [targetPath, content] of outputs) {
    if (writeIfChanged(targetPath, content)) {
      changed.push(path.relative(repoRoot, targetPath));
    }
  }

  if (changed.length === 0) {
    console.log('[ssot:generate] No changes. Generated artifacts are up to date.');
    return;
  }

  console.log('[ssot:generate] Updated generated artifacts:');
  for (const file of changed) {
    console.log(` - ${file}`);
  }
}

main();
