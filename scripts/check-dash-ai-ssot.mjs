#!/usr/bin/env node
import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, '..');

const OCR_SOURCE_PATH = path.join(repoRoot, 'lib/dash-ai/ocrPrompts.ts');
const PHONICS_SOURCE_PATH = path.join(repoRoot, 'lib/dash-ai/phonicsPrompt.ts');

const WEB_OCR_TARGET_PATH = path.join(repoRoot, 'web/src/lib/dash-ai/ocrPrompts.ts');
const EDGE_OCR_TARGET_PATH = path.join(repoRoot, 'supabase/functions/ai-proxy/generated/ocrPrompts.ts');
const EDGE_PHONICS_TARGET_PATH = path.join(repoRoot, 'supabase/functions/ai-proxy/generated/phonicsPrompt.ts');

const GENERATED_HEADER = [
  '/**',
  ' * AUTO-GENERATED FILE. DO NOT EDIT MANUALLY.',
  ' * Source of truth: lib/dash-ai/ocrPrompts.ts and lib/dash-ai/phonicsPrompt.ts',
  ' * Generated by: scripts/generate-dash-ai-ssot.mjs',
  ' */',
  '',
].join('\n');

function extractExportConstBlock(source, name) {
  const pattern = new RegExp(`export const ${name} = \\[[\\s\\S]*?\\]\\.join\\('\\\\n'\\);`);
  const match = source.match(pattern);
  if (!match) {
    throw new Error(`Failed to extract constant block: ${name}`);
  }
  return match[0];
}

function stripLeadingCommentBlock(source) {
  return source.replace(/^\/\*\*[\s\S]*?\*\/\s*/, '');
}

function buildWebOcrContent(ocrSource) {
  const withoutLocalHeader = stripLeadingCommentBlock(ocrSource).trimStart();
  return `${GENERATED_HEADER}${withoutLocalHeader.trimEnd()}\n`;
}

function buildEdgeOcrContent(ocrSource) {
  const homework = extractExportConstBlock(ocrSource, 'HOMEWORK_SCAN_PROMPT');
  const document = extractExportConstBlock(ocrSource, 'DOCUMENT_SCAN_PROMPT');
  const handwriting = extractExportConstBlock(ocrSource, 'HANDWRITING_ANALYSIS_PROMPT');

  return [
    GENERATED_HEADER.trimEnd(),
    '',
    homework,
    '',
    document,
    '',
    handwriting,
    '',
    'export const OCR_PROMPT_BY_TASK: Record<\'homework\' | \'document\' | \'handwriting\', string> = {',
    '  homework: HOMEWORK_SCAN_PROMPT,',
    '  document: DOCUMENT_SCAN_PROMPT,',
    '  handwriting: HANDWRITING_ANALYSIS_PROMPT,',
    '};',
    '',
  ].join('\n');
}

function buildEdgePhonicsContent(phonicsSource) {
  const phonics = extractExportConstBlock(phonicsSource, 'SHARED_PHONICS_PROMPT_BLOCK');
  return `${GENERATED_HEADER}${phonics}\n`;
}

function assertMatches(targetPath, expectedContent, mismatches) {
  const rel = path.relative(repoRoot, targetPath);
  if (!fs.existsSync(targetPath)) {
    mismatches.push(`${rel} (missing)`);
    return;
  }
  const actual = fs.readFileSync(targetPath, 'utf8');
  if (actual !== expectedContent) {
    mismatches.push(`${rel} (out of sync)`);
  }
}

function main() {
  const ocrSource = fs.readFileSync(OCR_SOURCE_PATH, 'utf8');
  const phonicsSource = fs.readFileSync(PHONICS_SOURCE_PATH, 'utf8');

  const expected = [
    [WEB_OCR_TARGET_PATH, buildWebOcrContent(ocrSource)],
    [EDGE_OCR_TARGET_PATH, buildEdgeOcrContent(ocrSource)],
    [EDGE_PHONICS_TARGET_PATH, buildEdgePhonicsContent(phonicsSource)],
  ];

  const mismatches = [];
  for (const [targetPath, content] of expected) {
    assertMatches(targetPath, content, mismatches);
  }

  if (mismatches.length > 0) {
    console.error('[ssot:check] Drift detected in generated files:');
    for (const mismatch of mismatches) {
      console.error(` - ${mismatch}`);
    }
    console.error('\nRun: npm run ssot:generate');
    process.exit(1);
  }

  console.log('[ssot:check] Generated files are in sync.');
}

main();
